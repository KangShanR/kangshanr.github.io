<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Kang Shan</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                Home
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                Archives
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                Tags
            </a>
            

            
            <a href="/about/" class="header-nav-link">
                About
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">Kang Shan's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">Home</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">Archives</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">Tags</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">About</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    <article class="post-whole">
        <div class="post-title">
            <h2 class="title">SpringMVC</h2>
            <div class="post-meta">
                <span class="post-time">2017-08-20</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Spring/">Spring</a>
                    
                </span>
                
                <span class="post-visit"> visited：<span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
        <div class="post-toc" id="post-toc">
    <strong class="post-toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-SpringMVC"><span class="toc-text">1. SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.1. 核心对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-springMVC-%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">1.1.1. springMVC 中的处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E4%BB%A3%E6%9B%BF-xml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">1.2. 使用代码代替 xml 配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-LocalResolver-%E5%8C%BA%E5%9F%9F%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">1.2.1. LocalResolver 区域解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%A4%9A%E9%83%A8%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%99%A8-MultipartResolver"><span class="toc-text">1.2.2. 多部件解析器 MultipartResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-json-%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="toc-text">1.2.3. json 数据交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JsonConvert2HttpMessage"><span class="toc-text">JsonConvert2HttpMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-xml-%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="toc-text">1.2.4. xml 数据交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-text">1.2.5. 数据校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-Restful-%E6%9E%B6%E6%9E%84"><span class="toc-text">1.2.6. Restful 架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-configuration-based-on-java-codes"><span class="toc-text">1.3. configuration based on java codes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-ant-style"><span class="toc-text">1.3.1. ant style</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-RequestMapping"><span class="toc-text">1.3.2. RequestMapping</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-1-URI-Pattern"><span class="toc-text">1.3.2.1. URI Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.3.2.2. 自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-3-Explicit-Registrations"><span class="toc-text">1.3.2.3. Explicit Registrations</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Functional-Endpoints"><span class="toc-text">1.4. Functional Endpoints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Annotated-Controllers"><span class="toc-text">1.5. Annotated Controllers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-DataBidder"><span class="toc-text">1.5.1. DataBidder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-Exceptions"><span class="toc-text">1.5.2. Exceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%E9%93%BE-Chain-of-Exceptions"><span class="toc-text">1.5.2.1. 异常处理器链 Chain of Exceptions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Asynchronous-Requests"><span class="toc-text">1.6.  Asynchronous Requests</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Processing"><span class="toc-text">Processing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Compared-to-WebFlux"><span class="toc-text">Compared to WebFlux</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http-Streaming"><span class="toc-text">Http Streaming</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Objects"><span class="toc-text">Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raw-Data"><span class="toc-text">Raw Data</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Configuration"><span class="toc-text">Configuration</span></a></li></ol></li></ol></li></ol>
    <div class="back-to-top" id="back-to-top">
        <a href="javascript:void(0);">回到顶部</a>
    </div>
</div>
        <div class="post-content">
            <h1 id="1-SpringMVC"><a href="#1-SpringMVC" class="headerlink" title="1. SpringMVC"></a>1. SpringMVC</h1><!-- TOC -->

<ul>
<li><a href="#1-springmvc">1. SpringMVC</a><ul>
<li><a href="#11-%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1">1.1. 核心对象</a><ul>
<li><a href="#111-springmvc-%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8">1.1.1. springMVC 中的处理器</a></li>
</ul>
</li>
<li><a href="#12-%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E4%BB%A3%E6%9B%BF-xml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1.2. 使用代码代替 xml 配置文件</a><ul>
<li><a href="#121-localresolver-%E5%8C%BA%E5%9F%9F%E8%A7%A3%E6%9E%90%E5%99%A8">1.2.1. LocalResolver 区域解析器</a></li>
<li><a href="#122-%E5%A4%9A%E9%83%A8%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%99%A8-multipartresolver">1.2.2. 多部件解析器 MultipartResolver</a></li>
<li><a href="#123-json-%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">1.2.3. json 数据交互</a></li>
<li><a href="#124-jsonconvert2httpmessage">1.2.4. JsonConvert2HttpMessage</a></li>
<li><a href="#125-xml-%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">1.2.5. xml 数据交互</a></li>
<li><a href="#126-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C">1.2.6. 数据校验</a></li>
<li><a href="#127-restful-%E6%9E%B6%E6%9E%84">1.2.7. Restful 架构</a></li>
</ul>
</li>
<li><a href="#13-configuration-based-on-java-codes">1.3. configuration based on java codes</a><ul>
<li><a href="#131-ant-style">1.3.1. ant style</a></li>
<li><a href="#132-requestmapping">1.3.2. RequestMapping</a><ul>
<li><a href="#1321-uri-pattern">1.3.2.1. URI Pattern</a></li>
<li><a href="#1322-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">1.3.2.2. 自定义注解</a></li>
<li><a href="#1323-explicit-registrations">1.3.2.3. Explicit Registrations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#14-functional-endpoints">1.4. Functional Endpoints</a></li>
<li><a href="#15-annotated-controllers">1.5. Annotated Controllers</a><ul>
<li><a href="#151-databidder">1.5.1. DataBidder</a></li>
<li><a href="#152-exceptions">1.5.2. Exceptions</a><ul>
<li><a href="#1521-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%E9%93%BE-chain-of-exceptions">1.5.2.1. 异常处理器链 Chain of Exceptions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-asynchronous-requests">1.6. Asynchronous Requests</a><ul>
<li><a href="#161-processing">1.6.1. Processing</a><ul>
<li><a href="#1611-compared-to-webflux">1.6.1.1. Compared to WebFlux</a></li>
</ul>
</li>
<li><a href="#162-http-streaming">1.6.2. Http Streaming</a><ul>
<li><a href="#1621-objects">1.6.2.1. Objects</a></li>
<li><a href="#1622-raw-data">1.6.2.2. Raw Data</a></li>
</ul>
</li>
<li><a href="#163-configuration">1.6.3. Configuration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<blockquote>
<p>SpringMVC 同样是一种 MVC 架构，它与传统 MVC 框架的不同之处在于使用了中央调度器，用中央调度器 DispatcherServlet 来分发所有的请求与响应，中央调度器的存在就大大降低了其他组件之间的耦合度。这种分发请求与响应的实现得益于 spring 的装配。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><strong>中央处理器的配置</strong>：在web.xml中配置 springmvc 的 servlet</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>中央处理器 DispatcherServlet 在web.xml中被配置成一个 servlet ,并通过初始化上下文配置参数 springmvc.xml 的路径与设置其启动时机与该servlet初始化时机；<ol>
<li>其中 load-on-startup 这个属性来指定这个中央处理器被初始化的时机：<ol>
<li>当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些；</li>
<li>当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序；</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="1-1-核心对象"><a href="#1-1-核心对象" class="headerlink" title="1.1. 核心对象"></a>1.1. 核心对象</h2><blockquote>
<p>各个核心对象都有默认值，也就是说如果没有手动配置这些， springmvc 会按默认配置进行构建窗口。默认配置文件：spring-webmvc 包中 org.springframework.web.servlet 中的 DispatcherServlet.properties 。</p>
</blockquote>
<ol>
<li><p><strong>中央分发控制器</strong>（在springMVC框架中，它是核心的核心，所有的分发都由它处理，所以也叫 <strong>中央处理器</strong> ），处理请求并给出响应（下面的三个关键组件就是装配在 springmvc 中的，但中央处理器是装配在 web.xml 中作为一个 servlet 的）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html">替代方案 WebApplicationInitializer</a></li>
</ol>
</li>
<li><p><strong>处理器映射器</strong> HandlerMapping ：设置 handler 处理器与 url 资源的映射</p>
<ol>
<li><p>使用 BeanNameUrlHandlerMapping 这个类时，就会将 handler 的 name 属性值作为 url 映射，访问这个处理器就填写其 name 属性值:<code>&lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.kang.springdemo.controller.LoginController&quot;/&gt;</code> 如上，就可能过name属性值，设置 <code>&lt;a href=&quot;loginController.do&gt;登录&lt;/a&gt;</code></p>
</li>
<li><p>SimpleUrlHandlerMapping 这个类型的映射要求映射 url 与 controller 的配置 id 相对应，并在这个节点内将 controller 的 id 与相关的 key 对应起来；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappings&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--配置指定的url与bean的id映射,可添加多个--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;/login.do&quot;</span>&gt;</span>login<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;/login2.do&quot;</span>&gt;</span>login2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginController.do&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kang.springdemo.controller.LoginController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;login2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginController2.do&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kang.springdemo.controller.LoginController2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用注解实现处理器与 url 的映射 <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></p>
<ol>
<li>这个配置节点就决定了处理器与其中的方法可以被注解 <code>@RequestMapping(&quot;url_name&quot;)</code> 映射并指定 url</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>处理器适配器</strong> HandlerAdapter，用于规定处理器的编写规则</p>
<ol>
<li><p>使用接口来配置适配器：</p>
<ol>
<li>当指定为 SimpleControllerHandlerAdapter 时，它就规定了要想成为处理器，就要实现 Controller 这个接口；</li>
<li>HttpRequestHandlerAdapter 这个适配器要求所有的 Handler 都必须实现 HttpRequestAdapter 接口；</li>
</ol>
</li>
<li><p>使用注解实现配置适配器（这个配置节点就决定了，有 <code>@Controller</code> 注解的类就是处理器）：</p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注解适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>视图解析器</strong> 用来解析处理器处理后的逻辑视图，比如：加上前缀后缀，指定到特定的视图。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>如果 springMVC 没有配置视图解析器，如果 接口返回的 字符串（如： “hello”）给的是相对路径（‘jsp’），那么 spring 会把当前路径给配上去（如果 当前的 controller 的 uri 是 “/v1/say” ，那么这时返回的视图 uri 就是 “/v1/say/hello”），这个时候返回的视图就会在 当前的 controller 中去找 hello 方法接口，产生问题。如果返回的字符串是绝对路径（如： “/WEB-INF/jsp/hello.jsp”），那么spring 就会在服务器的此绝对路径里去找这个 jsp 文件并返回给客户端。</p>
</li>
<li><p><strong>Small Notes:</strong></p>
<ol>
<li>在 SpringMVC 中这四个核心的对象就已经可以将整个架构支撑起来了，整个<strong>SpringMVC架构流程</strong>：<ol>
<li>中央分发器收到来自客户端的请求时，先将请求分发给处理器映射器，由控制器映射器决定了请求的<strong>处理器</strong>是谁（按面向对象编程思想，这儿一定是生成了映射的处理器对象，同时也<strong>生成拦截器</strong>之类的组件）；</li>
<li>同时分发器分发请求给处理器适配器，<strong>适配器对相关的处理器进行适配扩展，并调用处理器对请求进行处理，</strong> 处理结果就包括了逻辑视图与其他的响应结果（比如：存放在ModelAndView中），适配器再将这些处理结果返回给中央分发器；</li>
<li>中央分发器将结果分发给<strong>视图解析器</strong>，视图解析器对逻辑视图进行解析（比如：加上前缀后缀），视图解析器再解析之后的具体的view返回给中央分发器；</li>
<li>中央分发器收到view后对其进行<strong>渲染</strong>（将数据结果填充至视图中），再把最终结果响应出去；</li>
</ol>
</li>
</ol>
</li>
<li><p>整个SpringMVC流程如上，我们常常使用时并不会完全按照上面四个核心对象进行配置，相对来说有更便利的方法来配置这四个核心对象:</p>
<ul>
<li><strong>组件扫描器：</strong>自动扫描 <code>@Controller</code> 标记的控制器，这样省去将各个配置器配置在bean中：  <!-- 扫描器组件，将指定包中的带有特定注解的类全都扫描进容器可用的controller中 -->
  &lt;context:component-scan base-package=”com.kang.springdemo.controller,<pre><code>                                    com.kang.springdemo.service&quot;&gt;
  &lt;!-- 指定注解过滤器 --&gt;
  &lt;context:include-filter type=&quot;annotation&quot;
  expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
</code></pre>
  </context:component-scan></li>
<li><strong>注解映射器：</strong>注解式映射器配置可以直接将使用过注解<code>@RequestMapping</code>的方法进行映射，而直接在处理器中寻到相关的处理方法； <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></li>
<li><strong>注解处理器适配器：</strong>注解式处理器适配器，配置此甜酸器直接对标记<code>@RequestMapping</code>的方法进行适配： <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></li>
<li><strong>SpringMVC中的注解驱动配置：</strong>注解驱动综合了前两个注解式的适配器与映射器，因此配置此驱动即可省略适配器与映射器的配置：<code>&lt;mvc:annotation-driven/&gt;</code></li>
</ul>
</li>
<li><p><strong>Tips:</strong></p>
<ul>
<li><em>在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象；</em></li>
</ul>
</li>
</ul>
<h3 id="1-1-1-springMVC-中的处理器"><a href="#1-1-1-springMVC-中的处理器" class="headerlink" title="1.1.1. springMVC 中的处理器"></a>1.1.1. springMVC 中的处理器</h3><p>在 DispatcherServlet 中， spring 规约的处理器 bean <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet-special-bean-types">reference</a></p>
<ol>
<li><p>通过上一步实现来自前端请求必须都通过 web.xml 文件中指定的 servlet 处理，也就是大部分请求都是交给了 springmvc，所有的 springmvc 的配置都在 springmvc.xml 文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。</p>
</li>
<li><p>springmvc.xml 配置中就指定了适配器映射，使用 <code>@Controller</code> 注解就让该类成为处理器</p>
</li>
<li><p><code>@RequestMapping(&quot;url_name&quot;)</code> 则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url;</p>
</li>
<li><p>注解使用时映射的方法中，可以与前端数据相通的<strong>参数</strong>有：</p>
<ol>
<li>简单数据类型</li>
<li>pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password</li>
<li>session/request/response：用法与之前一致，可以用分发请求也可以重定向；</li>
<li>Model/ModelAndView：</li>
<li>也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中；</li>
<li>注解<code>@RequestParam</code>的使用：<ol>
<li>其中有参数：<ol>
<li>name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法；</li>
<li>required：boolean 类型，当其值为 true 时，请求必须带有这个参数；</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>使用 controller 处理器时，各类方法 <strong>返回数据类型</strong>：</p>
<ol>
<li>ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图）</li>
<li>String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串”response:+方法映射”；</li>
<li><strong>void</strong>:在controller形参上定义request与response来指定响应结果：<ol>
<li>“forward:+方法映射”，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到；</li>
<li>也可以直接使用<code>response</code>重定向到指定页面：<code>response.sendRedirect(String url);</code></li>
<li>使用<code>response</code>指定响应结果：<ol>
<li>响应jason数据：<code>response.setCharacterEncoding(&quot;utf-8&quot;);</code></li>
<li><code>response.getWriter().write(String &quot;jason格式的字符串&quot;);</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="1-2-使用代码代替-xml-配置文件"><a href="#1-2-使用代码代替-xml-配置文件" class="headerlink" title="1.2. 使用代码代替 xml 配置文件"></a>1.2. 使用代码代替 xml 配置文件</h2><p>参照 spring mvc doc： org.springframework.web.WebApplicationInitializer。</p>
<h3 id="1-2-1-LocalResolver-区域解析器"><a href="#1-2-1-LocalResolver-区域解析器" class="headerlink" title="1.2.1. LocalResolver 区域解析器"></a>1.2.1. LocalResolver 区域解析器</h3><p>在 springmvc 中配置这个解析器，用于国际化。其中解析器常用的有：</p>
<ul>
<li>cookie ，根据 CookieLocaleResolver 来选择区域；<ul>
<li>这个区域解析器所采用的Cookie可以通过cookieName和cookieMaxAge属性进行定制。cookieMaxAge属性表示这个Cookie应该持续多少秒，-1表示这个Cookie在浏览器关闭之后就失效。</li>
</ul>
</li>
<li>SessionLocaleResolver<ul>
<li>它通过检验用户会话中预置的属性来解析区域。如果该会话属性不存在，它会根据accept-language HTTP头部确定默认区域。</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-多部件解析器-MultipartResolver"><a href="#1-2-2-多部件解析器-MultipartResolver" class="headerlink" title="1.2.2. 多部件解析器 MultipartResolver"></a>1.2.2. 多部件解析器 MultipartResolver</h3><p>用于文件上传，需要引入包：commons-fileupload 与 commons-io</p>
<h3 id="1-2-3-json-数据交互"><a href="#1-2-3-json-数据交互" class="headerlink" title="1.2.3. json 数据交互"></a>1.2.3. json 数据交互</h3><blockquote>
<p>在前后端分离的项目中，特别是存在为移动端提供的接口都应该使用 json 数据的格式对前端提供接口。</p>
</blockquote>
<p>渲染 view 是 mappingJackson2JsonView</p>
<ul>
<li><p>实际使用的是 <code>MappingJackson2HttpMessageConverter</code></p>
</li>
<li><p>添加在 DispatcherServlet 的适配器中的 messageConverters 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.xml.MappingJackson2HttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要使用的依赖包：</p>
<ol>
<li>jackson-core</li>
<li>jackson-annotations</li>
<li>jackson-databind</li>
</ol>
<p>使用两个注解：</p>
<ul>
<li>@RequestBody<ul>
<li>用于将请求的字符串使用 converter 转换成 json/xml 等格式并绑定到 controller 参数上去</li>
</ul>
</li>
<li>@ResponseBody<ul>
<li>用于将 controller 返回的结果 使用 converter 转换成 json/xml 格式直接 response 给浏览器</li>
</ul>
</li>
</ul>
<h3 id="JsonConvert2HttpMessage"><a href="#JsonConvert2HttpMessage" class="headerlink" title="JsonConvert2HttpMessage"></a>JsonConvert2HttpMessage</h3><p>在 spring mvc 中将请求与响应数据转换成 Http 所需要的对象需要使用到序列化与反序列化。其中使用时 mvc 中的配置 configureMessageConverters 方法。在使用时有一个问题，当使用 Jackson2ObjectMapperBuilder 来build 一个 JsonMapper 时，其本身会在 class path 中去寻找所需要的 Module ，并将项目中存在的  module 注册到 builder 中默认的 objectMapper 中。如果此时再手动在 builder 上注册  module 会出现重复的 module 如 JavaTimeModule objectMapper 默认 feature (MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS) 会忽略掉重复的 module 注册，因此手动在 builder 注册的重复 module 会失效，包括手动添加的 module 的各种属性。比如，指定 java8.javaTimeModule 中的 LocalDateTime 反序列化/序列化格式为 “YYYY-MM-dd HH:mm:ss”(其默认为 “YYYY-MM-ddTHH:mm:ss”)，将会无效。</p>
<ul>
<li>解决办法：直接在 builder 中手动注册 LocalDateTime 序列化与反序列化器格式，而不在 builder 中注册相应的 module。这样处理的结果是，builder 默认会注册 JavaTimeModule 到其 ObjectMapper ，但也会注册一个 SimpleModule 到 ObjectMapper ，同时 simple 的权限更高，在序列化时会优先使用 simpleModule。</li>
</ul>
<h3 id="1-2-4-xml-数据交互"><a href="#1-2-4-xml-数据交互" class="headerlink" title="1.2.4. xml 数据交互"></a>1.2.4. xml 数据交互</h3><p>使用的渲染 view 是 mappingJackson2XmlView</p>
<ul>
<li><p>实际使用的是 <code>MappingJackson2XmlHttpMessageConverter</code></p>
</li>
<li><p>添加在 DispatcherServlet 的适配器中的 messageConverters 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要的依赖包：</p>
<ol>
<li>jackson-annotations</li>
<li>jackson-dataformat-xml</li>
</ol>
<p>使用：<br> 同样使用两个标签 <code>@RequestBody</code> <code>@ResponseBody</code> 并联合使用 <code>@RequestMapping(produces=&#123;&#125;, consumes=&#123;&#125;)</code> 来确定请求与返回数据的格式。</p>
<h3 id="1-2-5-数据校验"><a href="#1-2-5-数据校验" class="headerlink" title="1.2.5. 数据校验"></a>1.2.5. 数据校验</h3><p>springmvc 中可以直接使用 Hibernate 的一个校验框架：hibernate-validator。基于注解实现数据的校验。</p>
<h3 id="1-2-6-Restful-架构"><a href="#1-2-6-Restful-架构" class="headerlink" title="1.2.6. Restful 架构"></a>1.2.6. Restful 架构</h3><ul>
<li>只是一种规范，终极的目标是资源 URI</li>
</ul>
<h2 id="1-3-configuration-based-on-java-codes"><a href="#1-3-configuration-based-on-java-codes" class="headerlink" title="1.3. configuration based on java codes"></a>1.3. configuration based on java codes</h2><p>使用 java 代码配置 mvc <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config">reference</a></p>
<h3 id="1-3-1-ant-style"><a href="#1-3-1-ant-style" class="headerlink" title="1.3.1. ant style"></a>1.3.1. ant style</h3><p>关于 spring 中写 ant style 路径规则参照此类 doc: <code>org.springframework.util.AntPathMatcher</code></p>
<h3 id="1-3-2-RequestMapping"><a href="#1-3-2-RequestMapping" class="headerlink" title="1.3.2. RequestMapping"></a>1.3.2. RequestMapping</h3><ul>
<li><p>可使用正则表达式来匹配 url 参数</p>
</li>
<li><p>pattern 匹配比较，越具体的 url 越匹配。</p>
</li>
<li><p>Consumable/Producible Media Types 请求消费/生产数据类型匹配，<code>MediaType</code> 中有基本的类型。可使用 非 <code>!</code> 运行符</p>
</li>
<li><p>Parameters,headers</p>
<ul>
<li><p>窄化请求路径：指定参数是否存在 <code>param</code> <code>!param</code>，指定具体参数类型： <code>param=myValue</code></p>
</li>
<li><p>headers 相同窄化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTTP HEAD,OPTIONS 请求，自动转换请求到 GET 上，也可配置多个请求方式在同一个 URL 上</p>
</li>
<li><p>所有 handler 请求响应的方法都会映射成一个 RequestMappingInfo ，其中包括了所有的 headers/consumes/produces, etc.，再将所有的方法注册到 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#registerMapping 中（容器 HashMap）。此 Mapping 实现 InitializeBean 会自动在 Spring 中实现并在其 afterPropertiesSet 方法中进行注册 handler method 方法。</p>
</li>
<li><p>@ResponseStatus 可以给特定方法 controller 指定其响应状态码</p>
</li>
<li><p>@ExceptionHandler 注解在 @ControllerAdvice 中异常处理，其 doc 说明了很多问题。</p>
</li>
</ul>
<h4 id="1-3-2-1-URI-Pattern"><a href="#1-3-2-1-URI-Pattern" class="headerlink" title="1.3.2.1. URI Pattern"></a>1.3.2.1. URI Pattern</h4><p>URI 路径样式与通配符</p>
<ul>
<li><code>?</code> 一个字符</li>
<li><code>*</code> 匹配任意个字符在同一个 uri 片段中： <code>/resources/*/versions</code> 不匹配 <code>/resources/a/b/versions</code></li>
<li><code>**</code> 匹配任意个 uri 片段，但只能出现在 末尾： <code>/resource/**/version</code> 是非法的</li>
<li><code>&#123;name&#125;</code> 匹配一个路径片段 （path segment）并将其捕获为名为 <code>name</code> 的变量</li>
<li><code>&#123;name:[a-z]+&#125;</code> 匹配一个符合正则表达式 <code>[a-z]+</code> 的路径片段，并将其捕获为 <code>name</code> 变量</li>
<li><code>&#123;*path&#125;</code> 匹配任意个路径片段并捕获其为 <code>path</code> 变量<ul>
<li>使用捕获的变量使用 <code>@PathVariable</code> 注解在 handler 参数中即可。</li>
</ul>
</li>
</ul>
<h4 id="1-3-2-2-自定义注解"><a href="#1-3-2-2-自定义注解" class="headerlink" title="1.3.2.2. 自定义注解"></a>1.3.2.2. 自定义注解</h4><p><em>Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclass RequestMappingHandlerMapping and overriding the getCustomMethodCondition method, where you can check the custom attribute and return your own RequestCondition.</em></p>
<h4 id="1-3-2-3-Explicit-Registrations"><a href="#1-3-2-3-Explicit-Registrations" class="headerlink" title="1.3.2.3. Explicit Registrations"></a>1.3.2.3. Explicit Registrations</h4><p>显式注册 RequestMapping</p>
<p>除使用注解进行注册外，可以直接使用代码实现更灵活的 RequestMapping 注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoWired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandlerMapping</span><span class="params">(RequestMappingHandlerMapping mapping, UserHandler handler)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">	RequestMappingInfo info = RequestMappingInfo</span><br><span class="line">			.paths(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>).methods(RequestMethod.GET).build();</span><br><span class="line">	Method method = UserHandler.class.getMethod(<span class="string">&quot;getUser&quot;</span>, Long.class);</span><br><span class="line">	mapping.registerMapping(info, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 handler 中的方法与 <code>/user/&#123;id&#125;</code> 映射关联上。</p>
<h2 id="1-4-Functional-Endpoints"><a href="#1-4-Functional-Endpoints" class="headerlink" title="1.4. Functional Endpoints"></a>1.4. Functional Endpoints</h2><p>函数式 mvc 编程，与 jdk8 很好地整合。可以直接使用流式编码将请求与响应数据装配好，诸如：header/body<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#webmvc-fn">reference</a></p>
<h2 id="1-5-Annotated-Controllers"><a href="#1-5-Annotated-Controllers" class="headerlink" title="1.5. Annotated Controllers"></a>1.5. Annotated Controllers</h2><p>Spring MVC 提供的注解式 Controller。<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller">reference</a></p>
<h3 id="1-5-1-DataBidder"><a href="#1-5-1-DataBidder" class="headerlink" title="1.5.1. DataBidder"></a>1.5.1. DataBidder</h3><p>使用 <code>@DataBidder</code> 给 Controller 添加数据绑定。</p>
<h3 id="1-5-2-Exceptions"><a href="#1-5-2-Exceptions" class="headerlink" title="1.5.2. Exceptions"></a>1.5.2. Exceptions</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-exceptionhandlers">reference</a></p>
<p>spring MVC 中的异常。</p>
<p>Spring MVC中的异常处理器 HandlerExceptionResolver 的实现：</p>
<ol>
<li>SimpleMappingExceptionResolver 可指定异常类名与错误页面的映射，用于浏览器应用</li>
<li>DefaultHandlerExceptionResolver 通过 Spring MVC 处理异常，并将异常与状态码映射。<code>ResponseEntityExceptionHandler</code> and REST API exceptions</li>
<li>ResponseStatusExceptionResolver 通过注解 <code>@ResponseStatus</code> 处理异常。根据注解值映射其到相应 HTTP 状态码</li>
<li>ExceptionHandlerExceptionResolver 通过调用 Controller 或 ControllerAdvice 中的 <code>@ExceptionHandler</code> 方法处理异常。</li>
</ol>
<h4 id="1-5-2-1-异常处理器链-Chain-of-Exceptions"><a href="#1-5-2-1-异常处理器链-Chain-of-Exceptions" class="headerlink" title="1.5.2.1. 异常处理器链 Chain of Exceptions"></a>1.5.2.1. 异常处理器链 Chain of Exceptions</h4><ol>
<li><p>形成异常处理器链直接 declare 多个异常处理器 bean 即可，指定其 <code>order</code> 值，越高的 order 值，执行处理得越晚。</p>
</li>
<li><p>异常处理器返回数据规约：</p>
<ol>
<li><p>使用 ModelAndView 指定错误页面</p>
</li>
<li><p>如果处理器已经将异常处理，返回一个空的 ModelAndView</p>
</li>
<li><p>如果处理器未处理，后面的处理器继续，如果最后异常一直未被处理，抛给 Servlet 容器。</p>
<ol>
<li><p>当所有异常处理器未将异常处理，异常传递到 Servlet 容器或指定了一个错误状态码（4xx,5xx），servlet container 可以渲染一个默认的错误 HTML 页面，在 web.xml 中配置（servlet API 不提供 java 形式的方式创建 error page mapping，只能以此种形式创建    ）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>servlet container 同时会作一个 ERROR 分发到配置的 URL ，于是就交给了 DispatcherServlet，如果有 Controller 对此 URL 处理，将映射到此 Controller 进行处理。剩下的就交给 Controller ，可能指定一个 model ，也可能响应一个 JSON。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Spring MVC 自动注册内置的异常处理器处理的异常包括：Spring MVC 异常、<code>@ResponseStatus</code> 注解的异常、<code>@ExceptionHandler</code> 注解的方法处理。可自定义异常处理器列表替换内置的处理器。</p>
</li>
</ol>
<h2 id="1-6-Asynchronous-Requests"><a href="#1-6-Asynchronous-Requests" class="headerlink" title="1.6.  Asynchronous Requests"></a>1.6.  Asynchronous Requests</h2><blockquote>
<p>异步请求</p>
</blockquote>
<h3 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h3><blockquote>
<p>异步请求的处理</p>
</blockquote>
<ol>
<li>ServletRequest 可以通过 <code>request.startAsync()</code> 切换入异步模式。异步模式开启，主要的效果是 Servlet 与 Filter 可退出，同时 response 保持打开至处理完成。</li>
<li><code>request.startAsync()</code> 方法返回 AsyncContext，可以使用此对象进行更细致地控制异步处理。</li>
<li>异步处理完成后，DispatcherServlet 将接收处理结果继续处理 response 。</li>
</ol>
<h4 id="Compared-to-WebFlux"><a href="#Compared-to-WebFlux" class="headerlink" title="Compared to WebFlux"></a>Compared to WebFlux</h4><ol>
<li>Spring WebFlux 不仅不需要构建在 Servlet API 之上，而且不需要异步 request ，因为其就是为异步请求而生。异步处理已设计在其框架之中，天生支持所有阶段的请求处理。</li>
</ol>
<h3 id="Http-Streaming"><a href="#Http-Streaming" class="headerlink" title="Http Streaming"></a>Http Streaming</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming">流式响应 Http 请求</a></p>
</blockquote>
<h4 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h4><ol>
<li>使用 ResponseBodyEmitter 让返回一个 value 可以生产对象流，每个对象都将被 HttpMessageConverter 序列化被写进 response 对象。</li>
<li>也可以将 ResponseBodyEmitter 写入一个 ResponseBody 中，实现自定义 header 与 status 。</li>
<li>当 Emitter 出现 I/O 异常，如：Client 离开。应用不需要清理连接，不需要调用 emitter.complete() / emitter.completeWithError()。Servlet Container 会自动初始化一个 AsyncListener 错误通知，Spring MVC 来完成 completeWithError 的调用。整个请求将执行一个最终的 Async 分发到应用，期间 Spring MVC 将使用配置异常处理器完成此次请求。</li>
</ol>
<h4 id="Raw-Data"><a href="#Raw-Data" class="headerlink" title="Raw Data"></a>Raw Data</h4><blockquote>
<p>有时需要直接返回不经过 message conversion 的生肉数据到响应输出流，比如：文件下载，这时可以使用 <code>StreamingResponseBody</code> 作为返回数据类型。</p>
</blockquote>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><blockquote>
<p>异步请求的配置 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-configuration">reference</a></p>
</blockquote>
<p>异步请求属性必须在 servlet container 级别配置。</p>
<ol>
<li>在servlet container 配置：1. Filter 和 Servlet 定义处需要将标识 asyncSupport 设置为 true。此外 Filter Mapping 需要定义为处理 DispatchType 为 <code>ASYNC</code>。<ol>
<li>java 配置中，如果使用的是 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 初始化 Servlet Container ，以上配置是自动完成的。</li>
<li>web.xml 配置，you can add <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code> to the DispatcherServlet and to Filter declarations and add <code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code> to filter mappings.</li>
</ol>
</li>
<li>Spring MVC 配置<ol>
<li>Java 配置，在 WebMvcConfigurer 中使用 configureAsyncSupport 回调</li>
<li>XML namespace: Use the <code>&lt;async-support&gt;</code> element under <code>&lt;mvc:annotation-driven&gt;</code></li>
<li>此外还可以配置：<ol>
<li>异步请求的默认超时值，如果不配置将取决于 Servlet Container</li>
<li>AsyncTaskExecutor ，用以执行异步请求，响应类型 REACTIVE TYPE  streaming 流执行从 controller 方法返回的 callable 实例。默认此配置是 <code>SimpleAsyncTaskExecutor</code>。</li>
<li><code>DeferredResultProcessingInterceptor</code> 实现与 <code>CallableProcessingInterceptor</code> 实现。</li>
<li>DeferredResult 与 ResponseBodyEmitter 可以单独设置其超时值，Callable 可以通过 <code>WebAsyncTask</code> 设置。</li>
</ol>
</li>
</ol>
</li>
</ol>

        </div>
        
        <div class="post-tag">
            
            <a class="tag" href="/tags/Spring/" title="Spring">Spring</a>
            
            <a class="tag" href="/tags/Java/" title="Java">Java</a>
            
            <a class="tag" href="/tags/SpringMVC/" title="SpringMVC">SpringMVC</a>
            
        </div>
        
    </article>
</div>
<div class="paginator">
    
        
            <a class="prev" href="/2017/08/23/Spring/Spring_Bean/">
                <i class="iconfont icon-prev"></i>
                <span class="nav-default">Spring bean</span>
                <span class="nav-mobile">Prev</span>
            </a>
        
        
            <a class="next" href="/2017/08/15/Spring/spring/">
                <span class="nav-default">Spring</span>
                <span class="nav-mobile">Next</span>
                <i class="iconfont icon-next"></i>
            </a>
        
    
</div>
<div id="comment-container"></div>
    </div>
</div>
<footer class="footer-social">
    
    <a class="social-link" target="_blank" href="https://github.com/KangShanR">
        <i class="iconfont icon-github"></i>
    </a>
    

    

    
    <a class="social-link" target="_blank" href="http://weibo.com/hey_you_go">
        <i class="iconfont icon-weibo"></i>
    </a>
    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
                2017 -
            
            2021
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin">Kang Shan</a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    
    var gitment = new Gitment({
        id: 'SpringMVC',
        owner: 'KangShanR',
        repo: '',
        oauth: {
            client_id: '074819c3098d17273370',
            client_secret: '7b600971b388f1af62c5802851a6b8a9130634cd'
        }
    });
    gitment.render('comment-container');
    

</script>
</html>
