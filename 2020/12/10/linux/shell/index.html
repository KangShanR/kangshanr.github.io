<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Kang Shan
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><blockquote>
<p>Shell 是一个可以执行命令／程序／shell 脚本的环境，提供了访问 Unix 系统的接口。其根据输入执行程序，执行完成后将结果展示出来。 <a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/unix/unix-what-is-shell.htm">Shell</a></p>
</blockquote>
<h2 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h2><blockquote>
<p>变量</p>
</blockquote>
<ul>
<li>只读变量 <code>readonly variable</code></li>
<li><code>unset &#123;variable_name&#125;</code> 重置一个变量，只读变量不可重置，重置后不能再访问</li>
<li>变量类型<ul>
<li>Local variable.存在于当前shell实例中的变量，shell开启程序后，程序不能访问local variable .</li>
<li>Environment variable. 环境变量，shell进程中任何地方可以获取环境变量.</li>
<li>Shell variable.shell脚本中定义的变量，可以是 local variable ,也可是Environment variable .</li>
</ul>
</li>
</ul>
<h2 id="Basic-operators"><a href="#Basic-operators" class="headerlink" title="Basic operators"></a>Basic operators</h2><p><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/unix/unix-basic-operators.htm">reference</a></p>
<h3 id="Arithmetic-operators"><a href="#Arithmetic-operators" class="headerlink" title="Arithmetic operators"></a>Arithmetic operators</h3><ul>
<li>使用基础运算符时引用变量需要同样使用 <code>$</code> 符号，但赋值时直接使用变量名即可。<code>expr a = $b</code></li>
<li>运算符与表达式之间需要空格分开。<code>expr $a != $b</code></li>
<li><code>*</code> 乘号使用需要添加转义 <code>\*</code></li>
<li>条件表达式使用需要被方括号(括号与表达式之间需要空格分隔)所包围：　<code>[ $a == $b ]</code></li>
</ul>
<h3 id="Relational-Operators"><a href="#Relational-Operators" class="headerlink" title="Relational Operators"></a>Relational Operators</h3><ul>
<li>同样需要方括号与空格包围变量 <code>[ $a -eq $b ]</code></li>
<li><code>-eq</code> equals</li>
<li><code>-ne</code> not equals</li>
<li><code>-gt</code> greater than</li>
<li><code>-lt</code> less than</li>
<li><code>-ge</code> greater or equals</li>
<li><code>-le</code> less or equals</li>
<li>关系运算符支付数值类，如果是string类必须是代表数值的string，eg:<code>&quot;100&quot;</code></li>
</ul>
<h3 id="Boolean-Operators"><a href="#Boolean-Operators" class="headerlink" title="Boolean Operators"></a>Boolean Operators</h3><ul>
<li><code>!</code> 取反</li>
<li><code>-o</code> OR</li>
<li><code>-a</code> AND</li>
<li>eg: <code>[ $a -gt 100 -a $b -le 20 ]</code></li>
</ul>
<h3 id="String-Operators"><a href="#String-Operators" class="headerlink" title="String Operators"></a>String Operators</h3><ul>
<li><code>=</code></li>
<li><code>!=</code></li>
<li><code>-z</code> zero 检测字串其长度是否为 ０  <code>[ -z $a ]</code></li>
<li><code>-n</code> not-zero 字串长度不为 0 <code>[ -n $a ]</code></li>
<li>str 检测字串是否为 empty <code>[ $a ]</code></li>
</ul>
<h3 id="File-Test-Operators"><a href="#File-Test-Operators" class="headerlink" title="File Test Operators"></a>File Test Operators</h3><p>检测关联到文件的变量属性。假如一个变量 <code>file</code> 关联到一个 test 文件，大小100bytes，有 read/write/execute 权限。其相关命令如下：</p>
<ul>
<li><code>-b file</code> check if file is a block special file. <code>[ -b $file ]</code> false</li>
<li><code>-c file</code> check if file is a character special file. <code>[ -c $file ]</code> false</li>
<li><code>-d file</code> check if file is a directory. <code>[ -d $file ]</code> false</li>
<li><code>-f file</code> check if file is an ordinal file as opposed to a directory or special file. <code>[ -f $file ]</code> is true</li>
<li><code>-e file</code> check if file exists. <code>[ -e $file ]</code> is true</li>
<li><code>-r</code>/<code>-w</code>/<code>-x</code> check if file is readable/writable/executable.</li>
</ul>
<h2 id="Decision-Making"><a href="#Decision-Making" class="headerlink" title="Decision Making"></a>Decision Making</h2><p><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/unix/unix-decision-making.htm">reference</a></p>
<p>shell 中两种类似 switch case 的分支语句：</p>
<ol>
<li>if…elif…else…fi</li>
<li>case…esac</li>
</ol>
<h2 id="Process-Control"><a href="#Process-Control" class="headerlink" title="Ｐrocess Control"></a>Ｐrocess Control</h2><ul>
<li>until 与 while 中的条件相反，满足条件在 while中循环，而不满足条件才在 until 中循环。</li>
<li><code>break n</code> 跳出循环，其中 n 代表正整数，默认不写为 1 只跳出当前层循环，而如果需要跳出第二层循环（从内往外数）就指定 n 为 2 。</li>
</ul>
<h2 id="Substitutions"><a href="#Substitutions" class="headerlink" title="Substitutions"></a>Substitutions</h2><blockquote>
<p>转义</p>
</blockquote>
<p>常用转义符号：</p>
<ul>
<li><code>\n</code> new line</li>
<li><code>\r</code> carriage return</li>
<li><code>\t</code> horizontal tab</li>
<li><code>\\</code> back slash</li>
<li><code>\a</code> alert</li>
<li><code>\b</code> backspace</li>
<li><code>\c</code> suppress trailing line</li>
<li><code>\f</code> form feed</li>
<li><code>\v</code> vertical tab</li>
</ul>
<h3 id="Command-Substitution"><a href="#Command-Substitution" class="headerlink" title="Command Substitution"></a>Command Substitution</h3><p><code>command</code> 使用 back quote 将命令包围起来，命令执行结果将返回。eg: echo “today is <code>date</code>“</p>
<h3 id="Variable-Substitution"><a href="#Variable-Substitution" class="headerlink" title="Variable Substitution"></a>Variable Substitution</h3><blockquote>
<p>变量转义</p>
</blockquote>
<p>使用变量转义可以将对变量进行检查，并对其返回值或变量作修改。</p>
<ul>
<li><code>$&#123;var:-word&#125;</code> 如果变量 var 为 null  或未设置，将使用 word 转义为结果， var 变量不会被设置成 word.</li>
<li><code>$&#123;var&#125;</code> 转义 var 的值</li>
<li><code>$&#123;var:=word&#125;</code> 转义 var 并将 word 赋值给 var。</li>
<li><code>$&#123;var:?message&#125;</code> 如果 var 未设置或为 null ，message 将打印到 standard error。用以检测变量 var 是否正确设置。</li>
<li><code>$&#123;var:+word&#125;</code> 如果 var 已设置，work 将转义给 var ，但 var 不会改变。</li>
</ul>
<h2 id="Quoting-Mechanisms"><a href="#Quoting-Mechanisms" class="headerlink" title="Quoting Mechanisms"></a>Quoting Mechanisms</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/unix/unix-quoting-mechanisms.htm">引用机制</a></p>
</blockquote>
<h3 id="Meta-Characters"><a href="#Meta-Characters" class="headerlink" title="Meta Characters"></a>Meta Characters</h3><blockquote>
<p>Unix 元字符在 shell 中有特殊含义，所以在命令中如果要使用其为普通字串，需要在其前加上转义符号 backslash <code>\</code>。 Unix 中的元字符包括：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* ? [ ] &#x27; &quot; \ $ ; &amp; ( ) | ^ &lt; &gt; new-line space tab</span><br></pre></td></tr></table></figure>

<p><code>?</code> 代表任何一个字符，而 <code>*</code> 代表任意多个字符。</p>
<h3 id="quoting"><a href="#quoting" class="headerlink" title="quoting"></a>quoting</h3><blockquote>
<p>引用方式有四种</p>
</blockquote>
<ol>
<li>单引号引用 <code>&#39;</code>，特殊符号会将全部的元字符给转义为字面量。当需要输出单引号时，此时可以使用 backslash 将其转义输出。</li>
<li>双引号引用 <code>&quot;</code>，大部分特殊符号被双引号引用有将丢失其特殊意义，但有例外：$ ` $ &#39; &quot; \</li>
<li>backslash <code>\</code>, 所有特殊变量在 backslash 后都将丢失其特殊意义</li>
<li>back quote `, 被 back quote 包围的任何字符都将会被当作命令执行。</li>
</ol>
<h2 id="IO-Redirection"><a href="#IO-Redirection" class="headerlink" title="IO Redirection"></a>IO Redirection</h2><blockquote>
<p>IO 重定向</p>
</blockquote>
<p>重定向的命令有：</p>
<ol>
<li><code>pgm &gt; file</code> 重定向到输出文件</li>
<li><code>pgm &gt;&gt; file</code> 将输出追加到指定文件</li>
<li><code>pgm &lt; file</code> 程序从文件读取输入</li>
<li><code>n &gt; file</code> 将 n fd 的流输出重定向到文件 file</li>
<li><code>n &gt;&gt; file</code> 将 fd n 的流输出重定向追加到文件 file</li>
<li><code>n &gt;&amp; m</code> 合并 fd n 流与 fd m 流输出</li>
<li><code>n &lt;&amp; m</code> 合并输入流 fd n 与 fd m</li>
<li><code>&lt;&lt; tag</code>  Standard input comes from here through next tag at the start of line</li>
<li><code>|</code> 管道，将前一个程序／应用的输出发送到下一个</li>
</ol>
<p>NOTE: <em>file descriptor（fd） 在 Unix 中使用非负整数表示，其中 0 表示标准输入 STDIN，1 表示标准输出 STDOUT，2 表示错误输出 STDERR</em><br>在 Unix 系统中每个非守护进程都有以上三个 IO 流，进程通过 kernel 访问文件 file table / inode table。</p>
<p>在脚本中实现交互</p>
<ol>
<li>使用重定向</li>
<li>使用管道</li>
<li>使用 expect （需要安装此功能）</li>
</ol>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><blockquote>
<p>Unix shell function</p>
</blockquote>
<ul>
<li>定义 function 其语法是：在方法名后跟上 <code>function_name () &#123;&#125;</code>，传递参数直接在命令行中添加，在方法中调用参数使用 <code>$n</code></li>
<li>返回数据使用关键字 <code>return</code></li>
<li><code>exit</code> 会终结整个 shell 执行，而不是 function 。</li>
<li><code>$?</code> 获取上一次命令返回值 <code>ret=$?</code>，此值只是一个整数代表结果，不能返回字符及其他</li>
<li>shell 文件调用需要使用 <code>. shell_file</code></li>
<li>shell 文件后缀可以不用写，一样的效果</li>
<li>shell 文件头指定 shell  执行 bash 类型也可不写，让系统默认的 shell 执行即可</li>
<li><code>echo $PATH</code> 可以看到系统全局变量，其中一般包括了 ~/bin ，所以要以在此文件路径中添加自己想要的全局 shell ，而实现任何地方不添加绝对路径前缀调用此 shell 。</li>
<li><code>$HOME</code> 调用当前用户目录，在 shell 中使用 ～ 不会生效。</li>
</ul>
<h2 id="Alias"><a href="#Alias" class="headerlink" title="Alias"></a>Alias</h2><blockquote>
<p>给 bash shell 命令添加别名.<a target="_blank" rel="noopener" href="https://blog.csdn.net/doiido/article/details/43762791">reference</a></p>
</blockquote>
<ul>
<li>使用命令 <code>alias command=&#39;command arguments&#39;</code> 给命令添加别名，从而缩小写常用参数的工作。eg: <code>alias grep=&#39;grep -iE --color=auto&#39;</code>，可以实现使用 grep 命令自动添加两个参数</li>
<li>如果要永久实现别名生效可以将命令添加到 ~/.bashrc 文件中并执行此文件</li>
<li>解除别名设置使用命令 <code>unalias name</code></li>
</ul>
<h2 id="添加机器命令别名与进入日志脚本"><a href="#添加机器命令别名与进入日志脚本" class="headerlink" title="添加机器命令别名与进入日志脚本"></a>添加机器命令别名与进入日志脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">D=`date +%F`</span><br><span class="line"></span><br><span class="line">echo &quot;today: $D&quot;</span><br><span class="line">echo &quot;AUGUMENTS: $@&quot;</span><br><span class="line">PT=&quot;/smapp/servers/snxia-api-app/logs/$D/&quot;</span><br><span class="line">echo &quot;path: $PT&quot;</span><br><span class="line">LOG_TYPE=&quot;&quot;</span><br><span class="line"></span><br><span class="line">alias grep=&#x27;grep -iE --color&#x27;</span><br><span class="line"></span><br><span class="line">if [ $# -eq 0 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;No arguments&quot;</span><br><span class="line">    cd $PT</span><br><span class="line">else</span><br><span class="line">    get_log_type $2</span><br><span class="line">    if [ $1 = &quot;v&quot; ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;vim ...&quot;</span><br><span class="line">        vim &quot;$PT/$LOG_TYPE&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_log_type () &#123;</span><br><span class="line">    echo &quot;arguments: $*&quot;</span><br><span class="line">    if [ $1 = &quot;e&quot; ]</span><br><span class="line">    then</span><br><span class="line">        LOG_TYPE=&quot;error-log.log&quot;</span><br><span class="line">    elif [ $1 = &quot;i&quot; ]</span><br><span class="line">    then</span><br><span class="line">        LGO_TYPE=&quot;info-log.log&quot;</span><br><span class="line">    else [ $1 = &quot;w&quot; ]</span><br><span class="line">        LOG_TYPE=&quot;warn-log.log&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h3 id="Shell-脚本中-cd-命令不生效"><a href="#Shell-脚本中-cd-命令不生效" class="headerlink" title="Shell 脚本中 cd 命令不生效"></a>Shell 脚本中 cd 命令不生效</h3><p>再现：在 l 脚本中写了 cd 命令，再放在 PATH 中，在 terminal 直接调用这个脚本 <code>l</code> ，发现当前目录还是原目录并未进入到脚本中指定的目录。</p>
<p>原因：在接 terminal 调用脚本，是在当前 shell 环境中执行另外一个进程，进程结束就返回了原 shell 。</p>
<p>解决：使用 <code>source</code> 或 <code>.</code> 命令在当前 shell 中执行脚本，而不是直接调用脚本。</p>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Kang | <a target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder">Theme: Hexo-Coder</a></h4>
        <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="light">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>