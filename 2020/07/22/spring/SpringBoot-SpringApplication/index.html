<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Kang Shan
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="1-SpringApplication"><a href="#1-SpringApplication" class="headerlink" title="1. SpringApplication"></a>1. SpringApplication</h1><!-- TOC -->

<ul>
<li><a href="#1-springapplication">1. SpringApplication</a><ul>
<li><a href="#11-application-availability">1.1. Application Availability</a><ul>
<li><a href="#111-liveness-state">1.1.1. Liveness State</a></li>
<li><a href="#112-readiness-state">1.1.2. Readiness State</a></li>
<li><a href="#113-managing-the-application-availability-state">1.1.3. Managing the Application Availability State</a></li>
</ul>
</li>
<li><a href="#12-application-events-and-listeners">1.2. Application Events and Listeners</a></li>
<li><a href="#13-web-environment">1.3. Web Environment</a></li>
<li><a href="#14-accessing-application-arguments">1.4. Accessing Application Arguments</a></li>
<li><a href="#using-the-applicationrunner-and-commandlinerunner">Using the ApplicationRunner and CommandLineRunner</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B">初始化流程</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-spring-application">SpringBoot Features</a></p>
<h2 id="1-1-Application-Availability"><a href="#1-1-Application-Availability" class="headerlink" title="1.1. Application Availability"></a>1.1. Application Availability</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability">系统可用性</a></p>
<p>可以通过注入 <code>ApplicationAvailability</code> 接口到 bean 中以获取应用可用性状态。</p>
<h3 id="1-1-1-Liveness-State"><a href="#1-1-1-Liveness-State" class="headerlink" title="1.1.1. Liveness State"></a>1.1.1. Liveness State</h3><p>应用活性，用以表明应用内部状态是否能正常工作，或是否能从异常中自动恢复。如果不能（失活），基础平台应该重启应用。一般来说，应用活性不应该基于外部检查，否则外部检查系统（数据库、缓存、Web API）出现异常，将触发大量重启与平台累积的失败。</p>
<p>Spring Boot 应用的内部状态一般取决于 <code>ApplicationContext</code>。如果 ApplicationContext 成功启动，Spring Boot 就将认为应用在有效的状态。只要 context  be refreshed ，应用就被认为是有活性的。</p>
<h3 id="1-1-2-Readiness-State"><a href="#1-1-2-Readiness-State" class="headerlink" title="1.1.2. Readiness State"></a>1.1.2. Readiness State</h3><p>应用就绪状态，用以表明应用是否对处理流量准备就绪。未进入就绪状态将告诉 platform 平台此时不宜路由流量到应用。典型的场景是在应用启动阶段，当 <code>CommandLineRunner</code> 与 <code>ApplicationRunner</code> 组件正在被处理时，或者应用忙于其他流量请求时而不能处理当前流量请求时。</p>
<p>需要在程序启动阶段添加任务可以通过将 bean 实现接口 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code>，而不是使用 Spring 组件生命周期回调 <code>@PostConstruct</code>。以上两个接口分别可获取到程序启动参数和命令行参数。</p>
<h3 id="1-1-3-Managing-the-Application-Availability-State"><a href="#1-1-3-Managing-the-Application-Availability-State" class="headerlink" title="1.1.3. Managing the Application Availability State"></a>1.1.3. Managing the Application Availability State</h3><ol>
<li>获取应用当前可用性状态：注入 <code>ApplicationAvailability</code> 接口并调用其方法；</li>
<li>监听应用可用性变化：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChange</span><span class="params">(AvailabilityChangeEvent&lt;ReadinessState&gt; event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getState()) &#123;</span><br><span class="line">    <span class="keyword">case</span> ACCEPTING_TRAFFIC:</span><br><span class="line">        <span class="comment">// create file /tmp/healthy</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> REFUSING_TRAFFIC:</span><br><span class="line">        <span class="comment">// remove file /tmp/healthy</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新应用可用性状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"><span class="comment">//自动 constructor 注入 publisher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LocalCacheVerifier</span><span class="params">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eventPublisher = eventPublisher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CacheCompletelyBrokenException ex) &#123;</span><br><span class="line">        <span class="comment">//发布一个可用性更新事件</span></span><br><span class="line">        AvailabilityChangeEvent.publish(<span class="keyword">this</span>.eventPublisher, ex, LivenessState.BROKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-Application-Events-and-Listeners"><a href="#1-2-Application-Events-and-Listeners" class="headerlink" title="1.2. Application Events and Listeners"></a>1.2. Application Events and Listeners</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability">应用事件与监听器</a></p>
<p>除了常规的应用事件 <code>ContextRefreshedEvent</code>， 一个 Spring 应用还可以发送其他事件。其中一些事件在整个应用上下文 <code>ApplicationContext</code> 创建前，对于这种事件并不能注册其监听器为一个 <code>Bean</code> ，但可以通过 <code>SpringApplication.addListeners()</code> 或 <code>SpringApplicationBuilder.listeners()</code> 方法注册。如果需要不考虑上下文是否创建自动注册监听器，可以在工程中 <code>META-INF/spring.factories</code> 引入监听器，使用 key <code>org.springframework.context.ApplicationListener=com.myproject.MyListener</code> 。</p>
<p>应用开始启动后，事件发布顺序如下：</p>
<ol>
<li><code>ApplicationStartingEvent</code> 在应用刚开始启动，除 listeners initializers 已注册外，所有的其他处理工作都还未开启时。</li>
<li><code>ApplicationEnvironmentPreparedEvent</code> 事件发布时机：<code>Environment</code> 在上下文中已清晰但上下文还未创建时</li>
<li><code>ApplicationContextInitializedEvent</code> 在 <code>ApplicationContext</code> 已准备且 ApplicationInitializers 已被调用但 bean definitions 还未加载时</li>
<li><code>ApplicationPreparedEvent</code> refreshed 开始之前 bean definitions 加载之后</li>
<li><code>ApplicationStartedEvent</code>context refreshed 之后，application runners 与 command-line runners 调用之前</li>
<li><code>AvailabilityChangeEvent</code> 在 <code>LivenessState.CORRECT</code> 可用性表明应用程序已具活性后</li>
<li><code>ApplicationReadyEvent</code> 在所有的 application/command-line runner 被调用之后</li>
<li><code>AvailabilityChangeEvent</code> 应用已为服务请求准备就绪 <code>ReadinessState.ACCEPTING_TRAFFIC</code> 之后</li>
<li><code>ApplicationFailedEvent</code> 启动异常之后</li>
</ol>
<p>以上 9 个事件是与 <code>SpringApplication</code> 绑定的事件，除此外，在 <code>ApplicationPreparedEvent</code> 与 <code>ApplicationStartedEvent</code> 之间还有两个事件：</p>
<ol>
<li><code>WebServerInitializedEvent</code> <code>WebServer</code> 准备就绪后。而 <code>ServletWebServerInitializedEvent</code> 与 <code>ReactiveWebServerInitializedEvent</code> 分别在 servlet 与 reactive variants 就绪后。</li>
<li><code>ContextRefreshedEvent</code> <code>ApplicationContext</code> 刷新后 when an ApplicationContext is refreshed.</li>
</ol>
<p>Spring Boot 就是使用以上各个事件来处理各类任务。</p>
<p><em>根据以上顺序，倒推 Spring 应用启动的处理有：</em></p>
<ol>
<li>注册 listeners 与 initializers</li>
<li>创建环境配置 <code>Environment</code></li>
<li>创建上下文 ApplicationContext ，调用 ApplicationInitializers</li>
<li>加载 bean definitions</li>
<li>如果是 web 工程应用，加载相关 WebServer: ServletWebServer/ReactiveWebServer</li>
<li>刷新 ApplicationContext</li>
<li>改变应用可用性为活性 <code>LivenessState.CORRECT</code></li>
<li>调用 application runner command-line runner</li>
<li>改变应用服务请求就绪状态为就绪 <code>ReadinessState.ACCEPTING_TRAFFIC</code></li>
</ol>
<p>Spring Framework 的事件发布机制在子 context 发布事件后，父 context 同样会收到相应的事件发布，所以如果应用使用了 SpringApplication 层级，一个监听器会收到相同类型的 application event。为了区别来自哪里，可以将 Context 注入对比。如果 listener 是个 bean 直接使用 @AutoWired 注入，如果 listener 不是 bean 需要实现 ApplicationContextAware 接口注入。</p>
<h2 id="1-3-Web-Environment"><a href="#1-3-Web-Environment" class="headerlink" title="1.3. Web Environment"></a>1.3. Web Environment</h2><p>SpringApplication 根据代码行为来创建正确的 <code>ApplicationContext</code> ，决定 <code>WebApplicationType</code> 的算法是：</p>
<ol>
<li>如果存在 Spring MVC ，使用 <code>AnnotationConfigServletWebApplicationContext</code></li>
<li>如果不使用 Spring MVC 使用 Spring WebFlux，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>否则，使用 <code>AnnotationConfigApplicationContext</code></li>
</ol>
<p>算法决定了，如果一个应用使用了 Spring MVC 也使用了 Spring WebFlux ，将按 Spring MVC 处理。可使用 <code>setWebApplicationType(WebApplicationType)</code> 方法直接覆盖算法决定。如果要完全控制 <code>ApplicationContext</code> 使用方法 <code>setApplicationContestClass(...)</code>。在使用 JUnit 测试时，不需要 web 层，可调方法 <code>sebWebApplicationType(WebApplicationType.NONE)</code></p>
<h2 id="1-4-Accessing-Application-Arguments"><a href="#1-4-Accessing-Application-Arguments" class="headerlink" title="1.4. Accessing Application Arguments"></a>1.4. Accessing Application Arguments</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment">访问应用参数</a></p>
<p>在 Spring Boot 中，当需要访问应用参数时，注入一个 <code>ApplicationArguments</code> bean，即可直接访问 <code>String[]</code> 参数或编译成 option 与 not-option 形式的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoWired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">    List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">    <span class="comment">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot 也注册了一个与 Environment 关联的 <code>CommandLinePropertySource</code>，这就意味着可以在程序中使用 <code>@Value</code> 注解直接注入各个命令行参数。</p>
<h2 id="Using-the-ApplicationRunner-and-CommandLineRunner"><a href="#Using-the-ApplicationRunner-and-CommandLineRunner" class="headerlink" title="Using the ApplicationRunner and CommandLineRunner"></a>Using the ApplicationRunner and CommandLineRunner</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment">使用应用、命令行Runner</a></p>
<p>如果需要在 SpringApplication 启动后执行某些代码，可以实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口，这两个接口都提供一个 <code>run(ApplicationArguments)</code> 方法定义，其实现都是在 <code>SpringApplication.run(...)</code> 方法完成之前调用。如果有多个 Runner 需要执行，可以在 Runner 上添加 <code>Order</code> 接口或 <code>@Order</code> 注解用以指定顺序。</p>
<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><blockquote>
<p>spring boot 在初始化中把大量工作做了。</p>
</blockquote>
<ol>
<li>加载 environment 数据</li>
<li>创建 context</li>
<li>context refresh<ol>
<li>其中对入口类进行数据扫描，工作在 <code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code>，大量调用 ConfigurationClassParser 进行数据解析。</li>
<li>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass 该解析器方法处理所有的 configuration 配置类数据，包括各注解 @Component @ComponentScan @PropertiesSource @Import @ImportSource @Bean 内嵌类、父类、接口默认方法 数据</li>
<li><code>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</code> 调用 beanFactoryPostProcessor ，其就包括了将所有的 component 中的 beanDefinition 注册到容器 BeanDefinitionRegistry 中，也包括调用所有的 BeanPostProcessor .</li>
<li>注册 BeanFactoryProcessor 时从 BeanDefinitionRegistry 获取其 BeanDefinition 进行初始化 bean 。</li>
<li>org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass 使用 CGLIB 动态代理生成 bean 子类</li>
</ol>
</li>
</ol>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Kang | <a target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder">Theme: Hexo-Coder</a></h4>
        <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="light">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>