<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Kang Shan
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Externalized-Configuration"><a href="#Externalized-Configuration" class="headerlink" title="Externalized Configuration"></a>Externalized Configuration</h1><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config">spring boot 外部配置</a></p>
<blockquote>
<p>外部配置</p>
</blockquote>
<p>一个应用，其通常添加外部配置的方式：properties file, yml files, environment variables, 命令行参数扩展配置。配置属性可以通过 <code>@Value</code> 直接被注入到 bean 中，通过 <code>Environment</code> 抽象直接访问，也可以通过 <code>@ConfigurationProperties</code> 绑定到结构对象上。</p>
<p>Spring Boot 加载 <code>PropertySource</code> 有明确的顺序，以保证正确覆盖配置值。其<strong>配置优先级</strong>从高到低依次为：</p>
<ol>
<li>当 devtool 在激活状态时， <code>$HOME/.config/spring-boot</code> 中的 devtool 全局配置</li>
<li><code>@TestPropertySource</code> 注解的 test 配置</li>
<li><code>@SpringBootTest</code> 注解与局部应用 test 注解上的 <code>Properties</code> 属性</li>
<li>命令行参数</li>
<li>内嵌于环境变量或系统属性的行内 JSON <code>SPRING_APPLICATION_JSON</code> 属性</li>
<li><code>ServletConfig</code> 初始化参数</li>
<li><code>ServletContext</code> 初始化参数</li>
<li><code>java:comp/env</code> JNDI 属性</li>
<li><code>System.getProperties()</code> Java 系统属性</li>
<li>操作系统环境变量 OS environment variables</li>
<li><code>random.*</code> 中的随机属性值 <code>RandomValuePropertySource</code></li>
<li>包外的特定 profile 属性文件 <code>application-&#123;profile&#125;.properties</code> 与 YAML 变体</li>
<li>包内特定 profile 属性文件 <code>application-&#123;profile&#125;.properties</code> 或 YAML 变体</li>
<li>包外应用属性文件 <code>application.properties</code> 和 YAML 变体</li>
<li>包内应用配置文件  <code>application.properties</code> 和 YAML 变体</li>
<li><code>@PropertySource</code> 注解于 configuration 类上标注的属性文件。需要注意的是，这种配置在 application refreshed 前不会被加载到 <code>Environment</code> 中去，因此如果使用这种方式添加诸如 <code>logging.*</code> <code>spring.main.*</code> 配置是无效的，因为在 context refreshed 前，这些配置已经被读取了。</li>
<li>通过 <code>SpringApplication.setDefaultProperties()</code> 设置的默认属性。</li>
</ol>
<p>Spring Boot 在加载配置时支持通配路径，在外部指定不同路径下的同名配置文件时使用通配路径就会很方便。<strong>通配路径必须包含且仅包含一个 <code>*</code> ，并且当以文件夹结尾时以 <code>/</code> 结尾，以文件为查找对象时以 <code>/&lt;filename&gt;</code> 结尾</strong>。查找出的位置以文件路径的字母顺序排序。</p>
<h2 id="Configuring-Random-Values"><a href="#Configuring-Random-Values" class="headerlink" title="Configuring Random Values"></a>Configuring Random Values</h2><p>配置随机值随机注入一个 integer/long/uuid/string :</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="meta">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">my.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="meta">my.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">my.number.less.than.ten</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="meta">my.number.in.range</span>=<span class="string">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>

<p>随机配置语法 <code>$&#123;random.int*&#125;</code>是 <code>OPEN value (,max) CLOSE</code> <code>OPEN</code> 与 <code>CLOSE</code> 指代任意符号用以将最大值与最小值包起来，<code>value</code> 与 <code>max</code> 是 integer 。如果提供 <code>max</code>，<code>value</code> 就指最小值，<code>max</code> 指最大值（不包含）。</p>
<h2 id="Accessing-Command-Line-Properties"><a href="#Accessing-Command-Line-Properties" class="headerlink" title="Accessing Command Line Properties"></a>Accessing Command Line Properties</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config">访问命令行参数</a></p>
<p>默认情况下命令行参数在 Spring 配置中有最高优先级别。在启动命令行中以 <code>--</code> 开始指定命令行参数。如果需要禁用命令行参数加入到系统 <code>Environment</code> 中，可以 <code>SpringApplication.setAddCommandLineProperties(false)</code>。</p>
<h2 id="Application-Property-Files"><a href="#Application-Property-Files" class="headerlink" title="Application Property Files"></a>Application Property Files</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-application-property-files">应用配置文件</a></p>
<p><code>SpringApplication</code> 将不同位置的配置文件 <code>application.properties</code> 或 <code>.yaml</code> 数据加载到 <code>Environment</code> 中，不同位置加载优先级为：</p>
<ol>
<li>当前路径子路径 <code>/config</code></li>
<li>当前路径 The current directory</li>
<li>classpath <code>/config</code> 包</li>
<li>classpath 根</li>
</ol>
<p>高优先级配置会覆盖低优先级配置。</p>
<p>如果需要修改配置文件，可以指定环境属性 <code>spring.config.name</code> 指定另一个配置文件，同时可指定 <code>spring.config.location</code> 多个配置文件路径（可为逗号 <code>,</code> 分隔的多个文件夹路径或文件路径，排列越靠后优先级越高）。这两个环境属性在很早期需要用以加载文件，所以必需以环境属性的方式（An OS Environment Variable, a system property, a command-line argument）指定。</p>
<p>当 <code>spring.config.location</code> 指定文件夹路径时，需要以 <code>/</code> 结尾，在运行时将在其后追加 <code>spring.config.name</code> 中分离出的文件名与 profile-specific file name 。当 location 指定了全文件名时，直接使用此文件名，但不支持 profile-specific variant，并被 profile-specific 属性覆盖。</p>
<p><code>spring.config.additional-location</code> 用以指定额外的配置路径，其优先级大于默认的路径</p>
<h2 id="Profile-specific-Properties"><a href="#Profile-specific-Properties" class="headerlink" title="Profile-specific Properties"></a>Profile-specific Properties</h2><p>通过 <code>spring.profiles.active</code> 变量激活当前应用的配置文件。profile 配置文件规约其名为 <code>application-&#123;profile&#125;.properties</code> ，当没有指定 profile 时， Environment 自动使用 <code>default</code> 作为 profile 环境配置，<code>application-default.properties</code> 中的属性将被加载。</p>
<p>与标准的 <code>application.properties</code> 配置文件一样，profile 配置文件将从指定位置加载，同时不管所打包的 jar 包内还是包内，profile-specific file 配置覆盖 non-specific ones。If several profiles are specified, a last-wins strategy applies.如果指定多个，后者覆盖前者。</p>
<p>如果在 <code>spring.config.location</code> 中指定了配置文件，那么此文件在 profile-specific variant 匹配中就不再考虑了。换句话说，如果需要使用 profile-specific 策略匹配配置文件，就不要在 <code>spring.config.location</code> 中添加相关的文件，最好其中只指定 directories 不指定文件。</p>
<h2 id="Placeholders-in-Properties"><a href="#Placeholders-in-Properties" class="headerlink" title="Placeholders in Properties"></a>Placeholders in Properties</h2><p>在使用配置文件中 <code>application.properties</code> 配置的值时会通过存在的 <code>Environment</code> 过滤，所以，可以在配置中使用占位符 <code>$&#123;&#125;</code> 引用先前定义好的配置（如：系统属性）。</p>
<h2 id="Type-safe-Configuration-Properties"><a href="#Type-safe-Configuration-Properties" class="headerlink" title="Type-safe Configuration Properties"></a>Type-safe Configuration Properties</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding">类型安全配置属性</a></p>
</blockquote>
<h3 id="JavaBean-Properties-Binding"><a href="#JavaBean-Properties-Binding" class="headerlink" title="JavaBean Properties Binding"></a>JavaBean Properties Binding</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding">JavaBean 属性绑定</a></p>
<ul>
<li>Spring Boot 映射配置到 javaBean 属性中并不是直接使用类的 Accessors(getter/setter)；</li>
<li>如同 Spring MVC ，配置属性绑定通过标准的 Java Beans 属性描述符实现，所以在默认的空的构造器与 getter setter 通常是必须的；</li>
<li>在以下情况下 setter 可以省略：<ul>
<li>被初始化过的 Maps，只需要 getter 不需要 setter，因为他们可以通过 binder 改变。</li>
<li>Collections Arrays 要么通过 <code>.yml</code> index 要么通过 <code>.properties</code> 的逗号分隔的单个值。在后者，setter 是必须的。如果初始化一个 collection ，保证其是可变的。</li>
<li>如果是内嵌的 POJO 属性，且已被初始化，setter 可以省略。如果需要让 binder 快速初始化 POJO ，这时 setter 是需要的。</li>
</ul>
</li>
<li>使用 Lombok 自动生成时，保证不要生成特定类型的构造器，因为容器可能需要用来初始化对象。</li>
<li>只有标准 Java Bean 属性才能被绑定，<strong>不支持绑定属性到静态字段上。</strong></li>
</ul>
<h3 id="Constructor-Binding"><a href="#Constructor-Binding" class="headerlink" title="Constructor Binding"></a>Constructor Binding</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding">构造器绑定</a></p>
<ul>
<li>在类上添加注解 <code>@ConstructorBinding</code></li>
<li>内嵌的属性 POJO 也会使用构造器绑定方式绑定配置属性。</li>
<li>默认值可使用 <code>@DefaultValue(&quot;default&quot;)</code> 注解添加在属性上，当 binder 找不到相关的配置就会强制将默认值添加到指定属性上</li>
<li>默认情况下，如果没有为属性配置值，对象属性将为 null 。如果需要返回一个非 null POJO，可以指定一个空的 <code>@DefaultValue</code> 在其上。</li>
<li>使用构造器绑定，<strong>需要添加 <code>@EnableConfigurationProperties</code> 或配置属性扫描</strong>。常规 Spring Bean 创建机制创建的 Bean （@Component @Bean @Import）上并不能通过此构建器绑定属性。</li>
<li>如果绑定的 Class 有多个 Constructor ，可直接将 <code>@ConstructorBinding</code> 注解在需要的构造器上。</li>
</ul>
<h3 id="Enable-ConfigurationProperties-annotated-Types"><a href="#Enable-ConfigurationProperties-annotated-Types" class="headerlink" title="Enable @ConfigurationProperties-annotated Types"></a>Enable @ConfigurationProperties-annotated Types</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding">注册配置 bean</a></p>
<ul>
<li>Spring Boot 提供了绑定配置到类的机制也提供注册其为 Bean 的机制。可以一个类一个类地配置也可像组件扫描一样配置属性扫描。</li>
<li>如果需要部分扫描到配置属性，可以在 <code>@EnableConfigurationProperties</code> 指定 type.class ，任意 <code>@Configuration</code> 组件是添加此属性。</li>
<li>添加 <code>@ConfigurationPropertiesScan</code> 注解在 Application 上会自动扫描包内所有的配置属性 Bean，注解上可添加包。</li>
<li>当 Bean 注册到容器中后，这个 bean 有一个便名 <code>&lt;prefix&gt;-&lt;fqn&gt;</code> ，<code>&lt;prefix&gt;</code> 是在 <code>@ConfigurationProperties(prefix=&quot;&quot;)</code> 上指定的前缀， <code>&lt;fqn&gt;</code> 指其全限定名。如果没有指定 prefix ，只有全限定名会为此 bean 所用。<em>这他妈有啥用？</em></li>
</ul>
<h3 id="Using-ConfigurationProperties-annotated-Types"><a href="#Using-ConfigurationProperties-annotated-Types" class="headerlink" title="Using @ConfigurationProperties-annotated Types"></a>Using @ConfigurationProperties-annotated Types</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding">使用自动配置属性 Bean</a></p>
<p>在组件 Bean 直接无注解注入 <code>private final ConfiguredData configuredData;</code></p>
<h3 id="Third-party-Configuration"><a href="#Third-party-Configuration" class="headerlink" title="Third-party Configuration"></a>Third-party Configuration</h3><blockquote>
<p>第三方 Bean 属性注入</p>
</blockquote>
<ul>
<li>直接在注入第三方 Bean 方法定义处加上 <code>@ConfigurationProperties</code> 注解，将自动将同名配置注入到 Bean 属性中。</li>
</ul>
<h3 id="Relaxed-Binding"><a href="#Relaxed-Binding" class="headerlink" title="Relaxed Binding"></a>Relaxed Binding</h3><blockquote>
<p>松绑定</p>
</blockquote>
<p>Spring Boot 松绑定 Environment 属性到 @ConfigurationProperties bean 中，所以不需要精确匹配 Environment 属性名与 bean 属性名。常见的例子是使用 dash-separated 或大小写环境属性 context-path 绑定到 contextPath，PORT绑定到 port。</p>
<p>使用 <code>@ConfigurationProperties(prefix=&quot;project.data&quot;)</code> 注解在有名为 <code>firstName</code> 属性的 bean 上（prefix 的值必须为 Kebab Case 写法），那么在配置文件中可以使用：</p>
<ol>
<li><code>project.data.first-name</code>: Kebab Case （小写，单词分隔使用 <code>-</code>，看起来像羊肉串，所以叫 Kebab Case），推荐在 <code>.properties</code> 或 <code>.yml</code> 中使用</li>
<li><code>project.data.firstName</code> : standard camel case syntax 标准驼峰语法</li>
<li><code>project.data.first_name</code> : underscore notation，下划线符号，在 <code>.properties</code> <code>.yml</code> 中一种可选的写法</li>
<li><code>PROJECT_DATA_FIRSTNAME</code> : upper case format，推荐在系统环境变量中使用。</li>
</ol>
<h4 id="从环境变量绑定数据-Binding-from-Environment-Variables"><a href="#从环境变量绑定数据-Binding-from-Environment-Variables" class="headerlink" title="从环境变量绑定数据 Binding from Environment Variables"></a>从环境变量绑定数据 Binding from Environment Variables</h4><p>大多操作系统的环境变量都使用严格命名规则，如 Linux 系统 shell 变量只能使用字母数字下划线，Unix 系统 shell 变量只能使用大写。Spring Boot 为与这些系统兼容，规则如下：</p>
<ol>
<li>用 <code>_</code> 代替 <code>.</code></li>
<li>移除所有的 <code>-</code></li>
<li>转换为大写形式</li>
</ol>
<p>比如：配置属性 <code>spring.main.log-startup-info</code> 将被系统环境变量 <code>SPRING_MAIN_LOGSTARTUPINFO</code> 的值所绑定。note:<em>下划线并不会被 dash 所替换</em></p>
<p>环境变量同样可以绑定到数组对象，数组的下标数字被下划线代替：<code>data[0].name</code> 被环境变量 DATA_0_NAME 值所赋。</p>
<h3 id="Merging-Complex-Types"><a href="#Merging-Complex-Types" class="headerlink" title="Merging Complex Types"></a>Merging Complex Types</h3><p>使用 <code>.yml</code> 与 <code>.properties</code> 外部配置文件添加属性给bean 时，会自动将各个同配置注入到列表属性中，也可以在其中指定不同的 profile 下不同的属性。</p>
<h3 id="Properties-Conversion"><a href="#Properties-Conversion" class="headerlink" title="Properties Conversion"></a>Properties Conversion</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-relaxed-binding">reference</a></p>
<p>Spring Boot 内置转换器可以将对多个类型数据进行转换，使用 <code>@**Unit</code> 注解指定单位</p>
<ol>
<li>Duration，ms <code>@DurationUnit</code> ns us ms s m h d</li>
<li>Period ， days <code>@PeriodUnit</code> y m w(weeks is a shortcut means “7 days”) d</li>
<li>DataSize, byte <code>@DataSizeUnit</code> B KB MB GB TB</li>
</ol>
<p>可自定义 converter。</p>
<h3 id="ConfigurationProperties-Validation"><a href="#ConfigurationProperties-Validation" class="headerlink" title="@ConfigurationProperties Validation"></a>@ConfigurationProperties Validation</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation">reference</a></p>
<ul>
<li>在注解 <code>@ConfigurationProperties</code> 的类上添加 <code>@Validated</code> ， 用以约束字段。也可以使用 JSR-303 <code>@Validation</code> （需要保证 JSR-303 在 classpath 之中）。在 @Configuration 组件 bean 定义处添加 <code>@Validated</code> 注解用以验证 bean 。</li>
<li>验证内嵌的属性，其相应的字段需要添加 <code>@Valid</code> 注解</li>
<li>自定义 Spring Validator 通过添加一个名为 <code>configurationPropertiesValidator</code> bean 定义静态方法实现，之所以要为 静态的 ，因为 configurationProperties validator 在应用生命周期很早阶段就需要实例化并使用，为避免与外部 <code>@Configuration</code> 类耦合而需要过早地将外部组件类实例化引起的错误，所以需要将此 validator bean 方法定义为静态的。</li>
</ul>
<h3 id="ConfigurationProperties-vs-Value"><a href="#ConfigurationProperties-vs-Value" class="headerlink" title="@ConfigurationProperties vs. @Value"></a>@ConfigurationProperties vs. @Value</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation">reference</a></p>
<ul>
<li><code>@Value</code> 是容器核心特性，不提供类似类型安全的特性，支持部分 spring 松绑定，不支持 元数据，但比 <code>@ConfigurationProperties</code> 多支持 SpEL 表达式。</li>
<li>如果同一个组件定义了多个配置属性，推荐使用 <code>@ConfigurationProperties</code> 在bean 类上，这样可以做结构化类型安全的bean 用以注入到 bean 中。</li>
<li>如果需要使用 <code>@Value</code> ，推荐引用属性名通过其标准形式 Kebab-Case using only lowercase letters 。这样做可以让 Spring Boot 使用与 <code>@ConfigurationProperties</code> 松绑定相同的逻辑。如：使用 <code>@Value(&quot;&#123;demo.first-name&#125;&quot;)</code> ，那么配置文件中的 <code>demo.firstName</code> 与 <code>demo.first-name</code>与系统环境变量 <code>DEMO_FIRSTNAME</code> 都会被当作有效配置（优先级此处不作讨论）。而如果使用 <code>@Value(&quot;&#123;demo.firstName&#125;&quot;)</code> 只有配置文件中的 <code>demo.firstName</code> 会被识别到。</li>
</ul>
<h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><blockquote>
<p>spring 中的环境属性 org.springframework.core.env.Environment。</p>
</blockquote>
<p>此接口用于当前应用在运行时的环境，应用环境的两个关键模型是 <code>profiles</code> 与 <code>properties</code>。与 property 相关的访问方法定义于其父接口 <code>PropertyResolver</code> 。PropertyResolver 定义了很多可以直接将 String convert 2 T 的方法。</p>
<p>要实现操作应用的 Environment ，能过 <code>ConfigurableEnvironment</code> 实现。//TODO</p>
<p><code>profile</code> 是特定命名的一组的 bean definition，只有在指定 profile 是激活状态才能将这组 bean 注册于容器。</p>
<p>ApplicationContext 中的 bean 都可以通过 EnvironmentAware 接口或注入 <code>@Inject Environment</code> 获取应用配置数据。 通常情况下，大多数应用级别的 bean 不需要直接与 Environment 交互获取配置数据，可以直接使用属性占位符配置器（PropertySourcesPlaceholderConfigurer） <code>$&#123;&#125;</code> 获取属性配置值。PropertySourcesPlaceholderConfigurer 是 EnvironmentAware ，并从 Spring 3.1 开始只要配置 <code>&lt;context:property-placeholder/&gt;</code> ，就默认注册。</p>
<h3 id="AbstractEnvironment"><a href="#AbstractEnvironment" class="headerlink" title="AbstractEnvironment"></a>AbstractEnvironment</h3><p>基本的环境变量，实现了接口 <code>ConfigurableEnvironment</code> 。其内部定义了基本的应用环境属性：忽略系统环境变量 <code>IGNORE_GETENV_PROPERTY_NAME</code> 默认为 false， 激活状态配置 <code>ACTIVE_PROFILES_PROPERTY_NAME</code> ，默认配置 <code>DEFAULT_PROFILES_PROPERTY_NAME</code> ，默认配置名 <code>RESERVED_DEFAULT_PROFILE_NAME</code> 。</p>
<h3 id="StandardEnvironment"><a href="#StandardEnvironment" class="headerlink" title="StandardEnvironment"></a>StandardEnvironment</h3><p>继承自 AbstractEnvironment ，在其基础上添加了系统变量 <code>SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</code> 与环境变量 <code>SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</code>。系统变量优先级更高，其初始化过程中先添加系统变量再添加环境变量在配置数据最末（环境变量可在同一个系统中跨服务共用，而系统变量是针对一个 JVM 而设置）。</p>
<h3 id="StandardServletEnvironment"><a href="#StandardServletEnvironment" class="headerlink" title="StandardServletEnvironment"></a>StandardServletEnvironment</h3><p>StandardServletEnvironment 基于 Servlet 的 web 应用 Environment 实现，继承自 StandardEnvironment 。每个基于 Servlet 的 web 应用 ApplicationContext 都会默认初始化一个实例。此环境会在 StandardEnvironment 的基础上依次（决定了配置变量的优先级从高到低）添加变量： servlet Config 属性 <code>SERVLET_CONTEXT_PROPERTY_SOURCE_NAME</code>，servlet context 属性 <code>SERVLET_CONFIG_PROPERTY_SOURCE_NAME</code> ，JNDI 属性 <code>JNDI_PROPERTY_SOURCE_NAME</code> 。</p>
<h2 id="PropertySourcePlaceHolderConfigurer"><a href="#PropertySourcePlaceHolderConfigurer" class="headerlink" title="PropertySourcePlaceHolderConfigurer"></a>PropertySourcePlaceHolderConfigurer</h2><p>使用此配置器解析 ApplicationContext 中的所有的 BeanDefinition 中的占位符（默认格式 <code>$&#123;value&#125;</code>）。其实现了 <code>BeanFactoryPostProcessor</code> ，在 ApplicationContext 初始化阶段，会自动扫描所有的 BeanDefinition 并将所有使用占位符的地方都使用配置数据值进行替换。以此来实现占位符引入配置到 bean 中。</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>用于字段或方法参数上的注解，用以表明其默认值。典型应用于表达式驱动依赖注入，也支持处理器方法参数的动态方案，如 Spring MVC。</p>
<p><code>@Value</code> 注解的实际的处理是通过 <code>AutowiredAnnotationBeanPostProcessor</code> 实现，这就意味着不能使用此注解用于 BeanFactoryPostProcessor 与 BeanPostProcessor。</p>
<h4 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h4><p>一个 BeanPostProcessor 。//todo</p>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Kang | <a target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder">Theme: Hexo-Coder</a></h4>
        <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="light">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>