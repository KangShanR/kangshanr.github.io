{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1613910828253},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1613910882660},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1613910882660},{"_id":"public/2021/02/21/hello-world/index.html","hash":"6eb26906d4a6b364ce7323804e372dab4fb856ae","modified":1613916538845},{"_id":"public/archives/index.html","hash":"7170bc5e8f54f73e5945fefacf76eeed8bbc5e7f","modified":1613919718559},{"_id":"public/archives/2021/index.html","hash":"32212c1df80b31b1f6ca7688b49a14d3f69f8b1b","modified":1613919718559},{"_id":"public/archives/2021/02/index.html","hash":"65c866bbc3aefc4c7ebaf4648794712604d37731","modified":1613919718559},{"_id":"public/index.html","hash":"0b101a6dd34fe33dcb577d77c2ce2c01549e3097","modified":1613919718559},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1613916538845},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1613916538845},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1613916538845},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1613916538845},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1613916538845},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1613916538845},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1613916538845},{"_id":"public/css/style.css","hash":"263d98c93ae32dda6f7bbc8473105f3c441aca99","modified":1613916538845},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1613916538845},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1613916538845},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1613916538845},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1613916538845},{"_id":"source/_posts/Anotation.md","hash":"6bbad0f8c6d317782bf67333c454f4779544871c","modified":1610456691669},{"_id":"source/_posts/ClassLoader.md","hash":"6e4bdc10d923c245a8e1936d92bfaec0dbe87eaa","modified":1610456691669},{"_id":"source/_posts/File.md","hash":"f03af5d58c48472fdb691a8f988748358049f4c3","modified":1610456691669},{"_id":"source/_posts/Garbege Collection.md","hash":"f49a3aad4a5139cae48f864d52ae9b616e0fc05e","modified":1612539545909},{"_id":"source/_posts/Hash.md","hash":"7410b3b29c0a32be0d5a3c42003fb39422469b58","modified":1610456691669},{"_id":"source/_posts/Pattern.md","hash":"3a0f3acb63a40585632d6306e72c8eeb1028f61c","modified":1611321937892},{"_id":"source/_posts/ServiceProvider.md","hash":"05fdf81c084abdb9de5920b406a37f60f6528c9f","modified":1610456691669},{"_id":"source/_posts/URI in Java.md","hash":"17c772d92a66d76100c34cb172cf749a64d157d9","modified":1610456691669},{"_id":"source/_posts/bridge method.md","hash":"bc599c00415917f7308b3db529be91a68a4f27f5","modified":1610721611555},{"_id":"source/_posts/date-calenda.md","hash":"beffdfeef83736c930bf0cbbc179f9f41fd760c0","modified":1610456691669},{"_id":"source/_posts/guigargage.md","hash":"85bb276ca74f3b37521e9311c0f46c7441fee8d8","modified":1610456691669},{"_id":"source/_posts/jar.md","hash":"7ebb0fa74004fc7ee8ec184fd83fefedbddfcab5","modified":1610456691669},{"_id":"source/_posts/java reflect.md","hash":"fd7066bfbbb877d4197d0248ace38f37eb982ce4","modified":1610456691669},{"_id":"source/_posts/java socket.md","hash":"202f513a3e5ef3f77b3d1379126f508570b4da00","modified":1610456691669},{"_id":"source/_posts/java transient.md","hash":"8e3c6dd3626db8168541697077c078fdaf8d8c8c","modified":1610456691669},{"_id":"source/_posts/java-abstractclass-interface.md","hash":"64f8984aa22990e7fdad8175c73d3dadd8f2d0ba","modified":1610456691669},{"_id":"source/_posts/java-bigdecimal.md","hash":"d98d9a9807c638f42dad2b706ef226c1098fbe6f","modified":1610456691669},{"_id":"source/_posts/java-code-rule.md","hash":"5001e33c0a660e9fc84281252c810fd493b9e29c","modified":1610456691669},{"_id":"source/_posts/java-keywords.md","hash":"3d21bf8d284d0a0e02ea1e2bbd479ca8d58c43c2","modified":1610456691669},{"_id":"source/_posts/java-try-catch-finally.md","hash":"60f4025f5ca64803fa0d1464da8d492dca5fa055","modified":1610456691669},{"_id":"source/_posts/java-type.md","hash":"6936e0b2d7d8518535d36465eb5f5c30c9f952e5","modified":1610456691669},{"_id":"source/_posts/java.md","hash":"bfbf03e0763178c36afb34c470abe7d9881151b7","modified":1610456691669},{"_id":"source/_posts/java8-features.md","hash":"de75016a24b9fb5783e557a4437833cbd1459730","modified":1610456691669},{"_id":"source/_posts/super-in-param-extends-in-result.md","hash":"b96e527921cab13c6982c715b1cb93e05631e635","modified":1610456691669},{"_id":"public/2021/02/21/bridge method/index.html","hash":"3559d44512df6b5cb58a2c394cb44b3a17db083c","modified":1613919718559},{"_id":"public/2021/01/22/Pattern/index.html","hash":"7dfc6fbfa342536185528ae75465a7af00a4be54","modified":1613919718559},{"_id":"public/2020/12/09/java transient/index.html","hash":"1f48022f05c179955d96a5188881c0e34f615b3f","modified":1613919718559},{"_id":"public/2020/11/10/java reflect/index.html","hash":"9c0d93ef89c413db8c05dddaa35b3e7a11918eed","modified":1613919718559},{"_id":"public/2020/11/03/java/index.html","hash":"a13998839c5bdababee0fee59a86bd1b1387d069","modified":1613919718559},{"_id":"public/2020/10/21/guigargage/index.html","hash":"e9306db3b2cc9f52c202d2a4fdc41e4ad005f1ef","modified":1613919718559},{"_id":"public/2020/10/20/jar/index.html","hash":"de5f5a60b60f3f3b35d547a461e88f816a8edd7e","modified":1613919718559},{"_id":"public/2020/10/12/java-keywords/index.html","hash":"e57956bc04b5017cfbac82f49a274318ea1e7a2c","modified":1613919718559},{"_id":"public/2020/09/15/ClassLoader/index.html","hash":"f96adaafc65b6ed1f98bb9a4e14f01be5cf7462b","modified":1613919718559},{"_id":"public/2020/08/12/File/index.html","hash":"006eee37ea408651ffe948163224d9603b10857d","modified":1613919718559},{"_id":"public/2020/08/12/Garbege Collection/index.html","hash":"d95485c4beed102f1ca871b6f51e3b96a5a0d449","modified":1613919718559},{"_id":"public/2020/08/07/ServiceProvider/index.html","hash":"2b9619fc0bf14565c2ef85b5653da5f3164508e0","modified":1613919718559},{"_id":"public/2020/03/15/java socket/index.html","hash":"01c73f3b3e25145fc271845e612598505aba0d36","modified":1613919718559},{"_id":"public/2019/01/29/java-type/index.html","hash":"9d8224b0a92fc5baa769368308c7fc0cc38eefd2","modified":1613919718559},{"_id":"public/2019/01/23/java-code-rule/index.html","hash":"183cbb3011a202494f5b370a316eac18c5a2738d","modified":1613919718559},{"_id":"public/2019/01/22/java-abstractclass-interface/index.html","hash":"d96e608bcea95831c6d552df9aa3a8cf9aad5d08","modified":1613919718559},{"_id":"public/2019/01/22/java-try-catch-finally/index.html","hash":"012513a0f6315e3bc308cfa6bec7992d77044d28","modified":1613919718559},{"_id":"public/2018/10/11/java-bigdecimal/index.html","hash":"fb10254563078cec676b2c6cb53f83115bf5fd3f","modified":1613919718559},{"_id":"public/2018/09/28/super-in-param-extends-in-result/index.html","hash":"186543c3e9b4dc2105165c2610875d44931dde9d","modified":1613919718559},{"_id":"public/2018/09/28/date-calenda/index.html","hash":"ff8d78727f65cb93a0ab50e6167f772af2382860","modified":1613919718559},{"_id":"public/2018/09/26/java8-features/index.html","hash":"8b54a1469cb2d34a5a8e2863b773287ee0516f6d","modified":1613919718559},{"_id":"public/archives/page/2/index.html","hash":"3adac671781a22fc534639560864d175300205ba","modified":1613919718559},{"_id":"public/archives/page/3/index.html","hash":"6250862ae3f922c373e077ba24fb44c661143e68","modified":1613919718559},{"_id":"public/archives/2017/index.html","hash":"6d6cdccd140d24a14c417337012bc825dd6717a2","modified":1613919718559},{"_id":"public/archives/2017/04/index.html","hash":"e1dffc9eba778cbc27a0d23fdc38ec30f6e77368","modified":1613919718559},{"_id":"public/archives/2017/11/index.html","hash":"c53f7d176fe7e9a687ab4d8a3b89d1ad14cc9088","modified":1613919718559},{"_id":"public/archives/2018/index.html","hash":"02375781cd5a052f46bbce69588d1eaf76bff811","modified":1613919718559},{"_id":"public/archives/2018/09/index.html","hash":"07333704bb1170430ac97e7e1151ba4fc2bbecd2","modified":1613919718559},{"_id":"public/archives/2018/10/index.html","hash":"6dab8e342f0dbb88f4a0ea3a325a4195475439a0","modified":1613919718559},{"_id":"public/archives/2019/index.html","hash":"29f6bd80f525d2ecd74e1a700c39d1caccf14aac","modified":1613919718559},{"_id":"public/archives/2019/01/index.html","hash":"49ac70758c24cc4d59ccbb8ad8a9ceccd144038f","modified":1613919718559},{"_id":"public/archives/2020/index.html","hash":"e2e92ed915a35d03c41fc238d88feed46e66acd3","modified":1613919718559},{"_id":"public/archives/2020/page/2/index.html","hash":"289c4cf23a97fd62ad331f0aa406fd9936069dee","modified":1613919718559},{"_id":"public/archives/2020/03/index.html","hash":"1af0b6f01565496f0737f38ae494d81329824584","modified":1613919718559},{"_id":"public/archives/2020/08/index.html","hash":"7374658f74dd51ea5149f8d0da819db13376aa65","modified":1613919718559},{"_id":"public/archives/2020/09/index.html","hash":"9c4ff43a273466e5e39d2ab495b6514d979097d7","modified":1613919718559},{"_id":"public/archives/2020/10/index.html","hash":"f50feb92856f37846b0a692f0872f066978eb5eb","modified":1613919718559},{"_id":"public/archives/2020/11/index.html","hash":"3ae5d35f673aa93c78cb5f2132a7bdd102996c49","modified":1613919718559},{"_id":"public/archives/2020/12/index.html","hash":"2bcb8d0ca3924c143039e43474e3816deacf9406","modified":1613919718559},{"_id":"public/archives/2021/01/index.html","hash":"223a77d13044415686949f40c49ddb0fc9c303ea","modified":1613919718559},{"_id":"public/categories/programming/index.html","hash":"f0278b28cad9f5a8b5e56ac9440e08e8a117f6ec","modified":1613919718559},{"_id":"public/categories/programing/index.html","hash":"347016d1ef7dd7cc12aec50b053b340f663366e1","modified":1613919718559},{"_id":"public/categories/java/index.html","hash":"983674c5ddbf917d6a5276fa681b854f4204bf51","modified":1613919718559},{"_id":"public/tags/java/index.html","hash":"834506f4731b71d0bd833b16e9c56f6c7f167e2a","modified":1613919718559},{"_id":"public/tags/java/page/2/index.html","hash":"d6b9d86db89dc15d06e3bce57ccfb10cf585a07c","modified":1613919718559},{"_id":"public/tags/programming/index.html","hash":"0ca6b1066feb6c1ce701c57a14ac0cd83b473119","modified":1613919718559},{"_id":"public/tags/class-loader/index.html","hash":"07d756e113aecfe0fc5890912e1bb3109d3b60fd","modified":1613919718559},{"_id":"public/tags/framework/index.html","hash":"223b7c5593c1a29841186e02a73f4e18d0ef2abc","modified":1613919718559},{"_id":"public/tags/file/index.html","hash":"3eda42f56a00028f451ca6a2836c6fbbdd6f846c","modified":1613919718559},{"_id":"public/tags/HashMap/index.html","hash":"62136b2729f0f76c80838d50f19fc0816d917ab6","modified":1613919718559},{"_id":"public/tags/Pattern-String/index.html","hash":"71fcc7b802d2297811ffc829a4beda1ce9767789","modified":1613919718559},{"_id":"public/tags/Apollo/index.html","hash":"6ad9a5a4001a9b53abbae6135a5c7cd553890970","modified":1613919718559},{"_id":"public/tags/URI/index.html","hash":"9e5a3fcbcd99558e50b6fcbfd15b541d4d4fc23f","modified":1613919718559},{"_id":"public/tags/guigarage/index.html","hash":"0a3dfa4183bf378aa50312e9f335acb28a818e3a","modified":1613919718559},{"_id":"public/tags/GUI/index.html","hash":"41c6122b7b3116d330b6e3b2e07429701ac0c475","modified":1613919718559},{"_id":"public/tags/jar/index.html","hash":"80f84c3e05150a5007ade916391537e403baeb47","modified":1613919718559},{"_id":"public/tags/package/index.html","hash":"93c82c0b7fae095d22081106c84ac87a7b43d202","modified":1613919718559},{"_id":"public/tags/jvm/index.html","hash":"b06a78358ad632630304bb4f8c1bbcefeedcc2d9","modified":1613919718559},{"_id":"public/tags/reflect/index.html","hash":"1191ec468006814c82a80e02e3e6a9159ba0ceb0","modified":1613919718559},{"_id":"public/tags/protocol/index.html","hash":"3fadc473e72735d6b40c22b1b23743860ab20c03","modified":1613919718559},{"_id":"public/tags/socket/index.html","hash":"cb8851661b6b59bfc8647233dfa3eb47d0f3bfe0","modified":1613919718559},{"_id":"public/tags/ssh/index.html","hash":"d62b1c84a1cf3c98dac60e93b995ce19b77ae644","modified":1613919718559},{"_id":"public/tags/port-forwarding/index.html","hash":"76db8f93306efb637f8fa9c1835fa66205d2e0c0","modified":1613919718559},{"_id":"public/tags/java-BigDecimal/index.html","hash":"e41c41ce15716f9ebda4109bc607b83801dac1b9","modified":1613919718559},{"_id":"public/tags/generic/index.html","hash":"f615e3adfc637bc50bce79f0ca1090a9d16e1f9a","modified":1613919718559},{"_id":"public/tags/shadowing/index.html","hash":"fa3e1ac8f57890e32fc4eee21315d4004f5bbb3d","modified":1613919718559},{"_id":"public/tags/IO/index.html","hash":"4a3bd3b6cf4b04f4c45fea788cc2baeee4cc4a71","modified":1613919718559},{"_id":"public/tags/java8/index.html","hash":"ccb5887f0e220154cf07afa50227c16a10f53517","modified":1613919718559},{"_id":"public/2020/08/13/URI in Java/index.html","hash":"5c72ad46c0a91e85fd254bc6d9b8113f47c9c253","modified":1613919718559},{"_id":"public/2017/11/17/Anotation/index.html","hash":"ced54317cbb8abda7be6c9deb3b36816cd84d88e","modified":1613919718559},{"_id":"public/2017/04/13/Hash/index.html","hash":"3e79a71105661184b0b874ca952c462364fae8d6","modified":1613919718559},{"_id":"public/page/2/index.html","hash":"fc3d988d1e3b7565f97b3a23928d9aeed657b571","modified":1613919718559},{"_id":"public/page/3/index.html","hash":"f9b894f07fc311f74aac99ccd5b11737edff89a2","modified":1613919718559}],"Category":[{"name":"programming","_id":"cklfa4p1k0002mshbapvm417c"},{"name":"programing","_id":"cklfa4p25000tmshb1snib9t5"},{"name":"java","_id":"cklfa4p290010mshb2jcv9jjz"}],"Data":[],"Page":[],"Post":[{"date":"2017-11-17T03:44:00.000Z","_content":"\n# Anotation\n\n> 有注解，必有其解析器。解析器使用类反射做了注解所增加的功能。\n\n## 注解的定义与使用\n\n> 注解是 JAVA5.0 之后的高级特性。可以使用自定义注解来使用。\n\n### 四个元注解\n\n注解的注解，用于标注该注解的基本属性。\n\n- @Documented 注解是否包含在 JavaDoc 中\n- @Retention 什么时候使用该注解，定义该注解的生命周期\n  - RetentionPolicy.SOURCE\n  - RetentionPolicy.CLASS\n  - RetentionPolicy.RUNTIME\n- @Target 定义该注解使用的地方\n  - ElementType.TYPE 类、接口、枚举等\n  - ElementType.FIELD 字段属性\n  - ElementType.METHOD 方法\n  - ElementType.PARAMETER 方法参数\n  - ElementType.CONSTRUCTOR 构造函数\n  - ElementType.LOCAL_VARIABLE 本地变量\n  - ElementType.PACKAGE 包\n- @Inherited 是否允许子类继承该注解\n\n### 注解的定义\n\n注解定义中的属性只能是 String、Enum、及基本数据类型\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Todo {\n  public enum Priority {LOW, MEDIUM, HIGH}\n  public enum Status {STARTED, NOT_STARTED}\n  String author() default \"Yash\";\n  Priority priority() default Priority.LOW;\n  Status status() default Status.NOT_STARTED;\n}\n```\n\n如果注解中属性只有一个，那么使用时不需要写属性名，直接写值即可：\n\n```java\n@Target(ElementType.TYPE)\n@interface Remark{\n  String author() default \"kfc\";\n}\n\n@Remark(\"jfk\")\npublic class Change{\n}\n```\n\n### 注解的解析器\n\n- 使用注解必然要写好其解析器，根据注解的不同生命周期，其解析器对相应的注解进行进行解析，获取其属性值，并做相应的处理。\n- 注解的保留策略：如果是 `RetentionPolicy.SOURCECODE`，则其在编译阶段会被使用，因为此时编译器根据其 源码策略 对其进行处理。\n- 注解的解析器是如果工作的？参照 spring 。\n\n## 注解 @Autowired 的使用\n\n单词： autowired 的意思就是自动装配。而在 java 编程中使用此注解就是将标注过注解的都自动装配到 spring 容器中。\n\n据此理解的话，在编码中：\n\n- 如果是属性被此注解标注，则此属性就将这个 bean 注入到容器中，不用写此属性的 getter() 与 setter() 方法，在 bean.xml 配置中也不用写此属性的 `<property>` 标签了；\n- 如果方法或构造函数被 @Autowired 注解，则此方法参数中的 bean 就会自动被查找装入到这个方法中；\n\n- 注解的解析器是 {@link AutowiredAnnotationBeanPostProcessor}\n- 可以使用此注解对构造器、方法、变量进入注入 bean 依赖。在构造器上，只能有一个构造器上此注解的 required 属性是 true。使用此注解后，方法参数中的 bean 将自动从 spring contaner 中查找并注入。\n    - 当多个构造器上是 not required 时，选择策略是：容器中能满足最多的构造参数的构造器会被选择，当只有一个构造器时，可以省略 `@AutoWired`\n\n## 注解 @ResponseBody\n\n此注解标明这个方法返回不经过视图解析器处理，直接将处理信息写成字节流返回给浏览器，成为 json 对象写到浏览器页面中。\n\n## @RequestBody\n\n- 此注解将请求的 body 部分数据使用 converter 解析并将相应的数据绑定到要返回的对象上；\n- 使用 converter 解析的结果绑定到 controller 中的方法的参数上；\n- 使用json 解析时，使用的属性访问器，也就是说要对应请求 json 数据 key 与属性访问器对应，而不是与请求 vo 的 property 的名对应；\n\n## @RequiresPermissions\n\nshiro 框架中的权限验证注解，用于验证是否拥有某权限。\n\n## @PathVariable\n\n用于将方法参数绑定到请求路径中去\n\n```java\n@Controller  \n@RequestMapping(\"/owners/{ownerId}\")  \npublic class RelativePathUriTemplateController {  \n\n  @RequestMapping(\"/pets/{petId}\")  \n  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {\n    // implementation omitted\n  }  \n}  \n```\n\n### @RequestHeader @CookieValue\n\n```java\n@RequestMapping(\"/displayHeaderInfo.do\")  \npublic void displayHeaderInfo(@RequestHeader(\"Accept-Encoding\") String encoding,  \n                              @RequestHeader(\"Keep-Alive\") long keepAlive)  {  \n}  \n```\n\n上面的代码就参数 encoding 与 keepAlive 分别绑定到了请求的 Header 中去。\n\n```java\n@RequestMapping(\"/displayHeaderInfo.do\")  \npublic void displayHeaderInfo(@CookieValue(\"JSESSIONID\") String cookie)  {  \n}\n```\n\n而这一段代码就将参数 cookie 绑定到 JSESSIONID 上。\n_note:关于这儿的请求是将请求的 header/cookie 中的值绑定到请求方法参数中还是将请求时的参数绑定到 header/cookie 中是一个未搞清的问题。查找上说是将 header/cookie 值绑定到请求方法参数中，但如果是这样就没必要设置这个参数了，直接获取这些值在方法中调用就是，而后者却更有必要，调用方法时参数就直接当作 header/cookie 值去请求了看来也更合理_\n\n### @Repository\n\n> 对应 dao 层的数据\n","source":"_posts/Anotation.md","raw":"---\ndate: \"2017-11-17 11:44\"\ncategories: programming\ntag: [java,programming]\n---\n\n# Anotation\n\n> 有注解，必有其解析器。解析器使用类反射做了注解所增加的功能。\n\n## 注解的定义与使用\n\n> 注解是 JAVA5.0 之后的高级特性。可以使用自定义注解来使用。\n\n### 四个元注解\n\n注解的注解，用于标注该注解的基本属性。\n\n- @Documented 注解是否包含在 JavaDoc 中\n- @Retention 什么时候使用该注解，定义该注解的生命周期\n  - RetentionPolicy.SOURCE\n  - RetentionPolicy.CLASS\n  - RetentionPolicy.RUNTIME\n- @Target 定义该注解使用的地方\n  - ElementType.TYPE 类、接口、枚举等\n  - ElementType.FIELD 字段属性\n  - ElementType.METHOD 方法\n  - ElementType.PARAMETER 方法参数\n  - ElementType.CONSTRUCTOR 构造函数\n  - ElementType.LOCAL_VARIABLE 本地变量\n  - ElementType.PACKAGE 包\n- @Inherited 是否允许子类继承该注解\n\n### 注解的定义\n\n注解定义中的属性只能是 String、Enum、及基本数据类型\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Todo {\n  public enum Priority {LOW, MEDIUM, HIGH}\n  public enum Status {STARTED, NOT_STARTED}\n  String author() default \"Yash\";\n  Priority priority() default Priority.LOW;\n  Status status() default Status.NOT_STARTED;\n}\n```\n\n如果注解中属性只有一个，那么使用时不需要写属性名，直接写值即可：\n\n```java\n@Target(ElementType.TYPE)\n@interface Remark{\n  String author() default \"kfc\";\n}\n\n@Remark(\"jfk\")\npublic class Change{\n}\n```\n\n### 注解的解析器\n\n- 使用注解必然要写好其解析器，根据注解的不同生命周期，其解析器对相应的注解进行进行解析，获取其属性值，并做相应的处理。\n- 注解的保留策略：如果是 `RetentionPolicy.SOURCECODE`，则其在编译阶段会被使用，因为此时编译器根据其 源码策略 对其进行处理。\n- 注解的解析器是如果工作的？参照 spring 。\n\n## 注解 @Autowired 的使用\n\n单词： autowired 的意思就是自动装配。而在 java 编程中使用此注解就是将标注过注解的都自动装配到 spring 容器中。\n\n据此理解的话，在编码中：\n\n- 如果是属性被此注解标注，则此属性就将这个 bean 注入到容器中，不用写此属性的 getter() 与 setter() 方法，在 bean.xml 配置中也不用写此属性的 `<property>` 标签了；\n- 如果方法或构造函数被 @Autowired 注解，则此方法参数中的 bean 就会自动被查找装入到这个方法中；\n\n- 注解的解析器是 {@link AutowiredAnnotationBeanPostProcessor}\n- 可以使用此注解对构造器、方法、变量进入注入 bean 依赖。在构造器上，只能有一个构造器上此注解的 required 属性是 true。使用此注解后，方法参数中的 bean 将自动从 spring contaner 中查找并注入。\n    - 当多个构造器上是 not required 时，选择策略是：容器中能满足最多的构造参数的构造器会被选择，当只有一个构造器时，可以省略 `@AutoWired`\n\n## 注解 @ResponseBody\n\n此注解标明这个方法返回不经过视图解析器处理，直接将处理信息写成字节流返回给浏览器，成为 json 对象写到浏览器页面中。\n\n## @RequestBody\n\n- 此注解将请求的 body 部分数据使用 converter 解析并将相应的数据绑定到要返回的对象上；\n- 使用 converter 解析的结果绑定到 controller 中的方法的参数上；\n- 使用json 解析时，使用的属性访问器，也就是说要对应请求 json 数据 key 与属性访问器对应，而不是与请求 vo 的 property 的名对应；\n\n## @RequiresPermissions\n\nshiro 框架中的权限验证注解，用于验证是否拥有某权限。\n\n## @PathVariable\n\n用于将方法参数绑定到请求路径中去\n\n```java\n@Controller  \n@RequestMapping(\"/owners/{ownerId}\")  \npublic class RelativePathUriTemplateController {  \n\n  @RequestMapping(\"/pets/{petId}\")  \n  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {\n    // implementation omitted\n  }  \n}  \n```\n\n### @RequestHeader @CookieValue\n\n```java\n@RequestMapping(\"/displayHeaderInfo.do\")  \npublic void displayHeaderInfo(@RequestHeader(\"Accept-Encoding\") String encoding,  \n                              @RequestHeader(\"Keep-Alive\") long keepAlive)  {  \n}  \n```\n\n上面的代码就参数 encoding 与 keepAlive 分别绑定到了请求的 Header 中去。\n\n```java\n@RequestMapping(\"/displayHeaderInfo.do\")  \npublic void displayHeaderInfo(@CookieValue(\"JSESSIONID\") String cookie)  {  \n}\n```\n\n而这一段代码就将参数 cookie 绑定到 JSESSIONID 上。\n_note:关于这儿的请求是将请求的 header/cookie 中的值绑定到请求方法参数中还是将请求时的参数绑定到 header/cookie 中是一个未搞清的问题。查找上说是将 header/cookie 值绑定到请求方法参数中，但如果是这样就没必要设置这个参数了，直接获取这些值在方法中调用就是，而后者却更有必要，调用方法时参数就直接当作 header/cookie 值去请求了看来也更合理_\n\n### @Repository\n\n> 对应 dao 层的数据\n","slug":"Anotation","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1d0000mshba55x4e9b","content":"<h1 id=\"Anotation\"><a href=\"#Anotation\" class=\"headerlink\" title=\"Anotation\"></a>Anotation</h1><blockquote>\n<p>有注解，必有其解析器。解析器使用类反射做了注解所增加的功能。</p>\n</blockquote>\n<h2 id=\"注解的定义与使用\"><a href=\"#注解的定义与使用\" class=\"headerlink\" title=\"注解的定义与使用\"></a>注解的定义与使用</h2><blockquote>\n<p>注解是 JAVA5.0 之后的高级特性。可以使用自定义注解来使用。</p>\n</blockquote>\n<h3 id=\"四个元注解\"><a href=\"#四个元注解\" class=\"headerlink\" title=\"四个元注解\"></a>四个元注解</h3><p>注解的注解，用于标注该注解的基本属性。</p>\n<ul>\n<li>@Documented 注解是否包含在 JavaDoc 中</li>\n<li>@Retention 什么时候使用该注解，定义该注解的生命周期<ul>\n<li>RetentionPolicy.SOURCE</li>\n<li>RetentionPolicy.CLASS</li>\n<li>RetentionPolicy.RUNTIME</li>\n</ul>\n</li>\n<li>@Target 定义该注解使用的地方<ul>\n<li>ElementType.TYPE 类、接口、枚举等</li>\n<li>ElementType.FIELD 字段属性</li>\n<li>ElementType.METHOD 方法</li>\n<li>ElementType.PARAMETER 方法参数</li>\n<li>ElementType.CONSTRUCTOR 构造函数</li>\n<li>ElementType.LOCAL_VARIABLE 本地变量</li>\n<li>ElementType.PACKAGE 包</li>\n</ul>\n</li>\n<li>@Inherited 是否允许子类继承该注解</li>\n</ul>\n<h3 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h3><p>注解定义中的属性只能是 String、Enum、及基本数据类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> Todo &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Priority</span> </span>&#123;LOW, MEDIUM, HIGH&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Status</span> </span>&#123;STARTED, NOT_STARTED&#125;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;Yash&quot;</span>;</span><br><span class=\"line\">  <span class=\"function\">Priority <span class=\"title\">priority</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Priority.LOW</span>;</span><br><span class=\"line\">  <span class=\"function\">Status <span class=\"title\">status</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Status.NOT_STARTED</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果注解中属性只有一个，那么使用时不需要写属性名，直接写值即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> Remark&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;kfc&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Remark(&quot;jfk&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Change</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注解的解析器\"><a href=\"#注解的解析器\" class=\"headerlink\" title=\"注解的解析器\"></a>注解的解析器</h3><ul>\n<li>使用注解必然要写好其解析器，根据注解的不同生命周期，其解析器对相应的注解进行进行解析，获取其属性值，并做相应的处理。</li>\n<li>注解的保留策略：如果是 <code>RetentionPolicy.SOURCECODE</code>，则其在编译阶段会被使用，因为此时编译器根据其 源码策略 对其进行处理。</li>\n<li>注解的解析器是如果工作的？参照 spring 。</li>\n</ul>\n<h2 id=\"注解-Autowired-的使用\"><a href=\"#注解-Autowired-的使用\" class=\"headerlink\" title=\"注解 @Autowired 的使用\"></a>注解 @Autowired 的使用</h2><p>单词： autowired 的意思就是自动装配。而在 java 编程中使用此注解就是将标注过注解的都自动装配到 spring 容器中。</p>\n<p>据此理解的话，在编码中：</p>\n<ul>\n<li><p>如果是属性被此注解标注，则此属性就将这个 bean 注入到容器中，不用写此属性的 getter() 与 setter() 方法，在 bean.xml 配置中也不用写此属性的 <code>&lt;property&gt;</code> 标签了；</p>\n</li>\n<li><p>如果方法或构造函数被 @Autowired 注解，则此方法参数中的 bean 就会自动被查找装入到这个方法中；</p>\n</li>\n<li><p>注解的解析器是 {@link AutowiredAnnotationBeanPostProcessor}</p>\n</li>\n<li><p>可以使用此注解对构造器、方法、变量进入注入 bean 依赖。在构造器上，只能有一个构造器上此注解的 required 属性是 true。使用此注解后，方法参数中的 bean 将自动从 spring contaner 中查找并注入。</p>\n<ul>\n<li>当多个构造器上是 not required 时，选择策略是：容器中能满足最多的构造参数的构造器会被选择，当只有一个构造器时，可以省略 <code>@AutoWired</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注解-ResponseBody\"><a href=\"#注解-ResponseBody\" class=\"headerlink\" title=\"注解 @ResponseBody\"></a>注解 @ResponseBody</h2><p>此注解标明这个方法返回不经过视图解析器处理，直接将处理信息写成字节流返回给浏览器，成为 json 对象写到浏览器页面中。</p>\n<h2 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a>@RequestBody</h2><ul>\n<li>此注解将请求的 body 部分数据使用 converter 解析并将相应的数据绑定到要返回的对象上；</li>\n<li>使用 converter 解析的结果绑定到 controller 中的方法的参数上；</li>\n<li>使用json 解析时，使用的属性访问器，也就是说要对应请求 json 数据 key 与属性访问器对应，而不是与请求 vo 的 property 的名对应；</li>\n</ul>\n<h2 id=\"RequiresPermissions\"><a href=\"#RequiresPermissions\" class=\"headerlink\" title=\"@RequiresPermissions\"></a>@RequiresPermissions</h2><p>shiro 框架中的权限验证注解，用于验证是否拥有某权限。</p>\n<h2 id=\"PathVariable\"><a href=\"#PathVariable\" class=\"headerlink\" title=\"@PathVariable\"></a>@PathVariable</h2><p>用于将方法参数绑定到请求路径中去</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span>  </span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RelativePathUriTemplateController</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@RequestMapping(&quot;/pets/&#123;petId&#125;&quot;)</span>  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">findPet</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String ownerId, <span class=\"meta\">@PathVariable</span> String petId, Model model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// implementation omitted</span></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RequestHeader-CookieValue\"><a href=\"#RequestHeader-CookieValue\" class=\"headerlink\" title=\"@RequestHeader @CookieValue\"></a>@RequestHeader @CookieValue</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">displayHeaderInfo</span><span class=\"params\">(<span class=\"meta\">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"meta\">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class=\"keyword\">long</span> keepAlive)</span>  </span>&#123;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就参数 encoding 与 keepAlive 分别绑定到了请求的 Header 中去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">displayHeaderInfo</span><span class=\"params\">(<span class=\"meta\">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span>  </span>&#123;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而这一段代码就将参数 cookie 绑定到 JSESSIONID 上。<br><em>note:关于这儿的请求是将请求的 header/cookie 中的值绑定到请求方法参数中还是将请求时的参数绑定到 header/cookie 中是一个未搞清的问题。查找上说是将 header/cookie 值绑定到请求方法参数中，但如果是这样就没必要设置这个参数了，直接获取这些值在方法中调用就是，而后者却更有必要，调用方法时参数就直接当作 header/cookie 值去请求了看来也更合理</em></p>\n<h3 id=\"Repository\"><a href=\"#Repository\" class=\"headerlink\" title=\"@Repository\"></a>@Repository</h3><blockquote>\n<p>对应 dao 层的数据</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Anotation\"><a href=\"#Anotation\" class=\"headerlink\" title=\"Anotation\"></a>Anotation</h1><blockquote>\n<p>有注解，必有其解析器。解析器使用类反射做了注解所增加的功能。</p>\n</blockquote>\n<h2 id=\"注解的定义与使用\"><a href=\"#注解的定义与使用\" class=\"headerlink\" title=\"注解的定义与使用\"></a>注解的定义与使用</h2><blockquote>\n<p>注解是 JAVA5.0 之后的高级特性。可以使用自定义注解来使用。</p>\n</blockquote>\n<h3 id=\"四个元注解\"><a href=\"#四个元注解\" class=\"headerlink\" title=\"四个元注解\"></a>四个元注解</h3><p>注解的注解，用于标注该注解的基本属性。</p>\n<ul>\n<li>@Documented 注解是否包含在 JavaDoc 中</li>\n<li>@Retention 什么时候使用该注解，定义该注解的生命周期<ul>\n<li>RetentionPolicy.SOURCE</li>\n<li>RetentionPolicy.CLASS</li>\n<li>RetentionPolicy.RUNTIME</li>\n</ul>\n</li>\n<li>@Target 定义该注解使用的地方<ul>\n<li>ElementType.TYPE 类、接口、枚举等</li>\n<li>ElementType.FIELD 字段属性</li>\n<li>ElementType.METHOD 方法</li>\n<li>ElementType.PARAMETER 方法参数</li>\n<li>ElementType.CONSTRUCTOR 构造函数</li>\n<li>ElementType.LOCAL_VARIABLE 本地变量</li>\n<li>ElementType.PACKAGE 包</li>\n</ul>\n</li>\n<li>@Inherited 是否允许子类继承该注解</li>\n</ul>\n<h3 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h3><p>注解定义中的属性只能是 String、Enum、及基本数据类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> Todo &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Priority</span> </span>&#123;LOW, MEDIUM, HIGH&#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Status</span> </span>&#123;STARTED, NOT_STARTED&#125;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;Yash&quot;</span>;</span><br><span class=\"line\">  <span class=\"function\">Priority <span class=\"title\">priority</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Priority.LOW</span>;</span><br><span class=\"line\">  <span class=\"function\">Status <span class=\"title\">status</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Status.NOT_STARTED</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果注解中属性只有一个，那么使用时不需要写属性名，直接写值即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> Remark&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;kfc&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Remark(&quot;jfk&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Change</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注解的解析器\"><a href=\"#注解的解析器\" class=\"headerlink\" title=\"注解的解析器\"></a>注解的解析器</h3><ul>\n<li>使用注解必然要写好其解析器，根据注解的不同生命周期，其解析器对相应的注解进行进行解析，获取其属性值，并做相应的处理。</li>\n<li>注解的保留策略：如果是 <code>RetentionPolicy.SOURCECODE</code>，则其在编译阶段会被使用，因为此时编译器根据其 源码策略 对其进行处理。</li>\n<li>注解的解析器是如果工作的？参照 spring 。</li>\n</ul>\n<h2 id=\"注解-Autowired-的使用\"><a href=\"#注解-Autowired-的使用\" class=\"headerlink\" title=\"注解 @Autowired 的使用\"></a>注解 @Autowired 的使用</h2><p>单词： autowired 的意思就是自动装配。而在 java 编程中使用此注解就是将标注过注解的都自动装配到 spring 容器中。</p>\n<p>据此理解的话，在编码中：</p>\n<ul>\n<li><p>如果是属性被此注解标注，则此属性就将这个 bean 注入到容器中，不用写此属性的 getter() 与 setter() 方法，在 bean.xml 配置中也不用写此属性的 <code>&lt;property&gt;</code> 标签了；</p>\n</li>\n<li><p>如果方法或构造函数被 @Autowired 注解，则此方法参数中的 bean 就会自动被查找装入到这个方法中；</p>\n</li>\n<li><p>注解的解析器是 {@link AutowiredAnnotationBeanPostProcessor}</p>\n</li>\n<li><p>可以使用此注解对构造器、方法、变量进入注入 bean 依赖。在构造器上，只能有一个构造器上此注解的 required 属性是 true。使用此注解后，方法参数中的 bean 将自动从 spring contaner 中查找并注入。</p>\n<ul>\n<li>当多个构造器上是 not required 时，选择策略是：容器中能满足最多的构造参数的构造器会被选择，当只有一个构造器时，可以省略 <code>@AutoWired</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注解-ResponseBody\"><a href=\"#注解-ResponseBody\" class=\"headerlink\" title=\"注解 @ResponseBody\"></a>注解 @ResponseBody</h2><p>此注解标明这个方法返回不经过视图解析器处理，直接将处理信息写成字节流返回给浏览器，成为 json 对象写到浏览器页面中。</p>\n<h2 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a>@RequestBody</h2><ul>\n<li>此注解将请求的 body 部分数据使用 converter 解析并将相应的数据绑定到要返回的对象上；</li>\n<li>使用 converter 解析的结果绑定到 controller 中的方法的参数上；</li>\n<li>使用json 解析时，使用的属性访问器，也就是说要对应请求 json 数据 key 与属性访问器对应，而不是与请求 vo 的 property 的名对应；</li>\n</ul>\n<h2 id=\"RequiresPermissions\"><a href=\"#RequiresPermissions\" class=\"headerlink\" title=\"@RequiresPermissions\"></a>@RequiresPermissions</h2><p>shiro 框架中的权限验证注解，用于验证是否拥有某权限。</p>\n<h2 id=\"PathVariable\"><a href=\"#PathVariable\" class=\"headerlink\" title=\"@PathVariable\"></a>@PathVariable</h2><p>用于将方法参数绑定到请求路径中去</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span>  </span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RelativePathUriTemplateController</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@RequestMapping(&quot;/pets/&#123;petId&#125;&quot;)</span>  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">findPet</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String ownerId, <span class=\"meta\">@PathVariable</span> String petId, Model model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// implementation omitted</span></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RequestHeader-CookieValue\"><a href=\"#RequestHeader-CookieValue\" class=\"headerlink\" title=\"@RequestHeader @CookieValue\"></a>@RequestHeader @CookieValue</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">displayHeaderInfo</span><span class=\"params\">(<span class=\"meta\">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"meta\">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class=\"keyword\">long</span> keepAlive)</span>  </span>&#123;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就参数 encoding 与 keepAlive 分别绑定到了请求的 Header 中去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">displayHeaderInfo</span><span class=\"params\">(<span class=\"meta\">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span>  </span>&#123;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而这一段代码就将参数 cookie 绑定到 JSESSIONID 上。<br><em>note:关于这儿的请求是将请求的 header/cookie 中的值绑定到请求方法参数中还是将请求时的参数绑定到 header/cookie 中是一个未搞清的问题。查找上说是将 header/cookie 值绑定到请求方法参数中，但如果是这样就没必要设置这个参数了，直接获取这些值在方法中调用就是，而后者却更有必要，调用方法时参数就直接当作 header/cookie 值去请求了看来也更合理</em></p>\n<h3 id=\"Repository\"><a href=\"#Repository\" class=\"headerlink\" title=\"@Repository\"></a>@Repository</h3><blockquote>\n<p>对应 dao 层的数据</p>\n</blockquote>\n"},{"date":"2020-09-15T09:50:17.000Z","_content":"\n# ClassLoader\n\n- ClassLoader 用于加载文件系统中 class 文件。\n- 每个 Class 对象都可以通过 getClassLoader() 方法获取到其加载器。\n- 数组 class 对象不通过 classLoader 加载，在运行时需要时再加载。数组元素的 classLoader 与 数组的 classLoader 是同一个，如果数组元素是基本类型，此数组没有 classLoader 。\n- ClassLoader 使用委托模式查找 classes 和 resources 。当请求找资源时，ClassLoader 实例在查找资源前会先委托其 父加载器查找。虚拟机内置的 ClassLoader 叫 \"bootstrap class loader\"， bootstrap class loader 没有父加载器，但常扮演其他加载器的父加载器。\n- ClassLoader 用于加载除 class 外的文件资源，eg: .properties\n","source":"_posts/ClassLoader.md","raw":"---\ndate: 2020-09-15 17:50:17\ntags: [java,class loader]\ncategories: programming\n---\n\n# ClassLoader\n\n- ClassLoader 用于加载文件系统中 class 文件。\n- 每个 Class 对象都可以通过 getClassLoader() 方法获取到其加载器。\n- 数组 class 对象不通过 classLoader 加载，在运行时需要时再加载。数组元素的 classLoader 与 数组的 classLoader 是同一个，如果数组元素是基本类型，此数组没有 classLoader 。\n- ClassLoader 使用委托模式查找 classes 和 resources 。当请求找资源时，ClassLoader 实例在查找资源前会先委托其 父加载器查找。虚拟机内置的 ClassLoader 叫 \"bootstrap class loader\"， bootstrap class loader 没有父加载器，但常扮演其他加载器的父加载器。\n- ClassLoader 用于加载除 class 外的文件资源，eg: .properties\n","slug":"ClassLoader","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1i0001mshbhvwidnbi","content":"<h1 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h1><ul>\n<li>ClassLoader 用于加载文件系统中 class 文件。</li>\n<li>每个 Class 对象都可以通过 getClassLoader() 方法获取到其加载器。</li>\n<li>数组 class 对象不通过 classLoader 加载，在运行时需要时再加载。数组元素的 classLoader 与 数组的 classLoader 是同一个，如果数组元素是基本类型，此数组没有 classLoader 。</li>\n<li>ClassLoader 使用委托模式查找 classes 和 resources 。当请求找资源时，ClassLoader 实例在查找资源前会先委托其 父加载器查找。虚拟机内置的 ClassLoader 叫 “bootstrap class loader”， bootstrap class loader 没有父加载器，但常扮演其他加载器的父加载器。</li>\n<li>ClassLoader 用于加载除 class 外的文件资源，eg: .properties</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h1><ul>\n<li>ClassLoader 用于加载文件系统中 class 文件。</li>\n<li>每个 Class 对象都可以通过 getClassLoader() 方法获取到其加载器。</li>\n<li>数组 class 对象不通过 classLoader 加载，在运行时需要时再加载。数组元素的 classLoader 与 数组的 classLoader 是同一个，如果数组元素是基本类型，此数组没有 classLoader 。</li>\n<li>ClassLoader 使用委托模式查找 classes 和 resources 。当请求找资源时，ClassLoader 实例在查找资源前会先委托其 父加载器查找。虚拟机内置的 ClassLoader 叫 “bootstrap class loader”， bootstrap class loader 没有父加载器，但常扮演其他加载器的父加载器。</li>\n<li>ClassLoader 用于加载除 class 外的文件资源，eg: .properties</li>\n</ul>\n"},{"date":"2020-08-12T09:32:00.000Z","description":"java class File","_content":"\n# File\n\njava `File` 类\n\n文件系统中前缀概念：\n\n- Unix 系统文件系统中绝对路径前缀是 `/`，相对路径没有前缀\n- Windows 平台路径前缀包括了：驱动符号后跟上 `:` (组成驱动指示符)，如果是绝对路径，将追加上 `\\\\`\n    - UNC（universal Naming Conversion）路径名是 `\\\\\\\\`, hostname 与 share name 放在第一二位。相对路径无前缀、驱动指示符\n\n文件系统分隔符\n\n- Unix 系统的分隔符 `/`\n- Windows 系统 `\\\\`\n","source":"_posts/File.md","raw":"---\ndate: 2020-08-12 17:32:00\ntags: [framework,java,file]\ncategories: programming\ndescription: java class File\n---\n\n# File\n\njava `File` 类\n\n文件系统中前缀概念：\n\n- Unix 系统文件系统中绝对路径前缀是 `/`，相对路径没有前缀\n- Windows 平台路径前缀包括了：驱动符号后跟上 `:` (组成驱动指示符)，如果是绝对路径，将追加上 `\\\\`\n    - UNC（universal Naming Conversion）路径名是 `\\\\\\\\`, hostname 与 share name 放在第一二位。相对路径无前缀、驱动指示符\n\n文件系统分隔符\n\n- Unix 系统的分隔符 `/`\n- Windows 系统 `\\\\`\n","slug":"File","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1n0004mshbgrbi1g65","content":"<h1 id=\"File\"><a href=\"#File\" class=\"headerlink\" title=\"File\"></a>File</h1><p>java <code>File</code> 类</p>\n<p>文件系统中前缀概念：</p>\n<ul>\n<li>Unix 系统文件系统中绝对路径前缀是 <code>/</code>，相对路径没有前缀</li>\n<li>Windows 平台路径前缀包括了：驱动符号后跟上 <code>:</code> (组成驱动指示符)，如果是绝对路径，将追加上 <code>\\\\</code><ul>\n<li>UNC（universal Naming Conversion）路径名是 <code>\\\\\\\\</code>, hostname 与 share name 放在第一二位。相对路径无前缀、驱动指示符</li>\n</ul>\n</li>\n</ul>\n<p>文件系统分隔符</p>\n<ul>\n<li>Unix 系统的分隔符 <code>/</code></li>\n<li>Windows 系统 <code>\\\\</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"File\"><a href=\"#File\" class=\"headerlink\" title=\"File\"></a>File</h1><p>java <code>File</code> 类</p>\n<p>文件系统中前缀概念：</p>\n<ul>\n<li>Unix 系统文件系统中绝对路径前缀是 <code>/</code>，相对路径没有前缀</li>\n<li>Windows 平台路径前缀包括了：驱动符号后跟上 <code>:</code> (组成驱动指示符)，如果是绝对路径，将追加上 <code>\\\\</code><ul>\n<li>UNC（universal Naming Conversion）路径名是 <code>\\\\\\\\</code>, hostname 与 share name 放在第一二位。相对路径无前缀、驱动指示符</li>\n</ul>\n</li>\n</ul>\n<p>文件系统分隔符</p>\n<ul>\n<li>Unix 系统的分隔符 <code>/</code></li>\n<li>Windows 系统 <code>\\\\</code></li>\n</ul>\n"},{"date":"2020-08-12T09:32:00.000Z","description":"java class File","_content":"\n# Java Garbage Collection\n\n[reference](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)\n","source":"_posts/Garbege Collection.md","raw":"---\ndate: 2020-08-12 17:32:00\ntags: [framework,java,file]\ncategories: programming\ndescription: java class File\n---\n\n# Java Garbage Collection\n\n[reference](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)\n","slug":"Garbege Collection","published":1,"updated":"2021-02-05T15:39:05.909Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1p0005mshbdfxuexu6","content":"<h1 id=\"Java-Garbage-Collection\"><a href=\"#Java-Garbage-Collection\" class=\"headerlink\" title=\"Java Garbage Collection\"></a>Java Garbage Collection</h1><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/\">reference</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java-Garbage-Collection\"><a href=\"#Java-Garbage-Collection\" class=\"headerlink\" title=\"Java Garbage Collection\"></a>Java Garbage Collection</h1><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/\">reference</a></p>\n"},{"date":"2017-04-13T07:02:43.000Z","description":"hash function && hash table","_content":"\n# Hash\n\nHash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。\n\n## Map\n\n- map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；\n- Map中键对象不允许重复，且键的唯一性很重要；\n- 不建议将多个键映射到同一个值对象；\n- Map接口下有的实现集合类有：\n    - HashMap，用到了哈希码的算法，以便快速查找一个键；\n    - TreeMap，其键按序存放\n    - HashTable，是 Dictionary 的子类，与 HashMap 类似；\n\n## HashMap\n\n[reference](https://www.jianshu.com/p/c658df4f4c77)\n\n- HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：\n\n```java\n/**\n* Computes key.hashCode() and spreads (XORs) higher bits of hash\n* to lower.  Because the table uses power-of-two masking, sets of\n* hashes that vary only in bits above the current mask will\n* always collide. (Among known examples are sets of Float keys\n* holding consecutive whole numbers in small tables.)  So we\n* apply a transform that spreads the impact of higher bits\n* downward. There is a tradeoff between speed, utility, and\n* quality of bit-spreading. Because many common sets of hashes\n* are already reasonably distributed (so don't benefit from\n* spreading), and because we use trees to handle large sets of\n* collisions in bins, we just XOR some shifted bits in the\n* cheapest possible way to reduce systematic lossage, as well as\n* to incorporate impact of the highest bits that would otherwise\n* never be used in index calculations because of table bounds.\n*/\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n- 如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。\n- HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。\n- HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 `hash & (capacity - 1)` 得到 bucket 下标。\n    - 之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （`10000` 的形式），`(capacity - 1)` 就会是 `1111` 的形式，而其与 hash 值进行 `&` 运算就刚好得到 hash 的模。\n    - 为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：\n\n    ```java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n## HashTable 与 HashMap 的区别\n\n- 底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。\n- HashTable 为同步的，可以保证一定的线程安全。\n","source":"_posts/Hash.md","raw":"---\ndate: 2017-04-13 15:02:43\ncategories: programming\ntags: [programming,java, HashMap]\ndescription: hash function && hash table\n---\n\n# Hash\n\nHash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。\n\n## Map\n\n- map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；\n- Map中键对象不允许重复，且键的唯一性很重要；\n- 不建议将多个键映射到同一个值对象；\n- Map接口下有的实现集合类有：\n    - HashMap，用到了哈希码的算法，以便快速查找一个键；\n    - TreeMap，其键按序存放\n    - HashTable，是 Dictionary 的子类，与 HashMap 类似；\n\n## HashMap\n\n[reference](https://www.jianshu.com/p/c658df4f4c77)\n\n- HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：\n\n```java\n/**\n* Computes key.hashCode() and spreads (XORs) higher bits of hash\n* to lower.  Because the table uses power-of-two masking, sets of\n* hashes that vary only in bits above the current mask will\n* always collide. (Among known examples are sets of Float keys\n* holding consecutive whole numbers in small tables.)  So we\n* apply a transform that spreads the impact of higher bits\n* downward. There is a tradeoff between speed, utility, and\n* quality of bit-spreading. Because many common sets of hashes\n* are already reasonably distributed (so don't benefit from\n* spreading), and because we use trees to handle large sets of\n* collisions in bins, we just XOR some shifted bits in the\n* cheapest possible way to reduce systematic lossage, as well as\n* to incorporate impact of the highest bits that would otherwise\n* never be used in index calculations because of table bounds.\n*/\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n- 如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。\n- HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。\n- HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 `hash & (capacity - 1)` 得到 bucket 下标。\n    - 之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （`10000` 的形式），`(capacity - 1)` 就会是 `1111` 的形式，而其与 hash 值进行 `&` 运算就刚好得到 hash 的模。\n    - 为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：\n\n    ```java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n## HashTable 与 HashMap 的区别\n\n- 底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。\n- HashTable 为同步的，可以保证一定的线程安全。\n","slug":"Hash","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1q0006mshbgal5h2ry","content":"<h1 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h1><p>Hash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><ul>\n<li>map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；</li>\n<li>Map中键对象不允许重复，且键的唯一性很重要；</li>\n<li>不建议将多个键映射到同一个值对象；</li>\n<li>Map接口下有的实现集合类有：<ul>\n<li>HashMap，用到了哈希码的算法，以便快速查找一个键；</li>\n<li>TreeMap，其键按序存放</li>\n<li>HashTable，是 Dictionary 的子类，与 HashMap 类似；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><a href=\"https://www.jianshu.com/p/c658df4f4c77\">reference</a></p>\n<ul>\n<li>HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class=\"line\"><span class=\"comment\">* to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class=\"line\"><span class=\"comment\">* hashes that vary only in bits above the current mask will</span></span><br><span class=\"line\"><span class=\"comment\">* always collide. (Among known examples are sets of Float keys</span></span><br><span class=\"line\"><span class=\"comment\">* holding consecutive whole numbers in small tables.)  So we</span></span><br><span class=\"line\"><span class=\"comment\">* apply a transform that spreads the impact of higher bits</span></span><br><span class=\"line\"><span class=\"comment\">* downward. There is a tradeoff between speed, utility, and</span></span><br><span class=\"line\"><span class=\"comment\">* quality of bit-spreading. Because many common sets of hashes</span></span><br><span class=\"line\"><span class=\"comment\">* are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class=\"line\"><span class=\"comment\">* spreading), and because we use trees to handle large sets of</span></span><br><span class=\"line\"><span class=\"comment\">* collisions in bins, we just XOR some shifted bits in the</span></span><br><span class=\"line\"><span class=\"comment\">* cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class=\"line\"><span class=\"comment\">* to incorporate impact of the highest bits that would otherwise</span></span><br><span class=\"line\"><span class=\"comment\">* never be used in index calculations because of table bounds.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。</p>\n</li>\n<li><p>HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。</p>\n</li>\n<li><p>HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 <code>hash &amp; (capacity - 1)</code> 得到 bucket 下标。</p>\n<ul>\n<li><p>之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （<code>10000</code> 的形式），<code>(capacity - 1)</code> 就会是 <code>1111</code> 的形式，而其与 hash 值进行 <code>&amp;</code> 运算就刚好得到 hash 的模。</p>\n</li>\n<li><p>为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashTable-与-HashMap-的区别\"><a href=\"#HashTable-与-HashMap-的区别\" class=\"headerlink\" title=\"HashTable 与 HashMap 的区别\"></a>HashTable 与 HashMap 的区别</h2><ul>\n<li>底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。</li>\n<li>HashTable 为同步的，可以保证一定的线程安全。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h1><p>Hash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><ul>\n<li>map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；</li>\n<li>Map中键对象不允许重复，且键的唯一性很重要；</li>\n<li>不建议将多个键映射到同一个值对象；</li>\n<li>Map接口下有的实现集合类有：<ul>\n<li>HashMap，用到了哈希码的算法，以便快速查找一个键；</li>\n<li>TreeMap，其键按序存放</li>\n<li>HashTable，是 Dictionary 的子类，与 HashMap 类似；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><a href=\"https://www.jianshu.com/p/c658df4f4c77\">reference</a></p>\n<ul>\n<li>HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class=\"line\"><span class=\"comment\">* to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class=\"line\"><span class=\"comment\">* hashes that vary only in bits above the current mask will</span></span><br><span class=\"line\"><span class=\"comment\">* always collide. (Among known examples are sets of Float keys</span></span><br><span class=\"line\"><span class=\"comment\">* holding consecutive whole numbers in small tables.)  So we</span></span><br><span class=\"line\"><span class=\"comment\">* apply a transform that spreads the impact of higher bits</span></span><br><span class=\"line\"><span class=\"comment\">* downward. There is a tradeoff between speed, utility, and</span></span><br><span class=\"line\"><span class=\"comment\">* quality of bit-spreading. Because many common sets of hashes</span></span><br><span class=\"line\"><span class=\"comment\">* are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class=\"line\"><span class=\"comment\">* spreading), and because we use trees to handle large sets of</span></span><br><span class=\"line\"><span class=\"comment\">* collisions in bins, we just XOR some shifted bits in the</span></span><br><span class=\"line\"><span class=\"comment\">* cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class=\"line\"><span class=\"comment\">* to incorporate impact of the highest bits that would otherwise</span></span><br><span class=\"line\"><span class=\"comment\">* never be used in index calculations because of table bounds.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。</p>\n</li>\n<li><p>HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。</p>\n</li>\n<li><p>HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 <code>hash &amp; (capacity - 1)</code> 得到 bucket 下标。</p>\n<ul>\n<li><p>之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （<code>10000</code> 的形式），<code>(capacity - 1)</code> 就会是 <code>1111</code> 的形式，而其与 hash 值进行 <code>&amp;</code> 运算就刚好得到 hash 的模。</p>\n</li>\n<li><p>为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashTable-与-HashMap-的区别\"><a href=\"#HashTable-与-HashMap-的区别\" class=\"headerlink\" title=\"HashTable 与 HashMap 的区别\"></a>HashTable 与 HashMap 的区别</h2><ul>\n<li>底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。</li>\n<li>HashTable 为同步的，可以保证一定的线程安全。</li>\n</ul>\n"},{"date":"2021-01-22T02:42:00.000Z","_content":"\n# Pattern\n\n## split\n\n- split(CharSequence cs, int limit) 使用正则表达式分割字串,limit 用以指定数量，当为非正数时不限制数量，但为　0   时会丢弃最后面的空串 `\"\"`;\n- split(cs) = split(cs, 0)\n","source":"_posts/Pattern.md","raw":"---\ncategories: programming\ndate: \"2021-1-22 10:42\"\ntag: Pattern, String\n---\n\n# Pattern\n\n## split\n\n- split(CharSequence cs, int limit) 使用正则表达式分割字串,limit 用以指定数量，当为非正数时不限制数量，但为　0   时会丢弃最后面的空串 `\"\"`;\n- split(cs) = split(cs, 0)\n","slug":"Pattern","published":1,"updated":"2021-01-22T13:25:37.892Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1t0009mshb0zsh2x6v","content":"<h1 id=\"Pattern\"><a href=\"#Pattern\" class=\"headerlink\" title=\"Pattern\"></a>Pattern</h1><h2 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h2><ul>\n<li>split(CharSequence cs, int limit) 使用正则表达式分割字串,limit 用以指定数量，当为非正数时不限制数量，但为　0   时会丢弃最后面的空串 <code>&quot;&quot;</code>;</li>\n<li>split(cs) = split(cs, 0)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Pattern\"><a href=\"#Pattern\" class=\"headerlink\" title=\"Pattern\"></a>Pattern</h1><h2 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h2><ul>\n<li>split(CharSequence cs, int limit) 使用正则表达式分割字串,limit 用以指定数量，当为非正数时不限制数量，但为　0   时会丢弃最后面的空串 <code>&quot;&quot;</code>;</li>\n<li>split(cs) = split(cs, 0)</li>\n</ul>\n"},{"layout":"draft","date":"2020-08-07T05:54:00.000Z","_content":"\n# ServiceProvider\n\n服务供应类 java.util.ServiceLoader\n\n要使用此需要将 Provider 实现与 Service 定义写入到 META-INF/services 文件中，以 UTF-8 编码方式，详情参照源码文档。\n","source":"_posts/ServiceProvider.md","raw":"---\nlayout: \"draft\"\ndate: \"2020-08-07 13:54\"\ntag: \"Apollo\"\n---\n\n# ServiceProvider\n\n服务供应类 java.util.ServiceLoader\n\n要使用此需要将 Provider 实现与 Service 定义写入到 META-INF/services 文件中，以 UTF-8 编码方式，详情参照源码文档。\n","slug":"ServiceProvider","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"photos":[],"link":"","_id":"cklfa4p1u000amshbbi0k0cwn","content":"<h1 id=\"ServiceProvider\"><a href=\"#ServiceProvider\" class=\"headerlink\" title=\"ServiceProvider\"></a>ServiceProvider</h1><p>服务供应类 java.util.ServiceLoader</p>\n<p>要使用此需要将 Provider 实现与 Service 定义写入到 META-INF/services 文件中，以 UTF-8 编码方式，详情参照源码文档。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ServiceProvider\"><a href=\"#ServiceProvider\" class=\"headerlink\" title=\"ServiceProvider\"></a>ServiceProvider</h1><p>服务供应类 java.util.ServiceLoader</p>\n<p>要使用此需要将 Provider 实现与 Service 定义写入到 META-INF/services 文件中，以 UTF-8 编码方式，详情参照源码文档。</p>\n"},{"date":"2020-08-13T03:14:00.000Z","description":"java URI class","_content":"\n# URI in Java\n\nURI syntax and components [URI 语法](https://www.ietf.org/rfc/rfc2396.txt)\n\nAt the highest level a URI reference (hereinafter simply \"URI\") in string form has the syntax `[scheme:]scheme-specific-part[#fragment]`\n\n## URI 分类\n\n- opaque 模糊类：不以 slash character `/` 开头，不需要进一步解析。eg：\n    - mailto:java-net@java.sun.com\n    - ews:comp.lang.java\n    - urn:isbn:096139210x\n- hierarchical 层级类，要么 scheme-specific-part 以 slash character `/` 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。\n    - eg：\n        - http://java.sun.com/j2se/1.3/\n        - docs/guide/collections/designfaq.html#28\n        - ../../../demo/jfc/SwingSet2/src/SwingSet2.java\n        - file:///~/calendar\n    - 层级类的 URI 需要进一步解析，其解析语法是 `[scheme:][//authority][path][?query][#fragment]`\n        - 如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：`[user-info@]host[:port]`。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。\n        - path 组件如果以slash character `/` 开头，则表明其是绝对路径，否则是相对的。*The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.*\n\nAll told, then, a URI instance has the following nine components:\n\nDescribes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment\n\n|Component|Type|\n|--|--|\n|scheme|String|\n|scheme-specific-part|String|\n|authority|String|\n|user-info|String|\n|host|String|\n|port|int|\n|path|String|\n|query|String|\n|fragment|String|\n\n## URL\n\nURL: Uniform Resource Locator.\n\nURL 与 URI 之间相互转换，使用方法： `URL.toURI()` 与 `URI.toURL()` 。\n\nURL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。\n\n## URI 文档翻译\n\n[original doc](https://www.ietf.org/rfc/rfc2396.txt)\n\n> 文档语法：\n> This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in\n\n>      <first>/<second>;<third>?<fourth>\n\n> The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.\n> The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that \"|\" is used to designate alternatives.  Briefly, rules are separated from definitions by an equal \"=\", indentation is used to continue a rule definition over more than one line, literals are quoted with \"\", parentheses \"(\" and \")\" are used to group elements, optional elements are enclosed in \"[\" and \"]\" brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.\n> Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.\n\n### 保留字符\n\n> reserved    = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\"$\" | \",\"\n\n如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。\n\n### 非保留字符\n\n大小写字母数字与标点符号\n\n> unreserved  = alphanum | mark\n> mark        = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" | \"(\" | \")\"\n\n在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。\n\n### 转义编码\n\n转义后的八进制符是由三个字符组成：`%` 加上两个十六进制字符。eg: `%20` 表示 ASCII 码 32 space。\n\n是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。\n\n### 被排除的 ASCII 字符\n\n- 控制符 US-ASCII coded characters 00-1F, 7F hexadecimal\n- 空格 space US-ASCII coded character 20 hexadecimal\n- 分隔符 delims \"<\" | \">\" | \"#\" | \"%\" | <\"> 网关代理用于分隔符 \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"[\" | \"]\" | \"`\"\n\n## URI 句法部件 （URI Syntactic Components）\n\nURI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： `<scheme>:<scheme-specific-part>`。使用的 scheme 后跟 `;` 再跟上一个意义解释取决于 scheme 的 String。\n\nURI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： `<scheme>://<authority><path>?<query>`。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 `<query>` 组件。\n\n`absoluteURI   = scheme \":\" ( hier_part | opaque_part )`\n\n本质上层级 URI 使用 slash `/` 分隔。某些文件系统同样使用 `/` 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。\n\n> hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n\n> net_path      = \"//\" authority [ abs_path ]\n\n> abs_path      = \"/\"  path_segments\n\nURI 不使用 `/` 分隔层级的话，将被通用 URI 解析器识别为不透明 'opaque'；\n\nopaque_part   = uric_no_slash *uric\n\nuric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\"&\" | \"=\" | \"+\" | \"$\" | \",\"\n\n使用 `<path>` 表示 `<abs_path>` 与 `<opaque_part>` 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。\n\n### Scheme 组件\n\n如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。\n\nScheme 由小写字母、数字、plus `+`/period `.`/hyphen `-` 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。`scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )`。相对 URI 从 base URI 继承而来，不以 scheme 开头。\n\n### Path 组件\n\n```\npath          = [ abs_path | opaque_part ]\n\npath_segments = segment *( \"/\" segment )\nsegment       = *pchar *( \";\" param )\nparam         = *pchar\n\npchar         = unreserved | escaped |\":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n```\n\n一个路径组件可由多个 segment 组成，segment 由 `/` 分隔。一个 segment 中，`/`,`?`,`=`,`;` 为保留字符。同时可由多个参数构成，参数之间使用 `;` 分隔。\n\n### Query 组件\n\n>    The query component is a string of information to be interpreted by the resource.\n> \n> query         = *uric\n> \n> Within a query component, the characters \";\", \"/\", \"?\", \":\", \"@\", \"&\", \"=\", \"+\", \",\", and \"$\" are reserved.\n","source":"_posts/URI in Java.md","raw":"---\ndate: 2020-08-13 11:14:00\ntags: [framework,java,URI]\ncategories: programming\ndescription: java URI class\n---\n\n# URI in Java\n\nURI syntax and components [URI 语法](https://www.ietf.org/rfc/rfc2396.txt)\n\nAt the highest level a URI reference (hereinafter simply \"URI\") in string form has the syntax `[scheme:]scheme-specific-part[#fragment]`\n\n## URI 分类\n\n- opaque 模糊类：不以 slash character `/` 开头，不需要进一步解析。eg：\n    - mailto:java-net@java.sun.com\n    - ews:comp.lang.java\n    - urn:isbn:096139210x\n- hierarchical 层级类，要么 scheme-specific-part 以 slash character `/` 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。\n    - eg：\n        - http://java.sun.com/j2se/1.3/\n        - docs/guide/collections/designfaq.html#28\n        - ../../../demo/jfc/SwingSet2/src/SwingSet2.java\n        - file:///~/calendar\n    - 层级类的 URI 需要进一步解析，其解析语法是 `[scheme:][//authority][path][?query][#fragment]`\n        - 如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：`[user-info@]host[:port]`。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。\n        - path 组件如果以slash character `/` 开头，则表明其是绝对路径，否则是相对的。*The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.*\n\nAll told, then, a URI instance has the following nine components:\n\nDescribes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment\n\n|Component|Type|\n|--|--|\n|scheme|String|\n|scheme-specific-part|String|\n|authority|String|\n|user-info|String|\n|host|String|\n|port|int|\n|path|String|\n|query|String|\n|fragment|String|\n\n## URL\n\nURL: Uniform Resource Locator.\n\nURL 与 URI 之间相互转换，使用方法： `URL.toURI()` 与 `URI.toURL()` 。\n\nURL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。\n\n## URI 文档翻译\n\n[original doc](https://www.ietf.org/rfc/rfc2396.txt)\n\n> 文档语法：\n> This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in\n\n>      <first>/<second>;<third>?<fourth>\n\n> The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.\n> The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that \"|\" is used to designate alternatives.  Briefly, rules are separated from definitions by an equal \"=\", indentation is used to continue a rule definition over more than one line, literals are quoted with \"\", parentheses \"(\" and \")\" are used to group elements, optional elements are enclosed in \"[\" and \"]\" brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.\n> Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.\n\n### 保留字符\n\n> reserved    = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\"$\" | \",\"\n\n如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。\n\n### 非保留字符\n\n大小写字母数字与标点符号\n\n> unreserved  = alphanum | mark\n> mark        = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" | \"(\" | \")\"\n\n在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。\n\n### 转义编码\n\n转义后的八进制符是由三个字符组成：`%` 加上两个十六进制字符。eg: `%20` 表示 ASCII 码 32 space。\n\n是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。\n\n### 被排除的 ASCII 字符\n\n- 控制符 US-ASCII coded characters 00-1F, 7F hexadecimal\n- 空格 space US-ASCII coded character 20 hexadecimal\n- 分隔符 delims \"<\" | \">\" | \"#\" | \"%\" | <\"> 网关代理用于分隔符 \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"[\" | \"]\" | \"`\"\n\n## URI 句法部件 （URI Syntactic Components）\n\nURI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： `<scheme>:<scheme-specific-part>`。使用的 scheme 后跟 `;` 再跟上一个意义解释取决于 scheme 的 String。\n\nURI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： `<scheme>://<authority><path>?<query>`。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 `<query>` 组件。\n\n`absoluteURI   = scheme \":\" ( hier_part | opaque_part )`\n\n本质上层级 URI 使用 slash `/` 分隔。某些文件系统同样使用 `/` 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。\n\n> hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n\n> net_path      = \"//\" authority [ abs_path ]\n\n> abs_path      = \"/\"  path_segments\n\nURI 不使用 `/` 分隔层级的话，将被通用 URI 解析器识别为不透明 'opaque'；\n\nopaque_part   = uric_no_slash *uric\n\nuric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\"&\" | \"=\" | \"+\" | \"$\" | \",\"\n\n使用 `<path>` 表示 `<abs_path>` 与 `<opaque_part>` 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。\n\n### Scheme 组件\n\n如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。\n\nScheme 由小写字母、数字、plus `+`/period `.`/hyphen `-` 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。`scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )`。相对 URI 从 base URI 继承而来，不以 scheme 开头。\n\n### Path 组件\n\n```\npath          = [ abs_path | opaque_part ]\n\npath_segments = segment *( \"/\" segment )\nsegment       = *pchar *( \";\" param )\nparam         = *pchar\n\npchar         = unreserved | escaped |\":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n```\n\n一个路径组件可由多个 segment 组成，segment 由 `/` 分隔。一个 segment 中，`/`,`?`,`=`,`;` 为保留字符。同时可由多个参数构成，参数之间使用 `;` 分隔。\n\n### Query 组件\n\n>    The query component is a string of information to be interpreted by the resource.\n> \n> query         = *uric\n> \n> Within a query component, the characters \";\", \"/\", \"?\", \":\", \"@\", \"&\", \"=\", \"+\", \",\", and \"$\" are reserved.\n","slug":"URI in Java","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1x000emshbfnhzhaj1","content":"<h1 id=\"URI-in-Java\"><a href=\"#URI-in-Java\" class=\"headerlink\" title=\"URI in Java\"></a>URI in Java</h1><p>URI syntax and components <a href=\"https://www.ietf.org/rfc/rfc2396.txt\">URI 语法</a></p>\n<p>At the highest level a URI reference (hereinafter simply “URI”) in string form has the syntax <code>[scheme:]scheme-specific-part[#fragment]</code></p>\n<h2 id=\"URI-分类\"><a href=\"#URI-分类\" class=\"headerlink\" title=\"URI 分类\"></a>URI 分类</h2><ul>\n<li>opaque 模糊类：不以 slash character <code>/</code> 开头，不需要进一步解析。eg：<ul>\n<li>mailto:<a href=\"mailto:&#106;&#x61;&#118;&#97;&#x2d;&#110;&#101;&#116;&#64;&#x6a;&#x61;&#x76;&#97;&#x2e;&#x73;&#117;&#110;&#x2e;&#99;&#111;&#x6d;\">&#106;&#x61;&#118;&#97;&#x2d;&#110;&#101;&#116;&#64;&#x6a;&#x61;&#x76;&#97;&#x2e;&#x73;&#117;&#110;&#x2e;&#99;&#111;&#x6d;</a></li>\n<li>ews:comp.lang.java</li>\n<li>urn:isbn:096139210x</li>\n</ul>\n</li>\n<li>hierarchical 层级类，要么 scheme-specific-part 以 slash character <code>/</code> 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。<ul>\n<li>eg：<ul>\n<li><a href=\"http://java.sun.com/j2se/1.3/\">http://java.sun.com/j2se/1.3/</a></li>\n<li>docs/guide/collections/designfaq.html#28</li>\n<li>../../../demo/jfc/SwingSet2/src/SwingSet2.java</li>\n<li>file:///~/calendar</li>\n</ul>\n</li>\n<li>层级类的 URI 需要进一步解析，其解析语法是 <code>[scheme:][//authority][path][?query][#fragment]</code><ul>\n<li>如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：<code>[user-info@]host[:port]</code>。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。</li>\n<li>path 组件如果以slash character <code>/</code> 开头，则表明其是绝对路径，否则是相对的。<em>The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>All told, then, a URI instance has the following nine components:</p>\n<p>Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>scheme</td>\n<td>String</td>\n</tr>\n<tr>\n<td>scheme-specific-part</td>\n<td>String</td>\n</tr>\n<tr>\n<td>authority</td>\n<td>String</td>\n</tr>\n<tr>\n<td>user-info</td>\n<td>String</td>\n</tr>\n<tr>\n<td>host</td>\n<td>String</td>\n</tr>\n<tr>\n<td>port</td>\n<td>int</td>\n</tr>\n<tr>\n<td>path</td>\n<td>String</td>\n</tr>\n<tr>\n<td>query</td>\n<td>String</td>\n</tr>\n<tr>\n<td>fragment</td>\n<td>String</td>\n</tr>\n</tbody></table>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>URL: Uniform Resource Locator.</p>\n<p>URL 与 URI 之间相互转换，使用方法： <code>URL.toURI()</code> 与 <code>URI.toURL()</code> 。</p>\n<p>URL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。</p>\n<h2 id=\"URI-文档翻译\"><a href=\"#URI-文档翻译\" class=\"headerlink\" title=\"URI 文档翻译\"></a>URI 文档翻译</h2><p><a href=\"https://www.ietf.org/rfc/rfc2396.txt\">original doc</a></p>\n<blockquote>\n<p>文档语法：<br>This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in</p>\n</blockquote>\n<blockquote>\n<pre><code> &lt;first&gt;/&lt;second&gt;;&lt;third&gt;?&lt;fourth&gt;\n</code></pre>\n</blockquote>\n<blockquote>\n<p>The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.<br>The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that “|” is used to designate alternatives.  Briefly, rules are separated from definitions by an equal “=”, indentation is used to continue a rule definition over more than one line, literals are quoted with “”, parentheses “(“ and “)” are used to group elements, optional elements are enclosed in “[“ and “]” brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.<br>Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.</p>\n</blockquote>\n<h3 id=\"保留字符\"><a href=\"#保留字符\" class=\"headerlink\" title=\"保留字符\"></a>保留字符</h3><blockquote>\n<p>reserved    = “;” | “/“ | “?” | “:” | “@” | “&amp;” | “=” | “+” |”$” | “,”</p>\n</blockquote>\n<p>如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。</p>\n<h3 id=\"非保留字符\"><a href=\"#非保留字符\" class=\"headerlink\" title=\"非保留字符\"></a>非保留字符</h3><p>大小写字母数字与标点符号</p>\n<blockquote>\n<p>unreserved  = alphanum | mark<br>mark        = “-“ | “_” | “.” | “!” | “~” | “*” | “‘“ | “(“ | “)”</p>\n</blockquote>\n<p>在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。</p>\n<h3 id=\"转义编码\"><a href=\"#转义编码\" class=\"headerlink\" title=\"转义编码\"></a>转义编码</h3><p>转义后的八进制符是由三个字符组成：<code>%</code> 加上两个十六进制字符。eg: <code>%20</code> 表示 ASCII 码 32 space。</p>\n<p>是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。</p>\n<h3 id=\"被排除的-ASCII-字符\"><a href=\"#被排除的-ASCII-字符\" class=\"headerlink\" title=\"被排除的 ASCII 字符\"></a>被排除的 ASCII 字符</h3><ul>\n<li>控制符 US-ASCII coded characters 00-1F, 7F hexadecimal</li>\n<li>空格 space US-ASCII coded character 20 hexadecimal</li>\n<li>分隔符 delims “&lt;” | “&gt;” | “#” | “%” | &lt;”&gt; 网关代理用于分隔符 “{“ | “}” | “|” | “&quot; | “^” | “[“ | “]” | “`”</li>\n</ul>\n<h2 id=\"URI-句法部件-（URI-Syntactic-Components）\"><a href=\"#URI-句法部件-（URI-Syntactic-Components）\" class=\"headerlink\" title=\"URI 句法部件 （URI Syntactic Components）\"></a>URI 句法部件 （URI Syntactic Components）</h2><p>URI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>。使用的 scheme 后跟 <code>;</code> 再跟上一个意义解释取决于 scheme 的 String。</p>\n<p>URI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： <code>&lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;?&lt;query&gt;</code>。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 <code>&lt;query&gt;</code> 组件。</p>\n<p><code>absoluteURI   = scheme &quot;:&quot; ( hier_part | opaque_part )</code></p>\n<p>本质上层级 URI 使用 slash <code>/</code> 分隔。某些文件系统同样使用 <code>/</code> 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。</p>\n<blockquote>\n<p>hier_part     = ( net_path | abs_path ) [ “?” query ]</p>\n</blockquote>\n<blockquote>\n<p>net_path      = “//“ authority [ abs_path ]</p>\n</blockquote>\n<blockquote>\n<p>abs_path      = “/“  path_segments</p>\n</blockquote>\n<p>URI 不使用 <code>/</code> 分隔层级的话，将被通用 URI 解析器识别为不透明 ‘opaque’；</p>\n<p>opaque_part   = uric_no_slash *uric</p>\n<p>uric_no_slash = unreserved | escaped | “;” | “?” | “:” | “@” |”&amp;” | “=” | “+” | “$” | “,”</p>\n<p>使用 <code>&lt;path&gt;</code> 表示 <code>&lt;abs_path&gt;</code> 与 <code>&lt;opaque_part&gt;</code> 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。</p>\n<h3 id=\"Scheme-组件\"><a href=\"#Scheme-组件\" class=\"headerlink\" title=\"Scheme 组件\"></a>Scheme 组件</h3><p>如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。</p>\n<p>Scheme 由小写字母、数字、plus <code>+</code>/period <code>.</code>/hyphen <code>-</code> 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。<code>scheme = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )</code>。相对 URI 从 base URI 继承而来，不以 scheme 开头。</p>\n<h3 id=\"Path-组件\"><a href=\"#Path-组件\" class=\"headerlink\" title=\"Path 组件\"></a>Path 组件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path          &#x3D; [ abs_path | opaque_part ]</span><br><span class=\"line\"></span><br><span class=\"line\">path_segments &#x3D; segment *( &quot;&#x2F;&quot; segment )</span><br><span class=\"line\">segment       &#x3D; *pchar *( &quot;;&quot; param )</span><br><span class=\"line\">param         &#x3D; *pchar</span><br><span class=\"line\"></span><br><span class=\"line\">pchar         &#x3D; unreserved | escaped |&quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;&#x3D;&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;</span><br></pre></td></tr></table></figure>\n\n<p>一个路径组件可由多个 segment 组成，segment 由 <code>/</code> 分隔。一个 segment 中，<code>/</code>,<code>?</code>,<code>=</code>,<code>;</code> 为保留字符。同时可由多个参数构成，参数之间使用 <code>;</code> 分隔。</p>\n<h3 id=\"Query-组件\"><a href=\"#Query-组件\" class=\"headerlink\" title=\"Query 组件\"></a>Query 组件</h3><blockquote>\n<p>   The query component is a string of information to be interpreted by the resource.</p>\n<p>query         = *uric</p>\n<p>Within a query component, the characters “;”, “/“, “?”, “:”, “@”, “&amp;”, “=”, “+”, “,”, and “$” are reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"URI-in-Java\"><a href=\"#URI-in-Java\" class=\"headerlink\" title=\"URI in Java\"></a>URI in Java</h1><p>URI syntax and components <a href=\"https://www.ietf.org/rfc/rfc2396.txt\">URI 语法</a></p>\n<p>At the highest level a URI reference (hereinafter simply “URI”) in string form has the syntax <code>[scheme:]scheme-specific-part[#fragment]</code></p>\n<h2 id=\"URI-分类\"><a href=\"#URI-分类\" class=\"headerlink\" title=\"URI 分类\"></a>URI 分类</h2><ul>\n<li>opaque 模糊类：不以 slash character <code>/</code> 开头，不需要进一步解析。eg：<ul>\n<li>mailto:<a href=\"mailto:&#106;&#x61;&#118;&#97;&#x2d;&#110;&#101;&#116;&#64;&#x6a;&#x61;&#x76;&#97;&#x2e;&#x73;&#117;&#110;&#x2e;&#99;&#111;&#x6d;\">&#106;&#x61;&#118;&#97;&#x2d;&#110;&#101;&#116;&#64;&#x6a;&#x61;&#x76;&#97;&#x2e;&#x73;&#117;&#110;&#x2e;&#99;&#111;&#x6d;</a></li>\n<li>ews:comp.lang.java</li>\n<li>urn:isbn:096139210x</li>\n</ul>\n</li>\n<li>hierarchical 层级类，要么 scheme-specific-part 以 slash character <code>/</code> 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。<ul>\n<li>eg：<ul>\n<li><a href=\"http://java.sun.com/j2se/1.3/\">http://java.sun.com/j2se/1.3/</a></li>\n<li>docs/guide/collections/designfaq.html#28</li>\n<li>../../../demo/jfc/SwingSet2/src/SwingSet2.java</li>\n<li>file:///~/calendar</li>\n</ul>\n</li>\n<li>层级类的 URI 需要进一步解析，其解析语法是 <code>[scheme:][//authority][path][?query][#fragment]</code><ul>\n<li>如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：<code>[user-info@]host[:port]</code>。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。</li>\n<li>path 组件如果以slash character <code>/</code> 开头，则表明其是绝对路径，否则是相对的。<em>The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>All told, then, a URI instance has the following nine components:</p>\n<p>Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>scheme</td>\n<td>String</td>\n</tr>\n<tr>\n<td>scheme-specific-part</td>\n<td>String</td>\n</tr>\n<tr>\n<td>authority</td>\n<td>String</td>\n</tr>\n<tr>\n<td>user-info</td>\n<td>String</td>\n</tr>\n<tr>\n<td>host</td>\n<td>String</td>\n</tr>\n<tr>\n<td>port</td>\n<td>int</td>\n</tr>\n<tr>\n<td>path</td>\n<td>String</td>\n</tr>\n<tr>\n<td>query</td>\n<td>String</td>\n</tr>\n<tr>\n<td>fragment</td>\n<td>String</td>\n</tr>\n</tbody></table>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>URL: Uniform Resource Locator.</p>\n<p>URL 与 URI 之间相互转换，使用方法： <code>URL.toURI()</code> 与 <code>URI.toURL()</code> 。</p>\n<p>URL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。</p>\n<h2 id=\"URI-文档翻译\"><a href=\"#URI-文档翻译\" class=\"headerlink\" title=\"URI 文档翻译\"></a>URI 文档翻译</h2><p><a href=\"https://www.ietf.org/rfc/rfc2396.txt\">original doc</a></p>\n<blockquote>\n<p>文档语法：<br>This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in</p>\n</blockquote>\n<blockquote>\n<pre><code> &lt;first&gt;/&lt;second&gt;;&lt;third&gt;?&lt;fourth&gt;\n</code></pre>\n</blockquote>\n<blockquote>\n<p>The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.<br>The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that “|” is used to designate alternatives.  Briefly, rules are separated from definitions by an equal “=”, indentation is used to continue a rule definition over more than one line, literals are quoted with “”, parentheses “(“ and “)” are used to group elements, optional elements are enclosed in “[“ and “]” brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.<br>Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.</p>\n</blockquote>\n<h3 id=\"保留字符\"><a href=\"#保留字符\" class=\"headerlink\" title=\"保留字符\"></a>保留字符</h3><blockquote>\n<p>reserved    = “;” | “/“ | “?” | “:” | “@” | “&amp;” | “=” | “+” |”$” | “,”</p>\n</blockquote>\n<p>如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。</p>\n<h3 id=\"非保留字符\"><a href=\"#非保留字符\" class=\"headerlink\" title=\"非保留字符\"></a>非保留字符</h3><p>大小写字母数字与标点符号</p>\n<blockquote>\n<p>unreserved  = alphanum | mark<br>mark        = “-“ | “_” | “.” | “!” | “~” | “*” | “‘“ | “(“ | “)”</p>\n</blockquote>\n<p>在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。</p>\n<h3 id=\"转义编码\"><a href=\"#转义编码\" class=\"headerlink\" title=\"转义编码\"></a>转义编码</h3><p>转义后的八进制符是由三个字符组成：<code>%</code> 加上两个十六进制字符。eg: <code>%20</code> 表示 ASCII 码 32 space。</p>\n<p>是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。</p>\n<h3 id=\"被排除的-ASCII-字符\"><a href=\"#被排除的-ASCII-字符\" class=\"headerlink\" title=\"被排除的 ASCII 字符\"></a>被排除的 ASCII 字符</h3><ul>\n<li>控制符 US-ASCII coded characters 00-1F, 7F hexadecimal</li>\n<li>空格 space US-ASCII coded character 20 hexadecimal</li>\n<li>分隔符 delims “&lt;” | “&gt;” | “#” | “%” | &lt;”&gt; 网关代理用于分隔符 “{“ | “}” | “|” | “&quot; | “^” | “[“ | “]” | “`”</li>\n</ul>\n<h2 id=\"URI-句法部件-（URI-Syntactic-Components）\"><a href=\"#URI-句法部件-（URI-Syntactic-Components）\" class=\"headerlink\" title=\"URI 句法部件 （URI Syntactic Components）\"></a>URI 句法部件 （URI Syntactic Components）</h2><p>URI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>。使用的 scheme 后跟 <code>;</code> 再跟上一个意义解释取决于 scheme 的 String。</p>\n<p>URI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： <code>&lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;?&lt;query&gt;</code>。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 <code>&lt;query&gt;</code> 组件。</p>\n<p><code>absoluteURI   = scheme &quot;:&quot; ( hier_part | opaque_part )</code></p>\n<p>本质上层级 URI 使用 slash <code>/</code> 分隔。某些文件系统同样使用 <code>/</code> 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。</p>\n<blockquote>\n<p>hier_part     = ( net_path | abs_path ) [ “?” query ]</p>\n</blockquote>\n<blockquote>\n<p>net_path      = “//“ authority [ abs_path ]</p>\n</blockquote>\n<blockquote>\n<p>abs_path      = “/“  path_segments</p>\n</blockquote>\n<p>URI 不使用 <code>/</code> 分隔层级的话，将被通用 URI 解析器识别为不透明 ‘opaque’；</p>\n<p>opaque_part   = uric_no_slash *uric</p>\n<p>uric_no_slash = unreserved | escaped | “;” | “?” | “:” | “@” |”&amp;” | “=” | “+” | “$” | “,”</p>\n<p>使用 <code>&lt;path&gt;</code> 表示 <code>&lt;abs_path&gt;</code> 与 <code>&lt;opaque_part&gt;</code> 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。</p>\n<h3 id=\"Scheme-组件\"><a href=\"#Scheme-组件\" class=\"headerlink\" title=\"Scheme 组件\"></a>Scheme 组件</h3><p>如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。</p>\n<p>Scheme 由小写字母、数字、plus <code>+</code>/period <code>.</code>/hyphen <code>-</code> 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。<code>scheme = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )</code>。相对 URI 从 base URI 继承而来，不以 scheme 开头。</p>\n<h3 id=\"Path-组件\"><a href=\"#Path-组件\" class=\"headerlink\" title=\"Path 组件\"></a>Path 组件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path          &#x3D; [ abs_path | opaque_part ]</span><br><span class=\"line\"></span><br><span class=\"line\">path_segments &#x3D; segment *( &quot;&#x2F;&quot; segment )</span><br><span class=\"line\">segment       &#x3D; *pchar *( &quot;;&quot; param )</span><br><span class=\"line\">param         &#x3D; *pchar</span><br><span class=\"line\"></span><br><span class=\"line\">pchar         &#x3D; unreserved | escaped |&quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;&#x3D;&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;</span><br></pre></td></tr></table></figure>\n\n<p>一个路径组件可由多个 segment 组成，segment 由 <code>/</code> 分隔。一个 segment 中，<code>/</code>,<code>?</code>,<code>=</code>,<code>;</code> 为保留字符。同时可由多个参数构成，参数之间使用 <code>;</code> 分隔。</p>\n<h3 id=\"Query-组件\"><a href=\"#Query-组件\" class=\"headerlink\" title=\"Query 组件\"></a>Query 组件</h3><blockquote>\n<p>   The query component is a string of information to be interpreted by the resource.</p>\n<p>query         = *uric</p>\n<p>Within a query component, the characters “;”, “/“, “?”, “:”, “@”, “&amp;”, “=”, “+”, “,”, and “$” are reserved.</p>\n</blockquote>\n"},{"_content":"# Bridge Method\n\n[reference](http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html#:~:text=Bridge%20methods%20in%20Java%20are,the%20actual%20method%20being%20invoked.)\n\n简言之，继承过来的与范型签名的方法都是 bridge method。\n","source":"_posts/bridge method.md","raw":"# Bridge Method\n\n[reference](http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html#:~:text=Bridge%20methods%20in%20Java%20are,the%20actual%20method%20being%20invoked.)\n\n简言之，继承过来的与范型签名的方法都是 bridge method。\n","slug":"bridge method","published":1,"date":"2021-02-21T15:01:31.292Z","updated":"2021-01-15T14:40:11.555Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p1y000hmshb9e2lh0ev","content":"<h1 id=\"Bridge-Method\"><a href=\"#Bridge-Method\" class=\"headerlink\" title=\"Bridge Method\"></a>Bridge Method</h1><p><a href=\"http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html#:~:text=Bridge%20methods%20in%20Java%20are,the%20actual%20method%20being%20invoked.\">reference</a></p>\n<p>简言之，继承过来的与范型签名的方法都是 bridge method。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Bridge-Method\"><a href=\"#Bridge-Method\" class=\"headerlink\" title=\"Bridge Method\"></a>Bridge Method</h1><p><a href=\"http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html#:~:text=Bridge%20methods%20in%20Java%20are,the%20actual%20method%20being%20invoked.\">reference</a></p>\n<p>简言之，继承过来的与范型签名的方法都是 bridge method。</p>\n"},{"layout":"post","title":"Date&Calenda","date":"2018-09-28T06:06:00.000Z","_content":"\n# Date & Calender & LocalDateTime\n\n> 日期 Data 类诸多方法已经被废弃，很多方法都建议使用 Calendar 中的新方法。而比较两个 日期 不用将 Date 转成 Calendar 进行比较，直接使用 Date.after(Date date) 等一系列方法即可。\n\n## LocalDateTime\n\n> LocalDateTime is one of new feature in java8, 相应还有 LocalDate 与 LocalTime 。\n","source":"_posts/date-calenda.md","raw":"---\nlayout: \"post\"\ntitle: \"Date&Calenda\"\ndate: \"2018-09-28 14:06\"\n---\n\n# Date & Calender & LocalDateTime\n\n> 日期 Data 类诸多方法已经被废弃，很多方法都建议使用 Calendar 中的新方法。而比较两个 日期 不用将 Date 转成 Calendar 进行比较，直接使用 Date.after(Date date) 等一系列方法即可。\n\n## LocalDateTime\n\n> LocalDateTime is one of new feature in java8, 相应还有 LocalDate 与 LocalTime 。\n","slug":"date-calenda","published":1,"updated":"2021-01-12T13:04:51.669Z","comments":1,"photos":[],"link":"","_id":"cklfa4p20000lmshbhsorbozq","content":"<h1 id=\"Date-amp-Calender-amp-LocalDateTime\"><a href=\"#Date-amp-Calender-amp-LocalDateTime\" class=\"headerlink\" title=\"Date &amp; Calender &amp; LocalDateTime\"></a>Date &amp; Calender &amp; LocalDateTime</h1><blockquote>\n<p>日期 Data 类诸多方法已经被废弃，很多方法都建议使用 Calendar 中的新方法。而比较两个 日期 不用将 Date 转成 Calendar 进行比较，直接使用 Date.after(Date date) 等一系列方法即可。</p>\n</blockquote>\n<h2 id=\"LocalDateTime\"><a href=\"#LocalDateTime\" class=\"headerlink\" title=\"LocalDateTime\"></a>LocalDateTime</h2><blockquote>\n<p>LocalDateTime is one of new feature in java8, 相应还有 LocalDate 与 LocalTime 。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Date-amp-Calender-amp-LocalDateTime\"><a href=\"#Date-amp-Calender-amp-LocalDateTime\" class=\"headerlink\" title=\"Date &amp; Calender &amp; LocalDateTime\"></a>Date &amp; Calender &amp; LocalDateTime</h1><blockquote>\n<p>日期 Data 类诸多方法已经被废弃，很多方法都建议使用 Calendar 中的新方法。而比较两个 日期 不用将 Date 转成 Calendar 进行比较，直接使用 Date.after(Date date) 等一系列方法即可。</p>\n</blockquote>\n<h2 id=\"LocalDateTime\"><a href=\"#LocalDateTime\" class=\"headerlink\" title=\"LocalDateTime\"></a>LocalDateTime</h2><blockquote>\n<p>LocalDateTime is one of new feature in java8, 相应还有 LocalDate 与 LocalTime 。</p>\n</blockquote>\n"},{"date":"2020-10-21T15:52:00.000Z","description":"java 中写 GUI 的包","_content":"\n# guigarage\n\n[reference](https://guigarage.com/2014/06/datafx-tutorial-4/)\n\n- 使用此包实现桌面应用程序[参考架构](https://guigarage.com/2014/06/datafx-tutorial-4/)\n- \n","source":"_posts/guigargage.md","raw":"---\ndate: 2020-10-21 23:52:00\ncategories: programing\ntags: [guigarage, java, GUI]\ndescription: java 中写 GUI 的包\n---\n\n# guigarage\n\n[reference](https://guigarage.com/2014/06/datafx-tutorial-4/)\n\n- 使用此包实现桌面应用程序[参考架构](https://guigarage.com/2014/06/datafx-tutorial-4/)\n- \n","slug":"guigargage","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p22000nmshb84o7c3nl","content":"<h1 id=\"guigarage\"><a href=\"#guigarage\" class=\"headerlink\" title=\"guigarage\"></a>guigarage</h1><p><a href=\"https://guigarage.com/2014/06/datafx-tutorial-4/\">reference</a></p>\n<ul>\n<li>使用此包实现桌面应用程序<a href=\"https://guigarage.com/2014/06/datafx-tutorial-4/\">参考架构</a></li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"guigarage\"><a href=\"#guigarage\" class=\"headerlink\" title=\"guigarage\"></a>guigarage</h1><p><a href=\"https://guigarage.com/2014/06/datafx-tutorial-4/\">reference</a></p>\n<ul>\n<li>使用此包实现桌面应用程序<a href=\"https://guigarage.com/2014/06/datafx-tutorial-4/\">参考架构</a></li>\n<li></li>\n</ul>\n"},{"date":"2020-10-20T03:02:00.000Z","description":"java jar","_content":"\n# Java jar\n\njava archive\n\n- 使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 `java jar cfmv jar-name manifest-file class-files`\n\n## installed extensions\n\n添加外部的 jar 用作扩展。\n\n- 可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。\n- 可以直接在 jre 中添加扩展。path：jre/lib/ext\n- 若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext\n\n## `java` command line\n\n> `java` 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。\n\n- `-` 标准选项 standard option\n- `-X` 非标准选项 non-standard option\n    - `-Xmn<size>` 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 `-XX:NewSize` 和  `-XX:MaxNewSize`。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。\n    - `-Xms<size>` 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。\n    - `-Xmx<size>` 要求与 Xms 一致，等于 `-XX:MaxHeapSize`，用以设置堆的内存最大分配置额。\n- `-XX` 高级选项 advanced option\n- `-D<name>=<value>` 设置系统属性\n\n## JVM\n\n[Oracle reference](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)\n","source":"_posts/jar.md","raw":"---\ndate: 2020-10-20 11:02:00\ncategories: java\ntags: [java, jar, package, jvm]\ndescription: java jar\n---\n\n# Java jar\n\njava archive\n\n- 使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 `java jar cfmv jar-name manifest-file class-files`\n\n## installed extensions\n\n添加外部的 jar 用作扩展。\n\n- 可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。\n- 可以直接在 jre 中添加扩展。path：jre/lib/ext\n- 若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext\n\n## `java` command line\n\n> `java` 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。\n\n- `-` 标准选项 standard option\n- `-X` 非标准选项 non-standard option\n    - `-Xmn<size>` 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 `-XX:NewSize` 和  `-XX:MaxNewSize`。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。\n    - `-Xms<size>` 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。\n    - `-Xmx<size>` 要求与 Xms 一致，等于 `-XX:MaxHeapSize`，用以设置堆的内存最大分配置额。\n- `-XX` 高级选项 advanced option\n- `-D<name>=<value>` 设置系统属性\n\n## JVM\n\n[Oracle reference](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)\n","slug":"jar","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p24000qmshb6ae5h59q","content":"<h1 id=\"Java-jar\"><a href=\"#Java-jar\" class=\"headerlink\" title=\"Java jar\"></a>Java jar</h1><p>java archive</p>\n<ul>\n<li>使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 <code>java jar cfmv jar-name manifest-file class-files</code></li>\n</ul>\n<h2 id=\"installed-extensions\"><a href=\"#installed-extensions\" class=\"headerlink\" title=\"installed extensions\"></a>installed extensions</h2><p>添加外部的 jar 用作扩展。</p>\n<ul>\n<li>可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。</li>\n<li>可以直接在 jre 中添加扩展。path：jre/lib/ext</li>\n<li>若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext</li>\n</ul>\n<h2 id=\"java-command-line\"><a href=\"#java-command-line\" class=\"headerlink\" title=\"java command line\"></a><code>java</code> command line</h2><blockquote>\n<p><code>java</code> 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。</p>\n</blockquote>\n<ul>\n<li><code>-</code> 标准选项 standard option</li>\n<li><code>-X</code> 非标准选项 non-standard option<ul>\n<li><code>-Xmn&lt;size&gt;</code> 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 <code>-XX:NewSize</code> 和  <code>-XX:MaxNewSize</code>。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。</li>\n<li><code>-Xms&lt;size&gt;</code> 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。</li>\n<li><code>-Xmx&lt;size&gt;</code> 要求与 Xms 一致，等于 <code>-XX:MaxHeapSize</code>，用以设置堆的内存最大分配置额。</li>\n</ul>\n</li>\n<li><code>-XX</code> 高级选项 advanced option</li>\n<li><code>-D&lt;name&gt;=&lt;value&gt;</code> 设置系统属性</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html\">Oracle reference</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java-jar\"><a href=\"#Java-jar\" class=\"headerlink\" title=\"Java jar\"></a>Java jar</h1><p>java archive</p>\n<ul>\n<li>使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 <code>java jar cfmv jar-name manifest-file class-files</code></li>\n</ul>\n<h2 id=\"installed-extensions\"><a href=\"#installed-extensions\" class=\"headerlink\" title=\"installed extensions\"></a>installed extensions</h2><p>添加外部的 jar 用作扩展。</p>\n<ul>\n<li>可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。</li>\n<li>可以直接在 jre 中添加扩展。path：jre/lib/ext</li>\n<li>若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext</li>\n</ul>\n<h2 id=\"java-command-line\"><a href=\"#java-command-line\" class=\"headerlink\" title=\"java command line\"></a><code>java</code> command line</h2><blockquote>\n<p><code>java</code> 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。</p>\n</blockquote>\n<ul>\n<li><code>-</code> 标准选项 standard option</li>\n<li><code>-X</code> 非标准选项 non-standard option<ul>\n<li><code>-Xmn&lt;size&gt;</code> 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 <code>-XX:NewSize</code> 和  <code>-XX:MaxNewSize</code>。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。</li>\n<li><code>-Xms&lt;size&gt;</code> 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。</li>\n<li><code>-Xmx&lt;size&gt;</code> 要求与 Xms 一致，等于 <code>-XX:MaxHeapSize</code>，用以设置堆的内存最大分配置额。</li>\n</ul>\n</li>\n<li><code>-XX</code> 高级选项 advanced option</li>\n<li><code>-D&lt;name&gt;=&lt;value&gt;</code> 设置系统属性</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html\">Oracle reference</a></p>\n"},{"date":"2020-11-10T08:19:00.000Z","_content":"\n\n","source":"_posts/java reflect.md","raw":"---\ndate: \"2020-11-10 16:19:00\"\ntags: [reflect, java]\n---\n\n\n","slug":"java reflect","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p26000umshb1342h55e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"socket","date":"2020-03-15T01:04:38.000Z","description":"附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面","_content":"\n# socket\n\nTCP 级别通信 API 。 socket 意为 插座，能理解为一切通信应用的都需要接到“插座”上。\n\n## java socket\n\njava socket 编程。[reference](https://cs.lmu.edu/~ray/notes/javanetexamples/#date)\n\n- ServerSocket 用于监听指定端口的 socket 。\n    - question: 并发地对端口进行访问， socket 是怎么处理？要对其排队吗？\n    - 还是说在传输层已经做好的信息的排队？\n\n```java\n\n```\n","source":"_posts/java socket.md","raw":"---\ntitle: socket\ndate: 2020-03-15 09:04:38\ncategories: programing\ntags: [protocol, socket]\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n---\n\n# socket\n\nTCP 级别通信 API 。 socket 意为 插座，能理解为一切通信应用的都需要接到“插座”上。\n\n## java socket\n\njava socket 编程。[reference](https://cs.lmu.edu/~ray/notes/javanetexamples/#date)\n\n- ServerSocket 用于监听指定端口的 socket 。\n    - question: 并发地对端口进行访问， socket 是怎么处理？要对其排队吗？\n    - 还是说在传输层已经做好的信息的排队？\n\n```java\n\n```\n","slug":"java socket","published":1,"updated":"2021-01-12T13:04:51.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p27000ymshb8jxr2rys","content":"<h1 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h1><p>TCP 级别通信 API 。 socket 意为 插座，能理解为一切通信应用的都需要接到“插座”上。</p>\n<h2 id=\"java-socket\"><a href=\"#java-socket\" class=\"headerlink\" title=\"java socket\"></a>java socket</h2><p>java socket 编程。<a href=\"https://cs.lmu.edu/~ray/notes/javanetexamples/#date\">reference</a></p>\n<ul>\n<li>ServerSocket 用于监听指定端口的 socket 。<ul>\n<li>question: 并发地对端口进行访问， socket 是怎么处理？要对其排队吗？</li>\n<li>还是说在传输层已经做好的信息的排队？</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h1><p>TCP 级别通信 API 。 socket 意为 插座，能理解为一切通信应用的都需要接到“插座”上。</p>\n<h2 id=\"java-socket\"><a href=\"#java-socket\" class=\"headerlink\" title=\"java socket\"></a>java socket</h2><p>java socket 编程。<a href=\"https://cs.lmu.edu/~ray/notes/javanetexamples/#date\">reference</a></p>\n<ul>\n<li>ServerSocket 用于监听指定端口的 socket 。<ul>\n<li>question: 并发地对端口进行访问， socket 是怎么处理？要对其排队吗？</li>\n<li>还是说在传输层已经做好的信息的排队？</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"date":"2020-12-09T04:12:00.000Z","description":"java transient","_content":"\n# transient\n\n用于标明在序列化时此变量不被序列化，反序列化时会将其赋予默认值。\n\n- 与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效\n- 与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。\n","source":"_posts/java transient.md","raw":"---\ntag: [ssh, port forwarding]\ndate: 2020-12-09 12:12:00\ndescription: java transient\n---\n\n# transient\n\n用于标明在序列化时此变量不被序列化，反序列化时会将其赋予默认值。\n\n- 与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效\n- 与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。\n","slug":"java transient","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p28000zmshbdwo2ecq5","content":"<h1 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h1><p>用于标明在序列化时此变量不被序列化，反序列化时会将其赋予默认值。</p>\n<ul>\n<li>与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效</li>\n<li>与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h1><p>用于标明在序列化时此变量不被序列化，反序列化时会将其赋予默认值。</p>\n<ul>\n<li>与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效</li>\n<li>与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。</li>\n</ul>\n"},{"layout":"post","title":"java-abstractClass&interface","date":"2019-01-22T05:01:00.000Z","_content":"\n# abstract class & interface\n\n> java 中 抽象类与接口\n\n## 两者的异同\n\n同：\n\n1. 都是面向对象中抽象的使用，相对于抽象类，接口是极其抽象的；\n\n异：\n\n1. 抽象类作为一种类，可以有各种成员，具有所有的普通类的特性。而接口只能有 public static final 的属性成员，接口方法都是缺省为 public abstract 修辞。\n2. 抽象类作为一种类用于声明一种对象（其子类的共同属性抽象为父类的方法）较为合适，而接口通常用于声明一种行为。\n3. 一个普通类只能于继承一个抽象类，却可以实现多个接口。\n","source":"_posts/java-abstractclass-interface.md","raw":"---\nlayout: \"post\"\ntitle: \"java-abstractClass&interface\"\ndate: \"2019-01-22 13:01\"\n---\n\n# abstract class & interface\n\n> java 中 抽象类与接口\n\n## 两者的异同\n\n同：\n\n1. 都是面向对象中抽象的使用，相对于抽象类，接口是极其抽象的；\n\n异：\n\n1. 抽象类作为一种类，可以有各种成员，具有所有的普通类的特性。而接口只能有 public static final 的属性成员，接口方法都是缺省为 public abstract 修辞。\n2. 抽象类作为一种类用于声明一种对象（其子类的共同属性抽象为父类的方法）较为合适，而接口通常用于声明一种行为。\n3. 一个普通类只能于继承一个抽象类，却可以实现多个接口。\n","slug":"java-abstractclass-interface","published":1,"updated":"2021-01-12T13:04:51.669Z","comments":1,"photos":[],"link":"","_id":"cklfa4p2a0012mshbaeyuh54w","content":"<h1 id=\"abstract-class-amp-interface\"><a href=\"#abstract-class-amp-interface\" class=\"headerlink\" title=\"abstract class &amp; interface\"></a>abstract class &amp; interface</h1><blockquote>\n<p>java 中 抽象类与接口</p>\n</blockquote>\n<h2 id=\"两者的异同\"><a href=\"#两者的异同\" class=\"headerlink\" title=\"两者的异同\"></a>两者的异同</h2><p>同：</p>\n<ol>\n<li>都是面向对象中抽象的使用，相对于抽象类，接口是极其抽象的；</li>\n</ol>\n<p>异：</p>\n<ol>\n<li>抽象类作为一种类，可以有各种成员，具有所有的普通类的特性。而接口只能有 public static final 的属性成员，接口方法都是缺省为 public abstract 修辞。</li>\n<li>抽象类作为一种类用于声明一种对象（其子类的共同属性抽象为父类的方法）较为合适，而接口通常用于声明一种行为。</li>\n<li>一个普通类只能于继承一个抽象类，却可以实现多个接口。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"abstract-class-amp-interface\"><a href=\"#abstract-class-amp-interface\" class=\"headerlink\" title=\"abstract class &amp; interface\"></a>abstract class &amp; interface</h1><blockquote>\n<p>java 中 抽象类与接口</p>\n</blockquote>\n<h2 id=\"两者的异同\"><a href=\"#两者的异同\" class=\"headerlink\" title=\"两者的异同\"></a>两者的异同</h2><p>同：</p>\n<ol>\n<li>都是面向对象中抽象的使用，相对于抽象类，接口是极其抽象的；</li>\n</ol>\n<p>异：</p>\n<ol>\n<li>抽象类作为一种类，可以有各种成员，具有所有的普通类的特性。而接口只能有 public static final 的属性成员，接口方法都是缺省为 public abstract 修辞。</li>\n<li>抽象类作为一种类用于声明一种对象（其子类的共同属性抽象为父类的方法）较为合适，而接口通常用于声明一种行为。</li>\n<li>一个普通类只能于继承一个抽象类，却可以实现多个接口。</li>\n</ol>\n"},{"layout":"post","date":"2018-10-11T12:11:00.000Z","_content":"\n# BigDecimal\n\n## methods\n\n- 四舍五入\n    - BigDecimal.ROUND_UP 进位，保留后的位数往上增，如果是负数，则相反成为保留为更小的数。\n    - BigDecimal.ROUND_DOWN 下降位，保留后的位数后往下减，如果是负数，则保留为更大的数。\n    - BigDecimal.ROUND_CEILING 进位，保留后的位数往上增，不管是正数还是负数。\n    - BigDecimal.ROUND_FLOOR ，保留后的位数往下减，不管是正数还是负数。\n\n**note**:UP 模式与 CEILING 模式的区别：看英文单词意思，可以看出来， CEILING 只会往大了加，不管是正数还是负数，而 UP 会读取到 数的正负方向，朝着数的方向增加。如：\n\n```java\nnew BigDecimal(4.03).setScale(1, BigDecimal.ROUND_UP)//结果是： 4.1\nnew BigDecimal(-4.03).setScale(1, BigDecimal.ROUND_UP)//结果是： -4.1\n\nnew BigDecimal(4.03).setScale(1, BigDecimal.ROUND_CEILING)//结果是： 4.1\nnew BigDecimal(-4.03).setScale(1, BigDecimal.ROUND_CEILING)// 结果是： -4.0\n```\n\nDOWN 模式 与 FLOOR 模式的区别则同理可得。\n\n- compare\n    - 在使用中，从数据库取出来的  数据 其 stringCache 为四位小数 比如： 0 就会被记为 0.0000 ，这个时候如果使用 BigDecimal.ZERO 与 取出来的数据 `0` 进行 equals 方法比较，返回结果就是 false 。如果要实现值的正常比较，就应该使用 BigDecimal.compare() 方法 根据其返回 int 数据来进行判断比较。\n- _已不推荐使用此种取小数位数方式，推荐使用 `java.math.RoundingMode`_  \n","source":"_posts/java-bigdecimal.md","raw":"---\nlayout: \"post\"\ndate: \"2018-10-11 20:11\"\ntag: \"java, BigDecimal\"\n---\n\n# BigDecimal\n\n## methods\n\n- 四舍五入\n    - BigDecimal.ROUND_UP 进位，保留后的位数往上增，如果是负数，则相反成为保留为更小的数。\n    - BigDecimal.ROUND_DOWN 下降位，保留后的位数后往下减，如果是负数，则保留为更大的数。\n    - BigDecimal.ROUND_CEILING 进位，保留后的位数往上增，不管是正数还是负数。\n    - BigDecimal.ROUND_FLOOR ，保留后的位数往下减，不管是正数还是负数。\n\n**note**:UP 模式与 CEILING 模式的区别：看英文单词意思，可以看出来， CEILING 只会往大了加，不管是正数还是负数，而 UP 会读取到 数的正负方向，朝着数的方向增加。如：\n\n```java\nnew BigDecimal(4.03).setScale(1, BigDecimal.ROUND_UP)//结果是： 4.1\nnew BigDecimal(-4.03).setScale(1, BigDecimal.ROUND_UP)//结果是： -4.1\n\nnew BigDecimal(4.03).setScale(1, BigDecimal.ROUND_CEILING)//结果是： 4.1\nnew BigDecimal(-4.03).setScale(1, BigDecimal.ROUND_CEILING)// 结果是： -4.0\n```\n\nDOWN 模式 与 FLOOR 模式的区别则同理可得。\n\n- compare\n    - 在使用中，从数据库取出来的  数据 其 stringCache 为四位小数 比如： 0 就会被记为 0.0000 ，这个时候如果使用 BigDecimal.ZERO 与 取出来的数据 `0` 进行 equals 方法比较，返回结果就是 false 。如果要实现值的正常比较，就应该使用 BigDecimal.compare() 方法 根据其返回 int 数据来进行判断比较。\n- _已不推荐使用此种取小数位数方式，推荐使用 `java.math.RoundingMode`_  \n","slug":"java-bigdecimal","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"photos":[],"link":"","_id":"cklfa4p2b0013mshbgmqbamjp","content":"<h1 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h1><h2 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h2><ul>\n<li>四舍五入<ul>\n<li>BigDecimal.ROUND_UP 进位，保留后的位数往上增，如果是负数，则相反成为保留为更小的数。</li>\n<li>BigDecimal.ROUND_DOWN 下降位，保留后的位数后往下减，如果是负数，则保留为更大的数。</li>\n<li>BigDecimal.ROUND_CEILING 进位，保留后的位数往上增，不管是正数还是负数。</li>\n<li>BigDecimal.ROUND_FLOOR ，保留后的位数往下减，不管是正数还是负数。</li>\n</ul>\n</li>\n</ul>\n<p><strong>note</strong>:UP 模式与 CEILING 模式的区别：看英文单词意思，可以看出来， CEILING 只会往大了加，不管是正数还是负数，而 UP 会读取到 数的正负方向，朝着数的方向增加。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_UP)<span class=\"comment\">//结果是： 4.1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(-<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_UP)<span class=\"comment\">//结果是： -4.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_CEILING)<span class=\"comment\">//结果是： 4.1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(-<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_CEILING)<span class=\"comment\">// 结果是： -4.0</span></span><br></pre></td></tr></table></figure>\n\n<p>DOWN 模式 与 FLOOR 模式的区别则同理可得。</p>\n<ul>\n<li>compare<ul>\n<li>在使用中，从数据库取出来的  数据 其 stringCache 为四位小数 比如： 0 就会被记为 0.0000 ，这个时候如果使用 BigDecimal.ZERO 与 取出来的数据 <code>0</code> 进行 equals 方法比较，返回结果就是 false 。如果要实现值的正常比较，就应该使用 BigDecimal.compare() 方法 根据其返回 int 数据来进行判断比较。</li>\n</ul>\n</li>\n<li><em>已不推荐使用此种取小数位数方式，推荐使用 <code>java.math.RoundingMode</code></em>  </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h1><h2 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h2><ul>\n<li>四舍五入<ul>\n<li>BigDecimal.ROUND_UP 进位，保留后的位数往上增，如果是负数，则相反成为保留为更小的数。</li>\n<li>BigDecimal.ROUND_DOWN 下降位，保留后的位数后往下减，如果是负数，则保留为更大的数。</li>\n<li>BigDecimal.ROUND_CEILING 进位，保留后的位数往上增，不管是正数还是负数。</li>\n<li>BigDecimal.ROUND_FLOOR ，保留后的位数往下减，不管是正数还是负数。</li>\n</ul>\n</li>\n</ul>\n<p><strong>note</strong>:UP 模式与 CEILING 模式的区别：看英文单词意思，可以看出来， CEILING 只会往大了加，不管是正数还是负数，而 UP 会读取到 数的正负方向，朝着数的方向增加。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_UP)<span class=\"comment\">//结果是： 4.1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(-<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_UP)<span class=\"comment\">//结果是： -4.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_CEILING)<span class=\"comment\">//结果是： 4.1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> BigDecimal(-<span class=\"number\">4.03</span>).setScale(<span class=\"number\">1</span>, BigDecimal.ROUND_CEILING)<span class=\"comment\">// 结果是： -4.0</span></span><br></pre></td></tr></table></figure>\n\n<p>DOWN 模式 与 FLOOR 模式的区别则同理可得。</p>\n<ul>\n<li>compare<ul>\n<li>在使用中，从数据库取出来的  数据 其 stringCache 为四位小数 比如： 0 就会被记为 0.0000 ，这个时候如果使用 BigDecimal.ZERO 与 取出来的数据 <code>0</code> 进行 equals 方法比较，返回结果就是 false 。如果要实现值的正常比较，就应该使用 BigDecimal.compare() 方法 根据其返回 int 数据来进行判断比较。</li>\n</ul>\n</li>\n<li><em>已不推荐使用此种取小数位数方式，推荐使用 <code>java.math.RoundingMode</code></em>  </li>\n</ul>\n"},{"layout":"post","title":"java code rule","date":"2019-01-23T06:22:00.000Z","_content":"\n# java naming rule\n\n> 编程过程中应该遵循的规范\n\n## 命名\n\n> 编程过程中命名规范\n\n### 命名规则\n\n- 匈牙利命名法（目前被抛弃的一种命名规则）：名字最前使用小写简写字母来表示一定的意义，其后接 大驼峰 命名的单词。比如：lAge，表示一个 long 数据类型的年龄；\n- 驼峰命名法：分为大驼峰与小驼峰，最常用的命名法，这儿如果是长句式名字， google 规范：先去 单引号 ，再去 横线，再使用驼峰命名，如果是 iOS 这种词，直接规范成： Ios。\n- 蛇形命名法：c++ 与 java 中的常量使用这种命名法，比如：CONFIG_NAME\n- 串式命名法：前端代码中常用，比如：office-length\n","source":"_posts/java-code-rule.md","raw":"---\nlayout: \"post\"\ntitle: \"java code rule\"\ndate: \"2019-01-23 14:22\"\n---\n\n# java naming rule\n\n> 编程过程中应该遵循的规范\n\n## 命名\n\n> 编程过程中命名规范\n\n### 命名规则\n\n- 匈牙利命名法（目前被抛弃的一种命名规则）：名字最前使用小写简写字母来表示一定的意义，其后接 大驼峰 命名的单词。比如：lAge，表示一个 long 数据类型的年龄；\n- 驼峰命名法：分为大驼峰与小驼峰，最常用的命名法，这儿如果是长句式名字， google 规范：先去 单引号 ，再去 横线，再使用驼峰命名，如果是 iOS 这种词，直接规范成： Ios。\n- 蛇形命名法：c++ 与 java 中的常量使用这种命名法，比如：CONFIG_NAME\n- 串式命名法：前端代码中常用，比如：office-length\n","slug":"java-code-rule","published":1,"updated":"2021-01-12T13:04:51.669Z","comments":1,"photos":[],"link":"","_id":"cklfa4p2c0015mshb21o16vn2","content":"<h1 id=\"java-naming-rule\"><a href=\"#java-naming-rule\" class=\"headerlink\" title=\"java naming rule\"></a>java naming rule</h1><blockquote>\n<p>编程过程中应该遵循的规范</p>\n</blockquote>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><blockquote>\n<p>编程过程中命名规范</p>\n</blockquote>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><ul>\n<li>匈牙利命名法（目前被抛弃的一种命名规则）：名字最前使用小写简写字母来表示一定的意义，其后接 大驼峰 命名的单词。比如：lAge，表示一个 long 数据类型的年龄；</li>\n<li>驼峰命名法：分为大驼峰与小驼峰，最常用的命名法，这儿如果是长句式名字， google 规范：先去 单引号 ，再去 横线，再使用驼峰命名，如果是 iOS 这种词，直接规范成： Ios。</li>\n<li>蛇形命名法：c++ 与 java 中的常量使用这种命名法，比如：CONFIG_NAME</li>\n<li>串式命名法：前端代码中常用，比如：office-length</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-naming-rule\"><a href=\"#java-naming-rule\" class=\"headerlink\" title=\"java naming rule\"></a>java naming rule</h1><blockquote>\n<p>编程过程中应该遵循的规范</p>\n</blockquote>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><blockquote>\n<p>编程过程中命名规范</p>\n</blockquote>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><ul>\n<li>匈牙利命名法（目前被抛弃的一种命名规则）：名字最前使用小写简写字母来表示一定的意义，其后接 大驼峰 命名的单词。比如：lAge，表示一个 long 数据类型的年龄；</li>\n<li>驼峰命名法：分为大驼峰与小驼峰，最常用的命名法，这儿如果是长句式名字， google 规范：先去 单引号 ，再去 横线，再使用驼峰命名，如果是 iOS 这种词，直接规范成： Ios。</li>\n<li>蛇形命名法：c++ 与 java 中的常量使用这种命名法，比如：CONFIG_NAME</li>\n<li>串式命名法：前端代码中常用，比如：office-length</li>\n</ul>\n"},{"date":"2020-10-12T10:52:00.000Z","description":"key words","_content":"\n# java key words\n\n## transient【瞬时】\n\n用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。\n\n## volatile\n\n[reference](http://tutorials.jenkov.com/java-concurrency/volatile.html)\n\n- volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。\n\n### volatile 可见性保证原则\n\n可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：\n\n- 对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。\n- 线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。\n\n### 指令重排\n\nJVM 与 CPU 为提升性能而允许指令重排。*使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？*\n\n指令重排带来的问题就是打乱了 volatile 可见性原则。\n\n### volatile happen-before 原则\n\n为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。\n\n\n","source":"_posts/java-keywords.md","raw":"---\ndate: 2020-10-12 18:52:00\ncategories: programming\ntags: [programming,java, HashMap]\ndescription: key words\n---\n\n# java key words\n\n## transient【瞬时】\n\n用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。\n\n## volatile\n\n[reference](http://tutorials.jenkov.com/java-concurrency/volatile.html)\n\n- volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。\n\n### volatile 可见性保证原则\n\n可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：\n\n- 对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。\n- 线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。\n\n### 指令重排\n\nJVM 与 CPU 为提升性能而允许指令重排。*使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？*\n\n指令重排带来的问题就是打乱了 volatile 可见性原则。\n\n### volatile happen-before 原则\n\n为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。\n\n\n","slug":"java-keywords","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cklfa4p2f0019mshbeqq9fc33","content":"<h1 id=\"java-key-words\"><a href=\"#java-key-words\" class=\"headerlink\" title=\"java key words\"></a>java key words</h1><h2 id=\"transient【瞬时】\"><a href=\"#transient【瞬时】\" class=\"headerlink\" title=\"transient【瞬时】\"></a>transient【瞬时】</h2><p>用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。</p>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p><a href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\">reference</a></p>\n<ul>\n<li>volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。</li>\n</ul>\n<h3 id=\"volatile-可见性保证原则\"><a href=\"#volatile-可见性保证原则\" class=\"headerlink\" title=\"volatile 可见性保证原则\"></a>volatile 可见性保证原则</h3><p>可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：</p>\n<ul>\n<li>对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。</li>\n<li>线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。</li>\n</ul>\n<h3 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h3><p>JVM 与 CPU 为提升性能而允许指令重排。<em>使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？</em></p>\n<p>指令重排带来的问题就是打乱了 volatile 可见性原则。</p>\n<h3 id=\"volatile-happen-before-原则\"><a href=\"#volatile-happen-before-原则\" class=\"headerlink\" title=\"volatile happen-before 原则\"></a>volatile happen-before 原则</h3><p>为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-key-words\"><a href=\"#java-key-words\" class=\"headerlink\" title=\"java key words\"></a>java key words</h1><h2 id=\"transient【瞬时】\"><a href=\"#transient【瞬时】\" class=\"headerlink\" title=\"transient【瞬时】\"></a>transient【瞬时】</h2><p>用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。</p>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p><a href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\">reference</a></p>\n<ul>\n<li>volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。</li>\n</ul>\n<h3 id=\"volatile-可见性保证原则\"><a href=\"#volatile-可见性保证原则\" class=\"headerlink\" title=\"volatile 可见性保证原则\"></a>volatile 可见性保证原则</h3><p>可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：</p>\n<ul>\n<li>对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。</li>\n<li>线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。</li>\n</ul>\n<h3 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h3><p>JVM 与 CPU 为提升性能而允许指令重排。<em>使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？</em></p>\n<p>指令重排带来的问题就是打乱了 volatile 可见性原则。</p>\n<h3 id=\"volatile-happen-before-原则\"><a href=\"#volatile-happen-before-原则\" class=\"headerlink\" title=\"volatile happen-before 原则\"></a>volatile happen-before 原则</h3><p>为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。</p>\n"},{"layout":"post","title":"java-try-catch-finally","date":"2019-01-22T04:45:00.000Z","_content":"\n# java try\n\n> 在 java 程序中，try catch finally 的使用执行顺序：\n\n1. 只要有 finally 是不是其中的代码就一定会执行？\n   1. 不一定，当在 try 的代码块中存在着让程序停止的代码，那么就不会执行到 finally 中去。比如： `System.exit();`\n2. 当 try 代码块进行了 return 后，在 finally 中再进行 return 一个新的值，将会以 finally 中的值为最终值。\n3. 当 try 块中进行了运算一个值，再在 finally 中去进行运算并返回，最终值通常理解为是两次运算都进行的结果，但如果这个值是一个基本类型的数据，结果是在 try 中进行的运算可能无效的。\n   1. 原因：如果这个值是一个基本类型时，如果 **没有将这个值进行 return** ，那么运算结果并没有被赋予到之前方法的形参栈帧上去，而这个时候直接到 finally 代码块中进行运算，就直接取到原方法未被赋结果值的参数，这个时候就会出现 try 代码块不被执行的结果。\n","source":"_posts/java-try-catch-finally.md","raw":"---\nlayout: \"post\"\ntitle: \"java-try-catch-finally\"\ndate: \"2019-01-22 12:45\"\n---\n\n# java try\n\n> 在 java 程序中，try catch finally 的使用执行顺序：\n\n1. 只要有 finally 是不是其中的代码就一定会执行？\n   1. 不一定，当在 try 的代码块中存在着让程序停止的代码，那么就不会执行到 finally 中去。比如： `System.exit();`\n2. 当 try 代码块进行了 return 后，在 finally 中再进行 return 一个新的值，将会以 finally 中的值为最终值。\n3. 当 try 块中进行了运算一个值，再在 finally 中去进行运算并返回，最终值通常理解为是两次运算都进行的结果，但如果这个值是一个基本类型的数据，结果是在 try 中进行的运算可能无效的。\n   1. 原因：如果这个值是一个基本类型时，如果 **没有将这个值进行 return** ，那么运算结果并没有被赋予到之前方法的形参栈帧上去，而这个时候直接到 finally 代码块中进行运算，就直接取到原方法未被赋结果值的参数，这个时候就会出现 try 代码块不被执行的结果。\n","slug":"java-try-catch-finally","published":1,"updated":"2021-01-12T13:04:51.669Z","comments":1,"photos":[],"link":"","_id":"cklfa4p2g001cmshbgbc5f4eo","content":"<h1 id=\"java-try\"><a href=\"#java-try\" class=\"headerlink\" title=\"java try\"></a>java try</h1><blockquote>\n<p>在 java 程序中，try catch finally 的使用执行顺序：</p>\n</blockquote>\n<ol>\n<li>只要有 finally 是不是其中的代码就一定会执行？<ol>\n<li>不一定，当在 try 的代码块中存在着让程序停止的代码，那么就不会执行到 finally 中去。比如： <code>System.exit();</code></li>\n</ol>\n</li>\n<li>当 try 代码块进行了 return 后，在 finally 中再进行 return 一个新的值，将会以 finally 中的值为最终值。</li>\n<li>当 try 块中进行了运算一个值，再在 finally 中去进行运算并返回，最终值通常理解为是两次运算都进行的结果，但如果这个值是一个基本类型的数据，结果是在 try 中进行的运算可能无效的。<ol>\n<li>原因：如果这个值是一个基本类型时，如果 <strong>没有将这个值进行 return</strong> ，那么运算结果并没有被赋予到之前方法的形参栈帧上去，而这个时候直接到 finally 代码块中进行运算，就直接取到原方法未被赋结果值的参数，这个时候就会出现 try 代码块不被执行的结果。</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-try\"><a href=\"#java-try\" class=\"headerlink\" title=\"java try\"></a>java try</h1><blockquote>\n<p>在 java 程序中，try catch finally 的使用执行顺序：</p>\n</blockquote>\n<ol>\n<li>只要有 finally 是不是其中的代码就一定会执行？<ol>\n<li>不一定，当在 try 的代码块中存在着让程序停止的代码，那么就不会执行到 finally 中去。比如： <code>System.exit();</code></li>\n</ol>\n</li>\n<li>当 try 代码块进行了 return 后，在 finally 中再进行 return 一个新的值，将会以 finally 中的值为最终值。</li>\n<li>当 try 块中进行了运算一个值，再在 finally 中去进行运算并返回，最终值通常理解为是两次运算都进行的结果，但如果这个值是一个基本类型的数据，结果是在 try 中进行的运算可能无效的。<ol>\n<li>原因：如果这个值是一个基本类型时，如果 <strong>没有将这个值进行 return</strong> ，那么运算结果并没有被赋予到之前方法的形参栈帧上去，而这个时候直接到 finally 代码块中进行运算，就直接取到原方法未被赋结果值的参数，这个时候就会出现 try 代码块不被执行的结果。</li>\n</ol>\n</li>\n</ol>\n"},{"layout":"post","title":"java - Type","date":"2019-01-29T10:46:00.000Z","_content":"\n# 1. java Type\n\n<!-- TOC -->autoauto1. [1. java Type](#1-java-type)auto    1. [1.1. java generic](#11-java-generic)auto        1. [1.1.1. 范型通配符](#111-范型通配符)auto            1. [1.1.1.1. PECS 原则](#1111-pecs-原则)autoauto<!-- /TOC -->\n\n> java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc\n\n[参考](https://blog.csdn.net/u011983531/article/details/80295479)\n\n## 1.1. java generic\n\njava 范型 [reference](https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n\n- 静态方法要实现范型，要在返回结果前加上范型标识 `<T, R> void generic()`\n- 使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：`builder.<String, Integer>build()`。否则，编译器只会当范型类型为 Object。\n- 范型构造器的使用与无参范型构造的实现：通过上一条即可实现。\n\n### 1.1.1. 范型通配符\n\n- 范型中 `super` 与 `extends` 的区别使用、非常规意义\n    - `? super` 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。\n        - 原因：当外部容器被 `? super` 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。\n    - `extends` 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 `? extends` 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。\n\n#### 1.1.1.1. PECS 原则\n\n[reference](https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super)\n\n在范型中使用通配符时，遵守 PECS 原则：\n\n- 一个容器如果只读取类型 T 的数据， 不写入，使用 `? extends T` 通配：Producer Extends。_之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费_\n- 容器如果只写入类型 T 数据，不用读取，使用 `? super T` 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。_同理，此时容器是一个消费数据的 consumer_\n    - 所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配\n- 如果即要读取又要写入，就不使用通配符\n\n---\n\n- Arrays.asList(T ...) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。\n","source":"_posts/java-type.md","raw":"---\nlayout: \"post\"\ntitle: \"java - Type\"\ndate: \"2019-01-29 18:46\"\ntags: [generic,java]\n---\n\n# 1. java Type\n\n<!-- TOC -->autoauto1. [1. java Type](#1-java-type)auto    1. [1.1. java generic](#11-java-generic)auto        1. [1.1.1. 范型通配符](#111-范型通配符)auto            1. [1.1.1.1. PECS 原则](#1111-pecs-原则)autoauto<!-- /TOC -->\n\n> java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc\n\n[参考](https://blog.csdn.net/u011983531/article/details/80295479)\n\n## 1.1. java generic\n\njava 范型 [reference](https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n\n- 静态方法要实现范型，要在返回结果前加上范型标识 `<T, R> void generic()`\n- 使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：`builder.<String, Integer>build()`。否则，编译器只会当范型类型为 Object。\n- 范型构造器的使用与无参范型构造的实现：通过上一条即可实现。\n\n### 1.1.1. 范型通配符\n\n- 范型中 `super` 与 `extends` 的区别使用、非常规意义\n    - `? super` 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。\n        - 原因：当外部容器被 `? super` 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。\n    - `extends` 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 `? extends` 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。\n\n#### 1.1.1.1. PECS 原则\n\n[reference](https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super)\n\n在范型中使用通配符时，遵守 PECS 原则：\n\n- 一个容器如果只读取类型 T 的数据， 不写入，使用 `? extends T` 通配：Producer Extends。_之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费_\n- 容器如果只写入类型 T 数据，不用读取，使用 `? super T` 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。_同理，此时容器是一个消费数据的 consumer_\n    - 所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配\n- 如果即要读取又要写入，就不使用通配符\n\n---\n\n- Arrays.asList(T ...) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。\n","slug":"java-type","published":1,"updated":"2021-01-12T13:04:51.669Z","comments":1,"photos":[],"link":"","_id":"cklfa4p2i001fmshbbnvfdzj7","content":"<h1 id=\"1-java-Type\"><a href=\"#1-java-Type\" class=\"headerlink\" title=\"1. java Type\"></a>1. java Type</h1><!-- TOC -->autoauto1. [1. java Type](#1-java-type)auto    1. [1.1. java generic](#11-java-generic)auto        1. [1.1.1. 范型通配符](#111-范型通配符)auto            1. [1.1.1.1. PECS 原则](#1111-pecs-原则)autoauto<!-- /TOC -->\n\n<blockquote>\n<p>java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/u011983531/article/details/80295479\">参考</a></p>\n<h2 id=\"1-1-java-generic\"><a href=\"#1-1-java-generic\" class=\"headerlink\" title=\"1.1. java generic\"></a>1.1. java generic</h2><p>java 范型 <a href=\"https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\">reference</a></p>\n<ul>\n<li>静态方法要实现范型，要在返回结果前加上范型标识 <code>&lt;T, R&gt; void generic()</code></li>\n<li>使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：<code>builder.&lt;String, Integer&gt;build()</code>。否则，编译器只会当范型类型为 Object。</li>\n<li>范型构造器的使用与无参范型构造的实现：通过上一条即可实现。</li>\n</ul>\n<h3 id=\"1-1-1-范型通配符\"><a href=\"#1-1-1-范型通配符\" class=\"headerlink\" title=\"1.1.1. 范型通配符\"></a>1.1.1. 范型通配符</h3><ul>\n<li>范型中 <code>super</code> 与 <code>extends</code> 的区别使用、非常规意义<ul>\n<li><code>? super</code> 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。<ul>\n<li>原因：当外部容器被 <code>? super</code> 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。</li>\n</ul>\n</li>\n<li><code>extends</code> 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 <code>? extends</code> 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-1-1-PECS-原则\"><a href=\"#1-1-1-1-PECS-原则\" class=\"headerlink\" title=\"1.1.1.1. PECS 原则\"></a>1.1.1.1. PECS 原则</h4><p><a href=\"https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super\">reference</a></p>\n<p>在范型中使用通配符时，遵守 PECS 原则：</p>\n<ul>\n<li>一个容器如果只读取类型 T 的数据， 不写入，使用 <code>? extends T</code> 通配：Producer Extends。<em>之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费</em></li>\n<li>容器如果只写入类型 T 数据，不用读取，使用 <code>? super T</code> 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。<em>同理，此时容器是一个消费数据的 consumer</em><ul>\n<li>所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配</li>\n</ul>\n</li>\n<li>如果即要读取又要写入，就不使用通配符</li>\n</ul>\n<hr>\n<ul>\n<li>Arrays.asList(T …) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-java-Type\"><a href=\"#1-java-Type\" class=\"headerlink\" title=\"1. java Type\"></a>1. java Type</h1><!-- TOC -->autoauto1. [1. java Type](#1-java-type)auto    1. [1.1. java generic](#11-java-generic)auto        1. [1.1.1. 范型通配符](#111-范型通配符)auto            1. [1.1.1.1. PECS 原则](#1111-pecs-原则)autoauto<!-- /TOC -->\n\n<blockquote>\n<p>java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/u011983531/article/details/80295479\">参考</a></p>\n<h2 id=\"1-1-java-generic\"><a href=\"#1-1-java-generic\" class=\"headerlink\" title=\"1.1. java generic\"></a>1.1. java generic</h2><p>java 范型 <a href=\"https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\">reference</a></p>\n<ul>\n<li>静态方法要实现范型，要在返回结果前加上范型标识 <code>&lt;T, R&gt; void generic()</code></li>\n<li>使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：<code>builder.&lt;String, Integer&gt;build()</code>。否则，编译器只会当范型类型为 Object。</li>\n<li>范型构造器的使用与无参范型构造的实现：通过上一条即可实现。</li>\n</ul>\n<h3 id=\"1-1-1-范型通配符\"><a href=\"#1-1-1-范型通配符\" class=\"headerlink\" title=\"1.1.1. 范型通配符\"></a>1.1.1. 范型通配符</h3><ul>\n<li>范型中 <code>super</code> 与 <code>extends</code> 的区别使用、非常规意义<ul>\n<li><code>? super</code> 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。<ul>\n<li>原因：当外部容器被 <code>? super</code> 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。</li>\n</ul>\n</li>\n<li><code>extends</code> 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 <code>? extends</code> 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-1-1-PECS-原则\"><a href=\"#1-1-1-1-PECS-原则\" class=\"headerlink\" title=\"1.1.1.1. PECS 原则\"></a>1.1.1.1. PECS 原则</h4><p><a href=\"https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super\">reference</a></p>\n<p>在范型中使用通配符时，遵守 PECS 原则：</p>\n<ul>\n<li>一个容器如果只读取类型 T 的数据， 不写入，使用 <code>? extends T</code> 通配：Producer Extends。<em>之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费</em></li>\n<li>容器如果只写入类型 T 数据，不用读取，使用 <code>? super T</code> 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。<em>同理，此时容器是一个消费数据的 consumer</em><ul>\n<li>所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配</li>\n</ul>\n</li>\n<li>如果即要读取又要写入，就不使用通配符</li>\n</ul>\n<hr>\n<ul>\n<li>Arrays.asList(T …) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。</li>\n</ul>\n"},{"layout":"post","date":"2020-11-03T14:32:00.000Z","_content":"# java overview\n\n关于 java 的概述。[官方文档](https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html)\n\n## java platform\n\n- java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。\n- java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。\n- java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。\n- javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。\n\n## shadowing\n\n[tutorial](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing)\n\n定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 `this.x` 调用对象的变量，而在内部类中可以使用 `Outer.this.x` 调用。\n\n## java IO\n\n### Data Streams\n\n使用 Data Streams 可以讲IO 基本类型数据与 String。\n\n### Object Streams\n\n[reference](https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html)\n\n- 使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。\n- Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。\n- 将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。\n","source":"_posts/java.md","raw":"---\nlayout: \"post\"\ndate: \"2020-11-03 22:32:00\"\ntags: [shadowing, java, IO]\n---\n# java overview\n\n关于 java 的概述。[官方文档](https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html)\n\n## java platform\n\n- java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。\n- java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。\n- java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。\n- javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。\n\n## shadowing\n\n[tutorial](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing)\n\n定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 `this.x` 调用对象的变量，而在内部类中可以使用 `Outer.this.x` 调用。\n\n## java IO\n\n### Data Streams\n\n使用 Data Streams 可以讲IO 基本类型数据与 String。\n\n### Object Streams\n\n[reference](https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html)\n\n- 使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。\n- Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。\n- 将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。\n","slug":"java","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"photos":[],"link":"","_id":"cklfa4p2j001gmshb4mo9cckv","content":"<h1 id=\"java-overview\"><a href=\"#java-overview\" class=\"headerlink\" title=\"java overview\"></a>java overview</h1><p>关于 java 的概述。<a href=\"https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html\">官方文档</a></p>\n<h2 id=\"java-platform\"><a href=\"#java-platform\" class=\"headerlink\" title=\"java platform\"></a>java platform</h2><ul>\n<li>java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。</li>\n<li>java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。</li>\n<li>java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。</li>\n<li>javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。</li>\n</ul>\n<h2 id=\"shadowing\"><a href=\"#shadowing\" class=\"headerlink\" title=\"shadowing\"></a>shadowing</h2><p><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing\">tutorial</a></p>\n<p>定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 <code>this.x</code> 调用对象的变量，而在内部类中可以使用 <code>Outer.this.x</code> 调用。</p>\n<h2 id=\"java-IO\"><a href=\"#java-IO\" class=\"headerlink\" title=\"java IO\"></a>java IO</h2><h3 id=\"Data-Streams\"><a href=\"#Data-Streams\" class=\"headerlink\" title=\"Data Streams\"></a>Data Streams</h3><p>使用 Data Streams 可以讲IO 基本类型数据与 String。</p>\n<h3 id=\"Object-Streams\"><a href=\"#Object-Streams\" class=\"headerlink\" title=\"Object Streams\"></a>Object Streams</h3><p><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html\">reference</a></p>\n<ul>\n<li>使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。</li>\n<li>Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。</li>\n<li>将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-overview\"><a href=\"#java-overview\" class=\"headerlink\" title=\"java overview\"></a>java overview</h1><p>关于 java 的概述。<a href=\"https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html\">官方文档</a></p>\n<h2 id=\"java-platform\"><a href=\"#java-platform\" class=\"headerlink\" title=\"java platform\"></a>java platform</h2><ul>\n<li>java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。</li>\n<li>java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。</li>\n<li>java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。</li>\n<li>javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。</li>\n</ul>\n<h2 id=\"shadowing\"><a href=\"#shadowing\" class=\"headerlink\" title=\"shadowing\"></a>shadowing</h2><p><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing\">tutorial</a></p>\n<p>定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 <code>this.x</code> 调用对象的变量，而在内部类中可以使用 <code>Outer.this.x</code> 调用。</p>\n<h2 id=\"java-IO\"><a href=\"#java-IO\" class=\"headerlink\" title=\"java IO\"></a>java IO</h2><h3 id=\"Data-Streams\"><a href=\"#Data-Streams\" class=\"headerlink\" title=\"Data Streams\"></a>Data Streams</h3><p>使用 Data Streams 可以讲IO 基本类型数据与 String。</p>\n<h3 id=\"Object-Streams\"><a href=\"#Object-Streams\" class=\"headerlink\" title=\"Object Streams\"></a>Object Streams</h3><p><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html\">reference</a></p>\n<ul>\n<li>使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。</li>\n<li>Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。</li>\n<li>将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。</li>\n</ul>\n"},{"layout":"post","date":"2018-09-26T10:50:00.000Z","_content":"\n# 1. java8 new features\n<!-- TOC -->\n\n- [1. java8 new features](#1-java8-new-features)\n  - [1.1. stream](#11-stream)\n  - [1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用](#12-对-stream-进行以下操作会将流关闭而不能再进行利用)\n  - [1.3. method](#13-method)\n    - [1.3.1. peek(Consumer())](#131-peekconsumer)\n  - [1.4. java8 time](#14-java8-time)\n    - [1.4.1. java8 中的各个新增的类](#141-java8-中的各个新增的类)\n\n<!-- /TOC -->\n\n## 1.1. stream\n\n> 列表进行 stream() 方法生成列表相应的流对象。对列表进行操作而不影响列表本身，很方便的一个对列表进行统计、过滤的特性。\n\n## 1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用\n\n- collect(Collector<T, T>) 常常将流进行操作后返回为 List<T> 进行再利用。这个时候就将关闭了，不能进行下一步流操作。\n- count() 此方法是统计流中数据数量，这个方法也会将流关闭。\n\n>> 如果在使用 流 的过程中，需要对流进行反复操作而又不得不使用用将其关闭的方法时，我们可以多次使用原列表生成流，这样可以多次操作。\n\n## 1.3. method\n\n> 流对于列表进行操作有诸多函数式接口参数方法，可以对列表进行过滤、筛选、求最值。\n\n### 1.3.1. peek(Consumer())\n\n> 这个方法需要使用将对 流 中的元素进行依次的消费。但如果要表现出来，需要在其后跟上 collect() 方法。\n\n## 1.4. java8 time\n\njava 8 time 包提供了更耐用的日历系统。\n\n- chronology 年代表\n- ISO： International Standardization Organization :国际标准化组织\n    - IsoChronology 国际标准年代\n\n### 1.4.1. java8 中的各个新增的类\n\n- Instant 瞬时，用以表示从 1970-01-01T00:00:00S 点开始计算的时间线中的某一个瞬间。两个属性\n    - seconds 秒，即从 1970 年开始计时到此对象代表的时刻经过的秒数\n    - nanos 纳秒，相应的纳秒数\n- ZoneId 时区 id，代表各个不同的时区\n    - 常用于 Instant 与 LocalDateTime 之间的转换；\n    - 有两种类型的 ZoneId:\n        - 固定偏移量：从标准时间 UTC(universal time coordinated)/Greenwich 完全解析偏移量而来\n        - 地理区域：根据地理位置定义的整个时区，其与 UTC/Greenwich 标准时间偏移量是整小时\n","source":"_posts/java8-features.md","raw":"---\nlayout: \"post\"\ntag: [java8]\ndate: \"2018-09-26 18:50\"\n---\n\n# 1. java8 new features\n<!-- TOC -->\n\n- [1. java8 new features](#1-java8-new-features)\n  - [1.1. stream](#11-stream)\n  - [1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用](#12-对-stream-进行以下操作会将流关闭而不能再进行利用)\n  - [1.3. method](#13-method)\n    - [1.3.1. peek(Consumer())](#131-peekconsumer)\n  - [1.4. java8 time](#14-java8-time)\n    - [1.4.1. java8 中的各个新增的类](#141-java8-中的各个新增的类)\n\n<!-- /TOC -->\n\n## 1.1. stream\n\n> 列表进行 stream() 方法生成列表相应的流对象。对列表进行操作而不影响列表本身，很方便的一个对列表进行统计、过滤的特性。\n\n## 1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用\n\n- collect(Collector<T, T>) 常常将流进行操作后返回为 List<T> 进行再利用。这个时候就将关闭了，不能进行下一步流操作。\n- count() 此方法是统计流中数据数量，这个方法也会将流关闭。\n\n>> 如果在使用 流 的过程中，需要对流进行反复操作而又不得不使用用将其关闭的方法时，我们可以多次使用原列表生成流，这样可以多次操作。\n\n## 1.3. method\n\n> 流对于列表进行操作有诸多函数式接口参数方法，可以对列表进行过滤、筛选、求最值。\n\n### 1.3.1. peek(Consumer())\n\n> 这个方法需要使用将对 流 中的元素进行依次的消费。但如果要表现出来，需要在其后跟上 collect() 方法。\n\n## 1.4. java8 time\n\njava 8 time 包提供了更耐用的日历系统。\n\n- chronology 年代表\n- ISO： International Standardization Organization :国际标准化组织\n    - IsoChronology 国际标准年代\n\n### 1.4.1. java8 中的各个新增的类\n\n- Instant 瞬时，用以表示从 1970-01-01T00:00:00S 点开始计算的时间线中的某一个瞬间。两个属性\n    - seconds 秒，即从 1970 年开始计时到此对象代表的时刻经过的秒数\n    - nanos 纳秒，相应的纳秒数\n- ZoneId 时区 id，代表各个不同的时区\n    - 常用于 Instant 与 LocalDateTime 之间的转换；\n    - 有两种类型的 ZoneId:\n        - 固定偏移量：从标准时间 UTC(universal time coordinated)/Greenwich 完全解析偏移量而来\n        - 地理区域：根据地理位置定义的整个时区，其与 UTC/Greenwich 标准时间偏移量是整小时\n","slug":"java8-features","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"photos":[],"link":"","_id":"cklfa4p2l001kmshb8wf1e36u","content":"<h1 id=\"1-java8-new-features\"><a href=\"#1-java8-new-features\" class=\"headerlink\" title=\"1. java8 new features\"></a>1. java8 new features</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#1-java8-new-features\">1. java8 new features</a><ul>\n<li><a href=\"#11-stream\">1.1. stream</a></li>\n<li><a href=\"#12-%E5%AF%B9-stream-%E8%BF%9B%E8%A1%8C%E4%BB%A5%E4%B8%8B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%B0%86%E6%B5%81%E5%85%B3%E9%97%AD%E8%80%8C%E4%B8%8D%E8%83%BD%E5%86%8D%E8%BF%9B%E8%A1%8C%E5%88%A9%E7%94%A8\">1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用</a></li>\n<li><a href=\"#13-method\">1.3. method</a><ul>\n<li><a href=\"#131-peekconsumer\">1.3.1. peek(Consumer())</a></li>\n</ul>\n</li>\n<li><a href=\"#14-java8-time\">1.4. java8 time</a><ul>\n<li><a href=\"#141-java8-%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%E6%96%B0%E5%A2%9E%E7%9A%84%E7%B1%BB\">1.4.1. java8 中的各个新增的类</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"1-1-stream\"><a href=\"#1-1-stream\" class=\"headerlink\" title=\"1.1. stream\"></a>1.1. stream</h2><blockquote>\n<p>列表进行 stream() 方法生成列表相应的流对象。对列表进行操作而不影响列表本身，很方便的一个对列表进行统计、过滤的特性。</p>\n</blockquote>\n<h2 id=\"1-2-对-stream-进行以下操作会将流关闭而不能再进行利用\"><a href=\"#1-2-对-stream-进行以下操作会将流关闭而不能再进行利用\" class=\"headerlink\" title=\"1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用\"></a>1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用</h2><ul>\n<li>collect(Collector&lt;T, T&gt;) 常常将流进行操作后返回为 List<T> 进行再利用。这个时候就将关闭了，不能进行下一步流操作。</li>\n<li>count() 此方法是统计流中数据数量，这个方法也会将流关闭。</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>如果在使用 流 的过程中，需要对流进行反复操作而又不得不使用用将其关闭的方法时，我们可以多次使用原列表生成流，这样可以多次操作。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"1-3-method\"><a href=\"#1-3-method\" class=\"headerlink\" title=\"1.3. method\"></a>1.3. method</h2><blockquote>\n<p>流对于列表进行操作有诸多函数式接口参数方法，可以对列表进行过滤、筛选、求最值。</p>\n</blockquote>\n<h3 id=\"1-3-1-peek-Consumer\"><a href=\"#1-3-1-peek-Consumer\" class=\"headerlink\" title=\"1.3.1. peek(Consumer())\"></a>1.3.1. peek(Consumer())</h3><blockquote>\n<p>这个方法需要使用将对 流 中的元素进行依次的消费。但如果要表现出来，需要在其后跟上 collect() 方法。</p>\n</blockquote>\n<h2 id=\"1-4-java8-time\"><a href=\"#1-4-java8-time\" class=\"headerlink\" title=\"1.4. java8 time\"></a>1.4. java8 time</h2><p>java 8 time 包提供了更耐用的日历系统。</p>\n<ul>\n<li>chronology 年代表</li>\n<li>ISO： International Standardization Organization :国际标准化组织<ul>\n<li>IsoChronology 国际标准年代</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-4-1-java8-中的各个新增的类\"><a href=\"#1-4-1-java8-中的各个新增的类\" class=\"headerlink\" title=\"1.4.1. java8 中的各个新增的类\"></a>1.4.1. java8 中的各个新增的类</h3><ul>\n<li>Instant 瞬时，用以表示从 1970-01-01T00:00:00S 点开始计算的时间线中的某一个瞬间。两个属性<ul>\n<li>seconds 秒，即从 1970 年开始计时到此对象代表的时刻经过的秒数</li>\n<li>nanos 纳秒，相应的纳秒数</li>\n</ul>\n</li>\n<li>ZoneId 时区 id，代表各个不同的时区<ul>\n<li>常用于 Instant 与 LocalDateTime 之间的转换；</li>\n<li>有两种类型的 ZoneId:<ul>\n<li>固定偏移量：从标准时间 UTC(universal time coordinated)/Greenwich 完全解析偏移量而来</li>\n<li>地理区域：根据地理位置定义的整个时区，其与 UTC/Greenwich 标准时间偏移量是整小时</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-java8-new-features\"><a href=\"#1-java8-new-features\" class=\"headerlink\" title=\"1. java8 new features\"></a>1. java8 new features</h1><!-- TOC -->\n\n<ul>\n<li><a href=\"#1-java8-new-features\">1. java8 new features</a><ul>\n<li><a href=\"#11-stream\">1.1. stream</a></li>\n<li><a href=\"#12-%E5%AF%B9-stream-%E8%BF%9B%E8%A1%8C%E4%BB%A5%E4%B8%8B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%B0%86%E6%B5%81%E5%85%B3%E9%97%AD%E8%80%8C%E4%B8%8D%E8%83%BD%E5%86%8D%E8%BF%9B%E8%A1%8C%E5%88%A9%E7%94%A8\">1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用</a></li>\n<li><a href=\"#13-method\">1.3. method</a><ul>\n<li><a href=\"#131-peekconsumer\">1.3.1. peek(Consumer())</a></li>\n</ul>\n</li>\n<li><a href=\"#14-java8-time\">1.4. java8 time</a><ul>\n<li><a href=\"#141-java8-%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%E6%96%B0%E5%A2%9E%E7%9A%84%E7%B1%BB\">1.4.1. java8 中的各个新增的类</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n\n<h2 id=\"1-1-stream\"><a href=\"#1-1-stream\" class=\"headerlink\" title=\"1.1. stream\"></a>1.1. stream</h2><blockquote>\n<p>列表进行 stream() 方法生成列表相应的流对象。对列表进行操作而不影响列表本身，很方便的一个对列表进行统计、过滤的特性。</p>\n</blockquote>\n<h2 id=\"1-2-对-stream-进行以下操作会将流关闭而不能再进行利用\"><a href=\"#1-2-对-stream-进行以下操作会将流关闭而不能再进行利用\" class=\"headerlink\" title=\"1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用\"></a>1.2. 对 stream 进行以下操作会将流关闭而不能再进行利用</h2><ul>\n<li>collect(Collector&lt;T, T&gt;) 常常将流进行操作后返回为 List<T> 进行再利用。这个时候就将关闭了，不能进行下一步流操作。</li>\n<li>count() 此方法是统计流中数据数量，这个方法也会将流关闭。</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>如果在使用 流 的过程中，需要对流进行反复操作而又不得不使用用将其关闭的方法时，我们可以多次使用原列表生成流，这样可以多次操作。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"1-3-method\"><a href=\"#1-3-method\" class=\"headerlink\" title=\"1.3. method\"></a>1.3. method</h2><blockquote>\n<p>流对于列表进行操作有诸多函数式接口参数方法，可以对列表进行过滤、筛选、求最值。</p>\n</blockquote>\n<h3 id=\"1-3-1-peek-Consumer\"><a href=\"#1-3-1-peek-Consumer\" class=\"headerlink\" title=\"1.3.1. peek(Consumer())\"></a>1.3.1. peek(Consumer())</h3><blockquote>\n<p>这个方法需要使用将对 流 中的元素进行依次的消费。但如果要表现出来，需要在其后跟上 collect() 方法。</p>\n</blockquote>\n<h2 id=\"1-4-java8-time\"><a href=\"#1-4-java8-time\" class=\"headerlink\" title=\"1.4. java8 time\"></a>1.4. java8 time</h2><p>java 8 time 包提供了更耐用的日历系统。</p>\n<ul>\n<li>chronology 年代表</li>\n<li>ISO： International Standardization Organization :国际标准化组织<ul>\n<li>IsoChronology 国际标准年代</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-4-1-java8-中的各个新增的类\"><a href=\"#1-4-1-java8-中的各个新增的类\" class=\"headerlink\" title=\"1.4.1. java8 中的各个新增的类\"></a>1.4.1. java8 中的各个新增的类</h3><ul>\n<li>Instant 瞬时，用以表示从 1970-01-01T00:00:00S 点开始计算的时间线中的某一个瞬间。两个属性<ul>\n<li>seconds 秒，即从 1970 年开始计时到此对象代表的时刻经过的秒数</li>\n<li>nanos 纳秒，相应的纳秒数</li>\n</ul>\n</li>\n<li>ZoneId 时区 id，代表各个不同的时区<ul>\n<li>常用于 Instant 与 LocalDateTime 之间的转换；</li>\n<li>有两种类型的 ZoneId:<ul>\n<li>固定偏移量：从标准时间 UTC(universal time coordinated)/Greenwich 完全解析偏移量而来</li>\n<li>地理区域：根据地理位置定义的整个时区，其与 UTC/Greenwich 标准时间偏移量是整小时</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","description":"super in param&extends in result","date":"2018-09-28T07:52:00.000Z","_content":"\n# <? extends R> method(<? super T>) 通配符在定义方法的参数与返回结果时的原理\n\n- extends 规定了上界；用作返回结果限定；\n- super 规定了下界；用作参数限定\n","source":"_posts/super-in-param-extends-in-result.md","raw":"---\nlayout: \"post\"\ndescription: \"super in param&extends in result\"\ndate: \"2018-09-28 15:52\"\n---\n\n# <? extends R> method(<? super T>) 通配符在定义方法的参数与返回结果时的原理\n\n- extends 规定了上界；用作返回结果限定；\n- super 规定了下界；用作参数限定\n","slug":"super-in-param-extends-in-result","published":1,"updated":"2021-01-12T13:04:51.669Z","title":"","comments":1,"photos":[],"link":"","_id":"cklfa4p2m001mmshb87da3bky","content":"<h1 id=\"lt-extends-R-gt-method-lt-super-T-gt-通配符在定义方法的参数与返回结果时的原理\"><a href=\"#lt-extends-R-gt-method-lt-super-T-gt-通配符在定义方法的参数与返回结果时的原理\" class=\"headerlink\" title=\"&lt;? extends R&gt; method(&lt;? super T&gt;) 通配符在定义方法的参数与返回结果时的原理\"></a>&lt;? extends R&gt; method(&lt;? super T&gt;) 通配符在定义方法的参数与返回结果时的原理</h1><ul>\n<li>extends 规定了上界；用作返回结果限定；</li>\n<li>super 规定了下界；用作参数限定</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"lt-extends-R-gt-method-lt-super-T-gt-通配符在定义方法的参数与返回结果时的原理\"><a href=\"#lt-extends-R-gt-method-lt-super-T-gt-通配符在定义方法的参数与返回结果时的原理\" class=\"headerlink\" title=\"&lt;? extends R&gt; method(&lt;? super T&gt;) 通配符在定义方法的参数与返回结果时的原理\"></a>&lt;? extends R&gt; method(&lt;? super T&gt;) 通配符在定义方法的参数与返回结果时的原理</h1><ul>\n<li>extends 规定了上界；用作返回结果限定；</li>\n<li>super 规定了下界；用作参数限定</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cklfa4p1p0005mshbdfxuexu6","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p1v000bmshb44oahq6j"},{"post_id":"cklfa4p1d0000mshba55x4e9b","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p1x000fmshbaigv4pjh"},{"post_id":"cklfa4p1q0006mshbgal5h2ry","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p1z000imshbh2dvadpf"},{"post_id":"cklfa4p1t0009mshb0zsh2x6v","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p22000mmshb0tc6e7xa"},{"post_id":"cklfa4p1i0001mshbhvwidnbi","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p23000omshb2t3iaca7"},{"post_id":"cklfa4p1x000emshbfnhzhaj1","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p25000rmshbhylt0meo"},{"post_id":"cklfa4p1n0004mshbgrbi1g65","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p26000vmshb4qy1ale6"},{"post_id":"cklfa4p27000ymshb8jxr2rys","category_id":"cklfa4p25000tmshb1snib9t5","_id":"cklfa4p2c0014mshb6fff61e9"},{"post_id":"cklfa4p22000nmshb84o7c3nl","category_id":"cklfa4p25000tmshb1snib9t5","_id":"cklfa4p2e0016mshbfoq576rf"},{"post_id":"cklfa4p24000qmshb6ae5h59q","category_id":"cklfa4p290010mshb2jcv9jjz","_id":"cklfa4p2g001amshba6lw0th6"},{"post_id":"cklfa4p2f0019mshbeqq9fc33","category_id":"cklfa4p1k0002mshbapvm417c","_id":"cklfa4p2k001hmshbfie3ginf"}],"PostTag":[{"post_id":"cklfa4p1d0000mshba55x4e9b","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p1y000gmshb6z0eefgd"},{"post_id":"cklfa4p1d0000mshba55x4e9b","tag_id":"cklfa4p1r0008mshbejf3hz72","_id":"cklfa4p1z000jmshbc52q5w33"},{"post_id":"cklfa4p1i0001mshbhvwidnbi","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p25000smshbcftu141m"},{"post_id":"cklfa4p1i0001mshbhvwidnbi","tag_id":"cklfa4p1z000kmshb1954hxf7","_id":"cklfa4p27000wmshb1ihmchl7"},{"post_id":"cklfa4p1n0004mshbgrbi1g65","tag_id":"cklfa4p23000pmshbae6n98sh","_id":"cklfa4p2f0018mshb18wx1428"},{"post_id":"cklfa4p1n0004mshbgrbi1g65","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p2g001bmshb4oa50g0o"},{"post_id":"cklfa4p1n0004mshbgrbi1g65","tag_id":"cklfa4p2a0011mshbekbn53gf","_id":"cklfa4p2i001emshb28959iug"},{"post_id":"cklfa4p1p0005mshbdfxuexu6","tag_id":"cklfa4p23000pmshbae6n98sh","_id":"cklfa4p2k001jmshb49051hiz"},{"post_id":"cklfa4p1p0005mshbdfxuexu6","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p2l001lmshbc59rdnv6"},{"post_id":"cklfa4p1p0005mshbdfxuexu6","tag_id":"cklfa4p2a0011mshbekbn53gf","_id":"cklfa4p2n001omshb2jjc18tt"},{"post_id":"cklfa4p1q0006mshbgal5h2ry","tag_id":"cklfa4p1r0008mshbejf3hz72","_id":"cklfa4p2o001qmshbbgy78ly4"},{"post_id":"cklfa4p1q0006mshbgal5h2ry","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p2o001rmshb2dv1ehzt"},{"post_id":"cklfa4p1q0006mshbgal5h2ry","tag_id":"cklfa4p2m001nmshbc71n9e0g","_id":"cklfa4p2o001tmshbburwewsw"},{"post_id":"cklfa4p1t0009mshb0zsh2x6v","tag_id":"cklfa4p2n001pmshbgqwd9s3u","_id":"cklfa4p2p001umshb7w7felzv"},{"post_id":"cklfa4p1u000amshbbi0k0cwn","tag_id":"cklfa4p2o001smshb03a3funb","_id":"cklfa4p2p001wmshb04k2cprt"},{"post_id":"cklfa4p1x000emshbfnhzhaj1","tag_id":"cklfa4p23000pmshbae6n98sh","_id":"cklfa4p2t001zmshbeypxb33b"},{"post_id":"cklfa4p1x000emshbfnhzhaj1","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p2t0020mshbhm509xh5"},{"post_id":"cklfa4p1x000emshbfnhzhaj1","tag_id":"cklfa4p2p001xmshb1t2qfgb4","_id":"cklfa4p2t0022mshb23kx8cv2"},{"post_id":"cklfa4p22000nmshb84o7c3nl","tag_id":"cklfa4p2q001ymshbhb3oa4do","_id":"cklfa4p2u0024mshbhnxcaz2b"},{"post_id":"cklfa4p22000nmshb84o7c3nl","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p2u0025mshb7t9pabqc"},{"post_id":"cklfa4p22000nmshb84o7c3nl","tag_id":"cklfa4p2t0021mshb661sfff9","_id":"cklfa4p2u0027mshb12lfh5mb"},{"post_id":"cklfa4p24000qmshb6ae5h59q","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p2v002amshb34074cbx"},{"post_id":"cklfa4p24000qmshb6ae5h59q","tag_id":"cklfa4p2t0023mshbfhs0bq87","_id":"cklfa4p2w002bmshb6bgpgh9r"},{"post_id":"cklfa4p24000qmshb6ae5h59q","tag_id":"cklfa4p2u0026mshb0j66fzf2","_id":"cklfa4p2w002dmshbe2zhfy3n"},{"post_id":"cklfa4p24000qmshb6ae5h59q","tag_id":"cklfa4p2v0028mshb551h1xni","_id":"cklfa4p2w002emshb6msbdmpf"},{"post_id":"cklfa4p26000umshb1342h55e","tag_id":"cklfa4p2v0029mshb0em31qiq","_id":"cklfa4p2x002gmshb13y5cwj9"},{"post_id":"cklfa4p26000umshb1342h55e","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p2x002hmshb5ukqcfjk"},{"post_id":"cklfa4p27000ymshb8jxr2rys","tag_id":"cklfa4p2w002cmshbbetf64lg","_id":"cklfa4p2y002jmshb7gym85u6"},{"post_id":"cklfa4p27000ymshb8jxr2rys","tag_id":"cklfa4p2w002fmshbfzdn18va","_id":"cklfa4p2y002kmshbbulgdeb3"},{"post_id":"cklfa4p28000zmshbdwo2ecq5","tag_id":"cklfa4p2x002imshbc4v638tz","_id":"cklfa4p2z002nmshb0qx3f7iw"},{"post_id":"cklfa4p28000zmshbdwo2ecq5","tag_id":"cklfa4p2y002lmshb560z3ytv","_id":"cklfa4p2z002omshb6ac06ia4"},{"post_id":"cklfa4p2b0013mshbgmqbamjp","tag_id":"cklfa4p2y002mmshbh0r84bt7","_id":"cklfa4p2z002qmshb7wpkasg2"},{"post_id":"cklfa4p2f0019mshbeqq9fc33","tag_id":"cklfa4p1r0008mshbejf3hz72","_id":"cklfa4p30002smshbhqrr2hzi"},{"post_id":"cklfa4p2f0019mshbeqq9fc33","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p30002tmshbch0i1r21"},{"post_id":"cklfa4p2f0019mshbeqq9fc33","tag_id":"cklfa4p2m001nmshbc71n9e0g","_id":"cklfa4p31002vmshb0ov4a3tt"},{"post_id":"cklfa4p2i001fmshbbnvfdzj7","tag_id":"cklfa4p30002rmshbcg572tq3","_id":"cklfa4p31002wmshbhjmm1o8v"},{"post_id":"cklfa4p2i001fmshbbnvfdzj7","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p31002ymshbg4oc2v12"},{"post_id":"cklfa4p2j001gmshb4mo9cckv","tag_id":"cklfa4p30002umshbetuc5e78","_id":"cklfa4p320030mshb38ns77f0"},{"post_id":"cklfa4p2j001gmshb4mo9cckv","tag_id":"cklfa4p1n0003mshb56dvdnt6","_id":"cklfa4p320031mshb62q21btw"},{"post_id":"cklfa4p2j001gmshb4mo9cckv","tag_id":"cklfa4p31002xmshbddyx8y9w","_id":"cklfa4p320032mshb1cy6el9x"},{"post_id":"cklfa4p2l001kmshb8wf1e36u","tag_id":"cklfa4p32002zmshbe67ffcsj","_id":"cklfa4p320033mshbf7g3d4ud"}],"Tag":[{"name":"java","_id":"cklfa4p1n0003mshb56dvdnt6"},{"name":"programming","_id":"cklfa4p1r0008mshbejf3hz72"},{"name":"class loader","_id":"cklfa4p1z000kmshb1954hxf7"},{"name":"framework","_id":"cklfa4p23000pmshbae6n98sh"},{"name":"file","_id":"cklfa4p2a0011mshbekbn53gf"},{"name":"HashMap","_id":"cklfa4p2m001nmshbc71n9e0g"},{"name":"Pattern, String","_id":"cklfa4p2n001pmshbgqwd9s3u"},{"name":"Apollo","_id":"cklfa4p2o001smshb03a3funb"},{"name":"URI","_id":"cklfa4p2p001xmshb1t2qfgb4"},{"name":"guigarage","_id":"cklfa4p2q001ymshbhb3oa4do"},{"name":"GUI","_id":"cklfa4p2t0021mshb661sfff9"},{"name":"jar","_id":"cklfa4p2t0023mshbfhs0bq87"},{"name":"package","_id":"cklfa4p2u0026mshb0j66fzf2"},{"name":"jvm","_id":"cklfa4p2v0028mshb551h1xni"},{"name":"reflect","_id":"cklfa4p2v0029mshb0em31qiq"},{"name":"protocol","_id":"cklfa4p2w002cmshbbetf64lg"},{"name":"socket","_id":"cklfa4p2w002fmshbfzdn18va"},{"name":"ssh","_id":"cklfa4p2x002imshbc4v638tz"},{"name":"port forwarding","_id":"cklfa4p2y002lmshb560z3ytv"},{"name":"java, BigDecimal","_id":"cklfa4p2y002mmshbh0r84bt7"},{"name":"generic","_id":"cklfa4p30002rmshbcg572tq3"},{"name":"shadowing","_id":"cklfa4p30002umshbetuc5e78"},{"name":"IO","_id":"cklfa4p31002xmshbddyx8y9w"},{"name":"java8","_id":"cklfa4p32002zmshbe67ffcsj"}]}}