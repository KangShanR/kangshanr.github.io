{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/sky/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/sky/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/sky/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"themes/sky/source/css/common/third-part.scss","path":"css/common/third-part.scss","modified":0,"renderable":1},{"_id":"source/img/ex-gf.png","path":"img/ex-gf.png","modified":0,"renderable":0},{"_id":"source/img/git.png","path":"img/git.png","modified":0,"renderable":0},{"_id":"source/pictures/FAQ.pdf","path":"pictures/FAQ.pdf","modified":0,"renderable":0},{"_id":"source/pictures/balloonl_girl.JPG","path":"pictures/balloonl_girl.JPG","modified":0,"renderable":0},{"_id":"source/pictures/ex-gf.png","path":"pictures/ex-gf.png","modified":0,"renderable":0},{"_id":"source/pictures/favicon.png","path":"pictures/favicon.png","modified":0,"renderable":0},{"_id":"source/pictures/favicon2.png","path":"pictures/favicon2.png","modified":0,"renderable":0},{"_id":"source/pictures/git_comtribute_statistics.png","path":"pictures/git_comtribute_statistics.png","modified":0,"renderable":0},{"_id":"source/pictures/kangshan.xyz.certificate.jpg","path":"pictures/kangshan.xyz.certificate.jpg","modified":0,"renderable":0},{"_id":"source/pictures/koluo.jpg","path":"pictures/koluo.jpg","modified":0,"renderable":0},{"_id":"source/pictures/landscape_banner.jpg","path":"pictures/landscape_banner.jpg","modified":0,"renderable":0},{"_id":"source/pictures/programmer.jpg","path":"pictures/programmer.jpg","modified":0,"renderable":0},{"_id":"source/pictures/proud_busty.jpg","path":"pictures/proud_busty.jpg","modified":0,"renderable":0},{"_id":"source/pictures/theMoonEarth.jpg","path":"pictures/theMoonEarth.jpg","modified":0,"renderable":0},{"_id":"source/pictures/wizIcon_icons_l.png","path":"pictures/wizIcon_icons_l.png","modified":0,"renderable":0},{"_id":"source/pictures/腾讯云建站.pdf","path":"pictures/腾讯云建站.pdf","modified":0,"renderable":0},{"_id":"source/img/Logarithmic Function/Logarithmic Function.jpg","path":"img/Logarithmic Function/Logarithmic Function.jpg","modified":0,"renderable":0},{"_id":"source/img/Logarithmic Function/数学公式写法.png","path":"img/Logarithmic Function/数学公式写法.png","modified":0,"renderable":0},{"_id":"source/img/WuJun/Bigaso's wife.jpg","path":"img/WuJun/Bigaso's wife.jpg","modified":0,"renderable":0},{"_id":"source/img/WuJun/Bigaso's younth work.jpg","path":"img/WuJun/Bigaso's younth work.jpg","modified":0,"renderable":0},{"_id":"source/img/WuJun/Gerneca.jpg","path":"img/WuJun/Gerneca.jpg","modified":0,"renderable":0},{"_id":"source/img/WuJun/Les Demoiselles d'Avignon.jpg","path":"img/WuJun/Les Demoiselles d'Avignon.jpg","modified":0,"renderable":0},{"_id":"source/img/WuJun/Persistense of Memory.jpg","path":"img/WuJun/Persistense of Memory.jpg","modified":0,"renderable":0},{"_id":"source/img/WuJun/old guitarist.jpg","path":"img/WuJun/old guitarist.jpg","modified":0,"renderable":0},{"_id":"source/img/justice-league/AmyAdams.jpg","path":"img/justice-league/AmyAdams.jpg","modified":0,"renderable":0},{"_id":"source/img/justice-league/Aquaman.jpg","path":"img/justice-league/Aquaman.jpg","modified":0,"renderable":0},{"_id":"source/img/justice-league/BenAfflekAndGalGardot.jpg","path":"img/justice-league/BenAfflekAndGalGardot.jpg","modified":0,"renderable":0},{"_id":"source/img/justice-league/Cyborg.jpg","path":"img/justice-league/Cyborg.jpg","modified":0,"renderable":0},{"_id":"source/img/justice-league/GalGadot.jpg","path":"img/justice-league/GalGadot.jpg","modified":0,"renderable":0},{"_id":"source/img/justice-league/Justice-league.jpg","path":"img/justice-league/Justice-league.jpg","modified":0,"renderable":0},{"_id":"source/img/justice-league/TheFlash.jpg","path":"img/justice-league/TheFlash.jpg","modified":0,"renderable":0},{"_id":"source/img/my_pictures/office.jpg","path":"img/my_pictures/office.jpg","modified":0,"renderable":0},{"_id":"source/img/my_pictures/office2.jpg","path":"img/my_pictures/office2.jpg","modified":0,"renderable":0},{"_id":"source/img/my_pictures/office3.jpg","path":"img/my_pictures/office3.jpg","modified":0,"renderable":0},{"_id":"source/img/sql/join.jpg","path":"img/sql/join.jpg","modified":0,"renderable":0},{"_id":"source/pictures/Marvel 2018/Marvel.jpg","path":"pictures/Marvel 2018/Marvel.jpg","modified":0,"renderable":0},{"_id":"source/pictures/Marvel 2018/mcu-calss-3.jpg","path":"pictures/Marvel 2018/mcu-calss-3.jpg","modified":0,"renderable":0},{"_id":"source/pictures/Marvel 2018/mcuphoto.jpg","path":"pictures/Marvel 2018/mcuphoto.jpg","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/11182994.png","path":"pictures/baahuballi/11182994.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/11221463.png","path":"pictures/baahuballi/11221463.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/14823355.png","path":"pictures/baahuballi/14823355.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/17245146.png","path":"pictures/baahuballi/17245146.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/17288093.png","path":"pictures/baahuballi/17288093.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/17502766.png","path":"pictures/baahuballi/17502766.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/17645928.png","path":"pictures/baahuballi/17645928.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/17655319.png","path":"pictures/baahuballi/17655319.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/17676676.png","path":"pictures/baahuballi/17676676.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/17705988.png","path":"pictures/baahuballi/17705988.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18317418.png","path":"pictures/baahuballi/18317418.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18389475.png","path":"pictures/baahuballi/18389475.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18425543.png","path":"pictures/baahuballi/18425543.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18441408.png","path":"pictures/baahuballi/18441408.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18542294.png","path":"pictures/baahuballi/18542294.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18555258.png","path":"pictures/baahuballi/18555258.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18582573.png","path":"pictures/baahuballi/18582573.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/18601933.png","path":"pictures/baahuballi/18601933.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/a81563ee-ec3a-417e-8089-e1bb5b0a3fcd.png","path":"pictures/baahuballi/a81563ee-ec3a-417e-8089-e1bb5b0a3fcd.png","modified":0,"renderable":0},{"_id":"source/pictures/baahuballi/d9c21860-478d-4777-bf24-b6e1774d4368.png","path":"pictures/baahuballi/d9c21860-478d-4777-bf24-b6e1774d4368.png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/bg.jpg","path":"pictures/graduate/bg.jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (1).png","path":"pictures/graduate/graduate (1).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (2).jpg","path":"pictures/graduate/graduate (2).jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (2).png","path":"pictures/graduate/graduate (2).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (3).png","path":"pictures/graduate/graduate (3).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (4).jpg","path":"pictures/graduate/graduate (4).jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (5).jpg","path":"pictures/graduate/graduate (5).jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (5).png","path":"pictures/graduate/graduate (5).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (6).jpg","path":"pictures/graduate/graduate (6).jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (6).png","path":"pictures/graduate/graduate (6).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (7).jpg","path":"pictures/graduate/graduate (7).jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (7).png","path":"pictures/graduate/graduate (7).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (8).jpg","path":"pictures/graduate/graduate (8).jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (8).png","path":"pictures/graduate/graduate (8).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (9).jpg","path":"pictures/graduate/graduate (9).jpg","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate (9).png","path":"pictures/graduate/graduate (9).png","modified":0,"renderable":0},{"_id":"source/pictures/graduate/graduate(1).jpg","path":"pictures/graduate/graduate(1).jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/Hash.md","hash":"a2b20372da3af820ca3fbc2141b38fab1df51100","modified":1614182858350},{"_id":"source/_posts/URI in Java.md","hash":"c0981ff7108275d3c27b6037e2c71e1007e15cfb","modified":1614180143312},{"_id":"source/_posts/jar.md","hash":"87b15711dd098b58ff3f838cb7a7d19c313ee907","modified":1614180143064},{"_id":"source/_posts/java specification.md","hash":"bfd71139e5677a974cda05e883e14ccaf8375359","modified":1614180143112},{"_id":"source/_posts/java-keywords.md","hash":"bff9da81fac5ffc1d316a5c4b7909a3cc21a0a21","modified":1614180143176},{"_id":"source/_posts/java-type.md","hash":"3ce88bd94559902a48d7e6685421ebbbca472f9d","modified":1614180143248},{"_id":"source/categories/index.md","hash":"2cb3d6904276b2a782d10f4de985f525df7b4b3c","modified":1614181037046},{"_id":"source/about/index.md","hash":"6f10cbc691bd4b03df375d7e0e84da757f19fc94","modified":1614184142193},{"_id":"source/img/HELLO.html","hash":"34035c0df8db5524fc54dbe08d8d0ffa8733a098","modified":1609475299295},{"_id":"source/img/git.png","hash":"558c5b3217f5613b3d6fbb7b27aaf2e68427fde9","modified":1609475299299},{"_id":"source/pictures/favicon.png","hash":"6fdaed0f07d1905a4246e43a56d01292ce76dead","modified":1609475299519},{"_id":"source/pictures/favicon2.png","hash":"0241b4b8c5773b4d14871357c475863105a0202a","modified":1609475299519},{"_id":"source/pictures/git_comtribute_statistics.png","hash":"f38955532b3316b2ad0d023b9ce65ccb8b9def8e","modified":1609475299519},{"_id":"source/pictures/proud_busty.jpg","hash":"57504c52c414f2a96a71a8a12fc11405d839ca62","modified":1609475299615},{"_id":"source/pictures/wizIcon_icons_l.png","hash":"23c416d47db74b4352f23a104b31c4f4c2255ca3","modified":1609475299619},{"_id":"source/tags/index.md","hash":"7ce886a29c9c22e97c62c54c402d48a1efec370c","modified":1614181765733},{"_id":"source/_posts/JMM/CompletableFuture.md","hash":"c74f044b937020d178b67827e5b9f34d860397ab","modified":1614180142648},{"_id":"source/_posts/JMM/Java Merory Model.md","hash":"807217f0577d613ddc06a76d0363e32aaed22d52","modified":1614180142652},{"_id":"source/_posts/JMM/Lock Condition.md","hash":"7378581d8b242e9845b74045dc1822fa2fa2e1eb","modified":1614180142652},{"_id":"source/_posts/JMM/Thread.md","hash":"57106288b7a0c9e13435493b9b06e82e6b646ee5","modified":1614180142652},{"_id":"source/_posts/JMM/Volatile.md","hash":"c3eac2aae7680a831673fae409bcc7c133a01a4a","modified":1614180142652},{"_id":"source/_posts/JMM/lock.md","hash":"84e86797a8456fa28872b1f534dc2bc08043d1b7","modified":1614180142656},{"_id":"source/_posts/Linux/command line.md","hash":"efaef38d5b557acbb1a2a61a938a3e061ea556a9","modified":1614180142704},{"_id":"source/_posts/Linux/linux.md","hash":"c44ef0e41c5d24b9059f5493fb228582e0d3e99d","modified":1614180142712},{"_id":"source/_posts/Linux/shell.md","hash":"2650660eaf1ad90852dbda8829874f50ce112340","modified":1614180142712},{"_id":"source/_posts/Mysql/Deadlocks in InnoDB.md","hash":"f3db44b15f12d33cca0285b844d7f90cff721a7c","modified":1614180142868},{"_id":"source/_posts/Mysql/How to Minimize and Handle Deadlocks.md","hash":"51db90a8e87a01feb27fcbe69cec7fdeb1d64650","modified":1614180142872},{"_id":"source/_posts/Mysql/InnoDB Indexes On-Disk Structures.md","hash":"f414aa4a58231782a3d9b2754cd034329899234b","modified":1614180142884},{"_id":"source/_posts/Mysql/InnoDB Transaction Isolation Level.md","hash":"ce5bbadee5f0182a9f40f3ec8488eef0f7848555","modified":1614180142884},{"_id":"source/_posts/Mysql/InnoDB Transaction Model.md","hash":"163c430b69bcdf0b4e00ad0430bd86992e7331d9","modified":1614180142892},{"_id":"source/_posts/Mysql/InnoDB.md","hash":"fbcbcf5a6fba8b3ccc219f91c56ebcaea82ef5f7","modified":1614180142896},{"_id":"source/_posts/Mysql/Locks set by Different Sql Statements in InnoDB.md","hash":"70a3ad05fe461326e4142c98ee0951fff85a1fb6","modified":1614180142896},{"_id":"source/_posts/Mysql/Phantom Rows.md","hash":"b2b1219ad03e86aa9547a98a0d8cf623f6842b64","modified":1614180142896},{"_id":"source/_posts/Mysql/SELECT Statement.md","hash":"89ab96eb2379fb8c495450a7338596ce3558e4dc","modified":1614180142900},{"_id":"source/_posts/Mysql/mysql.md","hash":"8e09efd0e4506e3ebd7e1882902ec41d08f1631b","modified":1614180142900},{"_id":"source/_posts/Spring/Spring Expression Language.md","hash":"9e7999f937ffdbf581b2c7ff6857196fd244a45c","modified":1614180142960},{"_id":"source/_posts/Spring/Spring IOC.md","hash":"cb05f6f0c6b7641d857a95231ca92c430de095b6","modified":1614180142960},{"_id":"source/_posts/Spring/Spring-AOP.md","hash":"a0fedae2bc94c0e10ec963fa6f69d9a04b25a129","modified":1614180142964},{"_id":"source/_posts/Spring/Spring-Test.md","hash":"264bf38d4080abc95cab59c2f8d8f24745fd8a21","modified":1614180142964},{"_id":"source/_posts/Spring/SpringBoot-ExternalizedConfiguration.md","hash":"4dd86de471b81dc5a71324a3791a468dd3b29da8","modified":1614180142964},{"_id":"source/_posts/Spring/SpringBoot-Features.md","hash":"179b563b9026f3fbadea64e96ab6975f21e592a2","modified":1614180142972},{"_id":"source/_posts/Spring/SpringBoot-SpringApplication.md","hash":"916a8af53a13697b1c8cae617afbab06a5f2afe9","modified":1614181576768},{"_id":"source/_posts/Spring/Spring_Bean.md","hash":"796e2bd343630cbea1a135cb3a6df08a7ffc75a1","modified":1614180142976},{"_id":"source/_posts/Spring/Validation_databinding_typeConversion.md","hash":"12bd62cfa972f0f52a8bbb2a0e69e1fbcd3b4d1c","modified":1614180142976},{"_id":"source/_posts/Spring/spring boot.md","hash":"36e3961db3aa86f59ace0be2a4fd8e9d743151aa","modified":1614180142976},{"_id":"source/_posts/Spring/spring.md","hash":"b1f733ca09b47a64d3538a6395fa376e6c3a7526","modified":1614180142976},{"_id":"source/_posts/Spring/springMVC.md","hash":"1e77784343c4f5f90bf5804560041f842ca9d44f","modified":1614181572184},{"_id":"source/img/Logarithmic Function/Logarithmic Function.jpg","hash":"5c38373d59779d5b2e31bb6471c35bfd93fe9b88","modified":1609475299295},{"_id":"source/pictures/balloonl_girl.JPG","hash":"03bd522e74cb0048870a287f4c97cd2e7e0437ce","modified":1609475299515},{"_id":"source/pictures/koluo.jpg","hash":"041f6947ac99fabec2ca47940d08a261927e4d18","modified":1609475299615},{"_id":"source/img/WuJun/Bigaso's wife.jpg","hash":"b098e7160957aefc73cf28d8f08bdf244c41eee9","modified":1609475299295},{"_id":"source/img/WuJun/Bigaso's younth work.jpg","hash":"821ccf2a3356fb96ab18f562fb7c966d9c8dd9b5","modified":1609475299295},{"_id":"source/img/WuJun/Gerneca.jpg","hash":"662035925a746fdd8017e9591aeaf3b7a783ce16","modified":1609475299295},{"_id":"source/img/WuJun/Persistense of Memory.jpg","hash":"39653fbf5ca171cadc8dd73d6aa78876eabbfd82","modified":1609475299295},{"_id":"source/img/WuJun/old guitarist.jpg","hash":"fc778f80178e28e67f5158855d8918892c2077fd","modified":1609475299295},{"_id":"source/img/justice-league/GalGadot.jpg","hash":"e29bd6ea141fb7c95086f982dc6c7d6e34c345be","modified":1609475299315},{"_id":"source/img/my_pictures/office.jpg","hash":"6ec6d64389fd7d69e0dfd3b658885f60d916a51f","modified":1609475299331},{"_id":"source/img/my_pictures/office2.jpg","hash":"fadfa2125f07403c7f76565286213fc88469ef68","modified":1609475299331},{"_id":"source/img/my_pictures/office3.jpg","hash":"6464d9057fcec86b4f9f2d8868dd274fc324ffa2","modified":1609475299331},{"_id":"source/pictures/graduate/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1609475299519},{"_id":"source/pictures/graduate/graduate (6).jpg","hash":"d519e0e2753280c17077ad991620697ff50cbb54","modified":1609475299563},{"_id":"source/pictures/graduate/graduate (7).jpg","hash":"6049631b863faa9d15e13969dcb4f0d5a7d6eb06","modified":1609475299575},{"_id":"source/pictures/graduate/graduate (9).jpg","hash":"ab5f05cb38cdc9cccfda02ab699832da3e8730eb","modified":1609475299599},{"_id":"source/img/WuJun/Les Demoiselles d'Avignon.jpg","hash":"9cbf61a80431926a948d36bbfa75665838fbdc43","modified":1609475299295},{"_id":"source/img/sql/join.jpg","hash":"7e8dcf63bd75e009e21d41fd925d8a732e7eef33","modified":1609475299335},{"_id":"source/pictures/graduate/graduate (2).jpg","hash":"9a1d61ec2bd4757385bd37ab54a5db38b951e40a","modified":1609475299531},{"_id":"source/pictures/graduate/graduate (4).jpg","hash":"41ae23e2347da71772c3def3117313a139aa30e2","modified":1609475299551},{"_id":"source/pictures/graduate/graduate (5).jpg","hash":"e7fdac56041ce3a7b71b08578650ff57dd261c5c","modified":1609475299551},{"_id":"source/pictures/graduate/graduate (8).jpg","hash":"9ce1ede4311c58dbe43beba932abe7dc14a54386","modified":1609475299587},{"_id":"source/pictures/graduate/graduate(1).jpg","hash":"feffe2fdebfc02e09bef0b31cda966ea1e2595f0","modified":1609475299611},{"_id":"source/pictures/landscape_banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1609475299615},{"_id":"source/pictures/programmer.jpg","hash":"cd8637c3171e7c14d5caff965c681077d97e2dcf","modified":1609475299615},{"_id":"source/pictures/theMoonEarth.jpg","hash":"5af1ab5da9cceb8349d7b039fd1a9fe5d490545d","modified":1609475299619},{"_id":"source/img/Logarithmic Function/数学公式写法.png","hash":"f05b231183aa199fee57b07b1931f2fb00488dee","modified":1609475299295},{"_id":"themes/sky/layout/_partial/categorys.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1613925338103},{"_id":"themes/sky/README.md","hash":"40179efdc91f59546e0e951903d2cc970c1d30d1","modified":1613925338103},{"_id":"themes/sky/_config.yml","hash":"3bfe241b6a1d9403423e7bba4f1dadc6998cd9a9","modified":1614181822324},{"_id":"themes/sky/languages/default.yml","hash":"52fb1e5c4dd948f363b48d01bb5b8dbf41c1f154","modified":1613925338103},{"_id":"themes/sky/languages/en.yml","hash":"068a88a0692cc2ba694ca595a510001a288de2de","modified":1613925338103},{"_id":"themes/sky/languages/zh-CN.yml","hash":"52fb1e5c4dd948f363b48d01bb5b8dbf41c1f154","modified":1613925338103},{"_id":"themes/sky/layout/about.ejs","hash":"800c105b29f549795b844808c9eb14faddc21ccf","modified":1613925338103},{"_id":"themes/sky/layout/archive.ejs","hash":"6929f467b6afd2803b6b99826393ca24f048aa9c","modified":1613925338103},{"_id":"themes/sky/layout/categories.ejs","hash":"a65612c8bfcd6bb0902e749a26b3f78572cba76b","modified":1613925338103},{"_id":"themes/sky/layout/index.ejs","hash":"bb0d6fbf7f39b020dc4aa26ac2427071c41ed4bf","modified":1613925338103},{"_id":"themes/sky/layout/layout.ejs","hash":"e7fe1a9df223e72789d4e4837b4f799c209a6c1e","modified":1613925338103},{"_id":"themes/sky/layout/post.ejs","hash":"6bdd382d5b6abf58c0310c0eca22553346f7b06f","modified":1613925338103},{"_id":"themes/sky/layout/tags.ejs","hash":"6a2c8b0f27e4665f07df75c3bc69d90e89dc48e2","modified":1613925338103},{"_id":"themes/sky/layout/_partial/copyright.ejs","hash":"35691d5793407427b30ec98b8e1e3a4e3826582f","modified":1613925338103},{"_id":"themes/sky/layout/_partial/head.ejs","hash":"e036cdd8e586bce8d5932a7e5d7734e447fa0d6e","modified":1613925338103},{"_id":"themes/sky/layout/_partial/header.ejs","hash":"d192f46ed2fe81b07731bf5bf8e906dc05e70c11","modified":1613925338103},{"_id":"themes/sky/layout/_partial/mobile-header.ejs","hash":"efc29376e3a6dfacc6992a3960fdbcf5897180c7","modified":1613925338103},{"_id":"themes/sky/layout/_partial/paginator.ejs","hash":"8ae9c183d68b6389468142d19e2fa609243bc769","modified":1613925338103},{"_id":"themes/sky/layout/_partial/social.ejs","hash":"1fe20a940878f36e6747a1ecdfad0f966ae0d6d0","modified":1613925338103},{"_id":"themes/sky/layout/_partial/toc.ejs","hash":"0eebede0f570660affa2d6c28f66a1c2da5fd956","modified":1613925338103},{"_id":"themes/sky/source/css/_reset.scss","hash":"76731f66789dec06cf4cb5aa1e28dea15aae66cd","modified":1613925338103},{"_id":"themes/sky/source/css/_variables.scss","hash":"7eea115e894d923712f7dc11500e50e47d5c5a5c","modified":1613925338103},{"_id":"themes/sky/source/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1613925338103},{"_id":"themes/sky/source/css/style.scss","hash":"fc8b9105458a5b0ae09db5469b2a7ed63c8a80d0","modified":1613925338103},{"_id":"themes/sky/source/js/index.js","hash":"907faae45c668d3650efa971da364dddb674fb19","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/_header.scss","hash":"a25712ca2710a4de867b57708cbe7b18d727a9c6","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/_paginator.scss","hash":"a5093cacd58dd0c9f8747ea122f014a91174af0d","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/_post.scss","hash":"f4e369c42efa39dff5a0e788ce8826572bf0afae","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/_tags.scss","hash":"893286e3c42935fe6989f298578fb55e616b877e","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/archive.scss","hash":"e4c018a401f60bf3478f829a0cce3d22e458cea0","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/copyright.scss","hash":"9e2430aeba6c363272a2067ec99bd931b823f32a","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/mobile.scss","hash":"1bd748689d14eea293b2fa36cc3cd4470c4b9a97","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/social.scss","hash":"db00192dabb9d2ec03cfb00c896b8b92fa4c9256","modified":1613925338103},{"_id":"themes/sky/source/css/common/_utils.scss","hash":"566d520e7a76083a255ab0d2d2403ee7228df789","modified":1613925338103},{"_id":"themes/sky/source/css/common/third-part.scss","hash":"4532729275c05b3a10e0513d22b396832085ed66","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/post/code.scss","hash":"81aa2b4c93625c31d2b48d3575a695254ddbee11","modified":1613925338103},{"_id":"themes/sky/source/css/_partial/post/toc.scss","hash":"25d63b0a9b7ab80bb8de14c2dd72cbec8e0713b2","modified":1613925338103},{"_id":"source/img/justice-league/Cyborg.jpg","hash":"0ba90dbb39b24b0fe1b8cfdf26b26f94ecdd076b","modified":1609475299315},{"_id":"source/pictures/baahuballi/17502766.png","hash":"b73f374ff1220537e956fba32d5220b46c980b7a","modified":1609475299403},{"_id":"source/pictures/FAQ.pdf","hash":"0ae0ec0efd0b753c6a2208fb90114b4a1a4a961b","modified":1609475299335},{"_id":"source/img/ex-gf.png","hash":"43a756da31a97bcf3b1f41de783cf65f38d6d99a","modified":1609475299299},{"_id":"source/pictures/ex-gf.png","hash":"43a756da31a97bcf3b1f41de783cf65f38d6d99a","modified":1609475299519},{"_id":"source/pictures/baahuballi/11221463.png","hash":"a451ca5854ee5a506946f7d6f4854a7ec09c72c7","modified":1609475299379},{"_id":"source/pictures/腾讯云建站.pdf","hash":"18afaabfea736c10265be95e914ffc29fd10b62b","modified":1609475299619},{"_id":"source/img/justice-league/Aquaman.jpg","hash":"1552b470d6e8af8dda97cfaa966beef396aba942","modified":1609475299311},{"_id":"source/pictures/baahuballi/11182994.png","hash":"9c7ed122c9fc534019587f3c110989c903a3f295","modified":1609475299379},{"_id":"source/pictures/baahuballi/18542294.png","hash":"829bd6bc148ce3b276ac3e1f38889e3425d42633","modified":1609475299471},{"_id":"source/pictures/baahuballi/17245146.png","hash":"6a7b42d874018e221da64b08541744afe5ff2905","modified":1609475299395},{"_id":"source/pictures/baahuballi/17288093.png","hash":"b44083ef2feed4a24bc646de05d7f24e79dd143f","modified":1609475299403},{"_id":"source/pictures/baahuballi/17645928.png","hash":"2d163a37eee0c37991898025aa311bc3e04e2b9c","modified":1609475299407},{"_id":"source/pictures/kangshan.xyz.certificate.jpg","hash":"93d3284b462dab8441d9131dc92fe7f99273f8c0","modified":1609475299615},{"_id":"source/img/justice-league/BenAfflekAndGalGardot.jpg","hash":"2bfc18a3d431bea5f506316cb69dfa3b62f869c5","modified":1609475299315},{"_id":"source/img/justice-league/TheFlash.jpg","hash":"8ab600aa216ce1eb1617cf1588a79f0d1bf88f41","modified":1609475299331},{"_id":"source/pictures/baahuballi/18317418.png","hash":"91d674852fdfbbae2922d7f5fa53a0ad2e3d5642","modified":1609475299443},{"_id":"source/pictures/baahuballi/18389475.png","hash":"dd5bc3acc974e2107a25daa18d0481f1e64ddf09","modified":1609475299447},{"_id":"source/pictures/baahuballi/18582573.png","hash":"ee500c032674ba835ad568ddb8744f478f57a5c0","modified":1609475299483},{"_id":"source/img/justice-league/AmyAdams.jpg","hash":"693d7223b300133be3a4e146a8e18e45894a6cd0","modified":1609475299303},{"_id":"source/pictures/Marvel 2018/mcu-calss-3.jpg","hash":"b7685db7c11c9d1669210e4709e6b719cf42f757","modified":1609475299367},{"_id":"source/pictures/baahuballi/18425543.png","hash":"750fde6216bedea34e0199b7b77af9bb11ee8b4b","modified":1609475299455},{"_id":"source/pictures/baahuballi/18555258.png","hash":"da1f9e42bdff2773d7e0134b35ea270bd7a2d85f","modified":1609475299479},{"_id":"source/pictures/baahuballi/18601933.png","hash":"f1d822b8cd8a4f25ca7b148ec5165cb4944dcece","modified":1609475299491},{"_id":"source/pictures/baahuballi/17705988.png","hash":"4037bd553c3c711961353b039884ac1f5cbf4ec2","modified":1609475299435},{"_id":"source/pictures/baahuballi/18441408.png","hash":"dab35b4024db134b58ff552fa2d876dcb1e61afe","modified":1609475299467},{"_id":"source/pictures/graduate/graduate (7).png","hash":"3743b2714129d633b983414168e0f3e776e07ead","modified":1609475299587},{"_id":"source/pictures/graduate/graduate (8).png","hash":"e42a5dfdf29d991bcdc6ed3de4a2d771df32906e","modified":1609475299599},{"_id":"source/pictures/graduate/graduate (1).png","hash":"aa56016fff76a884c518e0c57d0942550d7add5a","modified":1609475299531},{"_id":"source/pictures/graduate/graduate (2).png","hash":"728e92a94b88edad81902fc7e873f2efa2d3c942","modified":1609475299539},{"_id":"source/img/justice-league/Justice-league.jpg","hash":"e9fccfc0eda315a77997ee87b70843f2e41a0029","modified":1609475299327},{"_id":"source/pictures/baahuballi/d9c21860-478d-4777-bf24-b6e1774d4368.png","hash":"74154388f1b3a9883cd1613611ecebfcc8b159ac","modified":1609475299515},{"_id":"source/pictures/graduate/graduate (3).png","hash":"2ec4d43a828e3ca04b095bc64513c7c55046217e","modified":1609475299551},{"_id":"source/pictures/graduate/graduate (5).png","hash":"81c21b913ff1e615d4a7526d11cc9e8f77e2ef62","modified":1609475299563},{"_id":"source/pictures/graduate/graduate (6).png","hash":"e2ce3439ed3bb881ca04eb292d5292b8db9ffc66","modified":1609475299575},{"_id":"source/pictures/graduate/graduate (9).png","hash":"afdff7312502274a04a2a1111debd660a7acfd69","modified":1609475299607},{"_id":"source/pictures/baahuballi/14823355.png","hash":"aaa6cbf9b241cac79e48e1496879f197eafbd87a","modified":1609475299391},{"_id":"source/pictures/baahuballi/17676676.png","hash":"04ce85f010ef321ca5817ccda53e9e4a8e4b0f98","modified":1609475299427},{"_id":"source/pictures/Marvel 2018/mcuphoto.jpg","hash":"c8c6e090de93ca87b9b6c734e9682e29459c636c","modified":1609475299379},{"_id":"source/pictures/baahuballi/a81563ee-ec3a-417e-8089-e1bb5b0a3fcd.png","hash":"03f92bf382ae372d46c26a8a3f258276eb5c1164","modified":1609475299507},{"_id":"source/pictures/baahuballi/17655319.png","hash":"277a5668573793d034736b7380d5534fb404e67a","modified":1609475299415},{"_id":"source/pictures/Marvel 2018/Marvel.jpg","hash":"d2636b94ea9f85f01aeda9e03b721720cc8245c1","modified":1609475299359},{"_id":"public/img/HELLO.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1614184344965},{"_id":"public/categories/index.html","hash":"478c5f6964c97f114cce14e38c3484b584eb0c47","modified":1614184344965},{"_id":"public/about/index.html","hash":"418cfda9217665344d0de088f5aa838fd0c80c74","modified":1614184344965},{"_id":"public/tags/index.html","hash":"459e0fdda93e65fae502fb8d50c10354631b252b","modified":1614184344965},{"_id":"public/2021/02/05/JMM/Lock Condition/index.html","hash":"39a6a768dbedebac1d225ed956622ebb17dbc9c7","modified":1614184344965},{"_id":"public/2021/01/28/JMM/Java Merory Model/index.html","hash":"367e7afc2fd88f5126fbec02304426c4430d7245","modified":1614184344965},{"_id":"public/2021/01/15/Mysql/SELECT Statement/index.html","hash":"ff5c900f05f6dcba087881a9358b10b82006585f","modified":1614184344965},{"_id":"public/2021/01/13/Mysql/How to Minimize and Handle Deadlocks/index.html","hash":"9d51dd4da5b51b68ec4223971807771d69aa7606","modified":1614184344965},{"_id":"public/2021/01/12/Mysql/Deadlocks in InnoDB/index.html","hash":"38eebc459d69afdc9a2bf4aa0f931e53ba77d071","modified":1614184344965},{"_id":"public/2021/01/12/Mysql/Phantom Rows/index.html","hash":"b92246916c4db9fbf401d685a151b0dca42e9fa0","modified":1614184344965},{"_id":"public/2021/01/07/Mysql/InnoDB Indexes On-Disk Structures/index.html","hash":"c331c57d0c2d344a85fd0c46938f1862af014fc9","modified":1614184344965},{"_id":"public/2021/01/07/Mysql/Locks set by Different Sql Statements in InnoDB/index.html","hash":"3a16257c2cb7bcdc1fe01d5d385e823be7be361f","modified":1614184344965},{"_id":"public/2020/12/28/JMM/Thread/index.html","hash":"c338261ec5dfa070edbcb0a4a997db8eeb9f71b0","modified":1614184344965},{"_id":"public/2020/12/10/Linux/command line/index.html","hash":"ce724194598374fecceec54aa57b66eb9ac1b649","modified":1614184344965},{"_id":"public/2020/11/03/java specification/index.html","hash":"00845a7fc4e2f990b1c4e18a2b3abd38f65d657e","modified":1614184344965},{"_id":"public/2020/10/20/jar/index.html","hash":"ba5b3e27b59b66f03f40450ef5d7b8edbc5c7f7d","modified":1614184344965},{"_id":"public/2020/10/12/java-keywords/index.html","hash":"595afe811f2444ceff6924909c6be3a96d09063c","modified":1614184344965},{"_id":"public/2020/09/23/Spring/Spring Expression Language/index.html","hash":"528ad0b1d38fc25c3675f290547777a066d0311d","modified":1614184344965},{"_id":"public/2020/07/23/Spring/SpringBoot-Features/index.html","hash":"f11733d6fc5f1c7b77df5ab0756db51bc0847270","modified":1614184344965},{"_id":"public/2020/06/11/JMM/lock/index.html","hash":"0b00f6e12ba0a934de42e7f50a5e9571fe837782","modified":1614184344965},{"_id":"public/2020/04/21/JMM/Volatile/index.html","hash":"af747ab98e7b1fdaf4535d0fc6a26117a933751b","modified":1614184344965},{"_id":"public/2019/01/29/java-type/index.html","hash":"5e3e4ce12914c266703f1d9bf0d4e8ada386b43c","modified":1614184344965},{"_id":"public/2018/09/28/JMM/CompletableFuture/index.html","hash":"e671a29f698aa3bfbf617654f15674a8148d8fa8","modified":1614184344965},{"_id":"public/2017/04/13/Hash/index.html","hash":"628d4649f7e4d08d656cbd69a3a9ef1d070ee368","modified":1614184344965},{"_id":"public/categories/Java/index.html","hash":"cb0e0870289a6ad6b6e659841d333865024d603a","modified":1614184344965},{"_id":"public/categories/Java/page/2/index.html","hash":"cb0e0870289a6ad6b6e659841d333865024d603a","modified":1614184344965},{"_id":"public/categories/Linux/index.html","hash":"7847afc3b208bd03dca47b547fca0c85389ba7f1","modified":1614184344965},{"_id":"public/categories/Mysql/index.html","hash":"b2a1607f7b9e501360e2f5a68a403859090a338e","modified":1614184344965},{"_id":"public/categories/Mysql/page/2/index.html","hash":"b2a1607f7b9e501360e2f5a68a403859090a338e","modified":1614184344965},{"_id":"public/categories/Linux/Shell/index.html","hash":"ffa9c6bc2ec30c09a5214aeda91ef5a87f4e2fa2","modified":1614184344965},{"_id":"public/categories/Spring/index.html","hash":"d986086a21a1e1b2256b1a3cf5f3a05f5dd6108b","modified":1614184344965},{"_id":"public/categories/AOP/index.html","hash":"ff33f838822bad70a8fb37d08a77f7ff0abd7ba5","modified":1614184344965},{"_id":"public/categories/SpringBoot/index.html","hash":"cc09519a8fe2dd95dba642d4aa3ba1192bf1f56c","modified":1614184344965},{"_id":"public/page/4/index.html","hash":"0b8979234b44caddd0b719ba8853fa1cf80f26c6","modified":1614184344965},{"_id":"public/tags/programming/index.html","hash":"3b933610e8d0ae70c16e0b9c2c02baef142e0252","modified":1614184344965},{"_id":"public/tags/java/index.html","hash":"71fb02044d8d057a6a28aed50a30ed99c854174a","modified":1614184344965},{"_id":"public/tags/java/page/2/index.html","hash":"71fb02044d8d057a6a28aed50a30ed99c854174a","modified":1614184344965},{"_id":"public/tags/HashMap/index.html","hash":"fca185051a018aa41db477d26201866f64714372","modified":1614184344965},{"_id":"public/tags/framework/index.html","hash":"1c690418a3d122e16f88be56f7ce3cda2a617be0","modified":1614184344965},{"_id":"public/tags/URI/index.html","hash":"f1cec1cbc5f1014a426433492a7ad927537bb489","modified":1614184344965},{"_id":"public/tags/jar/index.html","hash":"8393548b70385dc3d066d1edf841a7bb372158e6","modified":1614184344965},{"_id":"public/tags/package/index.html","hash":"24f2af7198443096ab9b9093099bf938c7c20e3c","modified":1614184344965},{"_id":"public/tags/jvm/index.html","hash":"aa562b002be0712cef3c50b78e48891ae9aba387","modified":1614184344965},{"_id":"public/tags/shadowing/index.html","hash":"83f19f8d98c1843e033b44d4378c64e479d6dd0b","modified":1614184344965},{"_id":"public/tags/IO/index.html","hash":"a3d723c5d3541fe91d96889235997226e99b19f1","modified":1614184344965},{"_id":"public/tags/generic/index.html","hash":"8e51fa0b494ba0a213c2eadac6697160e980eba7","modified":1614184344965},{"_id":"public/tags/concurrent/index.html","hash":"2216824da7876d584736a9ec85ac2fdec493513d","modified":1614184344965},{"_id":"public/tags/JMM/index.html","hash":"416fb8d3b875ef4e2d07f930cd9efbd4d549b97f","modified":1614184344965},{"_id":"public/tags/Java/index.html","hash":"6d2498f64648634c9be57d056952d221a850c1a7","modified":1614184344965},{"_id":"public/tags/Lock/index.html","hash":"5b4baafddbb0386ef2f8a7866ba2689591e0410c","modified":1614184344965},{"_id":"public/tags/volatile/index.html","hash":"1fbec2eb997e6edcfe331a0512c52f4e84db0823","modified":1614184344965},{"_id":"public/tags/lock/index.html","hash":"a943b28a6556d8e15fdc5caf9483dc3e98997263","modified":1614184344965},{"_id":"public/tags/linux/index.html","hash":"12e691d365aa81216b00e49fa1c4194f2f0d0be5","modified":1614184344965},{"_id":"public/tags/shell/index.html","hash":"15210290252a0930a5872494466ddbec6dc6f0e9","modified":1614184344965},{"_id":"public/tags/mysql/index.html","hash":"1b69972f767a89b5c5d0933b0fc3a52c95fd1564","modified":1614184344965},{"_id":"public/tags/InnoDB/index.html","hash":"2f36fede0cdc06cfd58d574c3670512b06d54358","modified":1614184344965},{"_id":"public/tags/Deadlock/index.html","hash":"a37663fa39cf0ced66f8536394a3d16700c3d025","modified":1614184344965},{"_id":"public/tags/index/index.html","hash":"92c69946b482451e6374b7c6ed2637ebf1e904b3","modified":1614184344965},{"_id":"public/tags/commit/index.html","hash":"b70aa4d8db88b6cd40b4deee396aaeb7c27135d4","modified":1614184344965},{"_id":"public/tags/InnoDB-Locking/index.html","hash":"c3d0a1b72c9ff557337f79e6518029838ecc56c4","modified":1614184344965},{"_id":"public/tags/SQL/index.html","hash":"591ad0e8c2fbcdeff9ba00924e1aa002fdc4ae50","modified":1614184344965},{"_id":"public/tags/Spring/index.html","hash":"6286067915679604a8c4e9317cf609df2b24623b","modified":1614184344965},{"_id":"public/tags/SpEL/index.html","hash":"8a0f119373986ed4b1a3f838ebf1940e091a989f","modified":1614184344965},{"_id":"public/tags/AOP/index.html","hash":"7a39d3817cdc4c6357f9bf0af7657b1009871094","modified":1614184344965},{"_id":"public/tags/test/index.html","hash":"5547a7e2fc21b5c6033384bfad76e4d057a7ebf8","modified":1614184344965},{"_id":"public/tags/SpringBoot/index.html","hash":"e6d2cc4765d99eb91663c6cad6ca07e92a04d6f0","modified":1614184344965},{"_id":"public/tags/validating/index.html","hash":"35ae292162bc438e45846bcf0d803bd25646ba80","modified":1614184344965},{"_id":"public/tags/data-binding/index.html","hash":"654050b796a06211c3254a3c8fa0d0dbff8c1862","modified":1614184344965},{"_id":"public/tags/type-conversion/index.html","hash":"98bca2684347e0d2bb819a33c402cfc5d4d77dd3","modified":1614184344965},{"_id":"public/tags/spring-boot/index.html","hash":"1e261e1dfd8c62d473603f97bee3e84f9467be1b","modified":1614184344965},{"_id":"public/tags/OS/index.html","hash":"1036dc477ee3450d31d147d979a62a7151422e79","modified":1614184344965},{"_id":"public/tags/Configuration/index.html","hash":"1a072bf3b5085408158ce8ec83e2c9a85919bae6","modified":1614184344965},{"_id":"public/tags/spring/index.html","hash":"ab36035a25e76eb9bc879d3c69936d7260600a35","modified":1614184344965},{"_id":"public/tags/SpringMVC/index.html","hash":"b1a77f0e12c49035db702cfe4b43b848ee8c3161","modified":1614184344965},{"_id":"public/2021/01/06/Mysql/InnoDB Transaction Model/index.html","hash":"acd9f5b33a5747fb0773a1c9bd74cfb53764ecd4","modified":1614184344965},{"_id":"public/2021/01/06/Mysql/InnoDB Transaction Isolation Level/index.html","hash":"428216209cc65322cd93dd2b56747a4f1d6d94c7","modified":1614184344965},{"_id":"public/2020/12/29/Mysql/InnoDB/index.html","hash":"021b456ede21645aa374c35323da956c604d2c14","modified":1614184344965},{"_id":"public/2020/12/10/Linux/shell/index.html","hash":"1554e0b1be494f35f9bb5852769b33d841659898","modified":1614184344965},{"_id":"public/2020/08/13/URI in Java/index.html","hash":"ddad73789a59e459d8cb690c918f3c0c18357d83","modified":1614184344965},{"_id":"public/2020/07/22/Spring/SpringBoot-SpringApplication/index.html","hash":"61aa52d9c86ec141a45c0e412c09b8a17c6e76a9","modified":1614184344965},{"_id":"public/2020/07/19/Spring/SpringBoot-ExternalizedConfiguration/index.html","hash":"eb27d5b7f4b143b54512ce301ca32ce22734aa5d","modified":1614184344965},{"_id":"public/2020/05/12/Linux/linux/index.html","hash":"53efdc017413bfde56ba728ae4a0ed51d0b934ec","modified":1614184344965},{"_id":"public/2020/04/21/Spring/Spring-Test/index.html","hash":"78d3f907301b269e0eaa053d222b21b29149845f","modified":1614184344965},{"_id":"public/2020/04/15/Spring/Validation_databinding_typeConversion/index.html","hash":"e0a1110b895637c97fe8d6d9045b933332d7d33e","modified":1614184344965},{"_id":"public/2020/04/10/Spring/spring boot/index.html","hash":"b3f69f230437fdd1e2c0975240e151a9f4a0e8fd","modified":1614184344965},{"_id":"public/2018/11/26/Spring/Spring-AOP/index.html","hash":"a4ef2a10d903058ca9d28c197cb5668ba4729d4d","modified":1614184344965},{"_id":"public/2018/11/01/Mysql/mysql/index.html","hash":"dc479338c9f5c606bf0e2c8fec15a909fcd2ef78","modified":1614184344965},{"_id":"public/2017/09/15/Spring/Spring IOC/index.html","hash":"dfb410e20ec435f6c40594d8e7cf0165d9dec005","modified":1614184344965},{"_id":"public/2017/08/23/Spring/Spring_Bean/index.html","hash":"8a42eb7b2aa328d794c469a4ea9dcd7b479b9b92","modified":1614184344965},{"_id":"public/2017/08/20/Spring/springMVC/index.html","hash":"94cf6f8dcffa003b09ed17f198818b10e23aaae3","modified":1614184344965},{"_id":"public/2017/08/15/Spring/spring/index.html","hash":"7bdeafa07adeb1ce8ac5b44d398db6638058d1b7","modified":1614184344965},{"_id":"public/archives/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/page/2/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/page/3/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/page/4/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2017/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2017/04/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2017/08/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2017/09/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2018/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2018/09/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2018/11/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2019/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2019/01/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/page/2/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/04/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/05/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/06/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/07/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/08/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/09/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/10/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/11/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2020/12/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2021/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2021/01/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/archives/2021/02/index.html","hash":"77dcd098658c2bad91a652330bdda084680c2ad3","modified":1614184344965},{"_id":"public/index.html","hash":"c92a2b29bd982c7610b7504fd248478f0fe04deb","modified":1614184344965},{"_id":"public/page/2/index.html","hash":"a7e449f2aef7b839d24f57d78bf68a7f67e54288","modified":1614184344965},{"_id":"public/page/3/index.html","hash":"b59b0d453ed80a8e89c3ca2510080088fc774343","modified":1614184344965},{"_id":"public/img/git.png","hash":"558c5b3217f5613b3d6fbb7b27aaf2e68427fde9","modified":1614184344965},{"_id":"public/pictures/favicon.png","hash":"6fdaed0f07d1905a4246e43a56d01292ce76dead","modified":1614184344965},{"_id":"public/pictures/favicon2.png","hash":"0241b4b8c5773b4d14871357c475863105a0202a","modified":1614184344965},{"_id":"public/pictures/git_comtribute_statistics.png","hash":"f38955532b3316b2ad0d023b9ce65ccb8b9def8e","modified":1614184344965},{"_id":"public/pictures/proud_busty.jpg","hash":"57504c52c414f2a96a71a8a12fc11405d839ca62","modified":1614184344965},{"_id":"public/pictures/wizIcon_icons_l.png","hash":"23c416d47db74b4352f23a104b31c4f4c2255ca3","modified":1614184344965},{"_id":"public/img/Logarithmic Function/Logarithmic Function.jpg","hash":"5c38373d59779d5b2e31bb6471c35bfd93fe9b88","modified":1614184344965},{"_id":"public/pictures/balloonl_girl.JPG","hash":"03bd522e74cb0048870a287f4c97cd2e7e0437ce","modified":1614184344965},{"_id":"public/pictures/koluo.jpg","hash":"041f6947ac99fabec2ca47940d08a261927e4d18","modified":1614184344965},{"_id":"public/img/WuJun/Bigaso's wife.jpg","hash":"b098e7160957aefc73cf28d8f08bdf244c41eee9","modified":1614184344965},{"_id":"public/img/WuJun/Bigaso's younth work.jpg","hash":"821ccf2a3356fb96ab18f562fb7c966d9c8dd9b5","modified":1614184344965},{"_id":"public/img/WuJun/Gerneca.jpg","hash":"662035925a746fdd8017e9591aeaf3b7a783ce16","modified":1614184344965},{"_id":"public/img/WuJun/Persistense of Memory.jpg","hash":"39653fbf5ca171cadc8dd73d6aa78876eabbfd82","modified":1614184344965},{"_id":"public/img/WuJun/old guitarist.jpg","hash":"fc778f80178e28e67f5158855d8918892c2077fd","modified":1614184344965},{"_id":"public/img/justice-league/GalGadot.jpg","hash":"e29bd6ea141fb7c95086f982dc6c7d6e34c345be","modified":1614184344965},{"_id":"public/img/my_pictures/office.jpg","hash":"6ec6d64389fd7d69e0dfd3b658885f60d916a51f","modified":1614184344965},{"_id":"public/img/my_pictures/office2.jpg","hash":"fadfa2125f07403c7f76565286213fc88469ef68","modified":1614184344965},{"_id":"public/img/my_pictures/office3.jpg","hash":"6464d9057fcec86b4f9f2d8868dd274fc324ffa2","modified":1614184344965},{"_id":"public/pictures/graduate/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (6).jpg","hash":"d519e0e2753280c17077ad991620697ff50cbb54","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (7).jpg","hash":"6049631b863faa9d15e13969dcb4f0d5a7d6eb06","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (9).jpg","hash":"ab5f05cb38cdc9cccfda02ab699832da3e8730eb","modified":1614184344965},{"_id":"public/img/WuJun/Les Demoiselles d'Avignon.jpg","hash":"9cbf61a80431926a948d36bbfa75665838fbdc43","modified":1614184344965},{"_id":"public/img/sql/join.jpg","hash":"7e8dcf63bd75e009e21d41fd925d8a732e7eef33","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (2).jpg","hash":"9a1d61ec2bd4757385bd37ab54a5db38b951e40a","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (4).jpg","hash":"41ae23e2347da71772c3def3117313a139aa30e2","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (5).jpg","hash":"e7fdac56041ce3a7b71b08578650ff57dd261c5c","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (8).jpg","hash":"9ce1ede4311c58dbe43beba932abe7dc14a54386","modified":1614184344965},{"_id":"public/pictures/graduate/graduate(1).jpg","hash":"feffe2fdebfc02e09bef0b31cda966ea1e2595f0","modified":1614184344965},{"_id":"public/js/index.js","hash":"907faae45c668d3650efa971da364dddb674fb19","modified":1614184344965},{"_id":"public/css/common/third-part.css","hash":"8985828afde1f77b827454b29318ab91dac9155e","modified":1614184344965},{"_id":"public/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1614184344965},{"_id":"public/pictures/landscape_banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1614184344965},{"_id":"public/pictures/programmer.jpg","hash":"cd8637c3171e7c14d5caff965c681077d97e2dcf","modified":1614184344965},{"_id":"public/img/Logarithmic Function/数学公式写法.png","hash":"f05b231183aa199fee57b07b1931f2fb00488dee","modified":1614184344965},{"_id":"public/pictures/theMoonEarth.jpg","hash":"5af1ab5da9cceb8349d7b039fd1a9fe5d490545d","modified":1614184344965},{"_id":"public/img/justice-league/Cyborg.jpg","hash":"0ba90dbb39b24b0fe1b8cfdf26b26f94ecdd076b","modified":1614184344965},{"_id":"public/pictures/baahuballi/17502766.png","hash":"b73f374ff1220537e956fba32d5220b46c980b7a","modified":1614184344965},{"_id":"public/pictures/FAQ.pdf","hash":"0ae0ec0efd0b753c6a2208fb90114b4a1a4a961b","modified":1614184344965},{"_id":"public/pictures/腾讯云建站.pdf","hash":"18afaabfea736c10265be95e914ffc29fd10b62b","modified":1614184344965},{"_id":"public/pictures/baahuballi/11221463.png","hash":"a451ca5854ee5a506946f7d6f4854a7ec09c72c7","modified":1614184344965},{"_id":"public/pictures/ex-gf.png","hash":"43a756da31a97bcf3b1f41de783cf65f38d6d99a","modified":1614184344965},{"_id":"public/img/ex-gf.png","hash":"43a756da31a97bcf3b1f41de783cf65f38d6d99a","modified":1614184344965},{"_id":"public/img/justice-league/Aquaman.jpg","hash":"1552b470d6e8af8dda97cfaa966beef396aba942","modified":1614184344965},{"_id":"public/pictures/baahuballi/11182994.png","hash":"9c7ed122c9fc534019587f3c110989c903a3f295","modified":1614184344965},{"_id":"public/pictures/baahuballi/18542294.png","hash":"829bd6bc148ce3b276ac3e1f38889e3425d42633","modified":1614184344965},{"_id":"public/pictures/baahuballi/17245146.png","hash":"6a7b42d874018e221da64b08541744afe5ff2905","modified":1614184344965},{"_id":"public/pictures/baahuballi/17288093.png","hash":"b44083ef2feed4a24bc646de05d7f24e79dd143f","modified":1614184344965},{"_id":"public/pictures/baahuballi/17645928.png","hash":"2d163a37eee0c37991898025aa311bc3e04e2b9c","modified":1614184344965},{"_id":"public/pictures/kangshan.xyz.certificate.jpg","hash":"93d3284b462dab8441d9131dc92fe7f99273f8c0","modified":1614184344965},{"_id":"public/img/justice-league/BenAfflekAndGalGardot.jpg","hash":"2bfc18a3d431bea5f506316cb69dfa3b62f869c5","modified":1614184344965},{"_id":"public/img/justice-league/TheFlash.jpg","hash":"8ab600aa216ce1eb1617cf1588a79f0d1bf88f41","modified":1614184344965},{"_id":"public/img/justice-league/AmyAdams.jpg","hash":"693d7223b300133be3a4e146a8e18e45894a6cd0","modified":1614184344965},{"_id":"public/pictures/baahuballi/18317418.png","hash":"91d674852fdfbbae2922d7f5fa53a0ad2e3d5642","modified":1614184344965},{"_id":"public/pictures/baahuballi/18389475.png","hash":"dd5bc3acc974e2107a25daa18d0481f1e64ddf09","modified":1614184344965},{"_id":"public/pictures/baahuballi/18582573.png","hash":"ee500c032674ba835ad568ddb8744f478f57a5c0","modified":1614184344965},{"_id":"public/css/style.css","hash":"d5d3e91e459ded59106a7a36f65bc3490eef77e8","modified":1614184344965},{"_id":"public/pictures/Marvel 2018/mcu-calss-3.jpg","hash":"b7685db7c11c9d1669210e4709e6b719cf42f757","modified":1614184344965},{"_id":"public/pictures/baahuballi/18555258.png","hash":"da1f9e42bdff2773d7e0134b35ea270bd7a2d85f","modified":1614184344965},{"_id":"public/pictures/baahuballi/18601933.png","hash":"f1d822b8cd8a4f25ca7b148ec5165cb4944dcece","modified":1614184344965},{"_id":"public/pictures/baahuballi/18425543.png","hash":"750fde6216bedea34e0199b7b77af9bb11ee8b4b","modified":1614184344965},{"_id":"public/pictures/baahuballi/18441408.png","hash":"dab35b4024db134b58ff552fa2d876dcb1e61afe","modified":1614184344965},{"_id":"public/pictures/baahuballi/17705988.png","hash":"4037bd553c3c711961353b039884ac1f5cbf4ec2","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (7).png","hash":"3743b2714129d633b983414168e0f3e776e07ead","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (8).png","hash":"e42a5dfdf29d991bcdc6ed3de4a2d771df32906e","modified":1614184344965},{"_id":"public/img/justice-league/Justice-league.jpg","hash":"e9fccfc0eda315a77997ee87b70843f2e41a0029","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (1).png","hash":"aa56016fff76a884c518e0c57d0942550d7add5a","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (2).png","hash":"728e92a94b88edad81902fc7e873f2efa2d3c942","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (6).png","hash":"e2ce3439ed3bb881ca04eb292d5292b8db9ffc66","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (3).png","hash":"2ec4d43a828e3ca04b095bc64513c7c55046217e","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (5).png","hash":"81c21b913ff1e615d4a7526d11cc9e8f77e2ef62","modified":1614184344965},{"_id":"public/pictures/graduate/graduate (9).png","hash":"afdff7312502274a04a2a1111debd660a7acfd69","modified":1614184344965},{"_id":"public/pictures/baahuballi/d9c21860-478d-4777-bf24-b6e1774d4368.png","hash":"74154388f1b3a9883cd1613611ecebfcc8b159ac","modified":1614184344965},{"_id":"public/pictures/baahuballi/14823355.png","hash":"aaa6cbf9b241cac79e48e1496879f197eafbd87a","modified":1614184344965},{"_id":"public/pictures/baahuballi/17676676.png","hash":"04ce85f010ef321ca5817ccda53e9e4a8e4b0f98","modified":1614184344965},{"_id":"public/pictures/Marvel 2018/mcuphoto.jpg","hash":"c8c6e090de93ca87b9b6c734e9682e29459c636c","modified":1614184344965},{"_id":"public/pictures/baahuballi/a81563ee-ec3a-417e-8089-e1bb5b0a3fcd.png","hash":"03f92bf382ae372d46c26a8a3f258276eb5c1164","modified":1614184344965},{"_id":"public/pictures/baahuballi/17655319.png","hash":"277a5668573793d034736b7380d5534fb404e67a","modified":1614184344965},{"_id":"public/pictures/Marvel 2018/Marvel.jpg","hash":"d2636b94ea9f85f01aeda9e03b721720cc8245c1","modified":1614184344965}],"Category":[{"name":"Java","_id":"ckljnokqe00042bhb7ca6c5od"},{"name":"Linux","_id":"ckljnokr300142bhbbn8n86bx"},{"name":"Mysql","_id":"ckljnokra001k2bhb6eyjcotx"},{"name":"Shell","parent":"ckljnokr300142bhbbn8n86bx","_id":"ckljnokro00282bhb489c5qvr"},{"name":"Spring","_id":"ckljnokru002m2bhb115qgdd0"},{"name":"AOP","_id":"ckljnokrw002s2bhb06gv3c4p"},{"name":"SpringBoot","_id":"ckljnokry00322bhb5aygcpuw"}],"Data":[],"Page":[{"title":"categories","date":"2021-02-21T16:05:59.000Z","categories":[],"tags":[],"_content":"layout: categories\n\nJava\nSpring\nAOP\nIoC\n\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-02-22 00:05:59\ncategories: []\ntags: []\n---\nlayout: categories\n\nJava\nSpring\nAOP\nIoC\n\n","updated":"2021-02-24T15:37:17.046Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckljnokq400002bhbc5mphc5c","content":"<p>layout: categories</p>\n<p>Java<br>Spring<br>AOP<br>IoC</p>\n","site":{"data":{}},"excerpt":"","more":"<p>layout: categories</p>\n<p>Java<br>Spring<br>AOP<br>IoC</p>\n"},{"title":"about","date":"2021-02-24T14:46:46.000Z","categories":[],"tags":[],"_content":"\n> 后端攻城狮一名,主攻 Java .在此分享一些自己学习笔记.\n> \n> **Email**:kangshan9988@gmail.com\n\n- 所用技术栈: [github](https://github.com/KangShanR/kangshanr.github.io) + [hexo](https://hexo.io/) 搭建.\n- Hexo 主题 [sky](https://github.com/iJinxin/hexo-theme-sky).*(致谢*[iJinxin](https://github.com/iJinxin)).\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-02-24 22:46:46\ncategories: []\ntags: []\n---\n\n> 后端攻城狮一名,主攻 Java .在此分享一些自己学习笔记.\n> \n> **Email**:kangshan9988@gmail.com\n\n- 所用技术栈: [github](https://github.com/KangShanR/kangshanr.github.io) + [hexo](https://hexo.io/) 搭建.\n- Hexo 主题 [sky](https://github.com/iJinxin/hexo-theme-sky).*(致谢*[iJinxin](https://github.com/iJinxin)).\n","updated":"2021-02-24T16:29:02.193Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckljnokqb00022bhbaopg4cuq","content":"<blockquote>\n<p>后端攻城狮一名,主攻 Java .在此分享一些自己学习笔记.</p>\n<p><strong>Email</strong>:kangshan9988@gmail.com</p>\n</blockquote>\n<ul>\n<li>所用技术栈: <a href=\"https://github.com/KangShanR/kangshanr.github.io\">github</a> + <a href=\"https://hexo.io/\">hexo</a> 搭建.</li>\n<li>Hexo 主题 <a href=\"https://github.com/iJinxin/hexo-theme-sky\">sky</a>.<em>(致谢</em><a href=\"https://github.com/iJinxin\">iJinxin</a>).</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>后端攻城狮一名,主攻 Java .在此分享一些自己学习笔记.</p>\n<p><strong>Email</strong>:kangshan9988@gmail.com</p>\n</blockquote>\n<ul>\n<li>所用技术栈: <a href=\"https://github.com/KangShanR/kangshanr.github.io\">github</a> + <a href=\"https://hexo.io/\">hexo</a> 搭建.</li>\n<li>Hexo 主题 <a href=\"https://github.com/iJinxin/hexo-theme-sky\">sky</a>.<em>(致谢</em><a href=\"https://github.com/iJinxin\">iJinxin</a>).</li>\n</ul>\n"},{"_content":"<html>\n<head>\n<title>HELLO WORLD</title>\n</head>\n<body>\n<body style=\"background-color:black\">\n<h1 style=\"color:white\">THIS IS YAN</h1>\n<p style=\"color:white\">NICE TO MEET U.THIS IS MY VERY FIRST CODE.</p>\n<hr />\n<!--这是一篇日记。-->\n<h2 style=\"color:006633\">2019年4月28日</h2>\n<p style=\"color:white\">今天是星期天，但是我还在上班。所有人都在上班。</p>\n<p style=\"color:white\">我早上听了一首歌，一首让人想流泪的歌。</p>\n<p style=\"color:white\">可能不止是这一首，是每一首。</p>\n<p style=\"color:white\">我脑子里搭配的画面全都来自丰子恺。</p>\n<p style=\"color:white\">还有那篇林海音的课文。“爸爸的花儿落了，我也不再是小孩子了。”</p>\n<br />\n<img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556454275490&di=b5f9c76ede8c2210130d3116a2abbafc&imgtype=0&src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5dd4c97b59902451f2732455564f842f4fddda351189b-wW22Z9_fw658\" />\n<br />\n<a href style=\"color:white\"><http://music.163.com/song?id=365623&userid=257390937\">你想听吗？点这里</a>\n\n</body>\n</html>","source":"img/HELLO.html","raw":"<html>\n<head>\n<title>HELLO WORLD</title>\n</head>\n<body>\n<body style=\"background-color:black\">\n<h1 style=\"color:white\">THIS IS YAN</h1>\n<p style=\"color:white\">NICE TO MEET U.THIS IS MY VERY FIRST CODE.</p>\n<hr />\n<!--这是一篇日记。-->\n<h2 style=\"color:006633\">2019年4月28日</h2>\n<p style=\"color:white\">今天是星期天，但是我还在上班。所有人都在上班。</p>\n<p style=\"color:white\">我早上听了一首歌，一首让人想流泪的歌。</p>\n<p style=\"color:white\">可能不止是这一首，是每一首。</p>\n<p style=\"color:white\">我脑子里搭配的画面全都来自丰子恺。</p>\n<p style=\"color:white\">还有那篇林海音的课文。“爸爸的花儿落了，我也不再是小孩子了。”</p>\n<br />\n<img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556454275490&di=b5f9c76ede8c2210130d3116a2abbafc&imgtype=0&src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5dd4c97b59902451f2732455564f842f4fddda351189b-wW22Z9_fw658\" />\n<br />\n<a href style=\"color:white\"><http://music.163.com/song?id=365623&userid=257390937\">你想听吗？点这里</a>\n\n</body>\n</html>","date":"2021-02-21T15:20:44.035Z","updated":"2021-01-01T04:28:19.295Z","path":"img/HELLO.html","title":"","comments":1,"layout":"page","_id":"ckljnokqh00062bhb3x4c04n5","content":"<html>\n<head>\n<title>HELLO WORLD</title>\n</head>\n<body>\n<body style=\"background-color:black\">\n<h1 style=\"color:white\">THIS IS YAN</h1>\n<p style=\"color:white\">NICE TO MEET U.THIS IS MY VERY FIRST CODE.</p>\n<hr />\n<!--这是一篇日记。-->\n<h2 style=\"color:006633\">2019年4月28日</h2>\n<p style=\"color:white\">今天是星期天，但是我还在上班。所有人都在上班。</p>\n<p style=\"color:white\">我早上听了一首歌，一首让人想流泪的歌。</p>\n<p style=\"color:white\">可能不止是这一首，是每一首。</p>\n<p style=\"color:white\">我脑子里搭配的画面全都来自丰子恺。</p>\n<p style=\"color:white\">还有那篇林海音的课文。“爸爸的花儿落了，我也不再是小孩子了。”</p>\n<br />\n<img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556454275490&di=b5f9c76ede8c2210130d3116a2abbafc&imgtype=0&src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5dd4c97b59902451f2732455564f842f4fddda351189b-wW22Z9_fw658\" />\n<br />\n<a href style=\"color:white\"><http://music.163.com/song?id=365623&userid=257390937\">你想听吗？点这里</a>\n\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<html>\n<head>\n<title>HELLO WORLD</title>\n</head>\n<body>\n<body style=\"background-color:black\">\n<h1 style=\"color:white\">THIS IS YAN</h1>\n<p style=\"color:white\">NICE TO MEET U.THIS IS MY VERY FIRST CODE.</p>\n<hr />\n<!--这是一篇日记。-->\n<h2 style=\"color:006633\">2019年4月28日</h2>\n<p style=\"color:white\">今天是星期天，但是我还在上班。所有人都在上班。</p>\n<p style=\"color:white\">我早上听了一首歌，一首让人想流泪的歌。</p>\n<p style=\"color:white\">可能不止是这一首，是每一首。</p>\n<p style=\"color:white\">我脑子里搭配的画面全都来自丰子恺。</p>\n<p style=\"color:white\">还有那篇林海音的课文。“爸爸的花儿落了，我也不再是小孩子了。”</p>\n<br />\n<img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556454275490&di=b5f9c76ede8c2210130d3116a2abbafc&imgtype=0&src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5dd4c97b59902451f2732455564f842f4fddda351189b-wW22Z9_fw658\" />\n<br />\n<a href style=\"color:white\"><http://music.163.com/song?id=365623&userid=257390937\">你想听吗？点这里</a>\n\n</body>\n</html>"},{"title":"tags","date":"2021-02-21T16:05:30.000Z","categories":[],"tags":[],"_content":"\nJava\nSpring\nAOP\nIoC","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-02-22 00:05:30\ncategories: []\ntags: []\n---\n\nJava\nSpring\nAOP\nIoC","updated":"2021-02-24T15:49:25.733Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckljnokqj00082bhb5xch2y20","content":"<p>Java<br>Spring<br>AOP<br>IoC</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Java<br>Spring<br>AOP<br>IoC</p>\n"}],"Post":[{"title":"Hash","layout":"post","date":"2017-04-13T07:02:43.000Z","description":"hash function && hash table","_content":"\nHash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。<!--more-->\n\n## .1. Map\n\n- map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；\n- Map中键对象不允许重复，且键的唯一性很重要；\n- 不建议将多个键映射到同一个值对象；\n- Map接口下有的实现集合类有：\n    - HashMap，用到了哈希码的算法，以便快速查找一个键；\n    - TreeMap，其键按序存放\n    - HashTable，是 Dictionary 的子类，与 HashMap 类似；\n\n## .2. HashMap\n\n[reference](https://www.jianshu.com/p/c658df4f4c77)\n\n- HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：\n\n```java\n/**\n* Computes key.hashCode() and spreads (XORs) higher bits of hash\n* to lower.  Because the table uses power-of-two masking, sets of\n* hashes that vary only in bits above the current mask will\n* always collide. (Among known examples are sets of Float keys\n* holding consecutive whole numbers in small tables.)  So we\n* apply a transform that spreads the impact of higher bits\n* downward. There is a tradeoff between speed, utility, and\n* quality of bit-spreading. Because many common sets of hashes\n* are already reasonably distributed (so don't benefit from\n* spreading), and because we use trees to handle large sets of\n* collisions in bins, we just XOR some shifted bits in the\n* cheapest possible way to reduce systematic lossage, as well as\n* to incorporate impact of the highest bits that would otherwise\n* never be used in index calculations because of table bounds.\n*/\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n- 如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。\n- HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。\n- HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 `hash & (capacity - 1)` 得到 bucket 下标。\n    - 之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （`10000` 的形式），`(capacity - 1)` 就会是 `1111` 的形式，而其与 hash 值进行 `&` 运算就刚好得到 hash 的模。\n    - 为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：\n\n    ```java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n## .3. HashTable 与 HashMap 的区别\n\n- 底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。\n- HashTable 为同步的，可以保证一定的线程安全。\n","source":"_posts/Hash.md","raw":"---\ntitle: Hash\nlayout: post\ndate: 2017-04-13 15:02:43\ncategories: [Java]\ntags: [programming,java, HashMap]\ndescription: hash function && hash table\n---\n\nHash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。<!--more-->\n\n## .1. Map\n\n- map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；\n- Map中键对象不允许重复，且键的唯一性很重要；\n- 不建议将多个键映射到同一个值对象；\n- Map接口下有的实现集合类有：\n    - HashMap，用到了哈希码的算法，以便快速查找一个键；\n    - TreeMap，其键按序存放\n    - HashTable，是 Dictionary 的子类，与 HashMap 类似；\n\n## .2. HashMap\n\n[reference](https://www.jianshu.com/p/c658df4f4c77)\n\n- HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：\n\n```java\n/**\n* Computes key.hashCode() and spreads (XORs) higher bits of hash\n* to lower.  Because the table uses power-of-two masking, sets of\n* hashes that vary only in bits above the current mask will\n* always collide. (Among known examples are sets of Float keys\n* holding consecutive whole numbers in small tables.)  So we\n* apply a transform that spreads the impact of higher bits\n* downward. There is a tradeoff between speed, utility, and\n* quality of bit-spreading. Because many common sets of hashes\n* are already reasonably distributed (so don't benefit from\n* spreading), and because we use trees to handle large sets of\n* collisions in bins, we just XOR some shifted bits in the\n* cheapest possible way to reduce systematic lossage, as well as\n* to incorporate impact of the highest bits that would otherwise\n* never be used in index calculations because of table bounds.\n*/\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n- 如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。\n- HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。\n- HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 `hash & (capacity - 1)` 得到 bucket 下标。\n    - 之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （`10000` 的形式），`(capacity - 1)` 就会是 `1111` 的形式，而其与 hash 值进行 `&` 运算就刚好得到 hash 的模。\n    - 为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：\n\n    ```java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n## .3. HashTable 与 HashMap 的区别\n\n- 底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。\n- HashTable 为同步的，可以保证一定的线程安全。\n","slug":"Hash","published":1,"updated":"2021-02-24T16:07:38.350Z","comments":1,"photos":[],"link":"","_id":"ckljnokq800012bhb0hdwauqj","content":"<p>Hash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。<span id=\"more\"></span></p>\n<h2 id=\"1-Map\"><a href=\"#1-Map\" class=\"headerlink\" title=\".1. Map\"></a>.1. Map</h2><ul>\n<li>map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；</li>\n<li>Map中键对象不允许重复，且键的唯一性很重要；</li>\n<li>不建议将多个键映射到同一个值对象；</li>\n<li>Map接口下有的实现集合类有：<ul>\n<li>HashMap，用到了哈希码的算法，以便快速查找一个键；</li>\n<li>TreeMap，其键按序存放</li>\n<li>HashTable，是 Dictionary 的子类，与 HashMap 类似；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-HashMap\"><a href=\"#2-HashMap\" class=\"headerlink\" title=\".2. HashMap\"></a>.2. HashMap</h2><p><a href=\"https://www.jianshu.com/p/c658df4f4c77\">reference</a></p>\n<ul>\n<li>HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class=\"line\"><span class=\"comment\">* to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class=\"line\"><span class=\"comment\">* hashes that vary only in bits above the current mask will</span></span><br><span class=\"line\"><span class=\"comment\">* always collide. (Among known examples are sets of Float keys</span></span><br><span class=\"line\"><span class=\"comment\">* holding consecutive whole numbers in small tables.)  So we</span></span><br><span class=\"line\"><span class=\"comment\">* apply a transform that spreads the impact of higher bits</span></span><br><span class=\"line\"><span class=\"comment\">* downward. There is a tradeoff between speed, utility, and</span></span><br><span class=\"line\"><span class=\"comment\">* quality of bit-spreading. Because many common sets of hashes</span></span><br><span class=\"line\"><span class=\"comment\">* are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class=\"line\"><span class=\"comment\">* spreading), and because we use trees to handle large sets of</span></span><br><span class=\"line\"><span class=\"comment\">* collisions in bins, we just XOR some shifted bits in the</span></span><br><span class=\"line\"><span class=\"comment\">* cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class=\"line\"><span class=\"comment\">* to incorporate impact of the highest bits that would otherwise</span></span><br><span class=\"line\"><span class=\"comment\">* never be used in index calculations because of table bounds.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。</p>\n</li>\n<li><p>HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。</p>\n</li>\n<li><p>HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 <code>hash &amp; (capacity - 1)</code> 得到 bucket 下标。</p>\n<ul>\n<li><p>之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （<code>10000</code> 的形式），<code>(capacity - 1)</code> 就会是 <code>1111</code> 的形式，而其与 hash 值进行 <code>&amp;</code> 运算就刚好得到 hash 的模。</p>\n</li>\n<li><p>为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-HashTable-与-HashMap-的区别\"><a href=\"#3-HashTable-与-HashMap-的区别\" class=\"headerlink\" title=\".3. HashTable 与 HashMap 的区别\"></a>.3. HashTable 与 HashMap 的区别</h2><ul>\n<li>底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。</li>\n<li>HashTable 为同步的，可以保证一定的线程安全。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Hash 算法应用在 Java 集合框架。其中 HashTable 基本实现数据结构的 HashTable 。HashMap 的底层有 HashTable 同时也有红黑树。HashSet 的内部就是一个HashMap 。","more":"</p>\n<h2 id=\"1-Map\"><a href=\"#1-Map\" class=\"headerlink\" title=\".1. Map\"></a>.1. Map</h2><ul>\n<li>map接口：是一种将键对象和值对象进行关联的容器，而且值对象可以是另一个Map，这样类推下去可以形成多级映射；</li>\n<li>Map中键对象不允许重复，且键的唯一性很重要；</li>\n<li>不建议将多个键映射到同一个值对象；</li>\n<li>Map接口下有的实现集合类有：<ul>\n<li>HashMap，用到了哈希码的算法，以便快速查找一个键；</li>\n<li>TreeMap，其键按序存放</li>\n<li>HashTable，是 Dictionary 的子类，与 HashMap 类似；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-HashMap\"><a href=\"#2-HashMap\" class=\"headerlink\" title=\".2. HashMap\"></a>.2. HashMap</h2><p><a href=\"https://www.jianshu.com/p/c658df4f4c77\">reference</a></p>\n<ul>\n<li>HashMap 中，其 hash 算法是在引用 Object 的 hash 方法后再对进行了额外的位运算：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class=\"line\"><span class=\"comment\">* to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class=\"line\"><span class=\"comment\">* hashes that vary only in bits above the current mask will</span></span><br><span class=\"line\"><span class=\"comment\">* always collide. (Among known examples are sets of Float keys</span></span><br><span class=\"line\"><span class=\"comment\">* holding consecutive whole numbers in small tables.)  So we</span></span><br><span class=\"line\"><span class=\"comment\">* apply a transform that spreads the impact of higher bits</span></span><br><span class=\"line\"><span class=\"comment\">* downward. There is a tradeoff between speed, utility, and</span></span><br><span class=\"line\"><span class=\"comment\">* quality of bit-spreading. Because many common sets of hashes</span></span><br><span class=\"line\"><span class=\"comment\">* are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class=\"line\"><span class=\"comment\">* spreading), and because we use trees to handle large sets of</span></span><br><span class=\"line\"><span class=\"comment\">* collisions in bins, we just XOR some shifted bits in the</span></span><br><span class=\"line\"><span class=\"comment\">* cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class=\"line\"><span class=\"comment\">* to incorporate impact of the highest bits that would otherwise</span></span><br><span class=\"line\"><span class=\"comment\">* never be used in index calculations because of table bounds.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如此做法：将高 16 位的 hashCode 与 hashCode 低 16 位进行 XOR (异或) 位运算。这样能保证结果高 16 位为 0 ，而低 16 位还不明白是如何保证 hashCode 不会冲突的。</p>\n</li>\n<li><p>HashTable 中直接对 HashCode 按 capacity 取模，而 HashMap 中其 threshold 并不单指总 Entry 数量阈值，在其初始化时指下一次 resize() capacity 的目标值。</p>\n</li>\n<li><p>HashTable 严格按时 HashTable 数据结构来定义，使用 Object hashCode() 计算其 hash 值，并按桶数量取模放置各个值入 HashTable 中。而在 HashMap 中，其对 Key 的 hash 值进入了高 16 位与低 16 位的或运算作为最终 hash 值，同时，在放置 Node 时，也并不是直接取模，使用 <code>hash &amp; (capacity - 1)</code> 得到 bucket 下标。</p>\n<ul>\n<li><p>之所以能使用此种位运算获取到 bucket 下标，因为其桶数量 capacity 始终是 2 的次冥 （<code>10000</code> 的形式），<code>(capacity - 1)</code> 就会是 <code>1111</code> 的形式，而其与 hash 值进行 <code>&amp;</code> 运算就刚好得到 hash 的模。</p>\n</li>\n<li><p>为了保持其 capacity 为 2 的多次冥的形式，HashMap 中使用方法专门做些事：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-HashTable-与-HashMap-的区别\"><a href=\"#3-HashTable-与-HashMap-的区别\" class=\"headerlink\" title=\".3. HashTable 与 HashMap 的区别\"></a>.3. HashTable 与 HashMap 的区别</h2><ul>\n<li>底层基本与 HashMap 一致，初始都是使用 HashTable 算法，使用链表来解决 Hash Collision 。但 HashMap 更高明的算法在于，其中链表长度超过阈值 8 就链表会转为红黑树，这也避免了整个 HashTable 退化成一个 链表。</li>\n<li>HashTable 为同步的，可以保证一定的线程安全。</li>\n</ul>"},{"title":"URI in Java","layout":"post","date":"2020-08-13T03:14:00.000Z","description":"java URI class","_content":"\n> URI syntax and components [URI 语法与组件](https://www.ietf.org/rfc/rfc2396.txt)\n\nAt the highest level a URI reference (hereinafter simply \"URI\") in string form has the syntax `[scheme:]scheme-specific-part[#fragment]`<!--more-->\n\n## .1. URI 分类\n\n- opaque 模糊类：不以 slash character `/` 开头，不需要进一步解析。eg：\n    - mailto:java-net@java.sun.com\n    - ews:comp.lang.java\n    - urn:isbn:096139210x\n- hierarchical 层级类，要么 scheme-specific-part 以 slash character `/` 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。\n    - eg：\n        - http://java.sun.com/j2se/1.3/\n        - docs/guide/collections/designfaq.html#28\n        - ../../../demo/jfc/SwingSet2/src/SwingSet2.java\n        - file:///~/calendar\n    - 层级类的 URI 需要进一步解析，其解析语法是 `[scheme:][//authority][path][?query][#fragment]`\n        - 如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：`[user-info@]host[:port]`。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。\n        - path 组件如果以slash character `/` 开头，则表明其是绝对路径，否则是相对的。*The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.*\n\nAll told, then, a URI instance has the following nine components:\n\nDescribes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment\n\n|Component|Type|\n|--|--|\n|scheme|String|\n|scheme-specific-part|String|\n|authority|String|\n|user-info|String|\n|host|String|\n|port|int|\n|path|String|\n|query|String|\n|fragment|String|\n\n## .2. URL\n\nURL: Uniform Resource Locator.\n\nURL 与 URI 之间相互转换，使用方法： `URL.toURI()` 与 `URI.toURL()` 。\n\nURL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。\n\n## .3. URI 文档翻译\n\n[original doc](https://www.ietf.org/rfc/rfc2396.txt)\n\n> 文档语法：\n> This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in\n\n>      <first>/<second>;<third>?<fourth>\n\n> The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.\n> The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that \"|\" is used to designate alternatives.  Briefly, rules are separated from definitions by an equal \"=\", indentation is used to continue a rule definition over more than one line, literals are quoted with \"\", parentheses \"(\" and \")\" are used to group elements, optional elements are enclosed in \"[\" and \"]\" brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.\n> Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.\n\n### .3.1. 保留字符\n\n> reserved    = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\"$\" | \",\"\n\n如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。\n\n### .3.2. 非保留字符\n\n大小写字母数字与标点符号\n\n> unreserved  = alphanum | mark\n> mark        = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" | \"(\" | \")\"\n\n在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。\n\n### .3.3. 转义编码\n\n转义后的八进制符是由三个字符组成：`%` 加上两个十六进制字符。eg: `%20` 表示 ASCII 码 32 space。\n\n是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。\n\n### .3.4. 被排除的 ASCII 字符\n\n- 控制符 US-ASCII coded characters 00-1F, 7F hexadecimal\n- 空格 space US-ASCII coded character 20 hexadecimal\n- 分隔符 delims \"<\" | \">\" | \"#\" | \"%\" | <\"> 网关代理用于分隔符 \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"[\" | \"]\" | \"`\"\n\n## .4. URI 句法部件 （URI Syntactic Components）\n\nURI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： `<scheme>:<scheme-specific-part>`。使用的 scheme 后跟 `;` 再跟上一个意义解释取决于 scheme 的 String。\n\nURI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： `<scheme>://<authority><path>?<query>`。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 `<query>` 组件。\n\n`absoluteURI   = scheme \":\" ( hier_part | opaque_part )`\n\n本质上层级 URI 使用 slash `/` 分隔。某些文件系统同样使用 `/` 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。\n\n> hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n\n> net_path      = \"//\" authority [ abs_path ]\n\n> abs_path      = \"/\"  path_segments\n\nURI 不使用 `/` 分隔层级的话，将被通用 URI 解析器识别为不透明 'opaque'；\n\nopaque_part   = uric_no_slash *uric\n\nuric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\"&\" | \"=\" | \"+\" | \"$\" | \",\"\n\n使用 `<path>` 表示 `<abs_path>` 与 `<opaque_part>` 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。\n\n### .4.1. Scheme 组件\n\n如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。\n\nScheme 由小写字母、数字、plus `+`/period `.`/hyphen `-` 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。`scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )`。相对 URI 从 base URI 继承而来，不以 scheme 开头。\n\n### .4.2. Path 组件\n\n```\npath          = [ abs_path | opaque_part ]\n\npath_segments = segment *( \"/\" segment )\nsegment       = *pchar *( \";\" param )\nparam         = *pchar\n\npchar         = unreserved | escaped |\":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n```\n\n一个路径组件可由多个 segment 组成，segment 由 `/` 分隔。一个 segment 中，`/`,`?`,`=`,`;` 为保留字符。同时可由多个参数构成，参数之间使用 `;` 分隔。\n\n### .4.3. Query 组件\n\n>    The query component is a string of information to be interpreted by the resource.\n> \n> query         = *uric\n> \n> Within a query component, the characters \";\", \"/\", \"?\", \":\", \"@\", \"&\", \"=\", \"+\", \",\", and \"$\" are reserved.\n","source":"_posts/URI in Java.md","raw":"---\ntitle: URI in Java\nlayout: post\ndate: 2020-08-13 11:14:00\ntags: [framework,java,URI]\ncategories: [Java]\ndescription: java URI class\n---\n\n> URI syntax and components [URI 语法与组件](https://www.ietf.org/rfc/rfc2396.txt)\n\nAt the highest level a URI reference (hereinafter simply \"URI\") in string form has the syntax `[scheme:]scheme-specific-part[#fragment]`<!--more-->\n\n## .1. URI 分类\n\n- opaque 模糊类：不以 slash character `/` 开头，不需要进一步解析。eg：\n    - mailto:java-net@java.sun.com\n    - ews:comp.lang.java\n    - urn:isbn:096139210x\n- hierarchical 层级类，要么 scheme-specific-part 以 slash character `/` 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。\n    - eg：\n        - http://java.sun.com/j2se/1.3/\n        - docs/guide/collections/designfaq.html#28\n        - ../../../demo/jfc/SwingSet2/src/SwingSet2.java\n        - file:///~/calendar\n    - 层级类的 URI 需要进一步解析，其解析语法是 `[scheme:][//authority][path][?query][#fragment]`\n        - 如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：`[user-info@]host[:port]`。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。\n        - path 组件如果以slash character `/` 开头，则表明其是绝对路径，否则是相对的。*The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.*\n\nAll told, then, a URI instance has the following nine components:\n\nDescribes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment\n\n|Component|Type|\n|--|--|\n|scheme|String|\n|scheme-specific-part|String|\n|authority|String|\n|user-info|String|\n|host|String|\n|port|int|\n|path|String|\n|query|String|\n|fragment|String|\n\n## .2. URL\n\nURL: Uniform Resource Locator.\n\nURL 与 URI 之间相互转换，使用方法： `URL.toURI()` 与 `URI.toURL()` 。\n\nURL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。\n\n## .3. URI 文档翻译\n\n[original doc](https://www.ietf.org/rfc/rfc2396.txt)\n\n> 文档语法：\n> This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in\n\n>      <first>/<second>;<third>?<fourth>\n\n> The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.\n> The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that \"|\" is used to designate alternatives.  Briefly, rules are separated from definitions by an equal \"=\", indentation is used to continue a rule definition over more than one line, literals are quoted with \"\", parentheses \"(\" and \")\" are used to group elements, optional elements are enclosed in \"[\" and \"]\" brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.\n> Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.\n\n### .3.1. 保留字符\n\n> reserved    = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\"$\" | \",\"\n\n如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。\n\n### .3.2. 非保留字符\n\n大小写字母数字与标点符号\n\n> unreserved  = alphanum | mark\n> mark        = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" | \"(\" | \")\"\n\n在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。\n\n### .3.3. 转义编码\n\n转义后的八进制符是由三个字符组成：`%` 加上两个十六进制字符。eg: `%20` 表示 ASCII 码 32 space。\n\n是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。\n\n### .3.4. 被排除的 ASCII 字符\n\n- 控制符 US-ASCII coded characters 00-1F, 7F hexadecimal\n- 空格 space US-ASCII coded character 20 hexadecimal\n- 分隔符 delims \"<\" | \">\" | \"#\" | \"%\" | <\"> 网关代理用于分隔符 \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"[\" | \"]\" | \"`\"\n\n## .4. URI 句法部件 （URI Syntactic Components）\n\nURI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： `<scheme>:<scheme-specific-part>`。使用的 scheme 后跟 `;` 再跟上一个意义解释取决于 scheme 的 String。\n\nURI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： `<scheme>://<authority><path>?<query>`。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 `<query>` 组件。\n\n`absoluteURI   = scheme \":\" ( hier_part | opaque_part )`\n\n本质上层级 URI 使用 slash `/` 分隔。某些文件系统同样使用 `/` 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。\n\n> hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n\n> net_path      = \"//\" authority [ abs_path ]\n\n> abs_path      = \"/\"  path_segments\n\nURI 不使用 `/` 分隔层级的话，将被通用 URI 解析器识别为不透明 'opaque'；\n\nopaque_part   = uric_no_slash *uric\n\nuric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\"&\" | \"=\" | \"+\" | \"$\" | \",\"\n\n使用 `<path>` 表示 `<abs_path>` 与 `<opaque_part>` 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。\n\n### .4.1. Scheme 组件\n\n如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。\n\nScheme 由小写字母、数字、plus `+`/period `.`/hyphen `-` 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。`scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )`。相对 URI 从 base URI 继承而来，不以 scheme 开头。\n\n### .4.2. Path 组件\n\n```\npath          = [ abs_path | opaque_part ]\n\npath_segments = segment *( \"/\" segment )\nsegment       = *pchar *( \";\" param )\nparam         = *pchar\n\npchar         = unreserved | escaped |\":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n```\n\n一个路径组件可由多个 segment 组成，segment 由 `/` 分隔。一个 segment 中，`/`,`?`,`=`,`;` 为保留字符。同时可由多个参数构成，参数之间使用 `;` 分隔。\n\n### .4.3. Query 组件\n\n>    The query component is a string of information to be interpreted by the resource.\n> \n> query         = *uric\n> \n> Within a query component, the characters \";\", \"/\", \"?\", \":\", \"@\", \"&\", \"=\", \"+\", \",\", and \"$\" are reserved.\n","slug":"URI in Java","published":1,"updated":"2021-02-24T15:22:23.312Z","comments":1,"photos":[],"link":"","_id":"ckljnokqc00032bhb79va8ox5","content":"<blockquote>\n<p>URI syntax and components <a href=\"https://www.ietf.org/rfc/rfc2396.txt\">URI 语法与组件</a></p>\n</blockquote>\n<p>At the highest level a URI reference (hereinafter simply “URI”) in string form has the syntax <code>[scheme:]scheme-specific-part[#fragment]</code><span id=\"more\"></span></p>\n<h2 id=\"1-URI-分类\"><a href=\"#1-URI-分类\" class=\"headerlink\" title=\".1. URI 分类\"></a>.1. URI 分类</h2><ul>\n<li>opaque 模糊类：不以 slash character <code>/</code> 开头，不需要进一步解析。eg：<ul>\n<li>mailto:<a href=\"mailto:&#x6a;&#x61;&#x76;&#x61;&#45;&#110;&#x65;&#116;&#64;&#106;&#97;&#118;&#97;&#x2e;&#115;&#x75;&#x6e;&#46;&#x63;&#111;&#109;\">&#x6a;&#x61;&#x76;&#x61;&#45;&#110;&#x65;&#116;&#64;&#106;&#97;&#118;&#97;&#x2e;&#115;&#x75;&#x6e;&#46;&#x63;&#111;&#109;</a></li>\n<li>ews:comp.lang.java</li>\n<li>urn:isbn:096139210x</li>\n</ul>\n</li>\n<li>hierarchical 层级类，要么 scheme-specific-part 以 slash character <code>/</code> 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。<ul>\n<li>eg：<ul>\n<li><a href=\"http://java.sun.com/j2se/1.3/\">http://java.sun.com/j2se/1.3/</a></li>\n<li>docs/guide/collections/designfaq.html#28</li>\n<li>../../../demo/jfc/SwingSet2/src/SwingSet2.java</li>\n<li>file:///~/calendar</li>\n</ul>\n</li>\n<li>层级类的 URI 需要进一步解析，其解析语法是 <code>[scheme:][//authority][path][?query][#fragment]</code><ul>\n<li>如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：<code>[user-info@]host[:port]</code>。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。</li>\n<li>path 组件如果以slash character <code>/</code> 开头，则表明其是绝对路径，否则是相对的。<em>The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>All told, then, a URI instance has the following nine components:</p>\n<p>Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>scheme</td>\n<td>String</td>\n</tr>\n<tr>\n<td>scheme-specific-part</td>\n<td>String</td>\n</tr>\n<tr>\n<td>authority</td>\n<td>String</td>\n</tr>\n<tr>\n<td>user-info</td>\n<td>String</td>\n</tr>\n<tr>\n<td>host</td>\n<td>String</td>\n</tr>\n<tr>\n<td>port</td>\n<td>int</td>\n</tr>\n<tr>\n<td>path</td>\n<td>String</td>\n</tr>\n<tr>\n<td>query</td>\n<td>String</td>\n</tr>\n<tr>\n<td>fragment</td>\n<td>String</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-URL\"><a href=\"#2-URL\" class=\"headerlink\" title=\".2. URL\"></a>.2. URL</h2><p>URL: Uniform Resource Locator.</p>\n<p>URL 与 URI 之间相互转换，使用方法： <code>URL.toURI()</code> 与 <code>URI.toURL()</code> 。</p>\n<p>URL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。</p>\n<h2 id=\"3-URI-文档翻译\"><a href=\"#3-URI-文档翻译\" class=\"headerlink\" title=\".3. URI 文档翻译\"></a>.3. URI 文档翻译</h2><p><a href=\"https://www.ietf.org/rfc/rfc2396.txt\">original doc</a></p>\n<blockquote>\n<p>文档语法：<br>This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in</p>\n</blockquote>\n<blockquote>\n<pre><code> &lt;first&gt;/&lt;second&gt;;&lt;third&gt;?&lt;fourth&gt;\n</code></pre>\n</blockquote>\n<blockquote>\n<p>The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.<br>The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that “|” is used to designate alternatives.  Briefly, rules are separated from definitions by an equal “=”, indentation is used to continue a rule definition over more than one line, literals are quoted with “”, parentheses “(“ and “)” are used to group elements, optional elements are enclosed in “[“ and “]” brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.<br>Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.</p>\n</blockquote>\n<h3 id=\"3-1-保留字符\"><a href=\"#3-1-保留字符\" class=\"headerlink\" title=\".3.1. 保留字符\"></a>.3.1. 保留字符</h3><blockquote>\n<p>reserved    = “;” | “/“ | “?” | “:” | “@” | “&amp;” | “=” | “+” |”$” | “,”</p>\n</blockquote>\n<p>如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。</p>\n<h3 id=\"3-2-非保留字符\"><a href=\"#3-2-非保留字符\" class=\"headerlink\" title=\".3.2. 非保留字符\"></a>.3.2. 非保留字符</h3><p>大小写字母数字与标点符号</p>\n<blockquote>\n<p>unreserved  = alphanum | mark<br>mark        = “-“ | “_” | “.” | “!” | “~” | “*” | “‘“ | “(“ | “)”</p>\n</blockquote>\n<p>在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。</p>\n<h3 id=\"3-3-转义编码\"><a href=\"#3-3-转义编码\" class=\"headerlink\" title=\".3.3. 转义编码\"></a>.3.3. 转义编码</h3><p>转义后的八进制符是由三个字符组成：<code>%</code> 加上两个十六进制字符。eg: <code>%20</code> 表示 ASCII 码 32 space。</p>\n<p>是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。</p>\n<h3 id=\"3-4-被排除的-ASCII-字符\"><a href=\"#3-4-被排除的-ASCII-字符\" class=\"headerlink\" title=\".3.4. 被排除的 ASCII 字符\"></a>.3.4. 被排除的 ASCII 字符</h3><ul>\n<li>控制符 US-ASCII coded characters 00-1F, 7F hexadecimal</li>\n<li>空格 space US-ASCII coded character 20 hexadecimal</li>\n<li>分隔符 delims “&lt;” | “&gt;” | “#” | “%” | &lt;”&gt; 网关代理用于分隔符 “{“ | “}” | “|” | “&quot; | “^” | “[“ | “]” | “`”</li>\n</ul>\n<h2 id=\"4-URI-句法部件-（URI-Syntactic-Components）\"><a href=\"#4-URI-句法部件-（URI-Syntactic-Components）\" class=\"headerlink\" title=\".4. URI 句法部件 （URI Syntactic Components）\"></a>.4. URI 句法部件 （URI Syntactic Components）</h2><p>URI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>。使用的 scheme 后跟 <code>;</code> 再跟上一个意义解释取决于 scheme 的 String。</p>\n<p>URI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： <code>&lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;?&lt;query&gt;</code>。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 <code>&lt;query&gt;</code> 组件。</p>\n<p><code>absoluteURI   = scheme &quot;:&quot; ( hier_part | opaque_part )</code></p>\n<p>本质上层级 URI 使用 slash <code>/</code> 分隔。某些文件系统同样使用 <code>/</code> 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。</p>\n<blockquote>\n<p>hier_part     = ( net_path | abs_path ) [ “?” query ]</p>\n</blockquote>\n<blockquote>\n<p>net_path      = “//“ authority [ abs_path ]</p>\n</blockquote>\n<blockquote>\n<p>abs_path      = “/“  path_segments</p>\n</blockquote>\n<p>URI 不使用 <code>/</code> 分隔层级的话，将被通用 URI 解析器识别为不透明 ‘opaque’；</p>\n<p>opaque_part   = uric_no_slash *uric</p>\n<p>uric_no_slash = unreserved | escaped | “;” | “?” | “:” | “@” |”&amp;” | “=” | “+” | “$” | “,”</p>\n<p>使用 <code>&lt;path&gt;</code> 表示 <code>&lt;abs_path&gt;</code> 与 <code>&lt;opaque_part&gt;</code> 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。</p>\n<h3 id=\"4-1-Scheme-组件\"><a href=\"#4-1-Scheme-组件\" class=\"headerlink\" title=\".4.1. Scheme 组件\"></a>.4.1. Scheme 组件</h3><p>如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。</p>\n<p>Scheme 由小写字母、数字、plus <code>+</code>/period <code>.</code>/hyphen <code>-</code> 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。<code>scheme = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )</code>。相对 URI 从 base URI 继承而来，不以 scheme 开头。</p>\n<h3 id=\"4-2-Path-组件\"><a href=\"#4-2-Path-组件\" class=\"headerlink\" title=\".4.2. Path 组件\"></a>.4.2. Path 组件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path          &#x3D; [ abs_path | opaque_part ]</span><br><span class=\"line\"></span><br><span class=\"line\">path_segments &#x3D; segment *( &quot;&#x2F;&quot; segment )</span><br><span class=\"line\">segment       &#x3D; *pchar *( &quot;;&quot; param )</span><br><span class=\"line\">param         &#x3D; *pchar</span><br><span class=\"line\"></span><br><span class=\"line\">pchar         &#x3D; unreserved | escaped |&quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;&#x3D;&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;</span><br></pre></td></tr></table></figure>\n\n<p>一个路径组件可由多个 segment 组成，segment 由 <code>/</code> 分隔。一个 segment 中，<code>/</code>,<code>?</code>,<code>=</code>,<code>;</code> 为保留字符。同时可由多个参数构成，参数之间使用 <code>;</code> 分隔。</p>\n<h3 id=\"4-3-Query-组件\"><a href=\"#4-3-Query-组件\" class=\"headerlink\" title=\".4.3. Query 组件\"></a>.4.3. Query 组件</h3><blockquote>\n<p>   The query component is a string of information to be interpreted by the resource.</p>\n<p>query         = *uric</p>\n<p>Within a query component, the characters “;”, “/“, “?”, “:”, “@”, “&amp;”, “=”, “+”, “,”, and “$” are reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>URI syntax and components <a href=\"https://www.ietf.org/rfc/rfc2396.txt\">URI 语法与组件</a></p>\n</blockquote>\n<p>At the highest level a URI reference (hereinafter simply “URI”) in string form has the syntax <code>[scheme:]scheme-specific-part[#fragment]</code>","more":"</p>\n<h2 id=\"1-URI-分类\"><a href=\"#1-URI-分类\" class=\"headerlink\" title=\".1. URI 分类\"></a>.1. URI 分类</h2><ul>\n<li>opaque 模糊类：不以 slash character <code>/</code> 开头，不需要进一步解析。eg：<ul>\n<li>mailto:<a href=\"mailto:&#x6a;&#x61;&#x76;&#x61;&#45;&#110;&#x65;&#116;&#64;&#106;&#97;&#118;&#97;&#x2e;&#115;&#x75;&#x6e;&#46;&#x63;&#111;&#109;\">&#x6a;&#x61;&#x76;&#x61;&#45;&#110;&#x65;&#116;&#64;&#106;&#97;&#118;&#97;&#x2e;&#115;&#x75;&#x6e;&#46;&#x63;&#111;&#109;</a></li>\n<li>ews:comp.lang.java</li>\n<li>urn:isbn:096139210x</li>\n</ul>\n</li>\n<li>hierarchical 层级类，要么 scheme-specific-part 以 slash character <code>/</code> 开头的绝对 URI，要么是不指定 scheme 的相对 URI 。<ul>\n<li>eg：<ul>\n<li><a href=\"http://java.sun.com/j2se/1.3/\">http://java.sun.com/j2se/1.3/</a></li>\n<li>docs/guide/collections/designfaq.html#28</li>\n<li>../../../demo/jfc/SwingSet2/src/SwingSet2.java</li>\n<li>file:///~/calendar</li>\n</ul>\n</li>\n<li>层级类的 URI 需要进一步解析，其解析语法是 <code>[scheme:][//authority][path][?query][#fragment]</code><ul>\n<li>如果指定了层级类 URI 的权限组件部分，either server-based, or registry-based。server-based 权限解析语法：<code>[user-info@]host[:port]</code>。几乎目前所有 URI 都是 server-based ，如果使用此语法解析权限组件失败，将认为此权限组件是 registry-based 。</li>\n<li>path 组件如果以slash character <code>/</code> 开头，则表明其是绝对路径，否则是相对的。<em>The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>All told, then, a URI instance has the following nine components:</p>\n<p>Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>scheme</td>\n<td>String</td>\n</tr>\n<tr>\n<td>scheme-specific-part</td>\n<td>String</td>\n</tr>\n<tr>\n<td>authority</td>\n<td>String</td>\n</tr>\n<tr>\n<td>user-info</td>\n<td>String</td>\n</tr>\n<tr>\n<td>host</td>\n<td>String</td>\n</tr>\n<tr>\n<td>port</td>\n<td>int</td>\n</tr>\n<tr>\n<td>path</td>\n<td>String</td>\n</tr>\n<tr>\n<td>query</td>\n<td>String</td>\n</tr>\n<tr>\n<td>fragment</td>\n<td>String</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-URL\"><a href=\"#2-URL\" class=\"headerlink\" title=\".2. URL\"></a>.2. URL</h2><p>URL: Uniform Resource Locator.</p>\n<p>URL 与 URI 之间相互转换，使用方法： <code>URL.toURI()</code> 与 <code>URI.toURL()</code> 。</p>\n<p>URL 不负责编码与解码，所以其不识别转义后的 URL 与转义前的 RUL。URL 的 HTML 形式的解码可使用 URLEncoder 与 URLDecoder 。</p>\n<h2 id=\"3-URI-文档翻译\"><a href=\"#3-URI-文档翻译\" class=\"headerlink\" title=\".3. URI 文档翻译\"></a>.3. URI 文档翻译</h2><p><a href=\"https://www.ietf.org/rfc/rfc2396.txt\">original doc</a></p>\n<blockquote>\n<p>文档语法：<br>This document uses two conventions to describe and define the syntax for URI.  The first, called the layout form, is a general of the order of components and component separators, as in</p>\n</blockquote>\n<blockquote>\n<pre><code> &lt;first&gt;/&lt;second&gt;;&lt;third&gt;?&lt;fourth&gt;\n</code></pre>\n</blockquote>\n<blockquote>\n<p>The component names are enclosed in angle-brackets and any characters outside angle-brackets are literal separators.  Whitespace should be ignored.  These descriptions are used informally and do not define the syntax requirements.<br>The second convention is a BNF-like grammar, used to define the formal URI syntax.  The grammar is that of [RFC822], except that “|” is used to designate alternatives.  Briefly, rules are separated from definitions by an equal “=”, indentation is used to continue a rule definition over more than one line, literals are quoted with “”, parentheses “(“ and “)” are used to group elements, optional elements are enclosed in “[“ and “]” brackets, and elements may be preceded with <n>* to designate n or more repetitions of the following element; n defaults to 0.<br>Unlike many specifications that use a BNF-like grammar to define the bytes (octets) allowed by a protocol, the URI grammar is defined in terms of characters.  Each literal in the grammar corresponds to the character it represents, rather than to the octet encoding of that character in any particular coded character set.  How a URI is represented in terms of bits and bytes on the wire is dependent upon the character encoding of the protocol used to transport it, or the charset of the document which contains it.</p>\n</blockquote>\n<h3 id=\"3-1-保留字符\"><a href=\"#3-1-保留字符\" class=\"headerlink\" title=\".3.1. 保留字符\"></a>.3.1. 保留字符</h3><blockquote>\n<p>reserved    = “;” | “/“ | “?” | “:” | “@” | “&amp;” | “=” | “+” |”$” | “,”</p>\n</blockquote>\n<p>如果使用了这些保留字符在 URI 中，需要转义。这些保留字符可以出现在 URI 中但不能出现在特定的 URI 组件中。一般来讲，如果 URI 语义改变或保留字符被转义为 US-ASCII 码所替换，字符就将被保留。</p>\n<h3 id=\"3-2-非保留字符\"><a href=\"#3-2-非保留字符\" class=\"headerlink\" title=\".3.2. 非保留字符\"></a>.3.2. 非保留字符</h3><p>大小写字母数字与标点符号</p>\n<blockquote>\n<p>unreserved  = alphanum | mark<br>mark        = “-“ | “_” | “.” | “!” | “~” | “*” | “‘“ | “(“ | “)”</p>\n</blockquote>\n<p>在 URI 中都为非保留字符，非保留字符被转义后仍保留原语义。但最好不要转义除非上下文只接受转义 URI。</p>\n<h3 id=\"3-3-转义编码\"><a href=\"#3-3-转义编码\" class=\"headerlink\" title=\".3.3. 转义编码\"></a>.3.3. 转义编码</h3><p>转义后的八进制符是由三个字符组成：<code>%</code> 加上两个十六进制字符。eg: <code>%20</code> 表示 ASCII 码 32 space。</p>\n<p>是否转义取决于转义算法，一般只需要将保留字符转义，而非保留字符可不转义。</p>\n<h3 id=\"3-4-被排除的-ASCII-字符\"><a href=\"#3-4-被排除的-ASCII-字符\" class=\"headerlink\" title=\".3.4. 被排除的 ASCII 字符\"></a>.3.4. 被排除的 ASCII 字符</h3><ul>\n<li>控制符 US-ASCII coded characters 00-1F, 7F hexadecimal</li>\n<li>空格 space US-ASCII coded character 20 hexadecimal</li>\n<li>分隔符 delims “&lt;” | “&gt;” | “#” | “%” | &lt;”&gt; 网关代理用于分隔符 “{“ | “}” | “|” | “&quot; | “^” | “[“ | “]” | “`”</li>\n</ul>\n<h2 id=\"4-URI-句法部件-（URI-Syntactic-Components）\"><a href=\"#4-URI-句法部件-（URI-Syntactic-Components）\" class=\"headerlink\" title=\".4. URI 句法部件 （URI Syntactic Components）\"></a>.4. URI 句法部件 （URI Syntactic Components）</h2><p>URI 语法主要取决于 scheme ，一般来讲，绝对 URI 的写法： <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>。使用的 scheme 后跟 <code>;</code> 再跟上一个意义解释取决于 scheme 的 String。</p>\n<p>URI 语法并不要求 scheme-specific-part 部分有任何通用结构，也不需要有一般性规则。但其子集会遵循在命名空间代表层级关系的通用语法，该请求由四个主要组件组成： <code>&lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;?&lt;query&gt;</code>。除了 scheme ，其他每一个组件都非必须。例如：有些 URI scheme 不允许 authority 组件，而其他的不使用 <code>&lt;query&gt;</code> 组件。</p>\n<p><code>absoluteURI   = scheme &quot;:&quot; ( hier_part | opaque_part )</code></p>\n<p>本质上层级 URI 使用 slash <code>/</code> 分隔。某些文件系统同样使用 <code>/</code> 构成文件名层级，所以这两者类似，但这不表明 URI 资源就是一个文件或 URI 映射到一个文件系统路径名。</p>\n<blockquote>\n<p>hier_part     = ( net_path | abs_path ) [ “?” query ]</p>\n</blockquote>\n<blockquote>\n<p>net_path      = “//“ authority [ abs_path ]</p>\n</blockquote>\n<blockquote>\n<p>abs_path      = “/“  path_segments</p>\n</blockquote>\n<p>URI 不使用 <code>/</code> 分隔层级的话，将被通用 URI 解析器识别为不透明 ‘opaque’；</p>\n<p>opaque_part   = uric_no_slash *uric</p>\n<p>uric_no_slash = unreserved | escaped | “;” | “?” | “:” | “@” |”&amp;” | “=” | “+” | “$” | “,”</p>\n<p>使用 <code>&lt;path&gt;</code> 表示 <code>&lt;abs_path&gt;</code> 与 <code>&lt;opaque_part&gt;</code> 结构，因为对于任一给定的 URI 它们相互排斥，且能被编译成单一组件。</p>\n<h3 id=\"4-1-Scheme-组件\"><a href=\"#4-1-Scheme-组件\" class=\"headerlink\" title=\".4.1. Scheme 组件\"></a>.4.1. Scheme 组件</h3><p>如有多种方式访问资源一样，URI 也可以有多种形式的 scheme 来识别资源。URI 由保留字符分隔的组件序列组成，其中第一个组件定义了剩余的 URI 字串的语义。</p>\n<p>Scheme 由小写字母、数字、plus <code>+</code>/period <code>.</code>/hyphen <code>-</code> 所构成，且只能以 小字字母开头，大写字母将被自动转为小写字母。<code>scheme = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )</code>。相对 URI 从 base URI 继承而来，不以 scheme 开头。</p>\n<h3 id=\"4-2-Path-组件\"><a href=\"#4-2-Path-组件\" class=\"headerlink\" title=\".4.2. Path 组件\"></a>.4.2. Path 组件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path          &#x3D; [ abs_path | opaque_part ]</span><br><span class=\"line\"></span><br><span class=\"line\">path_segments &#x3D; segment *( &quot;&#x2F;&quot; segment )</span><br><span class=\"line\">segment       &#x3D; *pchar *( &quot;;&quot; param )</span><br><span class=\"line\">param         &#x3D; *pchar</span><br><span class=\"line\"></span><br><span class=\"line\">pchar         &#x3D; unreserved | escaped |&quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;&#x3D;&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;</span><br></pre></td></tr></table></figure>\n\n<p>一个路径组件可由多个 segment 组成，segment 由 <code>/</code> 分隔。一个 segment 中，<code>/</code>,<code>?</code>,<code>=</code>,<code>;</code> 为保留字符。同时可由多个参数构成，参数之间使用 <code>;</code> 分隔。</p>\n<h3 id=\"4-3-Query-组件\"><a href=\"#4-3-Query-组件\" class=\"headerlink\" title=\".4.3. Query 组件\"></a>.4.3. Query 组件</h3><blockquote>\n<p>   The query component is a string of information to be interpreted by the resource.</p>\n<p>query         = *uric</p>\n<p>Within a query component, the characters “;”, “/“, “?”, “:”, “@”, “&amp;”, “=”, “+”, “,”, and “$” are reserved.</p>\n</blockquote>"},{"title":"Java Jar","date":"2020-10-20T03:02:00.000Z","description":"java jar","_content":"\njava archive\n\n- 使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 `java jar cfmv jar-name manifest-file class-files`<!--more-->\n\n## .1. installed extensions\n\n添加外部的 jar 用作扩展。\n\n- 可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。\n- 可以直接在 jre 中添加扩展。path：jre/lib/ext\n- 若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext\n\n## .2. `java` command line\n\n> `java` 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。\n\n- `-` 标准选项 standard option\n- `-X` 非标准选项 non-standard option\n    - `-Xmn<size>` 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 `-XX:NewSize` 和  `-XX:MaxNewSize`。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。\n    - `-Xms<size>` 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。\n    - `-Xmx<size>` 要求与 Xms 一致，等于 `-XX:MaxHeapSize`，用以设置堆的内存最大分配置额。\n- `-XX` 高级选项 advanced option\n- `-D<name>=<value>` 设置系统属性\n\n## .3. JVM\n\n[Oracle reference](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)\n","source":"_posts/jar.md","raw":"---\ntitle: Java Jar\ndate: 2020-10-20 11:02:00\ncategories: [Java]\ntags: [java, jar, package, jvm]\ndescription: java jar\n---\n\njava archive\n\n- 使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 `java jar cfmv jar-name manifest-file class-files`<!--more-->\n\n## .1. installed extensions\n\n添加外部的 jar 用作扩展。\n\n- 可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。\n- 可以直接在 jre 中添加扩展。path：jre/lib/ext\n- 若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext\n\n## .2. `java` command line\n\n> `java` 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。\n\n- `-` 标准选项 standard option\n- `-X` 非标准选项 non-standard option\n    - `-Xmn<size>` 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 `-XX:NewSize` 和  `-XX:MaxNewSize`。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。\n    - `-Xms<size>` 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。\n    - `-Xmx<size>` 要求与 Xms 一致，等于 `-XX:MaxHeapSize`，用以设置堆的内存最大分配置额。\n- `-XX` 高级选项 advanced option\n- `-D<name>=<value>` 设置系统属性\n\n## .3. JVM\n\n[Oracle reference](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)\n","slug":"jar","published":1,"updated":"2021-02-24T15:22:23.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckljnokqh00072bhb7qf4fji2","content":"<p>java archive</p>\n<ul>\n<li>使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 <code>java jar cfmv jar-name manifest-file class-files</code><span id=\"more\"></span></li>\n</ul>\n<h2 id=\"1-installed-extensions\"><a href=\"#1-installed-extensions\" class=\"headerlink\" title=\".1. installed extensions\"></a>.1. installed extensions</h2><p>添加外部的 jar 用作扩展。</p>\n<ul>\n<li>可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。</li>\n<li>可以直接在 jre 中添加扩展。path：jre/lib/ext</li>\n<li>若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext</li>\n</ul>\n<h2 id=\"2-java-command-line\"><a href=\"#2-java-command-line\" class=\"headerlink\" title=\".2. java command line\"></a>.2. <code>java</code> command line</h2><blockquote>\n<p><code>java</code> 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。</p>\n</blockquote>\n<ul>\n<li><code>-</code> 标准选项 standard option</li>\n<li><code>-X</code> 非标准选项 non-standard option<ul>\n<li><code>-Xmn&lt;size&gt;</code> 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 <code>-XX:NewSize</code> 和  <code>-XX:MaxNewSize</code>。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。</li>\n<li><code>-Xms&lt;size&gt;</code> 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。</li>\n<li><code>-Xmx&lt;size&gt;</code> 要求与 Xms 一致，等于 <code>-XX:MaxHeapSize</code>，用以设置堆的内存最大分配置额。</li>\n</ul>\n</li>\n<li><code>-XX</code> 高级选项 advanced option</li>\n<li><code>-D&lt;name&gt;=&lt;value&gt;</code> 设置系统属性</li>\n</ul>\n<h2 id=\"3-JVM\"><a href=\"#3-JVM\" class=\"headerlink\" title=\".3. JVM\"></a>.3. JVM</h2><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html\">Oracle reference</a></p>\n","site":{"data":{}},"excerpt":"<p>java archive</p>\n<ul>\n<li>使用 jdk 自带工具 javac 编译 java 文件成 class 字节码，再用打包命令 <code>java jar cfmv jar-name manifest-file class-files</code>","more":"</li>\n</ul>\n<h2 id=\"1-installed-extensions\"><a href=\"#1-installed-extensions\" class=\"headerlink\" title=\".1. installed extensions\"></a>.1. installed extensions</h2><p>添加外部的 jar 用作扩展。</p>\n<ul>\n<li>可在命令行中添加 classpath 的参数，指定 classpath 引用外部 jar 包，也可以在 manifest 文件中指定多个 classpath 。</li>\n<li>可以直接在 jre 中添加扩展。path：jre/lib/ext</li>\n<li>若有多个 jre，可以在用户目录中指定让多个 jre 使用同一个 jar 包：usr/java/packages/lib/ext</li>\n</ul>\n<h2 id=\"2-java-command-line\"><a href=\"#2-java-command-line\" class=\"headerlink\" title=\".2. java command line\"></a>.2. <code>java</code> command line</h2><blockquote>\n<p><code>java</code> 命令行在启动一个 java 进程时至关重要。其中关系到设置 jvm 的各项参数，项目启动的配置参数等等。</p>\n</blockquote>\n<ul>\n<li><code>-</code> 标准选项 standard option</li>\n<li><code>-X</code> 非标准选项 non-standard option<ul>\n<li><code>-Xmn&lt;size&gt;</code> 设置堆中最大／初始新生代大小。max nursery，如果需要设置初始大小与最大新生代大小，使用 <code>-XX:NewSize</code> 和  <code>-XX:MaxNewSize</code>。新生代设置过小会导致 GC 频率过高，设置过大，会导致 full GC 时间过长。Oracle 推荐新生代大小在堆的1/4 ~ 1/2 。</li>\n<li><code>-Xms&lt;size&gt;</code> 设置初始堆大小。单位为 byte ，大小需要为 1024 的倍数且超过 1m。如果没有设置此项，jvm 会计算新生代与老年代的初始大小之和为此项配置的值。</li>\n<li><code>-Xmx&lt;size&gt;</code> 要求与 Xms 一致，等于 <code>-XX:MaxHeapSize</code>，用以设置堆的内存最大分配置额。</li>\n</ul>\n</li>\n<li><code>-XX</code> 高级选项 advanced option</li>\n<li><code>-D&lt;name&gt;=&lt;value&gt;</code> 设置系统属性</li>\n</ul>\n<h2 id=\"3-JVM\"><a href=\"#3-JVM\" class=\"headerlink\" title=\".3. JVM\"></a>.3. JVM</h2><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html\">Oracle reference</a></p>"},{"layout":"post","title":"Java specification overview","date":"2020-11-03T14:32:00.000Z","_content":"\n关于 java 的概述文档翻译。[官方文档](https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html)\n\n## .1. java platform\n\n- java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。<!--more-->\n- java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。\n- java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。\n- javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。\n\n## .2. shadowing\n\n[tutorial](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing)\n\n定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 `this.x` 调用对象的变量，而在内部类中可以使用 `Outer.this.x` 调用。\n\n## .3. java IO\n\n### .3.1. Data Streams\n\n使用 Data Streams 可以讲IO 基本类型数据与 String。\n\n### .3.2. Object Streams\n\n[reference](https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html)\n\n- 使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。\n- Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。\n- 将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。\n","source":"_posts/java specification.md","raw":"---\nlayout: \"post\"\ntitle: Java specification overview\ndate: \"2020-11-03 22:32:00\"\ntags: [shadowing, java, IO]\ncategories: [Java]\n---\n\n关于 java 的概述文档翻译。[官方文档](https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html)\n\n## .1. java platform\n\n- java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。<!--more-->\n- java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。\n- java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。\n- javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。\n\n## .2. shadowing\n\n[tutorial](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing)\n\n定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 `this.x` 调用对象的变量，而在内部类中可以使用 `Outer.this.x` 调用。\n\n## .3. java IO\n\n### .3.1. Data Streams\n\n使用 Data Streams 可以讲IO 基本类型数据与 String。\n\n### .3.2. Object Streams\n\n[reference](https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html)\n\n- 使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。\n- Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。\n- 将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。\n","slug":"java specification","published":1,"updated":"2021-02-24T15:22:23.112Z","comments":1,"photos":[],"link":"","_id":"ckljnokqj00092bhbherl78k9","content":"<p>关于 java 的概述文档翻译。<a href=\"https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html\">官方文档</a></p>\n<h2 id=\"1-java-platform\"><a href=\"#1-java-platform\" class=\"headerlink\" title=\".1. java platform\"></a>.1. java platform</h2><ul>\n<li>java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。<span id=\"more\"></span></li>\n<li>java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。</li>\n<li>java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。</li>\n<li>javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。</li>\n</ul>\n<h2 id=\"2-shadowing\"><a href=\"#2-shadowing\" class=\"headerlink\" title=\".2. shadowing\"></a>.2. shadowing</h2><p><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing\">tutorial</a></p>\n<p>定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 <code>this.x</code> 调用对象的变量，而在内部类中可以使用 <code>Outer.this.x</code> 调用。</p>\n<h2 id=\"3-java-IO\"><a href=\"#3-java-IO\" class=\"headerlink\" title=\".3. java IO\"></a>.3. java IO</h2><h3 id=\"3-1-Data-Streams\"><a href=\"#3-1-Data-Streams\" class=\"headerlink\" title=\".3.1. Data Streams\"></a>.3.1. Data Streams</h3><p>使用 Data Streams 可以讲IO 基本类型数据与 String。</p>\n<h3 id=\"3-2-Object-Streams\"><a href=\"#3-2-Object-Streams\" class=\"headerlink\" title=\".3.2. Object Streams\"></a>.3.2. Object Streams</h3><p><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html\">reference</a></p>\n<ul>\n<li>使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。</li>\n<li>Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。</li>\n<li>将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>关于 java 的概述文档翻译。<a href=\"https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html\">官方文档</a></p>\n<h2 id=\"1-java-platform\"><a href=\"#1-java-platform\" class=\"headerlink\" title=\".1. java platform\"></a>.1. java platform</h2><ul>\n<li>java SE：java standard edition。java 标准版本，包括了 java 虚拟机，各类基础的 API 。","more":"</li>\n<li>java EE：java enterprise edition。构建于 java SE之上，提供 API 与运行时环境，用来开发、运行大型复杂安全可靠的网络应用。</li>\n<li>java ME：java micro edition。提供小型虚拟机与 API，用以在小型设备（如：手机）开发应用。用于小型设备应用开发的 API 常为特定的类库，因而java ME 的 API 是 java SE 所提供的 API 的子集。java ME 应用请求的服务器一般为 java EE 开发的。</li>\n<li>javaFX： JavaFX 平台用于创建富网络应用，这些应用常用轻量级用户交互 API 开发。JavaFX 应用通过硬件加速绘制器与媒体引擎，达到高性能、现代外观的效果。同时也能够使用高级 APIs 连接网络数据。JavaFX 应用也可作为 Java EE 服务的客户端。</li>\n</ul>\n<h2 id=\"2-shadowing\"><a href=\"#2-shadowing\" class=\"headerlink\" title=\".2. shadowing\"></a>.2. shadowing</h2><p><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing\">tutorial</a></p>\n<p>定义到内部同名变量、方法参数名会 shadows 外部的变量或参数。方法中可以使用 <code>this.x</code> 调用对象的变量，而在内部类中可以使用 <code>Outer.this.x</code> 调用。</p>\n<h2 id=\"3-java-IO\"><a href=\"#3-java-IO\" class=\"headerlink\" title=\".3. java IO\"></a>.3. java IO</h2><h3 id=\"3-1-Data-Streams\"><a href=\"#3-1-Data-Streams\" class=\"headerlink\" title=\".3.1. Data Streams\"></a>.3.1. Data Streams</h3><p>使用 Data Streams 可以讲IO 基本类型数据与 String。</p>\n<h3 id=\"3-2-Object-Streams\"><a href=\"#3-2-Object-Streams\" class=\"headerlink\" title=\".3.2. Object Streams\"></a>.3.2. Object Streams</h3><p><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html\">reference</a></p>\n<ul>\n<li>使用 Java Object Stream 可以 IO 引用类型数据。Java Object 实现 Serializable 接口即可被 IO 。</li>\n<li>Object stream 类是 ObjectInputStream 和 ObjectOutputStream，分别实现了 ObjectInput 与 ObjectOutput ，同时这两个又是 DataInput 与 DataOutput 的子接口，所以 object stream 同样包含了基本数据值与对象值。</li>\n<li>将一个 object 写入 stream 时，需要将其引用的 object 同时写入，以此类推直到最初的基本类型。两个 object 引用了同一个 object ，在写入 stream 时只会写一个 object 但外层两个 object 拥有不同的两个 reference 。在 read back 时也可以将引用关系给复原。但如果外层两个 object 被写入了不同的 stream 中，在 read back 时会恢复成两个不同的对象。</li>\n</ul>"},{"title":"Key Words in Java","date":"2020-10-12T10:52:00.000Z","description":"key words","_content":"\n## .1. transient【瞬时】\n\n用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。\n\n- 与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效\n- 与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。<!--more-->\n\n## .2. volatile\n\n[reference](http://tutorials.jenkov.com/java-concurrency/volatile.html)\n\n- volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。\n\n### .2.1. volatile 可见性保证原则\n\n可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：\n\n- 对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。\n- 线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。\n\n### .2.2. 指令重排\n\nJVM 与 CPU 为提升性能而允许指令重排。*使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？*\n\n指令重排带来的问题就是打乱了 volatile 可见性原则。\n\n### .2.3. volatile happen-before 原则\n\n为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。\n","source":"_posts/java-keywords.md","raw":"---\ntitle: Key Words in Java\ndate: 2020-10-12 18:52:00\ncategories: [Java]\ntags: [programming,java, HashMap]\ndescription: key words\n---\n\n## .1. transient【瞬时】\n\n用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。\n\n- 与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效\n- 与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。<!--more-->\n\n## .2. volatile\n\n[reference](http://tutorials.jenkov.com/java-concurrency/volatile.html)\n\n- volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。\n\n### .2.1. volatile 可见性保证原则\n\n可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：\n\n- 对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。\n- 线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。\n\n### .2.2. 指令重排\n\nJVM 与 CPU 为提升性能而允许指令重排。*使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？*\n\n指令重排带来的问题就是打乱了 volatile 可见性原则。\n\n### .2.3. volatile happen-before 原则\n\n为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。\n","slug":"java-keywords","published":1,"updated":"2021-02-24T15:22:23.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckljnokqm000a2bhb0k1fdeun","content":"<h2 id=\"1-transient【瞬时】\"><a href=\"#1-transient【瞬时】\" class=\"headerlink\" title=\".1. transient【瞬时】\"></a>.1. transient【瞬时】</h2><p>用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。</p>\n<ul>\n<li>与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效</li>\n<li>与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。<span id=\"more\"></span></li>\n</ul>\n<h2 id=\"2-volatile\"><a href=\"#2-volatile\" class=\"headerlink\" title=\".2. volatile\"></a>.2. volatile</h2><p><a href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\">reference</a></p>\n<ul>\n<li>volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。</li>\n</ul>\n<h3 id=\"2-1-volatile-可见性保证原则\"><a href=\"#2-1-volatile-可见性保证原则\" class=\"headerlink\" title=\".2.1. volatile 可见性保证原则\"></a>.2.1. volatile 可见性保证原则</h3><p>可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：</p>\n<ul>\n<li>对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。</li>\n<li>线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。</li>\n</ul>\n<h3 id=\"2-2-指令重排\"><a href=\"#2-2-指令重排\" class=\"headerlink\" title=\".2.2. 指令重排\"></a>.2.2. 指令重排</h3><p>JVM 与 CPU 为提升性能而允许指令重排。<em>使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？</em></p>\n<p>指令重排带来的问题就是打乱了 volatile 可见性原则。</p>\n<h3 id=\"2-3-volatile-happen-before-原则\"><a href=\"#2-3-volatile-happen-before-原则\" class=\"headerlink\" title=\".2.3. volatile happen-before 原则\"></a>.2.3. volatile happen-before 原则</h3><p>为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-transient【瞬时】\"><a href=\"#1-transient【瞬时】\" class=\"headerlink\" title=\".1. transient【瞬时】\"></a>.1. transient【瞬时】</h2><p>用以序列化、反序列化时所排除的变量，在进行序列化、反序列化时 transient 修辞的变量将不被序列化、反序列化。</p>\n<ul>\n<li>与 final 连用，final 修辞字段值会直接被序列化，因此 transient 修辞 final 字段无效</li>\n<li>与 static 连用，static 字段非对象所拥有，所以 transient 修辞的 static 字段无效。","more":"</li>\n</ul>\n<h2 id=\"2-volatile\"><a href=\"#2-volatile\" class=\"headerlink\" title=\".2. volatile\"></a>.2. volatile</h2><p><a href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\">reference</a></p>\n<ul>\n<li>volatile 用于将变量放置于主存而非 CPU 缓存，以避免多核多线程中读取变量产生可见性问题。</li>\n</ul>\n<h3 id=\"2-1-volatile-可见性保证原则\"><a href=\"#2-1-volatile-可见性保证原则\" class=\"headerlink\" title=\".2.1. volatile 可见性保证原则\"></a>.2.1. volatile 可见性保证原则</h3><p>可见性指在线程间变量被读写的正确性， java volatile 原则不仅保证 volatile 变量本身，也保证其相关变量：</p>\n<ul>\n<li>对于一个线程A写 volatile 变量随后线程 B 读取 volatile 变量的场景中，所有在线程A 写 volatile 变量前的变量对线程 A 都具可见性，同时，在线程 B 读取 volatile 变量后所有的变量对线程B 具可见性。</li>\n<li>线程A在读取一个 volatile 变量时，所有的变量都对线程 A 保持可见性也可以从主存中生读。</li>\n</ul>\n<h3 id=\"2-2-指令重排\"><a href=\"#2-2-指令重排\" class=\"headerlink\" title=\".2.2. 指令重排\"></a>.2.2. 指令重排</h3><p>JVM 与 CPU 为提升性能而允许指令重排。<em>使用指令重排可以将同一个变量的声明与赋值放在一起而提升性能？</em></p>\n<p>指令重排带来的问题就是打乱了 volatile 可见性原则。</p>\n<h3 id=\"2-3-volatile-happen-before-原则\"><a href=\"#2-3-volatile-happen-before-原则\" class=\"headerlink\" title=\".2.3. volatile happen-before 原则\"></a>.2.3. volatile happen-before 原则</h3><p>为保证指令重排不对 volatile 可见性干预，volatile 有 Happens-Before 原则。</p>"},{"layout":"post","title":"java - Type","date":"2019-01-29T10:46:00.000Z","_content":"\n> java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc\n\n[参考](https://blog.csdn.net/u011983531/article/details/80295479)\n\n## .1. java generic\n\njava 范型 [reference](https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n\n- 静态方法要实现范型，要在返回结果前加上范型标识 `<T, R> void generic()`\n- 使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：`builder.<String, Integer>build()`。否则，编译器只会当范型类型为 Object。\n- 范型构造器的使用与无参范型构造的实现：通过上一条即可实现。<!--more-->\n\n### .1.1. 范型通配符\n\n- 范型中 `super` 与 `extends` 的区别使用、非常规意义\n    - `? super` 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。\n        - 原因：当外部容器被 `? super` 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。\n    - `extends` 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 `? extends` 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。\n\n#### .1.1.1. PECS 原则\n\n[reference](https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super)\n\n在范型中使用通配符时，遵守 PECS 原则：\n\n- 一个容器如果只读取类型 T 的数据， 不写入，使用 `? extends T` 通配：Producer Extends。_之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费_\n- 容器如果只写入类型 T 数据，不用读取，使用 `? super T` 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。_同理，此时容器是一个消费数据的 consumer_\n    - 所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配\n- 如果即要读取又要写入，就不使用通配符\n\n---\n\n- Arrays.asList(T ...) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。\n","source":"_posts/java-type.md","raw":"---\nlayout: \"post\"\ntitle: \"java - Type\"\ndate: \"2019-01-29 18:46\"\ntags: [generic,java]\ncategories: [Java]\n---\n\n> java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc\n\n[参考](https://blog.csdn.net/u011983531/article/details/80295479)\n\n## .1. java generic\n\njava 范型 [reference](https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n\n- 静态方法要实现范型，要在返回结果前加上范型标识 `<T, R> void generic()`\n- 使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：`builder.<String, Integer>build()`。否则，编译器只会当范型类型为 Object。\n- 范型构造器的使用与无参范型构造的实现：通过上一条即可实现。<!--more-->\n\n### .1.1. 范型通配符\n\n- 范型中 `super` 与 `extends` 的区别使用、非常规意义\n    - `? super` 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。\n        - 原因：当外部容器被 `? super` 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。\n    - `extends` 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 `? extends` 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。\n\n#### .1.1.1. PECS 原则\n\n[reference](https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super)\n\n在范型中使用通配符时，遵守 PECS 原则：\n\n- 一个容器如果只读取类型 T 的数据， 不写入，使用 `? extends T` 通配：Producer Extends。_之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费_\n- 容器如果只写入类型 T 数据，不用读取，使用 `? super T` 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。_同理，此时容器是一个消费数据的 consumer_\n    - 所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配\n- 如果即要读取又要写入，就不使用通配符\n\n---\n\n- Arrays.asList(T ...) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。\n","slug":"java-type","published":1,"updated":"2021-02-24T15:22:23.248Z","comments":1,"photos":[],"link":"","_id":"ckljnokqp000d2bhbc8n7728q","content":"<blockquote>\n<p>java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/u011983531/article/details/80295479\">参考</a></p>\n<h2 id=\"1-java-generic\"><a href=\"#1-java-generic\" class=\"headerlink\" title=\".1. java generic\"></a>.1. java generic</h2><p>java 范型 <a href=\"https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\">reference</a></p>\n<ul>\n<li>静态方法要实现范型，要在返回结果前加上范型标识 <code>&lt;T, R&gt; void generic()</code></li>\n<li>使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：<code>builder.&lt;String, Integer&gt;build()</code>。否则，编译器只会当范型类型为 Object。</li>\n<li>范型构造器的使用与无参范型构造的实现：通过上一条即可实现。<span id=\"more\"></span></li>\n</ul>\n<h3 id=\"1-1-范型通配符\"><a href=\"#1-1-范型通配符\" class=\"headerlink\" title=\".1.1. 范型通配符\"></a>.1.1. 范型通配符</h3><ul>\n<li>范型中 <code>super</code> 与 <code>extends</code> 的区别使用、非常规意义<ul>\n<li><code>? super</code> 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。<ul>\n<li>原因：当外部容器被 <code>? super</code> 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。</li>\n</ul>\n</li>\n<li><code>extends</code> 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 <code>? extends</code> 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-1-PECS-原则\"><a href=\"#1-1-1-PECS-原则\" class=\"headerlink\" title=\".1.1.1. PECS 原则\"></a>.1.1.1. PECS 原则</h4><p><a href=\"https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super\">reference</a></p>\n<p>在范型中使用通配符时，遵守 PECS 原则：</p>\n<ul>\n<li>一个容器如果只读取类型 T 的数据， 不写入，使用 <code>? extends T</code> 通配：Producer Extends。<em>之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费</em></li>\n<li>容器如果只写入类型 T 数据，不用读取，使用 <code>? super T</code> 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。<em>同理，此时容器是一个消费数据的 consumer</em><ul>\n<li>所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配</li>\n</ul>\n</li>\n<li>如果即要读取又要写入，就不使用通配符</li>\n</ul>\n<hr>\n<ul>\n<li>Arrays.asList(T …) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>java 中使用的范型相关的 Type。在反序列化时，对于范型相关的类需要使用到的 Type 。mc</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/u011983531/article/details/80295479\">参考</a></p>\n<h2 id=\"1-java-generic\"><a href=\"#1-java-generic\" class=\"headerlink\" title=\".1. java generic\"></a>.1. java generic</h2><p>java 范型 <a href=\"https://blog.csdn.net/weixin_30662109/article/details/98836666?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\">reference</a></p>\n<ul>\n<li>静态方法要实现范型，要在返回结果前加上范型标识 <code>&lt;T, R&gt; void generic()</code></li>\n<li>使用无参的范型方法要在使用时确定范型类型在方法前加上范型参数：<code>builder.&lt;String, Integer&gt;build()</code>。否则，编译器只会当范型类型为 Object。</li>\n<li>范型构造器的使用与无参范型构造的实现：通过上一条即可实现。","more":"</li>\n</ul>\n<h3 id=\"1-1-范型通配符\"><a href=\"#1-1-范型通配符\" class=\"headerlink\" title=\".1.1. 范型通配符\"></a>.1.1. 范型通配符</h3><ul>\n<li>范型中 <code>super</code> 与 <code>extends</code> 的区别使用、非常规意义<ul>\n<li><code>? super</code> 指定范型类型下界，是所指类型与其父类型直至根类 Object。这种通配读取出数据只能使用 Object 接收，而可以正常地写入数据。<ul>\n<li>原因：当外部容器被 <code>? super</code> 通配指定了下界，也就指定了容器中数据类型的最细粒度，符合最小粒度与粒度更小的数据都可合法地写入。而读取数据时，对于通配的数据类型的存在，只能选择最大粒度的数据类型接收才能保证正确接收。</li>\n</ul>\n</li>\n<li><code>extends</code> 则相反，使用此通配，将不能进行 add ，只能为其指定一个现成的上界及上界之下的类型列表，可读。因为通配符 <code>? extends</code> 的存在（只要是目标类型及其子类都算合法），写入时编译器不知道此时类型应该按哪一个类型算。而读取时，编译器知道容器中所有通配的类型的上界就是最粗粒度，只按是粗粒度取出数据即可。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-1-PECS-原则\"><a href=\"#1-1-1-PECS-原则\" class=\"headerlink\" title=\".1.1.1. PECS 原则\"></a>.1.1.1. PECS 原则</h4><p><a href=\"https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super\">reference</a></p>\n<p>在范型中使用通配符时，遵守 PECS 原则：</p>\n<ul>\n<li>一个容器如果只读取类型 T 的数据， 不写入，使用 <code>? extends T</code> 通配：Producer Extends。<em>之所以此叫 Producer ，因为此时容器是一个 Producer，提供数据用以消费</em></li>\n<li>容器如果只写入类型 T 数据，不用读取，使用 <code>? super T</code> 通配： Comsumer Super。可以读取，不过读出来的只能识别为 Object。<em>同理，此时容器是一个消费数据的 consumer</em><ul>\n<li>所以一般方法返回结果（要往内写数据用以返回）使用 super 通配，而方法参数（要读取其中的数据）使用 extends 通配</li>\n</ul>\n</li>\n<li>如果即要读取又要写入，就不使用通配符</li>\n</ul>\n<hr>\n<ul>\n<li>Arrays.asList(T …) 方法产生的一个 ArrayList 是 Arrays 中定义的一个并未完全实现抽象类 AbstractList 的 List，使用其 add(T t) 方法会抛出异常。</li>\n</ul>"},{"layout":"post","title":"Java Concurrent","date":"2018-09-28T05:26:00.000Z","_content":"\n> Java 多线程\n\n## .1. CompletableFuture\n\nJava 异步编程的神器，利用执行器 Executor 去执行多个任务时内置多个整合异步执行结果的方法，且全面支持 Java8 的函数式接口。\n\n然而完全不能用于异步，只能在当前线程外开启异步而不能异步于当前线程执行任务。也就是说执行再多的异步任务，当前线程还是得等到 CompletableFuture 聚合出结果来才能执行下一步。 要在当前线程执行任务，使用线程池 ThreadPoolExecutor 。\n\n<!--more-->\n\n## .2. ThreadPoolExecutor\n\n> 使用线程池实现多线程编程\n\n工厂类 Executors 提供了便捷的构造线程池的方法，\n\n1. Executors.newCachedThreadPool() 无限线程数量，自动回收线程\n2. newFixedThreadPool() 固定线程数量线程池\n3. newSingleThreadExecutor() 单线程执行器\n\n如果需要更详细地控制微调线程池，就需要使用类中其他参数。\n\n### .2.1. Core and Maximum Pool Size\n\nThreadPoolExecutor 会根据 corePoolSize 与 maximumPoolSize 自动调整线程池 pool size 。\n\n当一个新的任务通过 execute(Runnable r) 方法被提交时，如果正在运行的线程数量低于 corePoolSize，这时会创建一个新的线程用以执行任务，不管此时其他已初始化好的线程是否是空闲状态。如果正运行的线程数量超过 corePoolSize 但少于 maximumPoolSize ，只有当队列是满的时才会创建新的线程执行任务。设置 corePoolSize == maximumPoolSize 就是设置了一个 fixed size Thread Pool 。如果设置 maximumPoolSize 为无限大（ Integer.MAX_VALUE ），就让线程池可并发执行任意数量的任务。一般来说， core Pool size 与 maximum pool size 在构造时设置好，但也可以使用 setCorePoolSize() 与 setMaximumPoolSize() 方法动态设置。\n\n### .2.2. Queuing 任务队列\n\n> 用于放置提交的不能当前执行的任务。BlockingQueue\n\n队列与 pool size 关系：\n\n- 如果正在运行的线程数量低于 corePoolSize ，执行器将添加一个线程而非放入队列。\n- 如果运行的线程数量超过 corePoolSize，执行器将排队入队列而非添加线程。\n- 当请求不能放置入队列，如果运行线程数量未超过 maximumPoolSize 将新添加一个线程，否则将拒绝请求。\n\n### .2.3. 三种排列策略\n\n1. 直接移交 direct handoff 。SynchronousQueue ，直接将任务提交给执行器不放置入队列。\n2. 无限队列 LinkedBlockingQueue\n3. 有限队列 ArrayBlockingQueue\n\n### .2.4. 任务拒绝\n\n当运行线程数量与队列容量都有限且已饱和，此时执行器将拒绝提交的任务。RejectedExecutionHandler#rejectExecution(Runnable, ThreadPoolExecutor).预定义的四种拒绝策略：\n\n1. 默认的 ThreadPoolExecutor.AbortPolicy ，直接抛出运行时异常 RejectedExecutionException。\n2. ThreadPoolExecutor.CallerRunsPolicy，让提交任务的线程自己运行任务。可以降低高峰时请求任务执行数量。\n3. ThreadPoolExecutor.DiscardPolicy，直接丢弃提交的任务。\n4. ThreadPoolExecutor.DiscardOldestPolicy，丢弃队列中最老的任务。\n\n可自定义任务拒绝策略。实现 RejectedExecutionHandler .\n\n### .2.5. Hook Methods\n\n在每个线程任务执行前后添加钩子用以执行自定义。如果钩子方法抛出异常，内部线程执行可能执行失败并被中断。\n\n1. beforeExecute(Thread, Runnable)\n2. afterExecute(Runnable, Throwable)\n\n### .2.6. 队列维护 Queue Maintenance\n\ngetQueue() 方法允许访问队列，但只推荐用以监控与 debug。当大量任务被取消，可使用 remove() purge() 方法回收队列空间。\n\n### .2.7. 线程池析构\n\n如果线程池不再被引用且没有线程在其中，将自动关闭 shutdown 。如果需要保证不被引用的线程池未被用户调用 shutdown() 方法被回收，需要将无用的线程死亡。方法是设置恰当的生命时长 keep-alive time ，低于0 的 corePoolSize 或 allowCoreThreadTimeOut(true)。\n","source":"_posts/JMM/CompletableFuture.md","raw":"---\nlayout: \"post\"\ntitle: Java Concurrent\ndate: \"2018-09-28 13:26\"\ncategories: [Java]\ntag: [java, concurrent]\n---\n\n> Java 多线程\n\n## .1. CompletableFuture\n\nJava 异步编程的神器，利用执行器 Executor 去执行多个任务时内置多个整合异步执行结果的方法，且全面支持 Java8 的函数式接口。\n\n然而完全不能用于异步，只能在当前线程外开启异步而不能异步于当前线程执行任务。也就是说执行再多的异步任务，当前线程还是得等到 CompletableFuture 聚合出结果来才能执行下一步。 要在当前线程执行任务，使用线程池 ThreadPoolExecutor 。\n\n<!--more-->\n\n## .2. ThreadPoolExecutor\n\n> 使用线程池实现多线程编程\n\n工厂类 Executors 提供了便捷的构造线程池的方法，\n\n1. Executors.newCachedThreadPool() 无限线程数量，自动回收线程\n2. newFixedThreadPool() 固定线程数量线程池\n3. newSingleThreadExecutor() 单线程执行器\n\n如果需要更详细地控制微调线程池，就需要使用类中其他参数。\n\n### .2.1. Core and Maximum Pool Size\n\nThreadPoolExecutor 会根据 corePoolSize 与 maximumPoolSize 自动调整线程池 pool size 。\n\n当一个新的任务通过 execute(Runnable r) 方法被提交时，如果正在运行的线程数量低于 corePoolSize，这时会创建一个新的线程用以执行任务，不管此时其他已初始化好的线程是否是空闲状态。如果正运行的线程数量超过 corePoolSize 但少于 maximumPoolSize ，只有当队列是满的时才会创建新的线程执行任务。设置 corePoolSize == maximumPoolSize 就是设置了一个 fixed size Thread Pool 。如果设置 maximumPoolSize 为无限大（ Integer.MAX_VALUE ），就让线程池可并发执行任意数量的任务。一般来说， core Pool size 与 maximum pool size 在构造时设置好，但也可以使用 setCorePoolSize() 与 setMaximumPoolSize() 方法动态设置。\n\n### .2.2. Queuing 任务队列\n\n> 用于放置提交的不能当前执行的任务。BlockingQueue\n\n队列与 pool size 关系：\n\n- 如果正在运行的线程数量低于 corePoolSize ，执行器将添加一个线程而非放入队列。\n- 如果运行的线程数量超过 corePoolSize，执行器将排队入队列而非添加线程。\n- 当请求不能放置入队列，如果运行线程数量未超过 maximumPoolSize 将新添加一个线程，否则将拒绝请求。\n\n### .2.3. 三种排列策略\n\n1. 直接移交 direct handoff 。SynchronousQueue ，直接将任务提交给执行器不放置入队列。\n2. 无限队列 LinkedBlockingQueue\n3. 有限队列 ArrayBlockingQueue\n\n### .2.4. 任务拒绝\n\n当运行线程数量与队列容量都有限且已饱和，此时执行器将拒绝提交的任务。RejectedExecutionHandler#rejectExecution(Runnable, ThreadPoolExecutor).预定义的四种拒绝策略：\n\n1. 默认的 ThreadPoolExecutor.AbortPolicy ，直接抛出运行时异常 RejectedExecutionException。\n2. ThreadPoolExecutor.CallerRunsPolicy，让提交任务的线程自己运行任务。可以降低高峰时请求任务执行数量。\n3. ThreadPoolExecutor.DiscardPolicy，直接丢弃提交的任务。\n4. ThreadPoolExecutor.DiscardOldestPolicy，丢弃队列中最老的任务。\n\n可自定义任务拒绝策略。实现 RejectedExecutionHandler .\n\n### .2.5. Hook Methods\n\n在每个线程任务执行前后添加钩子用以执行自定义。如果钩子方法抛出异常，内部线程执行可能执行失败并被中断。\n\n1. beforeExecute(Thread, Runnable)\n2. afterExecute(Runnable, Throwable)\n\n### .2.6. 队列维护 Queue Maintenance\n\ngetQueue() 方法允许访问队列，但只推荐用以监控与 debug。当大量任务被取消，可使用 remove() purge() 方法回收队列空间。\n\n### .2.7. 线程池析构\n\n如果线程池不再被引用且没有线程在其中，将自动关闭 shutdown 。如果需要保证不被引用的线程池未被用户调用 shutdown() 方法被回收，需要将无用的线程死亡。方法是设置恰当的生命时长 keep-alive time ，低于0 的 corePoolSize 或 allowCoreThreadTimeOut(true)。\n","slug":"JMM/CompletableFuture","published":1,"updated":"2021-02-24T15:22:22.648Z","comments":1,"photos":[],"link":"","_id":"ckljnokqq000e2bhb26ho7n3q","content":"<blockquote>\n<p>Java 多线程</p>\n</blockquote>\n<h2 id=\"1-CompletableFuture\"><a href=\"#1-CompletableFuture\" class=\"headerlink\" title=\".1. CompletableFuture\"></a>.1. CompletableFuture</h2><p>Java 异步编程的神器，利用执行器 Executor 去执行多个任务时内置多个整合异步执行结果的方法，且全面支持 Java8 的函数式接口。</p>\n<p>然而完全不能用于异步，只能在当前线程外开启异步而不能异步于当前线程执行任务。也就是说执行再多的异步任务，当前线程还是得等到 CompletableFuture 聚合出结果来才能执行下一步。 要在当前线程执行任务，使用线程池 ThreadPoolExecutor 。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-ThreadPoolExecutor\"><a href=\"#2-ThreadPoolExecutor\" class=\"headerlink\" title=\".2. ThreadPoolExecutor\"></a>.2. ThreadPoolExecutor</h2><blockquote>\n<p>使用线程池实现多线程编程</p>\n</blockquote>\n<p>工厂类 Executors 提供了便捷的构造线程池的方法，</p>\n<ol>\n<li>Executors.newCachedThreadPool() 无限线程数量，自动回收线程</li>\n<li>newFixedThreadPool() 固定线程数量线程池</li>\n<li>newSingleThreadExecutor() 单线程执行器</li>\n</ol>\n<p>如果需要更详细地控制微调线程池，就需要使用类中其他参数。</p>\n<h3 id=\"2-1-Core-and-Maximum-Pool-Size\"><a href=\"#2-1-Core-and-Maximum-Pool-Size\" class=\"headerlink\" title=\".2.1. Core and Maximum Pool Size\"></a>.2.1. Core and Maximum Pool Size</h3><p>ThreadPoolExecutor 会根据 corePoolSize 与 maximumPoolSize 自动调整线程池 pool size 。</p>\n<p>当一个新的任务通过 execute(Runnable r) 方法被提交时，如果正在运行的线程数量低于 corePoolSize，这时会创建一个新的线程用以执行任务，不管此时其他已初始化好的线程是否是空闲状态。如果正运行的线程数量超过 corePoolSize 但少于 maximumPoolSize ，只有当队列是满的时才会创建新的线程执行任务。设置 corePoolSize == maximumPoolSize 就是设置了一个 fixed size Thread Pool 。如果设置 maximumPoolSize 为无限大（ Integer.MAX_VALUE ），就让线程池可并发执行任意数量的任务。一般来说， core Pool size 与 maximum pool size 在构造时设置好，但也可以使用 setCorePoolSize() 与 setMaximumPoolSize() 方法动态设置。</p>\n<h3 id=\"2-2-Queuing-任务队列\"><a href=\"#2-2-Queuing-任务队列\" class=\"headerlink\" title=\".2.2. Queuing 任务队列\"></a>.2.2. Queuing 任务队列</h3><blockquote>\n<p>用于放置提交的不能当前执行的任务。BlockingQueue</p>\n</blockquote>\n<p>队列与 pool size 关系：</p>\n<ul>\n<li>如果正在运行的线程数量低于 corePoolSize ，执行器将添加一个线程而非放入队列。</li>\n<li>如果运行的线程数量超过 corePoolSize，执行器将排队入队列而非添加线程。</li>\n<li>当请求不能放置入队列，如果运行线程数量未超过 maximumPoolSize 将新添加一个线程，否则将拒绝请求。</li>\n</ul>\n<h3 id=\"2-3-三种排列策略\"><a href=\"#2-3-三种排列策略\" class=\"headerlink\" title=\".2.3. 三种排列策略\"></a>.2.3. 三种排列策略</h3><ol>\n<li>直接移交 direct handoff 。SynchronousQueue ，直接将任务提交给执行器不放置入队列。</li>\n<li>无限队列 LinkedBlockingQueue</li>\n<li>有限队列 ArrayBlockingQueue</li>\n</ol>\n<h3 id=\"2-4-任务拒绝\"><a href=\"#2-4-任务拒绝\" class=\"headerlink\" title=\".2.4. 任务拒绝\"></a>.2.4. 任务拒绝</h3><p>当运行线程数量与队列容量都有限且已饱和，此时执行器将拒绝提交的任务。RejectedExecutionHandler#rejectExecution(Runnable, ThreadPoolExecutor).预定义的四种拒绝策略：</p>\n<ol>\n<li>默认的 ThreadPoolExecutor.AbortPolicy ，直接抛出运行时异常 RejectedExecutionException。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy，让提交任务的线程自己运行任务。可以降低高峰时请求任务执行数量。</li>\n<li>ThreadPoolExecutor.DiscardPolicy，直接丢弃提交的任务。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy，丢弃队列中最老的任务。</li>\n</ol>\n<p>可自定义任务拒绝策略。实现 RejectedExecutionHandler .</p>\n<h3 id=\"2-5-Hook-Methods\"><a href=\"#2-5-Hook-Methods\" class=\"headerlink\" title=\".2.5. Hook Methods\"></a>.2.5. Hook Methods</h3><p>在每个线程任务执行前后添加钩子用以执行自定义。如果钩子方法抛出异常，内部线程执行可能执行失败并被中断。</p>\n<ol>\n<li>beforeExecute(Thread, Runnable)</li>\n<li>afterExecute(Runnable, Throwable)</li>\n</ol>\n<h3 id=\"2-6-队列维护-Queue-Maintenance\"><a href=\"#2-6-队列维护-Queue-Maintenance\" class=\"headerlink\" title=\".2.6. 队列维护 Queue Maintenance\"></a>.2.6. 队列维护 Queue Maintenance</h3><p>getQueue() 方法允许访问队列，但只推荐用以监控与 debug。当大量任务被取消，可使用 remove() purge() 方法回收队列空间。</p>\n<h3 id=\"2-7-线程池析构\"><a href=\"#2-7-线程池析构\" class=\"headerlink\" title=\".2.7. 线程池析构\"></a>.2.7. 线程池析构</h3><p>如果线程池不再被引用且没有线程在其中，将自动关闭 shutdown 。如果需要保证不被引用的线程池未被用户调用 shutdown() 方法被回收，需要将无用的线程死亡。方法是设置恰当的生命时长 keep-alive time ，低于0 的 corePoolSize 或 allowCoreThreadTimeOut(true)。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Java 多线程</p>\n</blockquote>\n<h2 id=\"1-CompletableFuture\"><a href=\"#1-CompletableFuture\" class=\"headerlink\" title=\".1. CompletableFuture\"></a>.1. CompletableFuture</h2><p>Java 异步编程的神器，利用执行器 Executor 去执行多个任务时内置多个整合异步执行结果的方法，且全面支持 Java8 的函数式接口。</p>\n<p>然而完全不能用于异步，只能在当前线程外开启异步而不能异步于当前线程执行任务。也就是说执行再多的异步任务，当前线程还是得等到 CompletableFuture 聚合出结果来才能执行下一步。 要在当前线程执行任务，使用线程池 ThreadPoolExecutor 。</p>","more":"<h2 id=\"2-ThreadPoolExecutor\"><a href=\"#2-ThreadPoolExecutor\" class=\"headerlink\" title=\".2. ThreadPoolExecutor\"></a>.2. ThreadPoolExecutor</h2><blockquote>\n<p>使用线程池实现多线程编程</p>\n</blockquote>\n<p>工厂类 Executors 提供了便捷的构造线程池的方法，</p>\n<ol>\n<li>Executors.newCachedThreadPool() 无限线程数量，自动回收线程</li>\n<li>newFixedThreadPool() 固定线程数量线程池</li>\n<li>newSingleThreadExecutor() 单线程执行器</li>\n</ol>\n<p>如果需要更详细地控制微调线程池，就需要使用类中其他参数。</p>\n<h3 id=\"2-1-Core-and-Maximum-Pool-Size\"><a href=\"#2-1-Core-and-Maximum-Pool-Size\" class=\"headerlink\" title=\".2.1. Core and Maximum Pool Size\"></a>.2.1. Core and Maximum Pool Size</h3><p>ThreadPoolExecutor 会根据 corePoolSize 与 maximumPoolSize 自动调整线程池 pool size 。</p>\n<p>当一个新的任务通过 execute(Runnable r) 方法被提交时，如果正在运行的线程数量低于 corePoolSize，这时会创建一个新的线程用以执行任务，不管此时其他已初始化好的线程是否是空闲状态。如果正运行的线程数量超过 corePoolSize 但少于 maximumPoolSize ，只有当队列是满的时才会创建新的线程执行任务。设置 corePoolSize == maximumPoolSize 就是设置了一个 fixed size Thread Pool 。如果设置 maximumPoolSize 为无限大（ Integer.MAX_VALUE ），就让线程池可并发执行任意数量的任务。一般来说， core Pool size 与 maximum pool size 在构造时设置好，但也可以使用 setCorePoolSize() 与 setMaximumPoolSize() 方法动态设置。</p>\n<h3 id=\"2-2-Queuing-任务队列\"><a href=\"#2-2-Queuing-任务队列\" class=\"headerlink\" title=\".2.2. Queuing 任务队列\"></a>.2.2. Queuing 任务队列</h3><blockquote>\n<p>用于放置提交的不能当前执行的任务。BlockingQueue</p>\n</blockquote>\n<p>队列与 pool size 关系：</p>\n<ul>\n<li>如果正在运行的线程数量低于 corePoolSize ，执行器将添加一个线程而非放入队列。</li>\n<li>如果运行的线程数量超过 corePoolSize，执行器将排队入队列而非添加线程。</li>\n<li>当请求不能放置入队列，如果运行线程数量未超过 maximumPoolSize 将新添加一个线程，否则将拒绝请求。</li>\n</ul>\n<h3 id=\"2-3-三种排列策略\"><a href=\"#2-3-三种排列策略\" class=\"headerlink\" title=\".2.3. 三种排列策略\"></a>.2.3. 三种排列策略</h3><ol>\n<li>直接移交 direct handoff 。SynchronousQueue ，直接将任务提交给执行器不放置入队列。</li>\n<li>无限队列 LinkedBlockingQueue</li>\n<li>有限队列 ArrayBlockingQueue</li>\n</ol>\n<h3 id=\"2-4-任务拒绝\"><a href=\"#2-4-任务拒绝\" class=\"headerlink\" title=\".2.4. 任务拒绝\"></a>.2.4. 任务拒绝</h3><p>当运行线程数量与队列容量都有限且已饱和，此时执行器将拒绝提交的任务。RejectedExecutionHandler#rejectExecution(Runnable, ThreadPoolExecutor).预定义的四种拒绝策略：</p>\n<ol>\n<li>默认的 ThreadPoolExecutor.AbortPolicy ，直接抛出运行时异常 RejectedExecutionException。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy，让提交任务的线程自己运行任务。可以降低高峰时请求任务执行数量。</li>\n<li>ThreadPoolExecutor.DiscardPolicy，直接丢弃提交的任务。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy，丢弃队列中最老的任务。</li>\n</ol>\n<p>可自定义任务拒绝策略。实现 RejectedExecutionHandler .</p>\n<h3 id=\"2-5-Hook-Methods\"><a href=\"#2-5-Hook-Methods\" class=\"headerlink\" title=\".2.5. Hook Methods\"></a>.2.5. Hook Methods</h3><p>在每个线程任务执行前后添加钩子用以执行自定义。如果钩子方法抛出异常，内部线程执行可能执行失败并被中断。</p>\n<ol>\n<li>beforeExecute(Thread, Runnable)</li>\n<li>afterExecute(Runnable, Throwable)</li>\n</ol>\n<h3 id=\"2-6-队列维护-Queue-Maintenance\"><a href=\"#2-6-队列维护-Queue-Maintenance\" class=\"headerlink\" title=\".2.6. 队列维护 Queue Maintenance\"></a>.2.6. 队列维护 Queue Maintenance</h3><p>getQueue() 方法允许访问队列，但只推荐用以监控与 debug。当大量任务被取消，可使用 remove() purge() 方法回收队列空间。</p>\n<h3 id=\"2-7-线程池析构\"><a href=\"#2-7-线程池析构\" class=\"headerlink\" title=\".2.7. 线程池析构\"></a>.2.7. 线程池析构</h3><p>如果线程池不再被引用且没有线程在其中，将自动关闭 shutdown 。如果需要保证不被引用的线程池未被用户调用 shutdown() 方法被回收，需要将无用的线程死亡。方法是设置恰当的生命时长 keep-alive time ，低于0 的 corePoolSize 或 allowCoreThreadTimeOut(true)。</p>"},{"layout":"post","title":"Java Memory Model","date":"2021-01-28T05:26:00.000Z","_content":"\nJava 内存模型[reference](http://www.cs.umd.edu/~pugh/java/memoryModel/)\n\n## .1. JSR 133 (Java Memory Model) FAQ\n\n[reference](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html)\n\n### .1.1. How does synchronization do?\n\n- Synchronization 同步存在多方面含义。最为人所知的是恒定排他性：一旦某个线程获取到 monitor ，monitor 上的同步意味着一个线程进入了 monitor 所保护的同步块，在此线程退出此同步块前没有其他线程能够再进入。<!--more-->\n- 同步同时保证一个线程在进入同步块前与中的写对于其他在相同 monitor 的线程保持可预测的可见性。当退出同步块，会释放 monitor ，这会将缓存中的数据 flush 到主存中，让此线程的写对其他线程可见。在进入同步块前，我们需要获取 monitor ，这带来的内存效应是将处理器 processor 的缓存置为无效，这样变量就必须从主存中重载。这样我们看到的效果就是前一次释放的所有写都可见。\n- 讨论缓存时并不意味问题只发生在多核心机器中，单核心机器中轻易地产生重排序。比如：编译器不可能在在获取前或释放后移动代码。我们在讨论获取与释放缓存时是省了很多可能的效果。\n- **新 JMM 语义创建了内存操作（read field, write field, lock, unlock）与其他线程的操作（start, join）的局部顺序，在此语义下，一些操作 happens-before 其他操作。当一个操作 happens-before 另一个操作，第一个操作保证排在第二个操作前，且对于第二个操作来说，第一个的所有操作对第二个可见。**其中规则包括：\n    - 程序命令指定下，一个线程所有操作都发生在后一个线程所有操作前；\n    - 一个 monitor 的解锁 unlock 发生在此 monitor 后来的锁 lock 之前；\n    - 同一个 volatile 下，写发生在后来的读之前；\n    - 一个线程的 start() 方法调用执行发生成这个线程的所有行为（action）之前；\n    - 一个线程的所有行为 action 发生在其 join() 方法调用成功返回的线程之前。\n- 这就意味着：同一个 monitor 保护下，一个退出同步块之前的线程可见的所有内存操作对任何进入同步块后线程都是可见的。因为所有的内存操作在 release 是发生，而所有的 release 又在 acquire 前发生。\n\n**Important Note:**为保证构建正确的 happens-before 关系，两个线程需要在同一个 monitor 上进行同步。线程Ａ同步在X上的可见对同步在Ｙ上的线程Ｂ并不可见。release 与 acquire 需要匹配在同一个 monitor 上才能执行正确的语义。\n\n### .1.2. How does a final fields work under the new JMM?\n\n- 对象的常量字段都在其构造器内赋值。\n- 一旦构造完成，即使没有添加 synchronization，常量字段的数据可以被其他所有线程可见。此外，常量字段所引用的对象或数组的可见值将被更新到与常量字段一样保持最新。\n- 一个对象正确的构造意味着：在构造期间对象的引用没有“逃逸”。**换句话说：不要将被构造对象的引用置于任何其他线程可见的位置，不要将其指向静态字段，不要将其注册为其他任何对象的监听器，等等。这些操作应该在对象构造完成之后进行，而不是在构造期间进行。**\n- 正确构造同样保证了引用常量字段所指向的对象或数组值在构造后依然是最新的值，所以可以让常量的指针指向对象或数组，而不用担心其他线程看到正确的引用看不到引用的值。但在这里最新的值仅仅是指构造完成后，不是所有的阶段。\n- 对于一个不可变对象（所有字段都是常量）被一个线程构造完成后，如果其他所有线程想要正确可见，仍然需要使用 synchronization 。并没有其他途径可以保证，这就要求程序获取常量字段代码对于并发的管理理解深入而细致，\n- JMM 对于使用 JNI 修改常量字段的行为并没有定义。\n\n### .1.3. What does volatile do?\n\n- volatile 字段用于线程间状态交流。对于 volatile 字段的读取都会获取到其他程的最后一次写。volatile 被设计用于不接受因缓存（cache）或指令重排（reordering）导致的 stale 值的字段。\n- volatile 维持半同步，用于标识字段以让在 processor 缓存中，被一个线程修改后立即被 flush 到主存中，编译器与运行时被禁止将 volatile 字段值置于 processor 寄存器中，从而保证其他线程对其修改可见。\n- 指令重排限制：\n    - 老版 JMM 不允许对 volatile 字段进行 reordering ，但可以对非 volatile 字段进行重排。这让 volatile 字段成了一个线程间信号条件的方式。\n    - 新版 JMM 除会限制字段不能被指令重排（reordering），同时要求 volatile 字段周围的字段都不能轻易被 reordering 。\n    - volatile 字段在修改与释放 monitor 内存效果一致（将 processor 缓存数据 flush 到主存中，从而其他线程可见），在读取与获取 monitor 内存效果一致（将本地处理器缓存中数据置为无效，变量值不得不从主存中读取）。\n\n**Important Note:**\n\n- 多线程访问 volatile 变量都是为了合适地设置 happens-before 关系。并不是线程A在写 volatile field f 时所有可见在线程Ｂ访问 volatile field g 后都可见。释放与获取锁需要匹配到相同的 volatile 字段才能保证语义正确。\n\n### .1.4. Does the new JMM fix the \"double-checked locking\" problem?\n\n双检锁问题\n\n- 单例模式中很多人喜欢使用双检锁模式，认为其可以降低线程阻塞概率。\n\n```java\n//double-checked locking, Don't do like this!\nprivate static Ins ins = null;\npublic Ins getIns(){\n    if(ins == null){\n        synchronized(this){\n            if(ins == null){\n                ins = new Ins();\n            }\n        }\n    }\n    return ins;\n}\n```\n\n- 上段代码的问题在于：在 synchronized 代码块中， ins 的初始化与赋值指令可能会被编译器或缓存重排，从而导致 ins 在某一时期内依然是个半初始化的对象，在这期间 synchronized 块外部其他读取 ins 的线程就会读取到这个半初始化的 ins 对象，就会产生使用未初始化完成的 ins 错误。\n- 在老版JMM 中添加 volatile 关键字到 ins 字段前并不能解决问题，在 JVM1.5 新版 JMM 的 volatile 可以解决问题。在使用 volatile 修辞后的 ins 并不会出现指令重排，也构成了内部线程初始化与外部线程读取的 happens-before 关系（一旦 ins 开始初始化，其他线程必须对其结果可见，也就是需要在其初始化完成前才读取到）。\n","source":"_posts/JMM/Java Merory Model.md","raw":"---\nlayout: \"post\"\ntitle: Java Memory Model\ncategories: [Java]\ndate: \"2021-1-28 13:26\"\ntag: [java, concurrent, JMM]\n---\n\nJava 内存模型[reference](http://www.cs.umd.edu/~pugh/java/memoryModel/)\n\n## .1. JSR 133 (Java Memory Model) FAQ\n\n[reference](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html)\n\n### .1.1. How does synchronization do?\n\n- Synchronization 同步存在多方面含义。最为人所知的是恒定排他性：一旦某个线程获取到 monitor ，monitor 上的同步意味着一个线程进入了 monitor 所保护的同步块，在此线程退出此同步块前没有其他线程能够再进入。<!--more-->\n- 同步同时保证一个线程在进入同步块前与中的写对于其他在相同 monitor 的线程保持可预测的可见性。当退出同步块，会释放 monitor ，这会将缓存中的数据 flush 到主存中，让此线程的写对其他线程可见。在进入同步块前，我们需要获取 monitor ，这带来的内存效应是将处理器 processor 的缓存置为无效，这样变量就必须从主存中重载。这样我们看到的效果就是前一次释放的所有写都可见。\n- 讨论缓存时并不意味问题只发生在多核心机器中，单核心机器中轻易地产生重排序。比如：编译器不可能在在获取前或释放后移动代码。我们在讨论获取与释放缓存时是省了很多可能的效果。\n- **新 JMM 语义创建了内存操作（read field, write field, lock, unlock）与其他线程的操作（start, join）的局部顺序，在此语义下，一些操作 happens-before 其他操作。当一个操作 happens-before 另一个操作，第一个操作保证排在第二个操作前，且对于第二个操作来说，第一个的所有操作对第二个可见。**其中规则包括：\n    - 程序命令指定下，一个线程所有操作都发生在后一个线程所有操作前；\n    - 一个 monitor 的解锁 unlock 发生在此 monitor 后来的锁 lock 之前；\n    - 同一个 volatile 下，写发生在后来的读之前；\n    - 一个线程的 start() 方法调用执行发生成这个线程的所有行为（action）之前；\n    - 一个线程的所有行为 action 发生在其 join() 方法调用成功返回的线程之前。\n- 这就意味着：同一个 monitor 保护下，一个退出同步块之前的线程可见的所有内存操作对任何进入同步块后线程都是可见的。因为所有的内存操作在 release 是发生，而所有的 release 又在 acquire 前发生。\n\n**Important Note:**为保证构建正确的 happens-before 关系，两个线程需要在同一个 monitor 上进行同步。线程Ａ同步在X上的可见对同步在Ｙ上的线程Ｂ并不可见。release 与 acquire 需要匹配在同一个 monitor 上才能执行正确的语义。\n\n### .1.2. How does a final fields work under the new JMM?\n\n- 对象的常量字段都在其构造器内赋值。\n- 一旦构造完成，即使没有添加 synchronization，常量字段的数据可以被其他所有线程可见。此外，常量字段所引用的对象或数组的可见值将被更新到与常量字段一样保持最新。\n- 一个对象正确的构造意味着：在构造期间对象的引用没有“逃逸”。**换句话说：不要将被构造对象的引用置于任何其他线程可见的位置，不要将其指向静态字段，不要将其注册为其他任何对象的监听器，等等。这些操作应该在对象构造完成之后进行，而不是在构造期间进行。**\n- 正确构造同样保证了引用常量字段所指向的对象或数组值在构造后依然是最新的值，所以可以让常量的指针指向对象或数组，而不用担心其他线程看到正确的引用看不到引用的值。但在这里最新的值仅仅是指构造完成后，不是所有的阶段。\n- 对于一个不可变对象（所有字段都是常量）被一个线程构造完成后，如果其他所有线程想要正确可见，仍然需要使用 synchronization 。并没有其他途径可以保证，这就要求程序获取常量字段代码对于并发的管理理解深入而细致，\n- JMM 对于使用 JNI 修改常量字段的行为并没有定义。\n\n### .1.3. What does volatile do?\n\n- volatile 字段用于线程间状态交流。对于 volatile 字段的读取都会获取到其他程的最后一次写。volatile 被设计用于不接受因缓存（cache）或指令重排（reordering）导致的 stale 值的字段。\n- volatile 维持半同步，用于标识字段以让在 processor 缓存中，被一个线程修改后立即被 flush 到主存中，编译器与运行时被禁止将 volatile 字段值置于 processor 寄存器中，从而保证其他线程对其修改可见。\n- 指令重排限制：\n    - 老版 JMM 不允许对 volatile 字段进行 reordering ，但可以对非 volatile 字段进行重排。这让 volatile 字段成了一个线程间信号条件的方式。\n    - 新版 JMM 除会限制字段不能被指令重排（reordering），同时要求 volatile 字段周围的字段都不能轻易被 reordering 。\n    - volatile 字段在修改与释放 monitor 内存效果一致（将 processor 缓存数据 flush 到主存中，从而其他线程可见），在读取与获取 monitor 内存效果一致（将本地处理器缓存中数据置为无效，变量值不得不从主存中读取）。\n\n**Important Note:**\n\n- 多线程访问 volatile 变量都是为了合适地设置 happens-before 关系。并不是线程A在写 volatile field f 时所有可见在线程Ｂ访问 volatile field g 后都可见。释放与获取锁需要匹配到相同的 volatile 字段才能保证语义正确。\n\n### .1.4. Does the new JMM fix the \"double-checked locking\" problem?\n\n双检锁问题\n\n- 单例模式中很多人喜欢使用双检锁模式，认为其可以降低线程阻塞概率。\n\n```java\n//double-checked locking, Don't do like this!\nprivate static Ins ins = null;\npublic Ins getIns(){\n    if(ins == null){\n        synchronized(this){\n            if(ins == null){\n                ins = new Ins();\n            }\n        }\n    }\n    return ins;\n}\n```\n\n- 上段代码的问题在于：在 synchronized 代码块中， ins 的初始化与赋值指令可能会被编译器或缓存重排，从而导致 ins 在某一时期内依然是个半初始化的对象，在这期间 synchronized 块外部其他读取 ins 的线程就会读取到这个半初始化的 ins 对象，就会产生使用未初始化完成的 ins 错误。\n- 在老版JMM 中添加 volatile 关键字到 ins 字段前并不能解决问题，在 JVM1.5 新版 JMM 的 volatile 可以解决问题。在使用 volatile 修辞后的 ins 并不会出现指令重排，也构成了内部线程初始化与外部线程读取的 happens-before 关系（一旦 ins 开始初始化，其他线程必须对其结果可见，也就是需要在其初始化完成前才读取到）。\n","slug":"JMM/Java Merory Model","published":1,"updated":"2021-02-24T15:22:22.652Z","comments":1,"photos":[],"link":"","_id":"ckljnokqs000i2bhb7conetq9","content":"<p>Java 内存模型<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/\">reference</a></p>\n<h2 id=\"1-JSR-133-Java-Memory-Model-FAQ\"><a href=\"#1-JSR-133-Java-Memory-Model-FAQ\" class=\"headerlink\" title=\".1. JSR 133 (Java Memory Model) FAQ\"></a>.1. JSR 133 (Java Memory Model) FAQ</h2><p><a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\">reference</a></p>\n<h3 id=\"1-1-How-does-synchronization-do\"><a href=\"#1-1-How-does-synchronization-do\" class=\"headerlink\" title=\".1.1. How does synchronization do?\"></a>.1.1. How does synchronization do?</h3><ul>\n<li>Synchronization 同步存在多方面含义。最为人所知的是恒定排他性：一旦某个线程获取到 monitor ，monitor 上的同步意味着一个线程进入了 monitor 所保护的同步块，在此线程退出此同步块前没有其他线程能够再进入。<span id=\"more\"></span></li>\n<li>同步同时保证一个线程在进入同步块前与中的写对于其他在相同 monitor 的线程保持可预测的可见性。当退出同步块，会释放 monitor ，这会将缓存中的数据 flush 到主存中，让此线程的写对其他线程可见。在进入同步块前，我们需要获取 monitor ，这带来的内存效应是将处理器 processor 的缓存置为无效，这样变量就必须从主存中重载。这样我们看到的效果就是前一次释放的所有写都可见。</li>\n<li>讨论缓存时并不意味问题只发生在多核心机器中，单核心机器中轻易地产生重排序。比如：编译器不可能在在获取前或释放后移动代码。我们在讨论获取与释放缓存时是省了很多可能的效果。</li>\n<li><strong>新 JMM 语义创建了内存操作（read field, write field, lock, unlock）与其他线程的操作（start, join）的局部顺序，在此语义下，一些操作 happens-before 其他操作。当一个操作 happens-before 另一个操作，第一个操作保证排在第二个操作前，且对于第二个操作来说，第一个的所有操作对第二个可见。</strong>其中规则包括：<ul>\n<li>程序命令指定下，一个线程所有操作都发生在后一个线程所有操作前；</li>\n<li>一个 monitor 的解锁 unlock 发生在此 monitor 后来的锁 lock 之前；</li>\n<li>同一个 volatile 下，写发生在后来的读之前；</li>\n<li>一个线程的 start() 方法调用执行发生成这个线程的所有行为（action）之前；</li>\n<li>一个线程的所有行为 action 发生在其 join() 方法调用成功返回的线程之前。</li>\n</ul>\n</li>\n<li>这就意味着：同一个 monitor 保护下，一个退出同步块之前的线程可见的所有内存操作对任何进入同步块后线程都是可见的。因为所有的内存操作在 release 是发生，而所有的 release 又在 acquire 前发生。</li>\n</ul>\n<p>**Important Note:**为保证构建正确的 happens-before 关系，两个线程需要在同一个 monitor 上进行同步。线程Ａ同步在X上的可见对同步在Ｙ上的线程Ｂ并不可见。release 与 acquire 需要匹配在同一个 monitor 上才能执行正确的语义。</p>\n<h3 id=\"1-2-How-does-a-final-fields-work-under-the-new-JMM\"><a href=\"#1-2-How-does-a-final-fields-work-under-the-new-JMM\" class=\"headerlink\" title=\".1.2. How does a final fields work under the new JMM?\"></a>.1.2. How does a final fields work under the new JMM?</h3><ul>\n<li>对象的常量字段都在其构造器内赋值。</li>\n<li>一旦构造完成，即使没有添加 synchronization，常量字段的数据可以被其他所有线程可见。此外，常量字段所引用的对象或数组的可见值将被更新到与常量字段一样保持最新。</li>\n<li>一个对象正确的构造意味着：在构造期间对象的引用没有“逃逸”。<strong>换句话说：不要将被构造对象的引用置于任何其他线程可见的位置，不要将其指向静态字段，不要将其注册为其他任何对象的监听器，等等。这些操作应该在对象构造完成之后进行，而不是在构造期间进行。</strong></li>\n<li>正确构造同样保证了引用常量字段所指向的对象或数组值在构造后依然是最新的值，所以可以让常量的指针指向对象或数组，而不用担心其他线程看到正确的引用看不到引用的值。但在这里最新的值仅仅是指构造完成后，不是所有的阶段。</li>\n<li>对于一个不可变对象（所有字段都是常量）被一个线程构造完成后，如果其他所有线程想要正确可见，仍然需要使用 synchronization 。并没有其他途径可以保证，这就要求程序获取常量字段代码对于并发的管理理解深入而细致，</li>\n<li>JMM 对于使用 JNI 修改常量字段的行为并没有定义。</li>\n</ul>\n<h3 id=\"1-3-What-does-volatile-do\"><a href=\"#1-3-What-does-volatile-do\" class=\"headerlink\" title=\".1.3. What does volatile do?\"></a>.1.3. What does volatile do?</h3><ul>\n<li>volatile 字段用于线程间状态交流。对于 volatile 字段的读取都会获取到其他程的最后一次写。volatile 被设计用于不接受因缓存（cache）或指令重排（reordering）导致的 stale 值的字段。</li>\n<li>volatile 维持半同步，用于标识字段以让在 processor 缓存中，被一个线程修改后立即被 flush 到主存中，编译器与运行时被禁止将 volatile 字段值置于 processor 寄存器中，从而保证其他线程对其修改可见。</li>\n<li>指令重排限制：<ul>\n<li>老版 JMM 不允许对 volatile 字段进行 reordering ，但可以对非 volatile 字段进行重排。这让 volatile 字段成了一个线程间信号条件的方式。</li>\n<li>新版 JMM 除会限制字段不能被指令重排（reordering），同时要求 volatile 字段周围的字段都不能轻易被 reordering 。</li>\n<li>volatile 字段在修改与释放 monitor 内存效果一致（将 processor 缓存数据 flush 到主存中，从而其他线程可见），在读取与获取 monitor 内存效果一致（将本地处理器缓存中数据置为无效，变量值不得不从主存中读取）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Important Note:</strong></p>\n<ul>\n<li>多线程访问 volatile 变量都是为了合适地设置 happens-before 关系。并不是线程A在写 volatile field f 时所有可见在线程Ｂ访问 volatile field g 后都可见。释放与获取锁需要匹配到相同的 volatile 字段才能保证语义正确。</li>\n</ul>\n<h3 id=\"1-4-Does-the-new-JMM-fix-the-“double-checked-locking”-problem\"><a href=\"#1-4-Does-the-new-JMM-fix-the-“double-checked-locking”-problem\" class=\"headerlink\" title=\".1.4. Does the new JMM fix the “double-checked locking” problem?\"></a>.1.4. Does the new JMM fix the “double-checked locking” problem?</h3><p>双检锁问题</p>\n<ul>\n<li>单例模式中很多人喜欢使用双检锁模式，认为其可以降低线程阻塞概率。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//double-checked locking, Don&#x27;t do like this!</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Ins ins = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Ins <span class=\"title\">getIns</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ins == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ins == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                ins = <span class=\"keyword\">new</span> Ins();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ins;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上段代码的问题在于：在 synchronized 代码块中， ins 的初始化与赋值指令可能会被编译器或缓存重排，从而导致 ins 在某一时期内依然是个半初始化的对象，在这期间 synchronized 块外部其他读取 ins 的线程就会读取到这个半初始化的 ins 对象，就会产生使用未初始化完成的 ins 错误。</li>\n<li>在老版JMM 中添加 volatile 关键字到 ins 字段前并不能解决问题，在 JVM1.5 新版 JMM 的 volatile 可以解决问题。在使用 volatile 修辞后的 ins 并不会出现指令重排，也构成了内部线程初始化与外部线程读取的 happens-before 关系（一旦 ins 开始初始化，其他线程必须对其结果可见，也就是需要在其初始化完成前才读取到）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Java 内存模型<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/\">reference</a></p>\n<h2 id=\"1-JSR-133-Java-Memory-Model-FAQ\"><a href=\"#1-JSR-133-Java-Memory-Model-FAQ\" class=\"headerlink\" title=\".1. JSR 133 (Java Memory Model) FAQ\"></a>.1. JSR 133 (Java Memory Model) FAQ</h2><p><a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\">reference</a></p>\n<h3 id=\"1-1-How-does-synchronization-do\"><a href=\"#1-1-How-does-synchronization-do\" class=\"headerlink\" title=\".1.1. How does synchronization do?\"></a>.1.1. How does synchronization do?</h3><ul>\n<li>Synchronization 同步存在多方面含义。最为人所知的是恒定排他性：一旦某个线程获取到 monitor ，monitor 上的同步意味着一个线程进入了 monitor 所保护的同步块，在此线程退出此同步块前没有其他线程能够再进入。","more":"</li>\n<li>同步同时保证一个线程在进入同步块前与中的写对于其他在相同 monitor 的线程保持可预测的可见性。当退出同步块，会释放 monitor ，这会将缓存中的数据 flush 到主存中，让此线程的写对其他线程可见。在进入同步块前，我们需要获取 monitor ，这带来的内存效应是将处理器 processor 的缓存置为无效，这样变量就必须从主存中重载。这样我们看到的效果就是前一次释放的所有写都可见。</li>\n<li>讨论缓存时并不意味问题只发生在多核心机器中，单核心机器中轻易地产生重排序。比如：编译器不可能在在获取前或释放后移动代码。我们在讨论获取与释放缓存时是省了很多可能的效果。</li>\n<li><strong>新 JMM 语义创建了内存操作（read field, write field, lock, unlock）与其他线程的操作（start, join）的局部顺序，在此语义下，一些操作 happens-before 其他操作。当一个操作 happens-before 另一个操作，第一个操作保证排在第二个操作前，且对于第二个操作来说，第一个的所有操作对第二个可见。</strong>其中规则包括：<ul>\n<li>程序命令指定下，一个线程所有操作都发生在后一个线程所有操作前；</li>\n<li>一个 monitor 的解锁 unlock 发生在此 monitor 后来的锁 lock 之前；</li>\n<li>同一个 volatile 下，写发生在后来的读之前；</li>\n<li>一个线程的 start() 方法调用执行发生成这个线程的所有行为（action）之前；</li>\n<li>一个线程的所有行为 action 发生在其 join() 方法调用成功返回的线程之前。</li>\n</ul>\n</li>\n<li>这就意味着：同一个 monitor 保护下，一个退出同步块之前的线程可见的所有内存操作对任何进入同步块后线程都是可见的。因为所有的内存操作在 release 是发生，而所有的 release 又在 acquire 前发生。</li>\n</ul>\n<p>**Important Note:**为保证构建正确的 happens-before 关系，两个线程需要在同一个 monitor 上进行同步。线程Ａ同步在X上的可见对同步在Ｙ上的线程Ｂ并不可见。release 与 acquire 需要匹配在同一个 monitor 上才能执行正确的语义。</p>\n<h3 id=\"1-2-How-does-a-final-fields-work-under-the-new-JMM\"><a href=\"#1-2-How-does-a-final-fields-work-under-the-new-JMM\" class=\"headerlink\" title=\".1.2. How does a final fields work under the new JMM?\"></a>.1.2. How does a final fields work under the new JMM?</h3><ul>\n<li>对象的常量字段都在其构造器内赋值。</li>\n<li>一旦构造完成，即使没有添加 synchronization，常量字段的数据可以被其他所有线程可见。此外，常量字段所引用的对象或数组的可见值将被更新到与常量字段一样保持最新。</li>\n<li>一个对象正确的构造意味着：在构造期间对象的引用没有“逃逸”。<strong>换句话说：不要将被构造对象的引用置于任何其他线程可见的位置，不要将其指向静态字段，不要将其注册为其他任何对象的监听器，等等。这些操作应该在对象构造完成之后进行，而不是在构造期间进行。</strong></li>\n<li>正确构造同样保证了引用常量字段所指向的对象或数组值在构造后依然是最新的值，所以可以让常量的指针指向对象或数组，而不用担心其他线程看到正确的引用看不到引用的值。但在这里最新的值仅仅是指构造完成后，不是所有的阶段。</li>\n<li>对于一个不可变对象（所有字段都是常量）被一个线程构造完成后，如果其他所有线程想要正确可见，仍然需要使用 synchronization 。并没有其他途径可以保证，这就要求程序获取常量字段代码对于并发的管理理解深入而细致，</li>\n<li>JMM 对于使用 JNI 修改常量字段的行为并没有定义。</li>\n</ul>\n<h3 id=\"1-3-What-does-volatile-do\"><a href=\"#1-3-What-does-volatile-do\" class=\"headerlink\" title=\".1.3. What does volatile do?\"></a>.1.3. What does volatile do?</h3><ul>\n<li>volatile 字段用于线程间状态交流。对于 volatile 字段的读取都会获取到其他程的最后一次写。volatile 被设计用于不接受因缓存（cache）或指令重排（reordering）导致的 stale 值的字段。</li>\n<li>volatile 维持半同步，用于标识字段以让在 processor 缓存中，被一个线程修改后立即被 flush 到主存中，编译器与运行时被禁止将 volatile 字段值置于 processor 寄存器中，从而保证其他线程对其修改可见。</li>\n<li>指令重排限制：<ul>\n<li>老版 JMM 不允许对 volatile 字段进行 reordering ，但可以对非 volatile 字段进行重排。这让 volatile 字段成了一个线程间信号条件的方式。</li>\n<li>新版 JMM 除会限制字段不能被指令重排（reordering），同时要求 volatile 字段周围的字段都不能轻易被 reordering 。</li>\n<li>volatile 字段在修改与释放 monitor 内存效果一致（将 processor 缓存数据 flush 到主存中，从而其他线程可见），在读取与获取 monitor 内存效果一致（将本地处理器缓存中数据置为无效，变量值不得不从主存中读取）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Important Note:</strong></p>\n<ul>\n<li>多线程访问 volatile 变量都是为了合适地设置 happens-before 关系。并不是线程A在写 volatile field f 时所有可见在线程Ｂ访问 volatile field g 后都可见。释放与获取锁需要匹配到相同的 volatile 字段才能保证语义正确。</li>\n</ul>\n<h3 id=\"1-4-Does-the-new-JMM-fix-the-“double-checked-locking”-problem\"><a href=\"#1-4-Does-the-new-JMM-fix-the-“double-checked-locking”-problem\" class=\"headerlink\" title=\".1.4. Does the new JMM fix the “double-checked locking” problem?\"></a>.1.4. Does the new JMM fix the “double-checked locking” problem?</h3><p>双检锁问题</p>\n<ul>\n<li>单例模式中很多人喜欢使用双检锁模式，认为其可以降低线程阻塞概率。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//double-checked locking, Don&#x27;t do like this!</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Ins ins = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Ins <span class=\"title\">getIns</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ins == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ins == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                ins = <span class=\"keyword\">new</span> Ins();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ins;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上段代码的问题在于：在 synchronized 代码块中， ins 的初始化与赋值指令可能会被编译器或缓存重排，从而导致 ins 在某一时期内依然是个半初始化的对象，在这期间 synchronized 块外部其他读取 ins 的线程就会读取到这个半初始化的 ins 对象，就会产生使用未初始化完成的 ins 错误。</li>\n<li>在老版JMM 中添加 volatile 关键字到 ins 字段前并不能解决问题，在 JVM1.5 新版 JMM 的 volatile 可以解决问题。在使用 volatile 修辞后的 ins 并不会出现指令重排，也构成了内部线程初始化与外部线程读取的 happens-before 关系（一旦 ins 开始初始化，其他线程必须对其结果可见，也就是需要在其初始化完成前才读取到）。</li>\n</ul>"},{"layout":"post","title":"Lock Condition","date":"2021-02-05T04:08:38.000Z","description":"Lock Condition","_content":"\n> Java 新式锁所用以判定条件接口<!--more-->\n\n## .1. Translation\n\n> Condition 源码文档翻译\n\n- Condition 区别于 Object monitor 方法（wait, notify, notifyAll）：联合任意 Lock 实现，对于第个 object 提供多个等待区（wait-sets）。Lock 代替 synchronized 方法语句，Condition 代替 Object monitor 方法。\n- Condition （也叫条件变量 condition variables、条件队列 condition queues）提供了一种挂起一个线程执行的方式，线程挂起直到另一个线程通过在某状态为 true 时通知为止。因为这种共享的状态信息发生在不同的线程中，所以其必须被保护，一个某种形式的 lock 与 condition 相关联。等待一个 condition 提供的关系属性是其原子地释放其关联的 lock 并挂起当前线程，就像 [Object.wait()](./Thread.md#wait()) 。\n- Condition 实例与 Lock 实例对象严格绑定的，要获取指定 Lock 的 Condition 实例对象，调用方法 Lock 实例的 newCondition() 方法。\n- 一个 Condition 可以实现与 Object monitor 方法不一样的行为、语义，比如：通知的顺序保证、执行通知时不需要持有 lock 。如果某个 Condition 实现提供了某项指定语义，需要在其文档中加以说明。\n- 需要注意的是, Condition 对象与其他普通对象无异，同样可以被用于 synchronized 语句中，同样可以调用其 monitor （wait/notification）方法。使用 Condition 实例作为锁，与 Condition 关联的 Lock 对象与调用 Condition 的 signaling(),waiting() 方法并没有特殊关系。但建议不要用 Condition 实例当作 synchronized 锁对象，以避免歧义。\n","source":"_posts/JMM/Lock Condition.md","raw":"---\nlayout: \"post\"\ntitle: Lock Condition\ndate: 2021-02-05 12:08:38\ntags: [Java, Lock] \ncategories: [Java]\ndescription: Lock Condition\n---\n\n> Java 新式锁所用以判定条件接口<!--more-->\n\n## .1. Translation\n\n> Condition 源码文档翻译\n\n- Condition 区别于 Object monitor 方法（wait, notify, notifyAll）：联合任意 Lock 实现，对于第个 object 提供多个等待区（wait-sets）。Lock 代替 synchronized 方法语句，Condition 代替 Object monitor 方法。\n- Condition （也叫条件变量 condition variables、条件队列 condition queues）提供了一种挂起一个线程执行的方式，线程挂起直到另一个线程通过在某状态为 true 时通知为止。因为这种共享的状态信息发生在不同的线程中，所以其必须被保护，一个某种形式的 lock 与 condition 相关联。等待一个 condition 提供的关系属性是其原子地释放其关联的 lock 并挂起当前线程，就像 [Object.wait()](./Thread.md#wait()) 。\n- Condition 实例与 Lock 实例对象严格绑定的，要获取指定 Lock 的 Condition 实例对象，调用方法 Lock 实例的 newCondition() 方法。\n- 一个 Condition 可以实现与 Object monitor 方法不一样的行为、语义，比如：通知的顺序保证、执行通知时不需要持有 lock 。如果某个 Condition 实现提供了某项指定语义，需要在其文档中加以说明。\n- 需要注意的是, Condition 对象与其他普通对象无异，同样可以被用于 synchronized 语句中，同样可以调用其 monitor （wait/notification）方法。使用 Condition 实例作为锁，与 Condition 关联的 Lock 对象与调用 Condition 的 signaling(),waiting() 方法并没有特殊关系。但建议不要用 Condition 实例当作 synchronized 锁对象，以避免歧义。\n","slug":"JMM/Lock Condition","published":1,"updated":"2021-02-24T15:22:22.652Z","comments":1,"photos":[],"link":"","_id":"ckljnokqu000k2bhb8k78hhro","content":"<blockquote>\n<p>Java 新式锁所用以判定条件接口<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"1-Translation\"><a href=\"#1-Translation\" class=\"headerlink\" title=\".1. Translation\"></a>.1. Translation</h2><blockquote>\n<p>Condition 源码文档翻译</p>\n</blockquote>\n<ul>\n<li>Condition 区别于 Object monitor 方法（wait, notify, notifyAll）：联合任意 Lock 实现，对于第个 object 提供多个等待区（wait-sets）。Lock 代替 synchronized 方法语句，Condition 代替 Object monitor 方法。</li>\n<li>Condition （也叫条件变量 condition variables、条件队列 condition queues）提供了一种挂起一个线程执行的方式，线程挂起直到另一个线程通过在某状态为 true 时通知为止。因为这种共享的状态信息发生在不同的线程中，所以其必须被保护，一个某种形式的 lock 与 condition 相关联。等待一个 condition 提供的关系属性是其原子地释放其关联的 lock 并挂起当前线程，就像 <a href=\"./Thread.md#wait()\">Object.wait()</a> 。</li>\n<li>Condition 实例与 Lock 实例对象严格绑定的，要获取指定 Lock 的 Condition 实例对象，调用方法 Lock 实例的 newCondition() 方法。</li>\n<li>一个 Condition 可以实现与 Object monitor 方法不一样的行为、语义，比如：通知的顺序保证、执行通知时不需要持有 lock 。如果某个 Condition 实现提供了某项指定语义，需要在其文档中加以说明。</li>\n<li>需要注意的是, Condition 对象与其他普通对象无异，同样可以被用于 synchronized 语句中，同样可以调用其 monitor （wait/notification）方法。使用 Condition 实例作为锁，与 Condition 关联的 Lock 对象与调用 Condition 的 signaling(),waiting() 方法并没有特殊关系。但建议不要用 Condition 实例当作 synchronized 锁对象，以避免歧义。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Java 新式锁所用以判定条件接口","more":"</p>\n</blockquote>\n<h2 id=\"1-Translation\"><a href=\"#1-Translation\" class=\"headerlink\" title=\".1. Translation\"></a>.1. Translation</h2><blockquote>\n<p>Condition 源码文档翻译</p>\n</blockquote>\n<ul>\n<li>Condition 区别于 Object monitor 方法（wait, notify, notifyAll）：联合任意 Lock 实现，对于第个 object 提供多个等待区（wait-sets）。Lock 代替 synchronized 方法语句，Condition 代替 Object monitor 方法。</li>\n<li>Condition （也叫条件变量 condition variables、条件队列 condition queues）提供了一种挂起一个线程执行的方式，线程挂起直到另一个线程通过在某状态为 true 时通知为止。因为这种共享的状态信息发生在不同的线程中，所以其必须被保护，一个某种形式的 lock 与 condition 相关联。等待一个 condition 提供的关系属性是其原子地释放其关联的 lock 并挂起当前线程，就像 <a href=\"./Thread.md#wait()\">Object.wait()</a> 。</li>\n<li>Condition 实例与 Lock 实例对象严格绑定的，要获取指定 Lock 的 Condition 实例对象，调用方法 Lock 实例的 newCondition() 方法。</li>\n<li>一个 Condition 可以实现与 Object monitor 方法不一样的行为、语义，比如：通知的顺序保证、执行通知时不需要持有 lock 。如果某个 Condition 实现提供了某项指定语义，需要在其文档中加以说明。</li>\n<li>需要注意的是, Condition 对象与其他普通对象无异，同样可以被用于 synchronized 语句中，同样可以调用其 monitor （wait/notification）方法。使用 Condition 实例作为锁，与 Condition 关联的 Lock 对象与调用 Condition 的 signaling(),waiting() 方法并没有特殊关系。但建议不要用 Condition 实例当作 synchronized 锁对象，以避免歧义。</li>\n</ul>"},{"layout":"post","title":"Java Thread & Java Object","date":"2020-12-28T04:01:00.000Z","description":"Java Thread & Java Object","_content":"\n> Java 线程与对象的基本方法\n\n## .1. Thread\n\n> java thread<!--more-->\n\n### .1.1. join\n\n- join(long timeout) 方法将循环调用 wait(long timeout) 方法，直到该线程(thisThread)死亡。也就是说，当前线程（执行 thisThread.join() 方法的线程)）会加入到该线程的等待区以获取该线程 monitor 。一般来讲，很少有与当前线程一起竞争该线程的锁，也就是会出现循环地获取到 thisThread 的锁，直到 timeout。\n- 当 timeout = 0 时，将一直等待 thisThread ，直到 thisThread 死亡。\n- 当 thisTread 死亡时，将调用其 notifyAll() 方法，将所有等待区的线程唤醒。\n- *整个过程就像，当前线程加入到 thisThread 的生命周期里一样，所以此方法命名为 join 是有一定道理的。*\n\n### .1.2. interrupt\n\n> public void interrupt();\n\nJDK doc:\n\n- 中断线程方法，Java 规范并不保证会立即中断响应，可能会是在处理完特定任务到达某个中断点再中断。对于被中断的线程来说，会被立即设置中断状态。\n- 除非线程是中断自己，否则 checkAccess() 方法会被调用以检查是否允许访问（如果中断自己则检查始终会通过），这可能会导致抛出 SecurityException\n- 如果线程正被 Object 的 wait 系列方法、Thread 的 join,sleep 系列方法所阻塞，其中断状态会被 interrupt 清除并收到一个 InterruptedException 。\n- 如果线程正在 InterruptibleChannel 上进行 I/O 操作而被阻塞，此 channel 将被关闭，同时线程被设置为中断状态并收到 ClosedByInterruptException　。\n- 如果线程正阻塞在 java.nio.channels.Selector 线程将被设置中断状态，并立即从 selection 操作中返回，可能会返回一个非零值，与调用 selector.wakeup 类似。\n- 除前面说到的三种情形之外，线程都会被设置中断状态。\n- 中断线程无实时响应效果。\n\n### .1.3. tips\n\n- [当前线程并不能捕获到其他线程的异常](https://stackoverflow.com/questions/6546193/how-to-catch-an-exception-from-a-thread)。如果需要对异步线程异常控制，使用 Future 或 Thread.UncaughtExceptionHandler；\n\n## .2. Object\n\n> 与线程生命周期相关的锁方法\n\n### .2.1. wait()\n\n> 据 Object 文档翻译\n\n- 调用此方法的前提是线程先对该对象的 monitor 加锁，notify 方法也是一样。\n- 调用此方法的线程会先释放该对象的 monitor ，再进入到对象 monitor wait-sets。\n- wait(long timeout) 方法让当前线程进入等待，直到有其他的线程调用对象的 notify()/notifyAll() 方法或者指定的时间流逝。\n- 当前线程必须拥有对象的监视器 monitor 。\n- 此该当让当前线程进入到对象的等待区，并放弃针对此对象的所有同步声明。线程 scheduling purpose 被废弃并进入到到冬眠阶段直到以下四个事件发生为止：\n    - 其他线程调用对象的 notify() 方法，并且本线程刚好被选中苏醒。\n    - 其他线程调用对象的 notifyAll() 方\n    - 其他线程调用本线程的 {@link Thread#interrupt()} 方法打断本线程等待阻塞。\n    - 指定的等待超时时间 timeout 已到，或多或少。如果 timeout 为 0 ，那么超时设置将不生效，只能让其他线程来 notify 。\n- wait() 方法只会让线程进入到指定对象的等待区，在等待该对象时也可以持有其他对象的同步锁。\n- wait() 方法只能被持有对象的 monitor 线程调用。\n\n### .2.2. notify()\n\n> Object 的 notify() 方法，此方法的文档描述了获取对象 monitor 的场景。\n\n- 方法用于唤醒一个等待在该对象 monitor 的线程。\n- 在等待区的线程都有可能被唤醒，具体由实现决定。一个线程进入对象的等待区调用对象的 wait() 方法即可。\n- 被唤醒的线程需要等待当前有锁的线程释放了当前对象的锁后才能直接运行，同时需要与其他参与到该对象同步竞争的活性线程一起竞争。eg: 被唤醒的线程更喜欢在成为下一个锁定该对象的线程没有可靠的优势与劣势。（？？？）\n- notify() 方法只能被拥有对象 monitor 的线程调用。一个线程要拥有对象的 monitor 有以下三种方式：\n    - 正执行对象的一个实例同步方法\n    - 执行对象的同步语句块\n    - 对于 class 对象的monitor，执行该 class 的静态同步方法\n- 同一时间只能有一个线程持有对象的 monitor 。\n\n### .2.3. clone()\n\n> 此方法与同步无关，但早期留意过一起翻译了。\n\n- clone() 方法创建当前对象的复制对象。具体的含义取决于对象的实现。一般来说，对于一个对象 x 需要以下含义：\n    - x.clone() != x\n    - x.clone().getClass() == x.getClass() 非必需\n    - x.clone().equals(x) 非必需\n- 按惯例：返回的对象需要通过调用 super.clone() 实现，如果一个类及其所有父类（除 Object 外）遵循了这个规则，`x.clone().getClass() == x.getClass()` 就会成立。\n- 按惯例，对象调用 clone() 方法返回的对象必须与对象保持独立。为实现这种独立，需要在调用 super.clone() 后对某些字段进行修改（Object.clone() 方法只是浅拷贝）。也就是说对一个可变对象的 copy 由两部分组成：对象内部**深度结构**的 clone 与用这些被 copy 的引用替换内部对象的引用。\n- 如果对象未实现 Cloneable 接口，将抛出 CloneNotSupportedException 。所有的数组都认为其实现了 Cloneable 接口。一个数组类型 T[] 在调用 clone() 方法后返回 T[] ，T 可以是任何引用或基本类型。\n    - 否则 clone() 将返回该 class 的一个新实例，并且该实例使用原对象相应的字段内容初始化所有的字段。也就是说该方法只是**浅拷贝**。\n- Object 本身并未实现 Cloneable 接口，所有直接调用 Object 对象的 clone() 方法将 throw 出运行时异常。\n","source":"_posts/JMM/Thread.md","raw":"---\nlayout: \"post\"\ntitle: Java Thread & Java Object\ndate: 2020-12-28 12:01:00\ntags: [java,programming]\ncategories: [Java]\ndescription: Java Thread & Java Object\n---\n\n> Java 线程与对象的基本方法\n\n## .1. Thread\n\n> java thread<!--more-->\n\n### .1.1. join\n\n- join(long timeout) 方法将循环调用 wait(long timeout) 方法，直到该线程(thisThread)死亡。也就是说，当前线程（执行 thisThread.join() 方法的线程)）会加入到该线程的等待区以获取该线程 monitor 。一般来讲，很少有与当前线程一起竞争该线程的锁，也就是会出现循环地获取到 thisThread 的锁，直到 timeout。\n- 当 timeout = 0 时，将一直等待 thisThread ，直到 thisThread 死亡。\n- 当 thisTread 死亡时，将调用其 notifyAll() 方法，将所有等待区的线程唤醒。\n- *整个过程就像，当前线程加入到 thisThread 的生命周期里一样，所以此方法命名为 join 是有一定道理的。*\n\n### .1.2. interrupt\n\n> public void interrupt();\n\nJDK doc:\n\n- 中断线程方法，Java 规范并不保证会立即中断响应，可能会是在处理完特定任务到达某个中断点再中断。对于被中断的线程来说，会被立即设置中断状态。\n- 除非线程是中断自己，否则 checkAccess() 方法会被调用以检查是否允许访问（如果中断自己则检查始终会通过），这可能会导致抛出 SecurityException\n- 如果线程正被 Object 的 wait 系列方法、Thread 的 join,sleep 系列方法所阻塞，其中断状态会被 interrupt 清除并收到一个 InterruptedException 。\n- 如果线程正在 InterruptibleChannel 上进行 I/O 操作而被阻塞，此 channel 将被关闭，同时线程被设置为中断状态并收到 ClosedByInterruptException　。\n- 如果线程正阻塞在 java.nio.channels.Selector 线程将被设置中断状态，并立即从 selection 操作中返回，可能会返回一个非零值，与调用 selector.wakeup 类似。\n- 除前面说到的三种情形之外，线程都会被设置中断状态。\n- 中断线程无实时响应效果。\n\n### .1.3. tips\n\n- [当前线程并不能捕获到其他线程的异常](https://stackoverflow.com/questions/6546193/how-to-catch-an-exception-from-a-thread)。如果需要对异步线程异常控制，使用 Future 或 Thread.UncaughtExceptionHandler；\n\n## .2. Object\n\n> 与线程生命周期相关的锁方法\n\n### .2.1. wait()\n\n> 据 Object 文档翻译\n\n- 调用此方法的前提是线程先对该对象的 monitor 加锁，notify 方法也是一样。\n- 调用此方法的线程会先释放该对象的 monitor ，再进入到对象 monitor wait-sets。\n- wait(long timeout) 方法让当前线程进入等待，直到有其他的线程调用对象的 notify()/notifyAll() 方法或者指定的时间流逝。\n- 当前线程必须拥有对象的监视器 monitor 。\n- 此该当让当前线程进入到对象的等待区，并放弃针对此对象的所有同步声明。线程 scheduling purpose 被废弃并进入到到冬眠阶段直到以下四个事件发生为止：\n    - 其他线程调用对象的 notify() 方法，并且本线程刚好被选中苏醒。\n    - 其他线程调用对象的 notifyAll() 方\n    - 其他线程调用本线程的 {@link Thread#interrupt()} 方法打断本线程等待阻塞。\n    - 指定的等待超时时间 timeout 已到，或多或少。如果 timeout 为 0 ，那么超时设置将不生效，只能让其他线程来 notify 。\n- wait() 方法只会让线程进入到指定对象的等待区，在等待该对象时也可以持有其他对象的同步锁。\n- wait() 方法只能被持有对象的 monitor 线程调用。\n\n### .2.2. notify()\n\n> Object 的 notify() 方法，此方法的文档描述了获取对象 monitor 的场景。\n\n- 方法用于唤醒一个等待在该对象 monitor 的线程。\n- 在等待区的线程都有可能被唤醒，具体由实现决定。一个线程进入对象的等待区调用对象的 wait() 方法即可。\n- 被唤醒的线程需要等待当前有锁的线程释放了当前对象的锁后才能直接运行，同时需要与其他参与到该对象同步竞争的活性线程一起竞争。eg: 被唤醒的线程更喜欢在成为下一个锁定该对象的线程没有可靠的优势与劣势。（？？？）\n- notify() 方法只能被拥有对象 monitor 的线程调用。一个线程要拥有对象的 monitor 有以下三种方式：\n    - 正执行对象的一个实例同步方法\n    - 执行对象的同步语句块\n    - 对于 class 对象的monitor，执行该 class 的静态同步方法\n- 同一时间只能有一个线程持有对象的 monitor 。\n\n### .2.3. clone()\n\n> 此方法与同步无关，但早期留意过一起翻译了。\n\n- clone() 方法创建当前对象的复制对象。具体的含义取决于对象的实现。一般来说，对于一个对象 x 需要以下含义：\n    - x.clone() != x\n    - x.clone().getClass() == x.getClass() 非必需\n    - x.clone().equals(x) 非必需\n- 按惯例：返回的对象需要通过调用 super.clone() 实现，如果一个类及其所有父类（除 Object 外）遵循了这个规则，`x.clone().getClass() == x.getClass()` 就会成立。\n- 按惯例，对象调用 clone() 方法返回的对象必须与对象保持独立。为实现这种独立，需要在调用 super.clone() 后对某些字段进行修改（Object.clone() 方法只是浅拷贝）。也就是说对一个可变对象的 copy 由两部分组成：对象内部**深度结构**的 clone 与用这些被 copy 的引用替换内部对象的引用。\n- 如果对象未实现 Cloneable 接口，将抛出 CloneNotSupportedException 。所有的数组都认为其实现了 Cloneable 接口。一个数组类型 T[] 在调用 clone() 方法后返回 T[] ，T 可以是任何引用或基本类型。\n    - 否则 clone() 将返回该 class 的一个新实例，并且该实例使用原对象相应的字段内容初始化所有的字段。也就是说该方法只是**浅拷贝**。\n- Object 本身并未实现 Cloneable 接口，所有直接调用 Object 对象的 clone() 方法将 throw 出运行时异常。\n","slug":"JMM/Thread","published":1,"updated":"2021-02-24T15:22:22.652Z","comments":1,"photos":[],"link":"","_id":"ckljnokqw000n2bhb8h34g94o","content":"<blockquote>\n<p>Java 线程与对象的基本方法</p>\n</blockquote>\n<h2 id=\"1-Thread\"><a href=\"#1-Thread\" class=\"headerlink\" title=\".1. Thread\"></a>.1. Thread</h2><blockquote>\n<p>java thread<span id=\"more\"></span></p>\n</blockquote>\n<h3 id=\"1-1-join\"><a href=\"#1-1-join\" class=\"headerlink\" title=\".1.1. join\"></a>.1.1. join</h3><ul>\n<li>join(long timeout) 方法将循环调用 wait(long timeout) 方法，直到该线程(thisThread)死亡。也就是说，当前线程（执行 thisThread.join() 方法的线程)）会加入到该线程的等待区以获取该线程 monitor 。一般来讲，很少有与当前线程一起竞争该线程的锁，也就是会出现循环地获取到 thisThread 的锁，直到 timeout。</li>\n<li>当 timeout = 0 时，将一直等待 thisThread ，直到 thisThread 死亡。</li>\n<li>当 thisTread 死亡时，将调用其 notifyAll() 方法，将所有等待区的线程唤醒。</li>\n<li><em>整个过程就像，当前线程加入到 thisThread 的生命周期里一样，所以此方法命名为 join 是有一定道理的。</em></li>\n</ul>\n<h3 id=\"1-2-interrupt\"><a href=\"#1-2-interrupt\" class=\"headerlink\" title=\".1.2. interrupt\"></a>.1.2. interrupt</h3><blockquote>\n<p>public void interrupt();</p>\n</blockquote>\n<p>JDK doc:</p>\n<ul>\n<li>中断线程方法，Java 规范并不保证会立即中断响应，可能会是在处理完特定任务到达某个中断点再中断。对于被中断的线程来说，会被立即设置中断状态。</li>\n<li>除非线程是中断自己，否则 checkAccess() 方法会被调用以检查是否允许访问（如果中断自己则检查始终会通过），这可能会导致抛出 SecurityException</li>\n<li>如果线程正被 Object 的 wait 系列方法、Thread 的 join,sleep 系列方法所阻塞，其中断状态会被 interrupt 清除并收到一个 InterruptedException 。</li>\n<li>如果线程正在 InterruptibleChannel 上进行 I/O 操作而被阻塞，此 channel 将被关闭，同时线程被设置为中断状态并收到 ClosedByInterruptException　。</li>\n<li>如果线程正阻塞在 java.nio.channels.Selector 线程将被设置中断状态，并立即从 selection 操作中返回，可能会返回一个非零值，与调用 selector.wakeup 类似。</li>\n<li>除前面说到的三种情形之外，线程都会被设置中断状态。</li>\n<li>中断线程无实时响应效果。</li>\n</ul>\n<h3 id=\"1-3-tips\"><a href=\"#1-3-tips\" class=\"headerlink\" title=\".1.3. tips\"></a>.1.3. tips</h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/6546193/how-to-catch-an-exception-from-a-thread\">当前线程并不能捕获到其他线程的异常</a>。如果需要对异步线程异常控制，使用 Future 或 Thread.UncaughtExceptionHandler；</li>\n</ul>\n<h2 id=\"2-Object\"><a href=\"#2-Object\" class=\"headerlink\" title=\".2. Object\"></a>.2. Object</h2><blockquote>\n<p>与线程生命周期相关的锁方法</p>\n</blockquote>\n<h3 id=\"2-1-wait\"><a href=\"#2-1-wait\" class=\"headerlink\" title=\".2.1. wait()\"></a>.2.1. wait()</h3><blockquote>\n<p>据 Object 文档翻译</p>\n</blockquote>\n<ul>\n<li>调用此方法的前提是线程先对该对象的 monitor 加锁，notify 方法也是一样。</li>\n<li>调用此方法的线程会先释放该对象的 monitor ，再进入到对象 monitor wait-sets。</li>\n<li>wait(long timeout) 方法让当前线程进入等待，直到有其他的线程调用对象的 notify()/notifyAll() 方法或者指定的时间流逝。</li>\n<li>当前线程必须拥有对象的监视器 monitor 。</li>\n<li>此该当让当前线程进入到对象的等待区，并放弃针对此对象的所有同步声明。线程 scheduling purpose 被废弃并进入到到冬眠阶段直到以下四个事件发生为止：<ul>\n<li>其他线程调用对象的 notify() 方法，并且本线程刚好被选中苏醒。</li>\n<li>其他线程调用对象的 notifyAll() 方</li>\n<li>其他线程调用本线程的 {@link Thread#interrupt()} 方法打断本线程等待阻塞。</li>\n<li>指定的等待超时时间 timeout 已到，或多或少。如果 timeout 为 0 ，那么超时设置将不生效，只能让其他线程来 notify 。</li>\n</ul>\n</li>\n<li>wait() 方法只会让线程进入到指定对象的等待区，在等待该对象时也可以持有其他对象的同步锁。</li>\n<li>wait() 方法只能被持有对象的 monitor 线程调用。</li>\n</ul>\n<h3 id=\"2-2-notify\"><a href=\"#2-2-notify\" class=\"headerlink\" title=\".2.2. notify()\"></a>.2.2. notify()</h3><blockquote>\n<p>Object 的 notify() 方法，此方法的文档描述了获取对象 monitor 的场景。</p>\n</blockquote>\n<ul>\n<li>方法用于唤醒一个等待在该对象 monitor 的线程。</li>\n<li>在等待区的线程都有可能被唤醒，具体由实现决定。一个线程进入对象的等待区调用对象的 wait() 方法即可。</li>\n<li>被唤醒的线程需要等待当前有锁的线程释放了当前对象的锁后才能直接运行，同时需要与其他参与到该对象同步竞争的活性线程一起竞争。eg: 被唤醒的线程更喜欢在成为下一个锁定该对象的线程没有可靠的优势与劣势。（？？？）</li>\n<li>notify() 方法只能被拥有对象 monitor 的线程调用。一个线程要拥有对象的 monitor 有以下三种方式：<ul>\n<li>正执行对象的一个实例同步方法</li>\n<li>执行对象的同步语句块</li>\n<li>对于 class 对象的monitor，执行该 class 的静态同步方法</li>\n</ul>\n</li>\n<li>同一时间只能有一个线程持有对象的 monitor 。</li>\n</ul>\n<h3 id=\"2-3-clone\"><a href=\"#2-3-clone\" class=\"headerlink\" title=\".2.3. clone()\"></a>.2.3. clone()</h3><blockquote>\n<p>此方法与同步无关，但早期留意过一起翻译了。</p>\n</blockquote>\n<ul>\n<li>clone() 方法创建当前对象的复制对象。具体的含义取决于对象的实现。一般来说，对于一个对象 x 需要以下含义：<ul>\n<li>x.clone() != x</li>\n<li>x.clone().getClass() == x.getClass() 非必需</li>\n<li>x.clone().equals(x) 非必需</li>\n</ul>\n</li>\n<li>按惯例：返回的对象需要通过调用 super.clone() 实现，如果一个类及其所有父类（除 Object 外）遵循了这个规则，<code>x.clone().getClass() == x.getClass()</code> 就会成立。</li>\n<li>按惯例，对象调用 clone() 方法返回的对象必须与对象保持独立。为实现这种独立，需要在调用 super.clone() 后对某些字段进行修改（Object.clone() 方法只是浅拷贝）。也就是说对一个可变对象的 copy 由两部分组成：对象内部<strong>深度结构</strong>的 clone 与用这些被 copy 的引用替换内部对象的引用。</li>\n<li>如果对象未实现 Cloneable 接口，将抛出 CloneNotSupportedException 。所有的数组都认为其实现了 Cloneable 接口。一个数组类型 T[] 在调用 clone() 方法后返回 T[] ，T 可以是任何引用或基本类型。<ul>\n<li>否则 clone() 将返回该 class 的一个新实例，并且该实例使用原对象相应的字段内容初始化所有的字段。也就是说该方法只是<strong>浅拷贝</strong>。</li>\n</ul>\n</li>\n<li>Object 本身并未实现 Cloneable 接口，所有直接调用 Object 对象的 clone() 方法将 throw 出运行时异常。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Java 线程与对象的基本方法</p>\n</blockquote>\n<h2 id=\"1-Thread\"><a href=\"#1-Thread\" class=\"headerlink\" title=\".1. Thread\"></a>.1. Thread</h2><blockquote>\n<p>java thread","more":"</p>\n</blockquote>\n<h3 id=\"1-1-join\"><a href=\"#1-1-join\" class=\"headerlink\" title=\".1.1. join\"></a>.1.1. join</h3><ul>\n<li>join(long timeout) 方法将循环调用 wait(long timeout) 方法，直到该线程(thisThread)死亡。也就是说，当前线程（执行 thisThread.join() 方法的线程)）会加入到该线程的等待区以获取该线程 monitor 。一般来讲，很少有与当前线程一起竞争该线程的锁，也就是会出现循环地获取到 thisThread 的锁，直到 timeout。</li>\n<li>当 timeout = 0 时，将一直等待 thisThread ，直到 thisThread 死亡。</li>\n<li>当 thisTread 死亡时，将调用其 notifyAll() 方法，将所有等待区的线程唤醒。</li>\n<li><em>整个过程就像，当前线程加入到 thisThread 的生命周期里一样，所以此方法命名为 join 是有一定道理的。</em></li>\n</ul>\n<h3 id=\"1-2-interrupt\"><a href=\"#1-2-interrupt\" class=\"headerlink\" title=\".1.2. interrupt\"></a>.1.2. interrupt</h3><blockquote>\n<p>public void interrupt();</p>\n</blockquote>\n<p>JDK doc:</p>\n<ul>\n<li>中断线程方法，Java 规范并不保证会立即中断响应，可能会是在处理完特定任务到达某个中断点再中断。对于被中断的线程来说，会被立即设置中断状态。</li>\n<li>除非线程是中断自己，否则 checkAccess() 方法会被调用以检查是否允许访问（如果中断自己则检查始终会通过），这可能会导致抛出 SecurityException</li>\n<li>如果线程正被 Object 的 wait 系列方法、Thread 的 join,sleep 系列方法所阻塞，其中断状态会被 interrupt 清除并收到一个 InterruptedException 。</li>\n<li>如果线程正在 InterruptibleChannel 上进行 I/O 操作而被阻塞，此 channel 将被关闭，同时线程被设置为中断状态并收到 ClosedByInterruptException　。</li>\n<li>如果线程正阻塞在 java.nio.channels.Selector 线程将被设置中断状态，并立即从 selection 操作中返回，可能会返回一个非零值，与调用 selector.wakeup 类似。</li>\n<li>除前面说到的三种情形之外，线程都会被设置中断状态。</li>\n<li>中断线程无实时响应效果。</li>\n</ul>\n<h3 id=\"1-3-tips\"><a href=\"#1-3-tips\" class=\"headerlink\" title=\".1.3. tips\"></a>.1.3. tips</h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/6546193/how-to-catch-an-exception-from-a-thread\">当前线程并不能捕获到其他线程的异常</a>。如果需要对异步线程异常控制，使用 Future 或 Thread.UncaughtExceptionHandler；</li>\n</ul>\n<h2 id=\"2-Object\"><a href=\"#2-Object\" class=\"headerlink\" title=\".2. Object\"></a>.2. Object</h2><blockquote>\n<p>与线程生命周期相关的锁方法</p>\n</blockquote>\n<h3 id=\"2-1-wait\"><a href=\"#2-1-wait\" class=\"headerlink\" title=\".2.1. wait()\"></a>.2.1. wait()</h3><blockquote>\n<p>据 Object 文档翻译</p>\n</blockquote>\n<ul>\n<li>调用此方法的前提是线程先对该对象的 monitor 加锁，notify 方法也是一样。</li>\n<li>调用此方法的线程会先释放该对象的 monitor ，再进入到对象 monitor wait-sets。</li>\n<li>wait(long timeout) 方法让当前线程进入等待，直到有其他的线程调用对象的 notify()/notifyAll() 方法或者指定的时间流逝。</li>\n<li>当前线程必须拥有对象的监视器 monitor 。</li>\n<li>此该当让当前线程进入到对象的等待区，并放弃针对此对象的所有同步声明。线程 scheduling purpose 被废弃并进入到到冬眠阶段直到以下四个事件发生为止：<ul>\n<li>其他线程调用对象的 notify() 方法，并且本线程刚好被选中苏醒。</li>\n<li>其他线程调用对象的 notifyAll() 方</li>\n<li>其他线程调用本线程的 {@link Thread#interrupt()} 方法打断本线程等待阻塞。</li>\n<li>指定的等待超时时间 timeout 已到，或多或少。如果 timeout 为 0 ，那么超时设置将不生效，只能让其他线程来 notify 。</li>\n</ul>\n</li>\n<li>wait() 方法只会让线程进入到指定对象的等待区，在等待该对象时也可以持有其他对象的同步锁。</li>\n<li>wait() 方法只能被持有对象的 monitor 线程调用。</li>\n</ul>\n<h3 id=\"2-2-notify\"><a href=\"#2-2-notify\" class=\"headerlink\" title=\".2.2. notify()\"></a>.2.2. notify()</h3><blockquote>\n<p>Object 的 notify() 方法，此方法的文档描述了获取对象 monitor 的场景。</p>\n</blockquote>\n<ul>\n<li>方法用于唤醒一个等待在该对象 monitor 的线程。</li>\n<li>在等待区的线程都有可能被唤醒，具体由实现决定。一个线程进入对象的等待区调用对象的 wait() 方法即可。</li>\n<li>被唤醒的线程需要等待当前有锁的线程释放了当前对象的锁后才能直接运行，同时需要与其他参与到该对象同步竞争的活性线程一起竞争。eg: 被唤醒的线程更喜欢在成为下一个锁定该对象的线程没有可靠的优势与劣势。（？？？）</li>\n<li>notify() 方法只能被拥有对象 monitor 的线程调用。一个线程要拥有对象的 monitor 有以下三种方式：<ul>\n<li>正执行对象的一个实例同步方法</li>\n<li>执行对象的同步语句块</li>\n<li>对于 class 对象的monitor，执行该 class 的静态同步方法</li>\n</ul>\n</li>\n<li>同一时间只能有一个线程持有对象的 monitor 。</li>\n</ul>\n<h3 id=\"2-3-clone\"><a href=\"#2-3-clone\" class=\"headerlink\" title=\".2.3. clone()\"></a>.2.3. clone()</h3><blockquote>\n<p>此方法与同步无关，但早期留意过一起翻译了。</p>\n</blockquote>\n<ul>\n<li>clone() 方法创建当前对象的复制对象。具体的含义取决于对象的实现。一般来说，对于一个对象 x 需要以下含义：<ul>\n<li>x.clone() != x</li>\n<li>x.clone().getClass() == x.getClass() 非必需</li>\n<li>x.clone().equals(x) 非必需</li>\n</ul>\n</li>\n<li>按惯例：返回的对象需要通过调用 super.clone() 实现，如果一个类及其所有父类（除 Object 外）遵循了这个规则，<code>x.clone().getClass() == x.getClass()</code> 就会成立。</li>\n<li>按惯例，对象调用 clone() 方法返回的对象必须与对象保持独立。为实现这种独立，需要在调用 super.clone() 后对某些字段进行修改（Object.clone() 方法只是浅拷贝）。也就是说对一个可变对象的 copy 由两部分组成：对象内部<strong>深度结构</strong>的 clone 与用这些被 copy 的引用替换内部对象的引用。</li>\n<li>如果对象未实现 Cloneable 接口，将抛出 CloneNotSupportedException 。所有的数组都认为其实现了 Cloneable 接口。一个数组类型 T[] 在调用 clone() 方法后返回 T[] ，T 可以是任何引用或基本类型。<ul>\n<li>否则 clone() 将返回该 class 的一个新实例，并且该实例使用原对象相应的字段内容初始化所有的字段。也就是说该方法只是<strong>浅拷贝</strong>。</li>\n</ul>\n</li>\n<li>Object 本身并未实现 Cloneable 接口，所有直接调用 Object 对象的 clone() 方法将 throw 出运行时异常。</li>\n</ul>"},{"layout":"post","title":"Volatile","date":"2020-04-21T04:08:38.000Z","description":"java keyword `volatile`","_content":"\njava 中关键字 volatile 的使用 [reference](https://mp.weixin.qq.com/s/AE0oeKiCU_aetfkW9Qk0cg)<!--more-->\n\n- volatile 的做法：\n    - 使用内存屏障让前后的指令重排（为提升效率，而在编译运行期对指令进行重排）都不干扰所修辞的变量；\n    - 单个线程里对共享变量的更新强制刷新到主内存中，而使其他线程中本地内存中的共享变量失效。\n    - 不保证原子性，\n        - 保证原子性：使用 `synchronize`\n        - 使用 `lock`\n        - 前两种太重，可使用 Atomic 包，其使用 CAS 循环实现原子操作。\n\n## .1. Volatile in Double Check Singleton\n\n双检锁单例中的共享变量需要加上 `volatile` 才能真正做到正确，否则在多线程情况下出现问题。\n\n单例模式\n\n```java\nprivate Singleton() {}\n\nprivate static Singleton ins;\n\npublic static Singleton getInstance() {\n    if (ins == null) {\n        synchronized (Singleton.class) {\n            if (ins == null) {\n                ins = new Singleton();\n            }\n        }\n    }\n    return ins;\n}\n```\n\n- 当 `int = new Instance()` 这一行代码并非原子性，其指定分为 3 个 :\n    - a. memory = allocate() 分配内存；\n    - b. ctorInstance(memory) 初始化对象；\n    - c. ins=memory 设置 ins 指向刚分配的地址。\n- a -> b -> c 三条指令可能会被重排 a -> c -> b 的顺序。在双检锁的案例中，当线程1走到 c 时，其他线程走到第一层检查 ins 是否为空时，会得到 false 的结果，因为此时 ins 已指向了一个内存地址，而线程1 此时还未为其初始化，而出现 bug 。\n","source":"_posts/JMM/Volatile.md","raw":"---\nlayout: \"post\"\ntitle: Volatile\ndate: 2020-04-21 12:08:38\ntags: [java,volatile]\ncategories: [Java]\ndescription: java keyword `volatile`\n---\n\njava 中关键字 volatile 的使用 [reference](https://mp.weixin.qq.com/s/AE0oeKiCU_aetfkW9Qk0cg)<!--more-->\n\n- volatile 的做法：\n    - 使用内存屏障让前后的指令重排（为提升效率，而在编译运行期对指令进行重排）都不干扰所修辞的变量；\n    - 单个线程里对共享变量的更新强制刷新到主内存中，而使其他线程中本地内存中的共享变量失效。\n    - 不保证原子性，\n        - 保证原子性：使用 `synchronize`\n        - 使用 `lock`\n        - 前两种太重，可使用 Atomic 包，其使用 CAS 循环实现原子操作。\n\n## .1. Volatile in Double Check Singleton\n\n双检锁单例中的共享变量需要加上 `volatile` 才能真正做到正确，否则在多线程情况下出现问题。\n\n单例模式\n\n```java\nprivate Singleton() {}\n\nprivate static Singleton ins;\n\npublic static Singleton getInstance() {\n    if (ins == null) {\n        synchronized (Singleton.class) {\n            if (ins == null) {\n                ins = new Singleton();\n            }\n        }\n    }\n    return ins;\n}\n```\n\n- 当 `int = new Instance()` 这一行代码并非原子性，其指定分为 3 个 :\n    - a. memory = allocate() 分配内存；\n    - b. ctorInstance(memory) 初始化对象；\n    - c. ins=memory 设置 ins 指向刚分配的地址。\n- a -> b -> c 三条指令可能会被重排 a -> c -> b 的顺序。在双检锁的案例中，当线程1走到 c 时，其他线程走到第一层检查 ins 是否为空时，会得到 false 的结果，因为此时 ins 已指向了一个内存地址，而线程1 此时还未为其初始化，而出现 bug 。\n","slug":"JMM/Volatile","published":1,"updated":"2021-02-24T15:22:22.652Z","comments":1,"photos":[],"link":"","_id":"ckljnokqy000q2bhbdobqe45s","content":"<p>java 中关键字 volatile 的使用 <a href=\"https://mp.weixin.qq.com/s/AE0oeKiCU_aetfkW9Qk0cg\">reference</a><span id=\"more\"></span></p>\n<ul>\n<li>volatile 的做法：<ul>\n<li>使用内存屏障让前后的指令重排（为提升效率，而在编译运行期对指令进行重排）都不干扰所修辞的变量；</li>\n<li>单个线程里对共享变量的更新强制刷新到主内存中，而使其他线程中本地内存中的共享变量失效。</li>\n<li>不保证原子性，<ul>\n<li>保证原子性：使用 <code>synchronize</code></li>\n<li>使用 <code>lock</code></li>\n<li>前两种太重，可使用 Atomic 包，其使用 CAS 循环实现原子操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-Volatile-in-Double-Check-Singleton\"><a href=\"#1-Volatile-in-Double-Check-Singleton\" class=\"headerlink\" title=\".1. Volatile in Double Check Singleton\"></a>.1. Volatile in Double Check Singleton</h2><p>双检锁单例中的共享变量需要加上 <code>volatile</code> 才能真正做到正确，否则在多线程情况下出现问题。</p>\n<p>单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton ins;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ins == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ins == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ins = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ins;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当 <code>int = new Instance()</code> 这一行代码并非原子性，其指定分为 3 个 :<ul>\n<li>a. memory = allocate() 分配内存；</li>\n<li>b. ctorInstance(memory) 初始化对象；</li>\n<li>c. ins=memory 设置 ins 指向刚分配的地址。</li>\n</ul>\n</li>\n<li>a -&gt; b -&gt; c 三条指令可能会被重排 a -&gt; c -&gt; b 的顺序。在双检锁的案例中，当线程1走到 c 时，其他线程走到第一层检查 ins 是否为空时，会得到 false 的结果，因为此时 ins 已指向了一个内存地址，而线程1 此时还未为其初始化，而出现 bug 。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>java 中关键字 volatile 的使用 <a href=\"https://mp.weixin.qq.com/s/AE0oeKiCU_aetfkW9Qk0cg\">reference</a>","more":"</p>\n<ul>\n<li>volatile 的做法：<ul>\n<li>使用内存屏障让前后的指令重排（为提升效率，而在编译运行期对指令进行重排）都不干扰所修辞的变量；</li>\n<li>单个线程里对共享变量的更新强制刷新到主内存中，而使其他线程中本地内存中的共享变量失效。</li>\n<li>不保证原子性，<ul>\n<li>保证原子性：使用 <code>synchronize</code></li>\n<li>使用 <code>lock</code></li>\n<li>前两种太重，可使用 Atomic 包，其使用 CAS 循环实现原子操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-Volatile-in-Double-Check-Singleton\"><a href=\"#1-Volatile-in-Double-Check-Singleton\" class=\"headerlink\" title=\".1. Volatile in Double Check Singleton\"></a>.1. Volatile in Double Check Singleton</h2><p>双检锁单例中的共享变量需要加上 <code>volatile</code> 才能真正做到正确，否则在多线程情况下出现问题。</p>\n<p>单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton ins;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ins == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ins == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ins = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ins;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当 <code>int = new Instance()</code> 这一行代码并非原子性，其指定分为 3 个 :<ul>\n<li>a. memory = allocate() 分配内存；</li>\n<li>b. ctorInstance(memory) 初始化对象；</li>\n<li>c. ins=memory 设置 ins 指向刚分配的地址。</li>\n</ul>\n</li>\n<li>a -&gt; b -&gt; c 三条指令可能会被重排 a -&gt; c -&gt; b 的顺序。在双检锁的案例中，当线程1走到 c 时，其他线程走到第一层检查 ins 是否为空时，会得到 false 的结果，因为此时 ins 已指向了一个内存地址，而线程1 此时还未为其初始化，而出现 bug 。</li>\n</ul>"},{"layout":"post","title":"Lock in Java","date":"2020-06-11T08:21:38.000Z","_content":"\njava 并发编程中的 lock.<!--more-->\n\n[reference](java.util.concurrent.locks.Lock)\n\n## .1. features\n\n- Lock 的限制访问共有资源，但某些 Lock 也可以让多个线程同时访问共享资源，如：{@link ReadWriteLock}。\n- Lock 提供了 synchronized 方法、语句同样的功能，但要更为灵活。synchronized 提供访问每一个对象隐式关联的监听锁，但其强制锁的获取与释放都使用阻塞结构方式：\n    - 多个锁被获取后，其释放的顺序必须与获取的顺序相反；\n    - 所有锁在释放时必须与其获取的语义范围一致。\n- synchronized 范围机制（scoping mechanism）使获取监听锁编程方式更为容易，也有益于避免包含锁的编程错误。但在某些情况下需要使用更为灵活的锁，比如在并发遍历数据结构时需要交替进行或链式锁定：\n    1. 在获取节点 A 的锁\n    2. 获取节点 B 的锁；\n    3. 释放节点 A 的锁再获取节点 C 的锁；\n    4. 释放节点 B 的锁再获取节点 D 的锁，依次类推。\n    5. 通过允许一个锁在不同的范围内获取与释放，与多个锁以任意顺序获取与释放实现以上功能。\n- 灵活性带来了额外的工作，缺少阻塞结构也就移除了在 synchronized 语句或方法中自动释放锁的功能。\n\n    ```java\n    Lock l = ...;\n    l.lock();\n    try {\n      // access the resource protected by this lock\n    } finally {\n      l.unlock();\n    }\n    ```\n  \n- 此外，可使用 tryLock() ，此方法获取锁可以被打断，使用方法 lockInterruptibly() 打断获取锁的流程。也可以使用 tryLock(long, TimeUnit) 方法实现超时限制获取锁。\n- Lock 可以实现与隐式监听锁很不一样的行为与语义，诸如顺序保证、非重入使用、死锁检测，如果 Lock 要实现这此语义，需要文档中特别说明。\n- 需要注意的是 Lock 实例与其他对象实例一样可以作为 synchronized 语句的锁对象，使用 Lock 实例作为 synchronized 语句的锁目标与 Lock 实例本身的 lock() 方法调用没有任何特别的关系。除在 Lock 本身内部实现外，建议尽量避免如此使用。\n\n### .1.1. 内存同步\n\n- 所有 Lock 实现必须强制像内置的监听锁样实现内存同步语义，[Java SE 文档描述](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4)\n- 成功的 lock 与 unlock 执行必须与锁与解锁动作语义一样实现内存同步效果。\n\n### .1.2. 实现注意事项\n\n- 锁获取有三种不同的形式，可中断、不可中断、超时设置（interruptible/non-interruptible/timed），其性能特质、顺序保证也各不相同。此外，中断一个正在获取锁的特性可能不会实现。\n- 因此一个 Lock 的实现中对于三种形式的锁获取并不需要保证都有明确定义相同的语义与规范，也可以不需要在锁获取进行时中断的属性。\n\n## .2. TODO list\n\n- [ ] [ReentrantLock](java.util.concurrent.locks.ReentrantLock)\n- [ ] [ReadWriteLock](java.util.concurrent.locks.ReadWriteLock)\n- [ ] [ReentrantReadWriteLock](java.util.concurrent.locks.ReentrantReadWriteLock)\n- [ ] [JSE 8 specifications](https://docs.oracle.com/javase/specs/index.html)\n","source":"_posts/JMM/lock.md","raw":"---\nlayout: \"post\"\ntitle: Lock in Java\ndate: 2020-06-11 16:21:38\ncategories: [Java]\ntags: [lock,concurrent]\n---\n\njava 并发编程中的 lock.<!--more-->\n\n[reference](java.util.concurrent.locks.Lock)\n\n## .1. features\n\n- Lock 的限制访问共有资源，但某些 Lock 也可以让多个线程同时访问共享资源，如：{@link ReadWriteLock}。\n- Lock 提供了 synchronized 方法、语句同样的功能，但要更为灵活。synchronized 提供访问每一个对象隐式关联的监听锁，但其强制锁的获取与释放都使用阻塞结构方式：\n    - 多个锁被获取后，其释放的顺序必须与获取的顺序相反；\n    - 所有锁在释放时必须与其获取的语义范围一致。\n- synchronized 范围机制（scoping mechanism）使获取监听锁编程方式更为容易，也有益于避免包含锁的编程错误。但在某些情况下需要使用更为灵活的锁，比如在并发遍历数据结构时需要交替进行或链式锁定：\n    1. 在获取节点 A 的锁\n    2. 获取节点 B 的锁；\n    3. 释放节点 A 的锁再获取节点 C 的锁；\n    4. 释放节点 B 的锁再获取节点 D 的锁，依次类推。\n    5. 通过允许一个锁在不同的范围内获取与释放，与多个锁以任意顺序获取与释放实现以上功能。\n- 灵活性带来了额外的工作，缺少阻塞结构也就移除了在 synchronized 语句或方法中自动释放锁的功能。\n\n    ```java\n    Lock l = ...;\n    l.lock();\n    try {\n      // access the resource protected by this lock\n    } finally {\n      l.unlock();\n    }\n    ```\n  \n- 此外，可使用 tryLock() ，此方法获取锁可以被打断，使用方法 lockInterruptibly() 打断获取锁的流程。也可以使用 tryLock(long, TimeUnit) 方法实现超时限制获取锁。\n- Lock 可以实现与隐式监听锁很不一样的行为与语义，诸如顺序保证、非重入使用、死锁检测，如果 Lock 要实现这此语义，需要文档中特别说明。\n- 需要注意的是 Lock 实例与其他对象实例一样可以作为 synchronized 语句的锁对象，使用 Lock 实例作为 synchronized 语句的锁目标与 Lock 实例本身的 lock() 方法调用没有任何特别的关系。除在 Lock 本身内部实现外，建议尽量避免如此使用。\n\n### .1.1. 内存同步\n\n- 所有 Lock 实现必须强制像内置的监听锁样实现内存同步语义，[Java SE 文档描述](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4)\n- 成功的 lock 与 unlock 执行必须与锁与解锁动作语义一样实现内存同步效果。\n\n### .1.2. 实现注意事项\n\n- 锁获取有三种不同的形式，可中断、不可中断、超时设置（interruptible/non-interruptible/timed），其性能特质、顺序保证也各不相同。此外，中断一个正在获取锁的特性可能不会实现。\n- 因此一个 Lock 的实现中对于三种形式的锁获取并不需要保证都有明确定义相同的语义与规范，也可以不需要在锁获取进行时中断的属性。\n\n## .2. TODO list\n\n- [ ] [ReentrantLock](java.util.concurrent.locks.ReentrantLock)\n- [ ] [ReadWriteLock](java.util.concurrent.locks.ReadWriteLock)\n- [ ] [ReentrantReadWriteLock](java.util.concurrent.locks.ReentrantReadWriteLock)\n- [ ] [JSE 8 specifications](https://docs.oracle.com/javase/specs/index.html)\n","slug":"JMM/lock","published":1,"updated":"2021-02-24T15:22:22.656Z","comments":1,"photos":[],"link":"","_id":"ckljnokqz000u2bhb7k2pgkbq","content":"<p>java 并发编程中的 lock.<span id=\"more\"></span></p>\n<p><a href=\"java.util.concurrent.locks.Lock\">reference</a></p>\n<h2 id=\"1-features\"><a href=\"#1-features\" class=\"headerlink\" title=\".1. features\"></a>.1. features</h2><ul>\n<li><p>Lock 的限制访问共有资源，但某些 Lock 也可以让多个线程同时访问共享资源，如：{@link ReadWriteLock}。</p>\n</li>\n<li><p>Lock 提供了 synchronized 方法、语句同样的功能，但要更为灵活。synchronized 提供访问每一个对象隐式关联的监听锁，但其强制锁的获取与释放都使用阻塞结构方式：</p>\n<ul>\n<li>多个锁被获取后，其释放的顺序必须与获取的顺序相反；</li>\n<li>所有锁在释放时必须与其获取的语义范围一致。</li>\n</ul>\n</li>\n<li><p>synchronized 范围机制（scoping mechanism）使获取监听锁编程方式更为容易，也有益于避免包含锁的编程错误。但在某些情况下需要使用更为灵活的锁，比如在并发遍历数据结构时需要交替进行或链式锁定：</p>\n<ol>\n<li>在获取节点 A 的锁</li>\n<li>获取节点 B 的锁；</li>\n<li>释放节点 A 的锁再获取节点 C 的锁；</li>\n<li>释放节点 B 的锁再获取节点 D 的锁，依次类推。</li>\n<li>通过允许一个锁在不同的范围内获取与释放，与多个锁以任意顺序获取与释放实现以上功能。</li>\n</ol>\n</li>\n<li><p>灵活性带来了额外的工作，缺少阻塞结构也就移除了在 synchronized 语句或方法中自动释放锁的功能。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock l = ...;</span><br><span class=\"line\">l.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// access the resource protected by this lock</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  l.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此外，可使用 tryLock() ，此方法获取锁可以被打断，使用方法 lockInterruptibly() 打断获取锁的流程。也可以使用 tryLock(long, TimeUnit) 方法实现超时限制获取锁。</p>\n</li>\n<li><p>Lock 可以实现与隐式监听锁很不一样的行为与语义，诸如顺序保证、非重入使用、死锁检测，如果 Lock 要实现这此语义，需要文档中特别说明。</p>\n</li>\n<li><p>需要注意的是 Lock 实例与其他对象实例一样可以作为 synchronized 语句的锁对象，使用 Lock 实例作为 synchronized 语句的锁目标与 Lock 实例本身的 lock() 方法调用没有任何特别的关系。除在 Lock 本身内部实现外，建议尽量避免如此使用。</p>\n</li>\n</ul>\n<h3 id=\"1-1-内存同步\"><a href=\"#1-1-内存同步\" class=\"headerlink\" title=\".1.1. 内存同步\"></a>.1.1. 内存同步</h3><ul>\n<li>所有 Lock 实现必须强制像内置的监听锁样实现内存同步语义，<a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4\">Java SE 文档描述</a></li>\n<li>成功的 lock 与 unlock 执行必须与锁与解锁动作语义一样实现内存同步效果。</li>\n</ul>\n<h3 id=\"1-2-实现注意事项\"><a href=\"#1-2-实现注意事项\" class=\"headerlink\" title=\".1.2. 实现注意事项\"></a>.1.2. 实现注意事项</h3><ul>\n<li>锁获取有三种不同的形式，可中断、不可中断、超时设置（interruptible/non-interruptible/timed），其性能特质、顺序保证也各不相同。此外，中断一个正在获取锁的特性可能不会实现。</li>\n<li>因此一个 Lock 的实现中对于三种形式的锁获取并不需要保证都有明确定义相同的语义与规范，也可以不需要在锁获取进行时中断的属性。</li>\n</ul>\n<h2 id=\"2-TODO-list\"><a href=\"#2-TODO-list\" class=\"headerlink\" title=\".2. TODO list\"></a>.2. TODO list</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"java.util.concurrent.locks.ReentrantLock\">ReentrantLock</a></li>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"java.util.concurrent.locks.ReadWriteLock\">ReadWriteLock</a></li>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"java.util.concurrent.locks.ReentrantReadWriteLock\">ReentrantReadWriteLock</a></li>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"https://docs.oracle.com/javase/specs/index.html\">JSE 8 specifications</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>java 并发编程中的 lock.","more":"</p>\n<p><a href=\"java.util.concurrent.locks.Lock\">reference</a></p>\n<h2 id=\"1-features\"><a href=\"#1-features\" class=\"headerlink\" title=\".1. features\"></a>.1. features</h2><ul>\n<li><p>Lock 的限制访问共有资源，但某些 Lock 也可以让多个线程同时访问共享资源，如：{@link ReadWriteLock}。</p>\n</li>\n<li><p>Lock 提供了 synchronized 方法、语句同样的功能，但要更为灵活。synchronized 提供访问每一个对象隐式关联的监听锁，但其强制锁的获取与释放都使用阻塞结构方式：</p>\n<ul>\n<li>多个锁被获取后，其释放的顺序必须与获取的顺序相反；</li>\n<li>所有锁在释放时必须与其获取的语义范围一致。</li>\n</ul>\n</li>\n<li><p>synchronized 范围机制（scoping mechanism）使获取监听锁编程方式更为容易，也有益于避免包含锁的编程错误。但在某些情况下需要使用更为灵活的锁，比如在并发遍历数据结构时需要交替进行或链式锁定：</p>\n<ol>\n<li>在获取节点 A 的锁</li>\n<li>获取节点 B 的锁；</li>\n<li>释放节点 A 的锁再获取节点 C 的锁；</li>\n<li>释放节点 B 的锁再获取节点 D 的锁，依次类推。</li>\n<li>通过允许一个锁在不同的范围内获取与释放，与多个锁以任意顺序获取与释放实现以上功能。</li>\n</ol>\n</li>\n<li><p>灵活性带来了额外的工作，缺少阻塞结构也就移除了在 synchronized 语句或方法中自动释放锁的功能。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock l = ...;</span><br><span class=\"line\">l.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// access the resource protected by this lock</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  l.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此外，可使用 tryLock() ，此方法获取锁可以被打断，使用方法 lockInterruptibly() 打断获取锁的流程。也可以使用 tryLock(long, TimeUnit) 方法实现超时限制获取锁。</p>\n</li>\n<li><p>Lock 可以实现与隐式监听锁很不一样的行为与语义，诸如顺序保证、非重入使用、死锁检测，如果 Lock 要实现这此语义，需要文档中特别说明。</p>\n</li>\n<li><p>需要注意的是 Lock 实例与其他对象实例一样可以作为 synchronized 语句的锁对象，使用 Lock 实例作为 synchronized 语句的锁目标与 Lock 实例本身的 lock() 方法调用没有任何特别的关系。除在 Lock 本身内部实现外，建议尽量避免如此使用。</p>\n</li>\n</ul>\n<h3 id=\"1-1-内存同步\"><a href=\"#1-1-内存同步\" class=\"headerlink\" title=\".1.1. 内存同步\"></a>.1.1. 内存同步</h3><ul>\n<li>所有 Lock 实现必须强制像内置的监听锁样实现内存同步语义，<a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4\">Java SE 文档描述</a></li>\n<li>成功的 lock 与 unlock 执行必须与锁与解锁动作语义一样实现内存同步效果。</li>\n</ul>\n<h3 id=\"1-2-实现注意事项\"><a href=\"#1-2-实现注意事项\" class=\"headerlink\" title=\".1.2. 实现注意事项\"></a>.1.2. 实现注意事项</h3><ul>\n<li>锁获取有三种不同的形式，可中断、不可中断、超时设置（interruptible/non-interruptible/timed），其性能特质、顺序保证也各不相同。此外，中断一个正在获取锁的特性可能不会实现。</li>\n<li>因此一个 Lock 的实现中对于三种形式的锁获取并不需要保证都有明确定义相同的语义与规范，也可以不需要在锁获取进行时中断的属性。</li>\n</ul>\n<h2 id=\"2-TODO-list\"><a href=\"#2-TODO-list\" class=\"headerlink\" title=\".2. TODO list\"></a>.2. TODO list</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"java.util.concurrent.locks.ReentrantLock\">ReentrantLock</a></li>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"java.util.concurrent.locks.ReadWriteLock\">ReadWriteLock</a></li>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"java.util.concurrent.locks.ReentrantReadWriteLock\">ReentrantReadWriteLock</a></li>\n<li><input disabled=\"\" type=\"checkbox\"> <a href=\"https://docs.oracle.com/javase/specs/index.html\">JSE 8 specifications</a></li>\n</ul>"},{"title":"Shell","layout":"post","date":"2020-12-10T10:01:00.000Z","description":"linux command line","_content":"\n## .1. vim 编辑器命令行\n\n> 以下命令是在编辑整个文件时（未进入到文件编辑内部时）进行行操作。<!--more-->\n\n**note:**\n- 行编辑时， backspace 只会让光标向前行动，不能删除前一个字符\n- 行编辑时，使用 delete 可以光标所在处后单个字符进行删除\n\n**文件操作相关命令:**\n- 从行编辑模式进行到文本编辑模式命令： i\n- 从文本编辑模式进行到行模式命令： esc\n- 当进行到行编辑模式时：\n    - :w 保存（write）\n    - :wq 保存退出(write quite)\n    - :q! 强制退出并不保存\n    - :w (newfile) 将另存为一个新的文件，原文件保持不变。如果新文件已经存在，可以在 `:w` 后加上 `!` 强制覆盖\n    - :x 保存文件并退出，此命令与 `:wq` 的区别在于：此命令只有在有过修改时才会保存，而 `:wq` 命令不管有没有修改都会强制进行保存更新修改时间。\n\n### .1.1. 行文本编辑命令\n\n- <n>dd 剪切光标所在行起的 n 行\n- dd 剪切光标所在行\n- d0 剪切光标所在处到行首\n- d$ 剪切光标所在处到行尾\n- <n>yy 复制光标所在行起的 n 行\n- p 粘贴\n- u 撤销操作\n- ctrl + r 恢复撤销\n- :(n),(m) m (j) 将 n 行到 m 行移动到 j 行之后。（移动到篇首就将 j 设置为 0）\n- :(n),(m) co (j) 将 n 行到 m 行复制到 j 行之后。（复制到篇首就将 j 设置为 0）\n- :(n),(m) de 将 n 行到 m 行删除\n\n**查看日志用**\n\n- /(chars) 查找文档中的字符，可用正则\n    - 进入到筛选高亮界面时\n    - n 切换到下一个\n    - N 上一个\n\n### .1.2. 设置 vim 编辑器的行号显示\n\n**临时设置**\n\n- 在行行编辑模式下，执行命令： `:set nu` 或 `:set number`\n- 取消行号显示： `:set nonu` 或 `:set nonumber`\n\n**在配置文件中设置默认显示**\n\n- 在用户模块配置：在 `~.vimrc` 中写入命令 `set nu` 即可以配置（如果用户目录中没有此配置文件，直接 使用 `vi ~.vimrc` 命令新建并写入即可）\n- 在 git 模块中配置： 在 git 安装目录中 `/etc/vimrc` 定稿命令行 `set nu`\n    - 以上两种方式的区别在于，用户模块只对该用户有效，而 git 模块是使用 git 都会有效\n","source":"_posts/Linux/command line.md","raw":"---\ntitle: Shell\nlayout: post\ndate: 2020-12-10 18:01:00\ncategories: [Linux]\ntags: [programming, linux, shell]\ndescription: linux command line\n---\n\n## .1. vim 编辑器命令行\n\n> 以下命令是在编辑整个文件时（未进入到文件编辑内部时）进行行操作。<!--more-->\n\n**note:**\n- 行编辑时， backspace 只会让光标向前行动，不能删除前一个字符\n- 行编辑时，使用 delete 可以光标所在处后单个字符进行删除\n\n**文件操作相关命令:**\n- 从行编辑模式进行到文本编辑模式命令： i\n- 从文本编辑模式进行到行模式命令： esc\n- 当进行到行编辑模式时：\n    - :w 保存（write）\n    - :wq 保存退出(write quite)\n    - :q! 强制退出并不保存\n    - :w (newfile) 将另存为一个新的文件，原文件保持不变。如果新文件已经存在，可以在 `:w` 后加上 `!` 强制覆盖\n    - :x 保存文件并退出，此命令与 `:wq` 的区别在于：此命令只有在有过修改时才会保存，而 `:wq` 命令不管有没有修改都会强制进行保存更新修改时间。\n\n### .1.1. 行文本编辑命令\n\n- <n>dd 剪切光标所在行起的 n 行\n- dd 剪切光标所在行\n- d0 剪切光标所在处到行首\n- d$ 剪切光标所在处到行尾\n- <n>yy 复制光标所在行起的 n 行\n- p 粘贴\n- u 撤销操作\n- ctrl + r 恢复撤销\n- :(n),(m) m (j) 将 n 行到 m 行移动到 j 行之后。（移动到篇首就将 j 设置为 0）\n- :(n),(m) co (j) 将 n 行到 m 行复制到 j 行之后。（复制到篇首就将 j 设置为 0）\n- :(n),(m) de 将 n 行到 m 行删除\n\n**查看日志用**\n\n- /(chars) 查找文档中的字符，可用正则\n    - 进入到筛选高亮界面时\n    - n 切换到下一个\n    - N 上一个\n\n### .1.2. 设置 vim 编辑器的行号显示\n\n**临时设置**\n\n- 在行行编辑模式下，执行命令： `:set nu` 或 `:set number`\n- 取消行号显示： `:set nonu` 或 `:set nonumber`\n\n**在配置文件中设置默认显示**\n\n- 在用户模块配置：在 `~.vimrc` 中写入命令 `set nu` 即可以配置（如果用户目录中没有此配置文件，直接 使用 `vi ~.vimrc` 命令新建并写入即可）\n- 在 git 模块中配置： 在 git 安装目录中 `/etc/vimrc` 定稿命令行 `set nu`\n    - 以上两种方式的区别在于，用户模块只对该用户有效，而 git 模块是使用 git 都会有效\n","slug":"Linux/command line","published":1,"updated":"2021-02-24T15:22:22.704Z","comments":1,"photos":[],"link":"","_id":"ckljnokr0000x2bhbh6ry95mr","content":"<h2 id=\"1-vim-编辑器命令行\"><a href=\"#1-vim-编辑器命令行\" class=\"headerlink\" title=\".1. vim 编辑器命令行\"></a>.1. vim 编辑器命令行</h2><blockquote>\n<p>以下命令是在编辑整个文件时（未进入到文件编辑内部时）进行行操作。<span id=\"more\"></span></p>\n</blockquote>\n<p><strong>note:</strong></p>\n<ul>\n<li>行编辑时， backspace 只会让光标向前行动，不能删除前一个字符</li>\n<li>行编辑时，使用 delete 可以光标所在处后单个字符进行删除</li>\n</ul>\n<p><strong>文件操作相关命令:</strong></p>\n<ul>\n<li>从行编辑模式进行到文本编辑模式命令： i</li>\n<li>从文本编辑模式进行到行模式命令： esc</li>\n<li>当进行到行编辑模式时：<ul>\n<li>:w 保存（write）</li>\n<li>:wq 保存退出(write quite)</li>\n<li>:q! 强制退出并不保存</li>\n<li>:w (newfile) 将另存为一个新的文件，原文件保持不变。如果新文件已经存在，可以在 <code>:w</code> 后加上 <code>!</code> 强制覆盖</li>\n<li>:x 保存文件并退出，此命令与 <code>:wq</code> 的区别在于：此命令只有在有过修改时才会保存，而 <code>:wq</code> 命令不管有没有修改都会强制进行保存更新修改时间。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-1-行文本编辑命令\"><a href=\"#1-1-行文本编辑命令\" class=\"headerlink\" title=\".1.1. 行文本编辑命令\"></a>.1.1. 行文本编辑命令</h3><ul>\n<li><n>dd 剪切光标所在行起的 n 行</li>\n<li>dd 剪切光标所在行</li>\n<li>d0 剪切光标所在处到行首</li>\n<li>d$ 剪切光标所在处到行尾</li>\n<li><n>yy 复制光标所在行起的 n 行</li>\n<li>p 粘贴</li>\n<li>u 撤销操作</li>\n<li>ctrl + r 恢复撤销</li>\n<li>:(n),(m) m (j) 将 n 行到 m 行移动到 j 行之后。（移动到篇首就将 j 设置为 0）</li>\n<li>:(n),(m) co (j) 将 n 行到 m 行复制到 j 行之后。（复制到篇首就将 j 设置为 0）</li>\n<li>:(n),(m) de 将 n 行到 m 行删除</li>\n</ul>\n<p><strong>查看日志用</strong></p>\n<ul>\n<li>/(chars) 查找文档中的字符，可用正则<ul>\n<li>进入到筛选高亮界面时</li>\n<li>n 切换到下一个</li>\n<li>N 上一个</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-设置-vim-编辑器的行号显示\"><a href=\"#1-2-设置-vim-编辑器的行号显示\" class=\"headerlink\" title=\".1.2. 设置 vim 编辑器的行号显示\"></a>.1.2. 设置 vim 编辑器的行号显示</h3><p><strong>临时设置</strong></p>\n<ul>\n<li>在行行编辑模式下，执行命令： <code>:set nu</code> 或 <code>:set number</code></li>\n<li>取消行号显示： <code>:set nonu</code> 或 <code>:set nonumber</code></li>\n</ul>\n<p><strong>在配置文件中设置默认显示</strong></p>\n<ul>\n<li>在用户模块配置：在 <code>~.vimrc</code> 中写入命令 <code>set nu</code> 即可以配置（如果用户目录中没有此配置文件，直接 使用 <code>vi ~.vimrc</code> 命令新建并写入即可）</li>\n<li>在 git 模块中配置： 在 git 安装目录中 <code>/etc/vimrc</code> 定稿命令行 <code>set nu</code><ul>\n<li>以上两种方式的区别在于，用户模块只对该用户有效，而 git 模块是使用 git 都会有效</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-vim-编辑器命令行\"><a href=\"#1-vim-编辑器命令行\" class=\"headerlink\" title=\".1. vim 编辑器命令行\"></a>.1. vim 编辑器命令行</h2><blockquote>\n<p>以下命令是在编辑整个文件时（未进入到文件编辑内部时）进行行操作。","more":"</p>\n</blockquote>\n<p><strong>note:</strong></p>\n<ul>\n<li>行编辑时， backspace 只会让光标向前行动，不能删除前一个字符</li>\n<li>行编辑时，使用 delete 可以光标所在处后单个字符进行删除</li>\n</ul>\n<p><strong>文件操作相关命令:</strong></p>\n<ul>\n<li>从行编辑模式进行到文本编辑模式命令： i</li>\n<li>从文本编辑模式进行到行模式命令： esc</li>\n<li>当进行到行编辑模式时：<ul>\n<li>:w 保存（write）</li>\n<li>:wq 保存退出(write quite)</li>\n<li>:q! 强制退出并不保存</li>\n<li>:w (newfile) 将另存为一个新的文件，原文件保持不变。如果新文件已经存在，可以在 <code>:w</code> 后加上 <code>!</code> 强制覆盖</li>\n<li>:x 保存文件并退出，此命令与 <code>:wq</code> 的区别在于：此命令只有在有过修改时才会保存，而 <code>:wq</code> 命令不管有没有修改都会强制进行保存更新修改时间。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-1-行文本编辑命令\"><a href=\"#1-1-行文本编辑命令\" class=\"headerlink\" title=\".1.1. 行文本编辑命令\"></a>.1.1. 行文本编辑命令</h3><ul>\n<li><n>dd 剪切光标所在行起的 n 行</li>\n<li>dd 剪切光标所在行</li>\n<li>d0 剪切光标所在处到行首</li>\n<li>d$ 剪切光标所在处到行尾</li>\n<li><n>yy 复制光标所在行起的 n 行</li>\n<li>p 粘贴</li>\n<li>u 撤销操作</li>\n<li>ctrl + r 恢复撤销</li>\n<li>:(n),(m) m (j) 将 n 行到 m 行移动到 j 行之后。（移动到篇首就将 j 设置为 0）</li>\n<li>:(n),(m) co (j) 将 n 行到 m 行复制到 j 行之后。（复制到篇首就将 j 设置为 0）</li>\n<li>:(n),(m) de 将 n 行到 m 行删除</li>\n</ul>\n<p><strong>查看日志用</strong></p>\n<ul>\n<li>/(chars) 查找文档中的字符，可用正则<ul>\n<li>进入到筛选高亮界面时</li>\n<li>n 切换到下一个</li>\n<li>N 上一个</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-设置-vim-编辑器的行号显示\"><a href=\"#1-2-设置-vim-编辑器的行号显示\" class=\"headerlink\" title=\".1.2. 设置 vim 编辑器的行号显示\"></a>.1.2. 设置 vim 编辑器的行号显示</h3><p><strong>临时设置</strong></p>\n<ul>\n<li>在行行编辑模式下，执行命令： <code>:set nu</code> 或 <code>:set number</code></li>\n<li>取消行号显示： <code>:set nonu</code> 或 <code>:set nonumber</code></li>\n</ul>\n<p><strong>在配置文件中设置默认显示</strong></p>\n<ul>\n<li>在用户模块配置：在 <code>~.vimrc</code> 中写入命令 <code>set nu</code> 即可以配置（如果用户目录中没有此配置文件，直接 使用 <code>vi ~.vimrc</code> 命令新建并写入即可）</li>\n<li>在 git 模块中配置： 在 git 安装目录中 <code>/etc/vimrc</code> 定稿命令行 <code>set nu</code><ul>\n<li>以上两种方式的区别在于，用户模块只对该用户有效，而 git 模块是使用 git 都会有效</li>\n</ul>\n</li>\n</ul>"},{"title":"Hash","layout":"Shell","date":"2020-12-10T10:01:00.000Z","description":"linux shell script","_content":"\n> Shell 是一个可以执行命令／程序／shell 脚本的环境，提供了访问 Unix 系统的接口。其根据输入执行程序，执行完成后将结果展示出来。 [Shell](https://www.tutorialspoint.com/unix/unix-what-is-shell.htm)<!--more-->\n\n## .1. variable\n\n> 变量\n\n- 只读变量 `readonly variable`\n- `unset {variable_name}` 重置一个变量，只读变量不可重置，重置后不能再访问\n- 变量类型\n    - Local variable.存在于当前shell实例中的变量，shell开启程序后，程序不能访问local variable .\n    - Environment variable. 环境变量，shell进程中任何地方可以获取环境变量.\n    - Shell variable.shell脚本中定义的变量，可以是 local variable ,也可是Environment variable .\n\n## .2. Basic operators\n\n[reference](https://www.tutorialspoint.com/unix/unix-basic-operators.htm)\n\n### .2.1. Arithmetic operators\n\n- 使用基础运算符时引用变量需要同样使用 `$` 符号，但赋值时直接使用变量名即可。`expr a = $b`\n- 运算符与表达式之间需要空格分开。`expr $a != $b`\n- `*` 乘号使用需要添加转义 `\\*`\n- 条件表达式使用需要被方括号(括号与表达式之间需要空格分隔)所包围：　`[ $a == $b ]`\n\n### .2.2. Relational Operators\n\n- 同样需要方括号与空格包围变量 `[ $a -eq $b ]`\n- `-eq` equals\n- `-ne` not equals\n- `-gt` greater than\n- `-lt` less than\n- `-ge` greater or equals\n- `-le` less or equals\n- 关系运算符支付数值类，如果是string类必须是代表数值的string，eg:`\"100\"`\n\n### .2.3. Boolean Operators\n\n- `!` 取反\n- `-o` OR\n- `-a` AND\n- eg: `[ $a -gt 100 -a $b -le 20 ]`\n\n### .2.4. String Operators\n\n- `=`\n- `!=`\n- `-z` zero 检测字串其长度是否为 ０  `[ -z $a ]`\n- `-n` not-zero 字串长度不为 0 `[ -n $a ]`\n- str 检测字串是否为 empty `[ $a ]`\n\n### .2.5. File Test Operators\n\n检测关联到文件的变量属性。假如一个变量 `file` 关联到一个 test 文件，大小100bytes，有 read/write/execute 权限。其相关命令如下：\n\n- `-b file` check if file is a block special file. `[ -b $file ]` false\n- `-c file` check if file is a character special file. `[ -c $file ]` false\n- `-d file` check if file is a directory. `[ -d $file ]` false\n- `-f file` check if file is an ordinal file as opposed to a directory or special file. `[ -f $file ]` is true\n- `-e file` check if file exists. `[ -e $file ]` is true\n- `-r`/`-w`/`-x` check if file is readable/writable/executable.\n\n## .3. Decision Making\n\n[reference](https://www.tutorialspoint.com/unix/unix-decision-making.htm)\n\nshell 中两种类似 switch case 的分支语句：\n\n1. if...elif...else...fi\n2. case...esac\n\n## .4. Ｐrocess Control\n\n- until 与 while 中的条件相反，满足条件在 while中循环，而不满足条件才在 until 中循环。\n- `break n` 跳出循环，其中 n 代表正整数，默认不写为 1 只跳出当前层循环，而如果需要跳出第二层循环（从内往外数）就指定 n 为 2 。\n\n## .5. Substitutions\n\n> 转义\n\n常用转义符号：\n\n- `\\n` new line\n- `\\r` carriage return\n- `\\t` horizontal tab\n- `\\\\` back slash\n- `\\a` alert\n- `\\b` backspace\n- `\\c` suppress trailing line\n- `\\f` form feed\n- `\\v` vertical tab\n\n### .5.1. Command Substitution\n\n`command` 使用 back quote 将命令包围起来，命令执行结果将返回。eg: echo \"today is `date`\"\n\n### .5.2. Variable Substitution\n\n> 变量转义\n\n使用变量转义可以将对变量进行检查，并对其返回值或变量作修改。\n\n- `${var:-word}` 如果变量 var 为 null  或未设置，将使用 word 转义为结果， var 变量不会被设置成 word.\n- `${var}` 转义 var 的值\n- `${var:=word}` 转义 var 并将 word 赋值给 var。\n- `${var:?message}` 如果 var 未设置或为 null ，message 将打印到 standard error。用以检测变量 var 是否正确设置。\n- `${var:+word}` 如果 var 已设置，work 将转义给 var ，但 var 不会改变。\n\n## .6. Quoting Mechanisms\n\n> [引用机制](https://www.tutorialspoint.com/unix/unix-quoting-mechanisms.htm)\n\n### .6.1. Meta Characters\n\n> Unix 元字符在 shell 中有特殊含义，所以在命令中如果要使用其为普通字串，需要在其前加上转义符号 backslash `\\`。 Unix 中的元字符包括：\n\n```shell\n* ? [ ] ' \" \\ $ ; & ( ) | ^ < > new-line space tab\n```\n\n`?` 代表任何一个字符，而 `*` 代表任意多个字符。\n\n### .6.2. quoting\n\n> 引用方式有四种\n\n1. 单引号引用 `'`，特殊符号会将全部的元字符给转义为字面量。当需要输出单引号时，此时可以使用 backslash 将其转义输出。\n2. 双引号引用 `\"`，大部分特殊符号被双引号引用有将丢失其特殊意义，但有例外：$ ` \\$ \\' \\\" \\\\\n3. backslash `\\`, 所有特殊变量在 backslash 后都将丢失其特殊意义\n4. back quote `, 被 back quote 包围的任何字符都将会被当作命令执行。\n\n## .7. IO Redirection\n\n> IO 重定向\n\n重定向的命令有：\n\n1. `pgm > file` 重定向到输出文件\n2. `pgm >> file` 将输出追加到指定文件\n3. `pgm < file` 程序从文件读取输入\n4. `n > file` 将 n fd 的流输出重定向到文件 file\n5. `n >> file` 将 fd n 的流输出重定向追加到文件 file\n6. `n >& m` 合并 fd n 流与 fd m 流输出\n7. `n <& m` 合并输入流 fd n 与 fd m\n8. `<< tag`  Standard input comes from here through next tag at the start of line\n9. `|` 管道，将前一个程序／应用的输出发送到下一个\n\nNOTE: *file descriptor（fd） 在 Unix 中使用非负整数表示，其中 0 表示标准输入 STDIN，1 表示标准输出 STDOUT，2 表示错误输出 STDERR*\n在 Unix 系统中每个非守护进程都有以上三个 IO 流，进程通过 kernel 访问文件 file table / inode table。\n\n在脚本中实现交互\n\n1. 使用重定向\n2. 使用管道\n3. 使用 expect （需要安装此功能）\n\n## .8. Functions\n\n> Unix shell function\n\n- 定义 function 其语法是：在方法名后跟上 `function_name () {}`，传递参数直接在命令行中添加，在方法中调用参数使用 `$n`\n- 返回数据使用关键字 `return`\n- `exit` 会终结整个 shell 执行，而不是 function 。\n- `$?` 获取上一次命令返回值 `ret=$?`，此值只是一个整数代表结果，不能返回字符及其他\n- shell 文件调用需要使用 `. shell_file`\n- shell 文件后缀可以不用写，一样的效果\n- shell 文件头指定 shell  执行 bash 类型也可不写，让系统默认的 shell 执行即可\n- `echo $PATH` 可以看到系统全局变量，其中一般包括了 ~/bin ，所以要以在此文件路径中添加自己想要的全局 shell ，而实现任何地方不添加绝对路径前缀调用此 shell 。\n- `$HOME` 调用当前用户目录，在 shell 中使用 ～ 不会生效。\n\n## .9. Alias\n\n> 给 bash shell 命令添加别名.[reference](https://blog.csdn.net/doiido/article/details/43762791)\n\n- 使用命令 `alias command='command arguments'` 给命令添加别名，从而缩小写常用参数的工作。eg: `alias grep='grep -iE --color=auto'`，可以实现使用 grep 命令自动添加两个参数\n- 如果要永久实现别名生效可以将命令添加到 ~/.bashrc 文件中并执行此文件\n- 解除别名设置使用命令 `unalias name`\n\n## .10. 添加机器命令别名与进入日志脚本\n\n```shell\n#!/bin/bash\nD=`date +%F`\n\necho \"today: $D\"\necho \"AUGUMENTS: $@\"\nPT=\"/smapp/servers/snxia-api-app/logs/$D/\"\necho \"path: $PT\"\nLOG_TYPE=\"\"\n\nalias grep='grep -iE --color'\n\nif [ $# -eq 0 ]\nthen\n    echo \"No arguments\"\n    cd $PT\nelse\n    get_log_type $2\n    if [ $1 = \"v\" ]\n    then\n        echo \"vim ...\"\n        vim \"$PT/$LOG_TYPE\"\n    fi\nfi\n\n\nget_log_type () {\n    echo \"arguments: $*\"\n    if [ $1 = \"e\" ]\n    then\n        LOG_TYPE=\"error-log.log\"\n    elif [ $1 = \"i\" ]\n    then\n        LGO_TYPE=\"info-log.log\"\n    else [ $1 = \"w\" ]\n        LOG_TYPE=\"warn-log.log\"\n    fi\n}\n\n```\n\n## .11. Questions\n\n### .11.1. Shell 脚本中 cd 命令不生效\n\n再现：在 l 脚本中写了 cd 命令，再放在 PATH 中，在 terminal 直接调用这个脚本 `l` ，发现当前目录还是原目录并未进入到脚本中指定的目录。\n\n原因：在接 terminal 调用脚本，是在当前 shell 环境中执行另外一个进程，进程结束就返回了原 shell 。\n\n解决：使用 `source` 或 `.` 命令在当前 shell 中执行脚本，而不是直接调用脚本。\n","source":"_posts/Linux/shell.md","raw":"---\ntitle: Hash\nlayout: Shell\ndate: 2020-12-10 18:01:00\ncategories: [Linux, Shell]\ntags: [programming, linux, shell]\ndescription: linux shell script\n---\n\n> Shell 是一个可以执行命令／程序／shell 脚本的环境，提供了访问 Unix 系统的接口。其根据输入执行程序，执行完成后将结果展示出来。 [Shell](https://www.tutorialspoint.com/unix/unix-what-is-shell.htm)<!--more-->\n\n## .1. variable\n\n> 变量\n\n- 只读变量 `readonly variable`\n- `unset {variable_name}` 重置一个变量，只读变量不可重置，重置后不能再访问\n- 变量类型\n    - Local variable.存在于当前shell实例中的变量，shell开启程序后，程序不能访问local variable .\n    - Environment variable. 环境变量，shell进程中任何地方可以获取环境变量.\n    - Shell variable.shell脚本中定义的变量，可以是 local variable ,也可是Environment variable .\n\n## .2. Basic operators\n\n[reference](https://www.tutorialspoint.com/unix/unix-basic-operators.htm)\n\n### .2.1. Arithmetic operators\n\n- 使用基础运算符时引用变量需要同样使用 `$` 符号，但赋值时直接使用变量名即可。`expr a = $b`\n- 运算符与表达式之间需要空格分开。`expr $a != $b`\n- `*` 乘号使用需要添加转义 `\\*`\n- 条件表达式使用需要被方括号(括号与表达式之间需要空格分隔)所包围：　`[ $a == $b ]`\n\n### .2.2. Relational Operators\n\n- 同样需要方括号与空格包围变量 `[ $a -eq $b ]`\n- `-eq` equals\n- `-ne` not equals\n- `-gt` greater than\n- `-lt` less than\n- `-ge` greater or equals\n- `-le` less or equals\n- 关系运算符支付数值类，如果是string类必须是代表数值的string，eg:`\"100\"`\n\n### .2.3. Boolean Operators\n\n- `!` 取反\n- `-o` OR\n- `-a` AND\n- eg: `[ $a -gt 100 -a $b -le 20 ]`\n\n### .2.4. String Operators\n\n- `=`\n- `!=`\n- `-z` zero 检测字串其长度是否为 ０  `[ -z $a ]`\n- `-n` not-zero 字串长度不为 0 `[ -n $a ]`\n- str 检测字串是否为 empty `[ $a ]`\n\n### .2.5. File Test Operators\n\n检测关联到文件的变量属性。假如一个变量 `file` 关联到一个 test 文件，大小100bytes，有 read/write/execute 权限。其相关命令如下：\n\n- `-b file` check if file is a block special file. `[ -b $file ]` false\n- `-c file` check if file is a character special file. `[ -c $file ]` false\n- `-d file` check if file is a directory. `[ -d $file ]` false\n- `-f file` check if file is an ordinal file as opposed to a directory or special file. `[ -f $file ]` is true\n- `-e file` check if file exists. `[ -e $file ]` is true\n- `-r`/`-w`/`-x` check if file is readable/writable/executable.\n\n## .3. Decision Making\n\n[reference](https://www.tutorialspoint.com/unix/unix-decision-making.htm)\n\nshell 中两种类似 switch case 的分支语句：\n\n1. if...elif...else...fi\n2. case...esac\n\n## .4. Ｐrocess Control\n\n- until 与 while 中的条件相反，满足条件在 while中循环，而不满足条件才在 until 中循环。\n- `break n` 跳出循环，其中 n 代表正整数，默认不写为 1 只跳出当前层循环，而如果需要跳出第二层循环（从内往外数）就指定 n 为 2 。\n\n## .5. Substitutions\n\n> 转义\n\n常用转义符号：\n\n- `\\n` new line\n- `\\r` carriage return\n- `\\t` horizontal tab\n- `\\\\` back slash\n- `\\a` alert\n- `\\b` backspace\n- `\\c` suppress trailing line\n- `\\f` form feed\n- `\\v` vertical tab\n\n### .5.1. Command Substitution\n\n`command` 使用 back quote 将命令包围起来，命令执行结果将返回。eg: echo \"today is `date`\"\n\n### .5.2. Variable Substitution\n\n> 变量转义\n\n使用变量转义可以将对变量进行检查，并对其返回值或变量作修改。\n\n- `${var:-word}` 如果变量 var 为 null  或未设置，将使用 word 转义为结果， var 变量不会被设置成 word.\n- `${var}` 转义 var 的值\n- `${var:=word}` 转义 var 并将 word 赋值给 var。\n- `${var:?message}` 如果 var 未设置或为 null ，message 将打印到 standard error。用以检测变量 var 是否正确设置。\n- `${var:+word}` 如果 var 已设置，work 将转义给 var ，但 var 不会改变。\n\n## .6. Quoting Mechanisms\n\n> [引用机制](https://www.tutorialspoint.com/unix/unix-quoting-mechanisms.htm)\n\n### .6.1. Meta Characters\n\n> Unix 元字符在 shell 中有特殊含义，所以在命令中如果要使用其为普通字串，需要在其前加上转义符号 backslash `\\`。 Unix 中的元字符包括：\n\n```shell\n* ? [ ] ' \" \\ $ ; & ( ) | ^ < > new-line space tab\n```\n\n`?` 代表任何一个字符，而 `*` 代表任意多个字符。\n\n### .6.2. quoting\n\n> 引用方式有四种\n\n1. 单引号引用 `'`，特殊符号会将全部的元字符给转义为字面量。当需要输出单引号时，此时可以使用 backslash 将其转义输出。\n2. 双引号引用 `\"`，大部分特殊符号被双引号引用有将丢失其特殊意义，但有例外：$ ` \\$ \\' \\\" \\\\\n3. backslash `\\`, 所有特殊变量在 backslash 后都将丢失其特殊意义\n4. back quote `, 被 back quote 包围的任何字符都将会被当作命令执行。\n\n## .7. IO Redirection\n\n> IO 重定向\n\n重定向的命令有：\n\n1. `pgm > file` 重定向到输出文件\n2. `pgm >> file` 将输出追加到指定文件\n3. `pgm < file` 程序从文件读取输入\n4. `n > file` 将 n fd 的流输出重定向到文件 file\n5. `n >> file` 将 fd n 的流输出重定向追加到文件 file\n6. `n >& m` 合并 fd n 流与 fd m 流输出\n7. `n <& m` 合并输入流 fd n 与 fd m\n8. `<< tag`  Standard input comes from here through next tag at the start of line\n9. `|` 管道，将前一个程序／应用的输出发送到下一个\n\nNOTE: *file descriptor（fd） 在 Unix 中使用非负整数表示，其中 0 表示标准输入 STDIN，1 表示标准输出 STDOUT，2 表示错误输出 STDERR*\n在 Unix 系统中每个非守护进程都有以上三个 IO 流，进程通过 kernel 访问文件 file table / inode table。\n\n在脚本中实现交互\n\n1. 使用重定向\n2. 使用管道\n3. 使用 expect （需要安装此功能）\n\n## .8. Functions\n\n> Unix shell function\n\n- 定义 function 其语法是：在方法名后跟上 `function_name () {}`，传递参数直接在命令行中添加，在方法中调用参数使用 `$n`\n- 返回数据使用关键字 `return`\n- `exit` 会终结整个 shell 执行，而不是 function 。\n- `$?` 获取上一次命令返回值 `ret=$?`，此值只是一个整数代表结果，不能返回字符及其他\n- shell 文件调用需要使用 `. shell_file`\n- shell 文件后缀可以不用写，一样的效果\n- shell 文件头指定 shell  执行 bash 类型也可不写，让系统默认的 shell 执行即可\n- `echo $PATH` 可以看到系统全局变量，其中一般包括了 ~/bin ，所以要以在此文件路径中添加自己想要的全局 shell ，而实现任何地方不添加绝对路径前缀调用此 shell 。\n- `$HOME` 调用当前用户目录，在 shell 中使用 ～ 不会生效。\n\n## .9. Alias\n\n> 给 bash shell 命令添加别名.[reference](https://blog.csdn.net/doiido/article/details/43762791)\n\n- 使用命令 `alias command='command arguments'` 给命令添加别名，从而缩小写常用参数的工作。eg: `alias grep='grep -iE --color=auto'`，可以实现使用 grep 命令自动添加两个参数\n- 如果要永久实现别名生效可以将命令添加到 ~/.bashrc 文件中并执行此文件\n- 解除别名设置使用命令 `unalias name`\n\n## .10. 添加机器命令别名与进入日志脚本\n\n```shell\n#!/bin/bash\nD=`date +%F`\n\necho \"today: $D\"\necho \"AUGUMENTS: $@\"\nPT=\"/smapp/servers/snxia-api-app/logs/$D/\"\necho \"path: $PT\"\nLOG_TYPE=\"\"\n\nalias grep='grep -iE --color'\n\nif [ $# -eq 0 ]\nthen\n    echo \"No arguments\"\n    cd $PT\nelse\n    get_log_type $2\n    if [ $1 = \"v\" ]\n    then\n        echo \"vim ...\"\n        vim \"$PT/$LOG_TYPE\"\n    fi\nfi\n\n\nget_log_type () {\n    echo \"arguments: $*\"\n    if [ $1 = \"e\" ]\n    then\n        LOG_TYPE=\"error-log.log\"\n    elif [ $1 = \"i\" ]\n    then\n        LGO_TYPE=\"info-log.log\"\n    else [ $1 = \"w\" ]\n        LOG_TYPE=\"warn-log.log\"\n    fi\n}\n\n```\n\n## .11. Questions\n\n### .11.1. Shell 脚本中 cd 命令不生效\n\n再现：在 l 脚本中写了 cd 命令，再放在 PATH 中，在 terminal 直接调用这个脚本 `l` ，发现当前目录还是原目录并未进入到脚本中指定的目录。\n\n原因：在接 terminal 调用脚本，是在当前 shell 环境中执行另外一个进程，进程结束就返回了原 shell 。\n\n解决：使用 `source` 或 `.` 命令在当前 shell 中执行脚本，而不是直接调用脚本。\n","slug":"Linux/shell","published":1,"updated":"2021-02-24T15:22:22.712Z","comments":1,"photos":[],"link":"","_id":"ckljnokr200112bhb7sdpclh6","content":"<blockquote>\n<p>Shell 是一个可以执行命令／程序／shell 脚本的环境，提供了访问 Unix 系统的接口。其根据输入执行程序，执行完成后将结果展示出来。 <a href=\"https://www.tutorialspoint.com/unix/unix-what-is-shell.htm\">Shell</a><span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"1-variable\"><a href=\"#1-variable\" class=\"headerlink\" title=\".1. variable\"></a>.1. variable</h2><blockquote>\n<p>变量</p>\n</blockquote>\n<ul>\n<li>只读变量 <code>readonly variable</code></li>\n<li><code>unset &#123;variable_name&#125;</code> 重置一个变量，只读变量不可重置，重置后不能再访问</li>\n<li>变量类型<ul>\n<li>Local variable.存在于当前shell实例中的变量，shell开启程序后，程序不能访问local variable .</li>\n<li>Environment variable. 环境变量，shell进程中任何地方可以获取环境变量.</li>\n<li>Shell variable.shell脚本中定义的变量，可以是 local variable ,也可是Environment variable .</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Basic-operators\"><a href=\"#2-Basic-operators\" class=\"headerlink\" title=\".2. Basic operators\"></a>.2. Basic operators</h2><p><a href=\"https://www.tutorialspoint.com/unix/unix-basic-operators.htm\">reference</a></p>\n<h3 id=\"2-1-Arithmetic-operators\"><a href=\"#2-1-Arithmetic-operators\" class=\"headerlink\" title=\".2.1. Arithmetic operators\"></a>.2.1. Arithmetic operators</h3><ul>\n<li>使用基础运算符时引用变量需要同样使用 <code>$</code> 符号，但赋值时直接使用变量名即可。<code>expr a = $b</code></li>\n<li>运算符与表达式之间需要空格分开。<code>expr $a != $b</code></li>\n<li><code>*</code> 乘号使用需要添加转义 <code>\\*</code></li>\n<li>条件表达式使用需要被方括号(括号与表达式之间需要空格分隔)所包围：　<code>[ $a == $b ]</code></li>\n</ul>\n<h3 id=\"2-2-Relational-Operators\"><a href=\"#2-2-Relational-Operators\" class=\"headerlink\" title=\".2.2. Relational Operators\"></a>.2.2. Relational Operators</h3><ul>\n<li>同样需要方括号与空格包围变量 <code>[ $a -eq $b ]</code></li>\n<li><code>-eq</code> equals</li>\n<li><code>-ne</code> not equals</li>\n<li><code>-gt</code> greater than</li>\n<li><code>-lt</code> less than</li>\n<li><code>-ge</code> greater or equals</li>\n<li><code>-le</code> less or equals</li>\n<li>关系运算符支付数值类，如果是string类必须是代表数值的string，eg:<code>&quot;100&quot;</code></li>\n</ul>\n<h3 id=\"2-3-Boolean-Operators\"><a href=\"#2-3-Boolean-Operators\" class=\"headerlink\" title=\".2.3. Boolean Operators\"></a>.2.3. Boolean Operators</h3><ul>\n<li><code>!</code> 取反</li>\n<li><code>-o</code> OR</li>\n<li><code>-a</code> AND</li>\n<li>eg: <code>[ $a -gt 100 -a $b -le 20 ]</code></li>\n</ul>\n<h3 id=\"2-4-String-Operators\"><a href=\"#2-4-String-Operators\" class=\"headerlink\" title=\".2.4. String Operators\"></a>.2.4. String Operators</h3><ul>\n<li><code>=</code></li>\n<li><code>!=</code></li>\n<li><code>-z</code> zero 检测字串其长度是否为 ０  <code>[ -z $a ]</code></li>\n<li><code>-n</code> not-zero 字串长度不为 0 <code>[ -n $a ]</code></li>\n<li>str 检测字串是否为 empty <code>[ $a ]</code></li>\n</ul>\n<h3 id=\"2-5-File-Test-Operators\"><a href=\"#2-5-File-Test-Operators\" class=\"headerlink\" title=\".2.5. File Test Operators\"></a>.2.5. File Test Operators</h3><p>检测关联到文件的变量属性。假如一个变量 <code>file</code> 关联到一个 test 文件，大小100bytes，有 read/write/execute 权限。其相关命令如下：</p>\n<ul>\n<li><code>-b file</code> check if file is a block special file. <code>[ -b $file ]</code> false</li>\n<li><code>-c file</code> check if file is a character special file. <code>[ -c $file ]</code> false</li>\n<li><code>-d file</code> check if file is a directory. <code>[ -d $file ]</code> false</li>\n<li><code>-f file</code> check if file is an ordinal file as opposed to a directory or special file. <code>[ -f $file ]</code> is true</li>\n<li><code>-e file</code> check if file exists. <code>[ -e $file ]</code> is true</li>\n<li><code>-r</code>/<code>-w</code>/<code>-x</code> check if file is readable/writable/executable.</li>\n</ul>\n<h2 id=\"3-Decision-Making\"><a href=\"#3-Decision-Making\" class=\"headerlink\" title=\".3. Decision Making\"></a>.3. Decision Making</h2><p><a href=\"https://www.tutorialspoint.com/unix/unix-decision-making.htm\">reference</a></p>\n<p>shell 中两种类似 switch case 的分支语句：</p>\n<ol>\n<li>if…elif…else…fi</li>\n<li>case…esac</li>\n</ol>\n<h2 id=\"4-Process-Control\"><a href=\"#4-Process-Control\" class=\"headerlink\" title=\".4. Ｐrocess Control\"></a>.4. Ｐrocess Control</h2><ul>\n<li>until 与 while 中的条件相反，满足条件在 while中循环，而不满足条件才在 until 中循环。</li>\n<li><code>break n</code> 跳出循环，其中 n 代表正整数，默认不写为 1 只跳出当前层循环，而如果需要跳出第二层循环（从内往外数）就指定 n 为 2 。</li>\n</ul>\n<h2 id=\"5-Substitutions\"><a href=\"#5-Substitutions\" class=\"headerlink\" title=\".5. Substitutions\"></a>.5. Substitutions</h2><blockquote>\n<p>转义</p>\n</blockquote>\n<p>常用转义符号：</p>\n<ul>\n<li><code>\\n</code> new line</li>\n<li><code>\\r</code> carriage return</li>\n<li><code>\\t</code> horizontal tab</li>\n<li><code>\\\\</code> back slash</li>\n<li><code>\\a</code> alert</li>\n<li><code>\\b</code> backspace</li>\n<li><code>\\c</code> suppress trailing line</li>\n<li><code>\\f</code> form feed</li>\n<li><code>\\v</code> vertical tab</li>\n</ul>\n<h3 id=\"5-1-Command-Substitution\"><a href=\"#5-1-Command-Substitution\" class=\"headerlink\" title=\".5.1. Command Substitution\"></a>.5.1. Command Substitution</h3><p><code>command</code> 使用 back quote 将命令包围起来，命令执行结果将返回。eg: echo “today is <code>date</code>“</p>\n<h3 id=\"5-2-Variable-Substitution\"><a href=\"#5-2-Variable-Substitution\" class=\"headerlink\" title=\".5.2. Variable Substitution\"></a>.5.2. Variable Substitution</h3><blockquote>\n<p>变量转义</p>\n</blockquote>\n<p>使用变量转义可以将对变量进行检查，并对其返回值或变量作修改。</p>\n<ul>\n<li><code>$&#123;var:-word&#125;</code> 如果变量 var 为 null  或未设置，将使用 word 转义为结果， var 变量不会被设置成 word.</li>\n<li><code>$&#123;var&#125;</code> 转义 var 的值</li>\n<li><code>$&#123;var:=word&#125;</code> 转义 var 并将 word 赋值给 var。</li>\n<li><code>$&#123;var:?message&#125;</code> 如果 var 未设置或为 null ，message 将打印到 standard error。用以检测变量 var 是否正确设置。</li>\n<li><code>$&#123;var:+word&#125;</code> 如果 var 已设置，work 将转义给 var ，但 var 不会改变。</li>\n</ul>\n<h2 id=\"6-Quoting-Mechanisms\"><a href=\"#6-Quoting-Mechanisms\" class=\"headerlink\" title=\".6. Quoting Mechanisms\"></a>.6. Quoting Mechanisms</h2><blockquote>\n<p><a href=\"https://www.tutorialspoint.com/unix/unix-quoting-mechanisms.htm\">引用机制</a></p>\n</blockquote>\n<h3 id=\"6-1-Meta-Characters\"><a href=\"#6-1-Meta-Characters\" class=\"headerlink\" title=\".6.1. Meta Characters\"></a>.6.1. Meta Characters</h3><blockquote>\n<p>Unix 元字符在 shell 中有特殊含义，所以在命令中如果要使用其为普通字串，需要在其前加上转义符号 backslash <code>\\</code>。 Unix 中的元字符包括：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* ? [ ] &#x27; &quot; \\ $ ; &amp; ( ) | ^ &lt; &gt; new-line space tab</span><br></pre></td></tr></table></figure>\n\n<p><code>?</code> 代表任何一个字符，而 <code>*</code> 代表任意多个字符。</p>\n<h3 id=\"6-2-quoting\"><a href=\"#6-2-quoting\" class=\"headerlink\" title=\".6.2. quoting\"></a>.6.2. quoting</h3><blockquote>\n<p>引用方式有四种</p>\n</blockquote>\n<ol>\n<li>单引号引用 <code>&#39;</code>，特殊符号会将全部的元字符给转义为字面量。当需要输出单引号时，此时可以使用 backslash 将其转义输出。</li>\n<li>双引号引用 <code>&quot;</code>，大部分特殊符号被双引号引用有将丢失其特殊意义，但有例外：$ ` $ &#39; &quot; \\</li>\n<li>backslash <code>\\</code>, 所有特殊变量在 backslash 后都将丢失其特殊意义</li>\n<li>back quote `, 被 back quote 包围的任何字符都将会被当作命令执行。</li>\n</ol>\n<h2 id=\"7-IO-Redirection\"><a href=\"#7-IO-Redirection\" class=\"headerlink\" title=\".7. IO Redirection\"></a>.7. IO Redirection</h2><blockquote>\n<p>IO 重定向</p>\n</blockquote>\n<p>重定向的命令有：</p>\n<ol>\n<li><code>pgm &gt; file</code> 重定向到输出文件</li>\n<li><code>pgm &gt;&gt; file</code> 将输出追加到指定文件</li>\n<li><code>pgm &lt; file</code> 程序从文件读取输入</li>\n<li><code>n &gt; file</code> 将 n fd 的流输出重定向到文件 file</li>\n<li><code>n &gt;&gt; file</code> 将 fd n 的流输出重定向追加到文件 file</li>\n<li><code>n &gt;&amp; m</code> 合并 fd n 流与 fd m 流输出</li>\n<li><code>n &lt;&amp; m</code> 合并输入流 fd n 与 fd m</li>\n<li><code>&lt;&lt; tag</code>  Standard input comes from here through next tag at the start of line</li>\n<li><code>|</code> 管道，将前一个程序／应用的输出发送到下一个</li>\n</ol>\n<p>NOTE: <em>file descriptor（fd） 在 Unix 中使用非负整数表示，其中 0 表示标准输入 STDIN，1 表示标准输出 STDOUT，2 表示错误输出 STDERR</em><br>在 Unix 系统中每个非守护进程都有以上三个 IO 流，进程通过 kernel 访问文件 file table / inode table。</p>\n<p>在脚本中实现交互</p>\n<ol>\n<li>使用重定向</li>\n<li>使用管道</li>\n<li>使用 expect （需要安装此功能）</li>\n</ol>\n<h2 id=\"8-Functions\"><a href=\"#8-Functions\" class=\"headerlink\" title=\".8. Functions\"></a>.8. Functions</h2><blockquote>\n<p>Unix shell function</p>\n</blockquote>\n<ul>\n<li>定义 function 其语法是：在方法名后跟上 <code>function_name () &#123;&#125;</code>，传递参数直接在命令行中添加，在方法中调用参数使用 <code>$n</code></li>\n<li>返回数据使用关键字 <code>return</code></li>\n<li><code>exit</code> 会终结整个 shell 执行，而不是 function 。</li>\n<li><code>$?</code> 获取上一次命令返回值 <code>ret=$?</code>，此值只是一个整数代表结果，不能返回字符及其他</li>\n<li>shell 文件调用需要使用 <code>. shell_file</code></li>\n<li>shell 文件后缀可以不用写，一样的效果</li>\n<li>shell 文件头指定 shell  执行 bash 类型也可不写，让系统默认的 shell 执行即可</li>\n<li><code>echo $PATH</code> 可以看到系统全局变量，其中一般包括了 ~/bin ，所以要以在此文件路径中添加自己想要的全局 shell ，而实现任何地方不添加绝对路径前缀调用此 shell 。</li>\n<li><code>$HOME</code> 调用当前用户目录，在 shell 中使用 ～ 不会生效。</li>\n</ul>\n<h2 id=\"9-Alias\"><a href=\"#9-Alias\" class=\"headerlink\" title=\".9. Alias\"></a>.9. Alias</h2><blockquote>\n<p>给 bash shell 命令添加别名.<a href=\"https://blog.csdn.net/doiido/article/details/43762791\">reference</a></p>\n</blockquote>\n<ul>\n<li>使用命令 <code>alias command=&#39;command arguments&#39;</code> 给命令添加别名，从而缩小写常用参数的工作。eg: <code>alias grep=&#39;grep -iE --color=auto&#39;</code>，可以实现使用 grep 命令自动添加两个参数</li>\n<li>如果要永久实现别名生效可以将命令添加到 ~/.bashrc 文件中并执行此文件</li>\n<li>解除别名设置使用命令 <code>unalias name</code></li>\n</ul>\n<h2 id=\"10-添加机器命令别名与进入日志脚本\"><a href=\"#10-添加机器命令别名与进入日志脚本\" class=\"headerlink\" title=\".10. 添加机器命令别名与进入日志脚本\"></a>.10. 添加机器命令别名与进入日志脚本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">D=`date +%F`</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;today: $D&quot;</span><br><span class=\"line\">echo &quot;AUGUMENTS: $@&quot;</span><br><span class=\"line\">PT=&quot;/smapp/servers/snxia-api-app/logs/$D/&quot;</span><br><span class=\"line\">echo &quot;path: $PT&quot;</span><br><span class=\"line\">LOG_TYPE=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">alias grep=&#x27;grep -iE --color&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $# -eq 0 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo &quot;No arguments&quot;</span><br><span class=\"line\">    cd $PT</span><br><span class=\"line\">else</span><br><span class=\"line\">    get_log_type $2</span><br><span class=\"line\">    if [ $1 = &quot;v&quot; ]</span><br><span class=\"line\">    then</span><br><span class=\"line\">        echo &quot;vim ...&quot;</span><br><span class=\"line\">        vim &quot;$PT/$LOG_TYPE&quot;</span><br><span class=\"line\">    fi</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">get_log_type () &#123;</span><br><span class=\"line\">    echo &quot;arguments: $*&quot;</span><br><span class=\"line\">    if [ $1 = &quot;e&quot; ]</span><br><span class=\"line\">    then</span><br><span class=\"line\">        LOG_TYPE=&quot;error-log.log&quot;</span><br><span class=\"line\">    elif [ $1 = &quot;i&quot; ]</span><br><span class=\"line\">    then</span><br><span class=\"line\">        LGO_TYPE=&quot;info-log.log&quot;</span><br><span class=\"line\">    else [ $1 = &quot;w&quot; ]</span><br><span class=\"line\">        LOG_TYPE=&quot;warn-log.log&quot;</span><br><span class=\"line\">    fi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-Questions\"><a href=\"#11-Questions\" class=\"headerlink\" title=\".11. Questions\"></a>.11. Questions</h2><h3 id=\"11-1-Shell-脚本中-cd-命令不生效\"><a href=\"#11-1-Shell-脚本中-cd-命令不生效\" class=\"headerlink\" title=\".11.1. Shell 脚本中 cd 命令不生效\"></a>.11.1. Shell 脚本中 cd 命令不生效</h3><p>再现：在 l 脚本中写了 cd 命令，再放在 PATH 中，在 terminal 直接调用这个脚本 <code>l</code> ，发现当前目录还是原目录并未进入到脚本中指定的目录。</p>\n<p>原因：在接 terminal 调用脚本，是在当前 shell 环境中执行另外一个进程，进程结束就返回了原 shell 。</p>\n<p>解决：使用 <code>source</code> 或 <code>.</code> 命令在当前 shell 中执行脚本，而不是直接调用脚本。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Shell 是一个可以执行命令／程序／shell 脚本的环境，提供了访问 Unix 系统的接口。其根据输入执行程序，执行完成后将结果展示出来。 <a href=\"https://www.tutorialspoint.com/unix/unix-what-is-shell.htm\">Shell</a>","more":"</p>\n</blockquote>\n<h2 id=\"1-variable\"><a href=\"#1-variable\" class=\"headerlink\" title=\".1. variable\"></a>.1. variable</h2><blockquote>\n<p>变量</p>\n</blockquote>\n<ul>\n<li>只读变量 <code>readonly variable</code></li>\n<li><code>unset &#123;variable_name&#125;</code> 重置一个变量，只读变量不可重置，重置后不能再访问</li>\n<li>变量类型<ul>\n<li>Local variable.存在于当前shell实例中的变量，shell开启程序后，程序不能访问local variable .</li>\n<li>Environment variable. 环境变量，shell进程中任何地方可以获取环境变量.</li>\n<li>Shell variable.shell脚本中定义的变量，可以是 local variable ,也可是Environment variable .</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Basic-operators\"><a href=\"#2-Basic-operators\" class=\"headerlink\" title=\".2. Basic operators\"></a>.2. Basic operators</h2><p><a href=\"https://www.tutorialspoint.com/unix/unix-basic-operators.htm\">reference</a></p>\n<h3 id=\"2-1-Arithmetic-operators\"><a href=\"#2-1-Arithmetic-operators\" class=\"headerlink\" title=\".2.1. Arithmetic operators\"></a>.2.1. Arithmetic operators</h3><ul>\n<li>使用基础运算符时引用变量需要同样使用 <code>$</code> 符号，但赋值时直接使用变量名即可。<code>expr a = $b</code></li>\n<li>运算符与表达式之间需要空格分开。<code>expr $a != $b</code></li>\n<li><code>*</code> 乘号使用需要添加转义 <code>\\*</code></li>\n<li>条件表达式使用需要被方括号(括号与表达式之间需要空格分隔)所包围：　<code>[ $a == $b ]</code></li>\n</ul>\n<h3 id=\"2-2-Relational-Operators\"><a href=\"#2-2-Relational-Operators\" class=\"headerlink\" title=\".2.2. Relational Operators\"></a>.2.2. Relational Operators</h3><ul>\n<li>同样需要方括号与空格包围变量 <code>[ $a -eq $b ]</code></li>\n<li><code>-eq</code> equals</li>\n<li><code>-ne</code> not equals</li>\n<li><code>-gt</code> greater than</li>\n<li><code>-lt</code> less than</li>\n<li><code>-ge</code> greater or equals</li>\n<li><code>-le</code> less or equals</li>\n<li>关系运算符支付数值类，如果是string类必须是代表数值的string，eg:<code>&quot;100&quot;</code></li>\n</ul>\n<h3 id=\"2-3-Boolean-Operators\"><a href=\"#2-3-Boolean-Operators\" class=\"headerlink\" title=\".2.3. Boolean Operators\"></a>.2.3. Boolean Operators</h3><ul>\n<li><code>!</code> 取反</li>\n<li><code>-o</code> OR</li>\n<li><code>-a</code> AND</li>\n<li>eg: <code>[ $a -gt 100 -a $b -le 20 ]</code></li>\n</ul>\n<h3 id=\"2-4-String-Operators\"><a href=\"#2-4-String-Operators\" class=\"headerlink\" title=\".2.4. String Operators\"></a>.2.4. String Operators</h3><ul>\n<li><code>=</code></li>\n<li><code>!=</code></li>\n<li><code>-z</code> zero 检测字串其长度是否为 ０  <code>[ -z $a ]</code></li>\n<li><code>-n</code> not-zero 字串长度不为 0 <code>[ -n $a ]</code></li>\n<li>str 检测字串是否为 empty <code>[ $a ]</code></li>\n</ul>\n<h3 id=\"2-5-File-Test-Operators\"><a href=\"#2-5-File-Test-Operators\" class=\"headerlink\" title=\".2.5. File Test Operators\"></a>.2.5. File Test Operators</h3><p>检测关联到文件的变量属性。假如一个变量 <code>file</code> 关联到一个 test 文件，大小100bytes，有 read/write/execute 权限。其相关命令如下：</p>\n<ul>\n<li><code>-b file</code> check if file is a block special file. <code>[ -b $file ]</code> false</li>\n<li><code>-c file</code> check if file is a character special file. <code>[ -c $file ]</code> false</li>\n<li><code>-d file</code> check if file is a directory. <code>[ -d $file ]</code> false</li>\n<li><code>-f file</code> check if file is an ordinal file as opposed to a directory or special file. <code>[ -f $file ]</code> is true</li>\n<li><code>-e file</code> check if file exists. <code>[ -e $file ]</code> is true</li>\n<li><code>-r</code>/<code>-w</code>/<code>-x</code> check if file is readable/writable/executable.</li>\n</ul>\n<h2 id=\"3-Decision-Making\"><a href=\"#3-Decision-Making\" class=\"headerlink\" title=\".3. Decision Making\"></a>.3. Decision Making</h2><p><a href=\"https://www.tutorialspoint.com/unix/unix-decision-making.htm\">reference</a></p>\n<p>shell 中两种类似 switch case 的分支语句：</p>\n<ol>\n<li>if…elif…else…fi</li>\n<li>case…esac</li>\n</ol>\n<h2 id=\"4-Process-Control\"><a href=\"#4-Process-Control\" class=\"headerlink\" title=\".4. Ｐrocess Control\"></a>.4. Ｐrocess Control</h2><ul>\n<li>until 与 while 中的条件相反，满足条件在 while中循环，而不满足条件才在 until 中循环。</li>\n<li><code>break n</code> 跳出循环，其中 n 代表正整数，默认不写为 1 只跳出当前层循环，而如果需要跳出第二层循环（从内往外数）就指定 n 为 2 。</li>\n</ul>\n<h2 id=\"5-Substitutions\"><a href=\"#5-Substitutions\" class=\"headerlink\" title=\".5. Substitutions\"></a>.5. Substitutions</h2><blockquote>\n<p>转义</p>\n</blockquote>\n<p>常用转义符号：</p>\n<ul>\n<li><code>\\n</code> new line</li>\n<li><code>\\r</code> carriage return</li>\n<li><code>\\t</code> horizontal tab</li>\n<li><code>\\\\</code> back slash</li>\n<li><code>\\a</code> alert</li>\n<li><code>\\b</code> backspace</li>\n<li><code>\\c</code> suppress trailing line</li>\n<li><code>\\f</code> form feed</li>\n<li><code>\\v</code> vertical tab</li>\n</ul>\n<h3 id=\"5-1-Command-Substitution\"><a href=\"#5-1-Command-Substitution\" class=\"headerlink\" title=\".5.1. Command Substitution\"></a>.5.1. Command Substitution</h3><p><code>command</code> 使用 back quote 将命令包围起来，命令执行结果将返回。eg: echo “today is <code>date</code>“</p>\n<h3 id=\"5-2-Variable-Substitution\"><a href=\"#5-2-Variable-Substitution\" class=\"headerlink\" title=\".5.2. Variable Substitution\"></a>.5.2. Variable Substitution</h3><blockquote>\n<p>变量转义</p>\n</blockquote>\n<p>使用变量转义可以将对变量进行检查，并对其返回值或变量作修改。</p>\n<ul>\n<li><code>$&#123;var:-word&#125;</code> 如果变量 var 为 null  或未设置，将使用 word 转义为结果， var 变量不会被设置成 word.</li>\n<li><code>$&#123;var&#125;</code> 转义 var 的值</li>\n<li><code>$&#123;var:=word&#125;</code> 转义 var 并将 word 赋值给 var。</li>\n<li><code>$&#123;var:?message&#125;</code> 如果 var 未设置或为 null ，message 将打印到 standard error。用以检测变量 var 是否正确设置。</li>\n<li><code>$&#123;var:+word&#125;</code> 如果 var 已设置，work 将转义给 var ，但 var 不会改变。</li>\n</ul>\n<h2 id=\"6-Quoting-Mechanisms\"><a href=\"#6-Quoting-Mechanisms\" class=\"headerlink\" title=\".6. Quoting Mechanisms\"></a>.6. Quoting Mechanisms</h2><blockquote>\n<p><a href=\"https://www.tutorialspoint.com/unix/unix-quoting-mechanisms.htm\">引用机制</a></p>\n</blockquote>\n<h3 id=\"6-1-Meta-Characters\"><a href=\"#6-1-Meta-Characters\" class=\"headerlink\" title=\".6.1. Meta Characters\"></a>.6.1. Meta Characters</h3><blockquote>\n<p>Unix 元字符在 shell 中有特殊含义，所以在命令中如果要使用其为普通字串，需要在其前加上转义符号 backslash <code>\\</code>。 Unix 中的元字符包括：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* ? [ ] &#x27; &quot; \\ $ ; &amp; ( ) | ^ &lt; &gt; new-line space tab</span><br></pre></td></tr></table></figure>\n\n<p><code>?</code> 代表任何一个字符，而 <code>*</code> 代表任意多个字符。</p>\n<h3 id=\"6-2-quoting\"><a href=\"#6-2-quoting\" class=\"headerlink\" title=\".6.2. quoting\"></a>.6.2. quoting</h3><blockquote>\n<p>引用方式有四种</p>\n</blockquote>\n<ol>\n<li>单引号引用 <code>&#39;</code>，特殊符号会将全部的元字符给转义为字面量。当需要输出单引号时，此时可以使用 backslash 将其转义输出。</li>\n<li>双引号引用 <code>&quot;</code>，大部分特殊符号被双引号引用有将丢失其特殊意义，但有例外：$ ` $ &#39; &quot; \\</li>\n<li>backslash <code>\\</code>, 所有特殊变量在 backslash 后都将丢失其特殊意义</li>\n<li>back quote `, 被 back quote 包围的任何字符都将会被当作命令执行。</li>\n</ol>\n<h2 id=\"7-IO-Redirection\"><a href=\"#7-IO-Redirection\" class=\"headerlink\" title=\".7. IO Redirection\"></a>.7. IO Redirection</h2><blockquote>\n<p>IO 重定向</p>\n</blockquote>\n<p>重定向的命令有：</p>\n<ol>\n<li><code>pgm &gt; file</code> 重定向到输出文件</li>\n<li><code>pgm &gt;&gt; file</code> 将输出追加到指定文件</li>\n<li><code>pgm &lt; file</code> 程序从文件读取输入</li>\n<li><code>n &gt; file</code> 将 n fd 的流输出重定向到文件 file</li>\n<li><code>n &gt;&gt; file</code> 将 fd n 的流输出重定向追加到文件 file</li>\n<li><code>n &gt;&amp; m</code> 合并 fd n 流与 fd m 流输出</li>\n<li><code>n &lt;&amp; m</code> 合并输入流 fd n 与 fd m</li>\n<li><code>&lt;&lt; tag</code>  Standard input comes from here through next tag at the start of line</li>\n<li><code>|</code> 管道，将前一个程序／应用的输出发送到下一个</li>\n</ol>\n<p>NOTE: <em>file descriptor（fd） 在 Unix 中使用非负整数表示，其中 0 表示标准输入 STDIN，1 表示标准输出 STDOUT，2 表示错误输出 STDERR</em><br>在 Unix 系统中每个非守护进程都有以上三个 IO 流，进程通过 kernel 访问文件 file table / inode table。</p>\n<p>在脚本中实现交互</p>\n<ol>\n<li>使用重定向</li>\n<li>使用管道</li>\n<li>使用 expect （需要安装此功能）</li>\n</ol>\n<h2 id=\"8-Functions\"><a href=\"#8-Functions\" class=\"headerlink\" title=\".8. Functions\"></a>.8. Functions</h2><blockquote>\n<p>Unix shell function</p>\n</blockquote>\n<ul>\n<li>定义 function 其语法是：在方法名后跟上 <code>function_name () &#123;&#125;</code>，传递参数直接在命令行中添加，在方法中调用参数使用 <code>$n</code></li>\n<li>返回数据使用关键字 <code>return</code></li>\n<li><code>exit</code> 会终结整个 shell 执行，而不是 function 。</li>\n<li><code>$?</code> 获取上一次命令返回值 <code>ret=$?</code>，此值只是一个整数代表结果，不能返回字符及其他</li>\n<li>shell 文件调用需要使用 <code>. shell_file</code></li>\n<li>shell 文件后缀可以不用写，一样的效果</li>\n<li>shell 文件头指定 shell  执行 bash 类型也可不写，让系统默认的 shell 执行即可</li>\n<li><code>echo $PATH</code> 可以看到系统全局变量，其中一般包括了 ~/bin ，所以要以在此文件路径中添加自己想要的全局 shell ，而实现任何地方不添加绝对路径前缀调用此 shell 。</li>\n<li><code>$HOME</code> 调用当前用户目录，在 shell 中使用 ～ 不会生效。</li>\n</ul>\n<h2 id=\"9-Alias\"><a href=\"#9-Alias\" class=\"headerlink\" title=\".9. Alias\"></a>.9. Alias</h2><blockquote>\n<p>给 bash shell 命令添加别名.<a href=\"https://blog.csdn.net/doiido/article/details/43762791\">reference</a></p>\n</blockquote>\n<ul>\n<li>使用命令 <code>alias command=&#39;command arguments&#39;</code> 给命令添加别名，从而缩小写常用参数的工作。eg: <code>alias grep=&#39;grep -iE --color=auto&#39;</code>，可以实现使用 grep 命令自动添加两个参数</li>\n<li>如果要永久实现别名生效可以将命令添加到 ~/.bashrc 文件中并执行此文件</li>\n<li>解除别名设置使用命令 <code>unalias name</code></li>\n</ul>\n<h2 id=\"10-添加机器命令别名与进入日志脚本\"><a href=\"#10-添加机器命令别名与进入日志脚本\" class=\"headerlink\" title=\".10. 添加机器命令别名与进入日志脚本\"></a>.10. 添加机器命令别名与进入日志脚本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">D=`date +%F`</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;today: $D&quot;</span><br><span class=\"line\">echo &quot;AUGUMENTS: $@&quot;</span><br><span class=\"line\">PT=&quot;/smapp/servers/snxia-api-app/logs/$D/&quot;</span><br><span class=\"line\">echo &quot;path: $PT&quot;</span><br><span class=\"line\">LOG_TYPE=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">alias grep=&#x27;grep -iE --color&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $# -eq 0 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo &quot;No arguments&quot;</span><br><span class=\"line\">    cd $PT</span><br><span class=\"line\">else</span><br><span class=\"line\">    get_log_type $2</span><br><span class=\"line\">    if [ $1 = &quot;v&quot; ]</span><br><span class=\"line\">    then</span><br><span class=\"line\">        echo &quot;vim ...&quot;</span><br><span class=\"line\">        vim &quot;$PT/$LOG_TYPE&quot;</span><br><span class=\"line\">    fi</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">get_log_type () &#123;</span><br><span class=\"line\">    echo &quot;arguments: $*&quot;</span><br><span class=\"line\">    if [ $1 = &quot;e&quot; ]</span><br><span class=\"line\">    then</span><br><span class=\"line\">        LOG_TYPE=&quot;error-log.log&quot;</span><br><span class=\"line\">    elif [ $1 = &quot;i&quot; ]</span><br><span class=\"line\">    then</span><br><span class=\"line\">        LGO_TYPE=&quot;info-log.log&quot;</span><br><span class=\"line\">    else [ $1 = &quot;w&quot; ]</span><br><span class=\"line\">        LOG_TYPE=&quot;warn-log.log&quot;</span><br><span class=\"line\">    fi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-Questions\"><a href=\"#11-Questions\" class=\"headerlink\" title=\".11. Questions\"></a>.11. Questions</h2><h3 id=\"11-1-Shell-脚本中-cd-命令不生效\"><a href=\"#11-1-Shell-脚本中-cd-命令不生效\" class=\"headerlink\" title=\".11.1. Shell 脚本中 cd 命令不生效\"></a>.11.1. Shell 脚本中 cd 命令不生效</h3><p>再现：在 l 脚本中写了 cd 命令，再放在 PATH 中，在 terminal 直接调用这个脚本 <code>l</code> ，发现当前目录还是原目录并未进入到脚本中指定的目录。</p>\n<p>原因：在接 terminal 调用脚本，是在当前 shell 环境中执行另外一个进程，进程结束就返回了原 shell 。</p>\n<p>解决：使用 <code>source</code> 或 <code>.</code> 命令在当前 shell 中执行脚本，而不是直接调用脚本。</p>"},{"title":"Deadlocks in InnoDB","layout":"post","description":"Deadlock in InnoDB","date":"2021-01-12T14:31:00.000Z","_content":"\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html)\n\n当不同的事务因为持有其他事务需要的锁不能继续处理时的场景叫死锁。因为事务之间在等待对方的资源释放，但又不释放自己所持有的资源。<!--more-->\n\n当多个事务通过语句 `SELECT ... FOR UPDATE` 或 `UPDATE` 对多张表中的行加锁，但加锁顺序不一致时会产生死锁。\n\n为降低死锁产生的可能性：\n\n- 使用事务而不要使用 `LOCK TABLES` 语句。\n- 让 insert/update 事务尽量小，以保证事务打开的时间尽量短。\n- 当不同的事务更新多张表或大量数据行时，在每个事务中使用相同的操作顺序（如：`SELECT ... FOR UPDATE`）；\n- 为 `SELECT ... FOR UPDATE` 与 `UPDATE` 语句使用的 column 创建索引。\n\n*事务隔离级别不影响死锁产生的可能性，因为事务隔离级别只改变读的行为，而死锁产生来源于写操作。*\n\n当死锁产生且死锁检测打开（默认打开状态），InnoDB 会检测死锁状态并回滚其中一个事务。如果使用配置 `innodb_deadlock_detect` 关闭了死锁检测，发生死锁时，InnoDB 根据配置 `innodb_lock_wait_timeout` 回滚事务。所以就算应用逻辑是正确的，也必须处理这种事务必须重试的场景。使用命令行 `SHOW ENGINE INNODB STATUS` 可以查看 InnoDB 用户事务的最后一个死锁。如果事务结构或应用错误处理伴随着高频的死锁，使用 `innodb_print_all_deadlocks=1` 将所有的死锁信息打印到 mysqld 错误日志中。\n\n## .1. An InnoDB Deadlock Example\n\n[reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-example.html)\n\n> 一个死锁例子。其中有两个客户端分别访问按以下顺序执行命令。\n\n1. clientA 创建表并在其中插入一条记录；\n2. clientA 开启新事务并使用 `SELECT * FROM t WHERE id = 1 LOCK IN SHARE MODE` 查询出这条数据；\n3. clientB 开启事务并执行删除这条数据的命令：`DELETE FROM t WHERE id = 1;`这个时候，因为 clientA 持有该行数据的 s-lock ，clientB 的 x-lock 不能立即获取，只会产生一个 x-lock 的请求放入到队列中。\n4. clientA 这时执行 `DELETE FROM t WHERE ID = 1;`。这个时候产生死锁。产生原因：clientA 需要一个 x-lock，但 clientB 已经有一个 x-lock 请求在队列中同时它又在等待　clientA 释放其正持有 s-lock 。A 正持有的 s-lock 也因为 B 优先的 x-lock 请求而不能升级为 x-lock 。最终结果是，InnoDB 为其中一个 client 生成一个 error，并释放其所持有的锁。这个 client 返回错误：`ERROR 1213 (40001): Deadlock found when trying to get lock;\ntry restarting transaction`，同时，另外的 client 的锁请求得到响应而删除这行数据。\n\n## .2. Deadlock Detection\n\n> [死锁检测](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html)\n\n当死锁检测打开（默认），InnoDB 会自动检测死锁并回滚基中一个或多个事务以打断死锁链条。InnoDB 会尝试回滚最小的事务，事务的大小取决于 inserted,updated,deleted 的行数。\n\n当 innodb_table_locks = 1 且 autocommit = 0 时， InnoDB 对表锁有感知，并且 InnoDB 之上的 MYSQL 层也感知行级锁。否则，InnoDB 不能对 MYSQL `LOCK TABLES` 语句加的表锁或 InnoDB 之外的存储引擎设置的锁进行死锁检测。这些场景下可以用设置系统变量 `innodb_lock_wait_timeout` 来解决。\n\n如果 InnoDB 监听的 LASTED DETECTED DEADLOCK 输出包含 “TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,” 的信息，这表明 wait-for list 上等待的事务数量超过了限制数量 200　。当等待列表事务数量超过 200 时直接当作死锁发生，并且尝试检查等待列表的事务是回滚过的。同样，如果等待列表上事务所拥有的加锁线程必须加超过 1000000 个锁也会产生这个错误。\n\n### .2.1. Disabling Deadlock Detection\n\n在高并发系统中，死锁检测在一定数量线程等待相同的锁时会造成响应延迟。这种情况下，关闭死锁检测在死锁发生时根据 `innodb_lock_wait_timeout` 设置来回滚事务会更高效。关闭死锁检测使用 `innodb_deadlock_detect` 配置项。\n\n","source":"_posts/Mysql/Deadlocks in InnoDB.md","raw":"---\ntitle: Deadlocks in InnoDB\nlayout: post\ntag: [mysql, InnoDB, Deadlock]\ncategories: [Mysql]\ndescription: Deadlock in InnoDB\ndate: \"2021-1-12 22:31:00\"\n---\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html)\n\n当不同的事务因为持有其他事务需要的锁不能继续处理时的场景叫死锁。因为事务之间在等待对方的资源释放，但又不释放自己所持有的资源。<!--more-->\n\n当多个事务通过语句 `SELECT ... FOR UPDATE` 或 `UPDATE` 对多张表中的行加锁，但加锁顺序不一致时会产生死锁。\n\n为降低死锁产生的可能性：\n\n- 使用事务而不要使用 `LOCK TABLES` 语句。\n- 让 insert/update 事务尽量小，以保证事务打开的时间尽量短。\n- 当不同的事务更新多张表或大量数据行时，在每个事务中使用相同的操作顺序（如：`SELECT ... FOR UPDATE`）；\n- 为 `SELECT ... FOR UPDATE` 与 `UPDATE` 语句使用的 column 创建索引。\n\n*事务隔离级别不影响死锁产生的可能性，因为事务隔离级别只改变读的行为，而死锁产生来源于写操作。*\n\n当死锁产生且死锁检测打开（默认打开状态），InnoDB 会检测死锁状态并回滚其中一个事务。如果使用配置 `innodb_deadlock_detect` 关闭了死锁检测，发生死锁时，InnoDB 根据配置 `innodb_lock_wait_timeout` 回滚事务。所以就算应用逻辑是正确的，也必须处理这种事务必须重试的场景。使用命令行 `SHOW ENGINE INNODB STATUS` 可以查看 InnoDB 用户事务的最后一个死锁。如果事务结构或应用错误处理伴随着高频的死锁，使用 `innodb_print_all_deadlocks=1` 将所有的死锁信息打印到 mysqld 错误日志中。\n\n## .1. An InnoDB Deadlock Example\n\n[reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-example.html)\n\n> 一个死锁例子。其中有两个客户端分别访问按以下顺序执行命令。\n\n1. clientA 创建表并在其中插入一条记录；\n2. clientA 开启新事务并使用 `SELECT * FROM t WHERE id = 1 LOCK IN SHARE MODE` 查询出这条数据；\n3. clientB 开启事务并执行删除这条数据的命令：`DELETE FROM t WHERE id = 1;`这个时候，因为 clientA 持有该行数据的 s-lock ，clientB 的 x-lock 不能立即获取，只会产生一个 x-lock 的请求放入到队列中。\n4. clientA 这时执行 `DELETE FROM t WHERE ID = 1;`。这个时候产生死锁。产生原因：clientA 需要一个 x-lock，但 clientB 已经有一个 x-lock 请求在队列中同时它又在等待　clientA 释放其正持有 s-lock 。A 正持有的 s-lock 也因为 B 优先的 x-lock 请求而不能升级为 x-lock 。最终结果是，InnoDB 为其中一个 client 生成一个 error，并释放其所持有的锁。这个 client 返回错误：`ERROR 1213 (40001): Deadlock found when trying to get lock;\ntry restarting transaction`，同时，另外的 client 的锁请求得到响应而删除这行数据。\n\n## .2. Deadlock Detection\n\n> [死锁检测](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html)\n\n当死锁检测打开（默认），InnoDB 会自动检测死锁并回滚基中一个或多个事务以打断死锁链条。InnoDB 会尝试回滚最小的事务，事务的大小取决于 inserted,updated,deleted 的行数。\n\n当 innodb_table_locks = 1 且 autocommit = 0 时， InnoDB 对表锁有感知，并且 InnoDB 之上的 MYSQL 层也感知行级锁。否则，InnoDB 不能对 MYSQL `LOCK TABLES` 语句加的表锁或 InnoDB 之外的存储引擎设置的锁进行死锁检测。这些场景下可以用设置系统变量 `innodb_lock_wait_timeout` 来解决。\n\n如果 InnoDB 监听的 LASTED DETECTED DEADLOCK 输出包含 “TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,” 的信息，这表明 wait-for list 上等待的事务数量超过了限制数量 200　。当等待列表事务数量超过 200 时直接当作死锁发生，并且尝试检查等待列表的事务是回滚过的。同样，如果等待列表上事务所拥有的加锁线程必须加超过 1000000 个锁也会产生这个错误。\n\n### .2.1. Disabling Deadlock Detection\n\n在高并发系统中，死锁检测在一定数量线程等待相同的锁时会造成响应延迟。这种情况下，关闭死锁检测在死锁发生时根据 `innodb_lock_wait_timeout` 设置来回滚事务会更高效。关闭死锁检测使用 `innodb_deadlock_detect` 配置项。\n\n","slug":"Mysql/Deadlocks in InnoDB","published":1,"updated":"2021-02-24T15:22:22.868Z","comments":1,"photos":[],"link":"","_id":"ckljnokr400152bhb1gcs2uip","content":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html\">reference</a></p>\n</blockquote>\n<p>当不同的事务因为持有其他事务需要的锁不能继续处理时的场景叫死锁。因为事务之间在等待对方的资源释放，但又不释放自己所持有的资源。<span id=\"more\"></span></p>\n<p>当多个事务通过语句 <code>SELECT ... FOR UPDATE</code> 或 <code>UPDATE</code> 对多张表中的行加锁，但加锁顺序不一致时会产生死锁。</p>\n<p>为降低死锁产生的可能性：</p>\n<ul>\n<li>使用事务而不要使用 <code>LOCK TABLES</code> 语句。</li>\n<li>让 insert/update 事务尽量小，以保证事务打开的时间尽量短。</li>\n<li>当不同的事务更新多张表或大量数据行时，在每个事务中使用相同的操作顺序（如：<code>SELECT ... FOR UPDATE</code>）；</li>\n<li>为 <code>SELECT ... FOR UPDATE</code> 与 <code>UPDATE</code> 语句使用的 column 创建索引。</li>\n</ul>\n<p><em>事务隔离级别不影响死锁产生的可能性，因为事务隔离级别只改变读的行为，而死锁产生来源于写操作。</em></p>\n<p>当死锁产生且死锁检测打开（默认打开状态），InnoDB 会检测死锁状态并回滚其中一个事务。如果使用配置 <code>innodb_deadlock_detect</code> 关闭了死锁检测，发生死锁时，InnoDB 根据配置 <code>innodb_lock_wait_timeout</code> 回滚事务。所以就算应用逻辑是正确的，也必须处理这种事务必须重试的场景。使用命令行 <code>SHOW ENGINE INNODB STATUS</code> 可以查看 InnoDB 用户事务的最后一个死锁。如果事务结构或应用错误处理伴随着高频的死锁，使用 <code>innodb_print_all_deadlocks=1</code> 将所有的死锁信息打印到 mysqld 错误日志中。</p>\n<h2 id=\"1-An-InnoDB-Deadlock-Example\"><a href=\"#1-An-InnoDB-Deadlock-Example\" class=\"headerlink\" title=\".1. An InnoDB Deadlock Example\"></a>.1. An InnoDB Deadlock Example</h2><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-example.html\">reference</a></p>\n<blockquote>\n<p>一个死锁例子。其中有两个客户端分别访问按以下顺序执行命令。</p>\n</blockquote>\n<ol>\n<li>clientA 创建表并在其中插入一条记录；</li>\n<li>clientA 开启新事务并使用 <code>SELECT * FROM t WHERE id = 1 LOCK IN SHARE MODE</code> 查询出这条数据；</li>\n<li>clientB 开启事务并执行删除这条数据的命令：<code>DELETE FROM t WHERE id = 1;</code>这个时候，因为 clientA 持有该行数据的 s-lock ，clientB 的 x-lock 不能立即获取，只会产生一个 x-lock 的请求放入到队列中。</li>\n<li>clientA 这时执行 <code>DELETE FROM t WHERE ID = 1;</code>。这个时候产生死锁。产生原因：clientA 需要一个 x-lock，但 clientB 已经有一个 x-lock 请求在队列中同时它又在等待　clientA 释放其正持有 s-lock 。A 正持有的 s-lock 也因为 B 优先的 x-lock 请求而不能升级为 x-lock 。最终结果是，InnoDB 为其中一个 client 生成一个 error，并释放其所持有的锁。这个 client 返回错误：<code>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code>，同时，另外的 client 的锁请求得到响应而删除这行数据。</li>\n</ol>\n<h2 id=\"2-Deadlock-Detection\"><a href=\"#2-Deadlock-Detection\" class=\"headerlink\" title=\".2. Deadlock Detection\"></a>.2. Deadlock Detection</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html\">死锁检测</a></p>\n</blockquote>\n<p>当死锁检测打开（默认），InnoDB 会自动检测死锁并回滚基中一个或多个事务以打断死锁链条。InnoDB 会尝试回滚最小的事务，事务的大小取决于 inserted,updated,deleted 的行数。</p>\n<p>当 innodb_table_locks = 1 且 autocommit = 0 时， InnoDB 对表锁有感知，并且 InnoDB 之上的 MYSQL 层也感知行级锁。否则，InnoDB 不能对 MYSQL <code>LOCK TABLES</code> 语句加的表锁或 InnoDB 之外的存储引擎设置的锁进行死锁检测。这些场景下可以用设置系统变量 <code>innodb_lock_wait_timeout</code> 来解决。</p>\n<p>如果 InnoDB 监听的 LASTED DETECTED DEADLOCK 输出包含 “TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,” 的信息，这表明 wait-for list 上等待的事务数量超过了限制数量 200　。当等待列表事务数量超过 200 时直接当作死锁发生，并且尝试检查等待列表的事务是回滚过的。同样，如果等待列表上事务所拥有的加锁线程必须加超过 1000000 个锁也会产生这个错误。</p>\n<h3 id=\"2-1-Disabling-Deadlock-Detection\"><a href=\"#2-1-Disabling-Deadlock-Detection\" class=\"headerlink\" title=\".2.1. Disabling Deadlock Detection\"></a>.2.1. Disabling Deadlock Detection</h3><p>在高并发系统中，死锁检测在一定数量线程等待相同的锁时会造成响应延迟。这种情况下，关闭死锁检测在死锁发生时根据 <code>innodb_lock_wait_timeout</code> 设置来回滚事务会更高效。关闭死锁检测使用 <code>innodb_deadlock_detect</code> 配置项。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html\">reference</a></p>\n</blockquote>\n<p>当不同的事务因为持有其他事务需要的锁不能继续处理时的场景叫死锁。因为事务之间在等待对方的资源释放，但又不释放自己所持有的资源。","more":"</p>\n<p>当多个事务通过语句 <code>SELECT ... FOR UPDATE</code> 或 <code>UPDATE</code> 对多张表中的行加锁，但加锁顺序不一致时会产生死锁。</p>\n<p>为降低死锁产生的可能性：</p>\n<ul>\n<li>使用事务而不要使用 <code>LOCK TABLES</code> 语句。</li>\n<li>让 insert/update 事务尽量小，以保证事务打开的时间尽量短。</li>\n<li>当不同的事务更新多张表或大量数据行时，在每个事务中使用相同的操作顺序（如：<code>SELECT ... FOR UPDATE</code>）；</li>\n<li>为 <code>SELECT ... FOR UPDATE</code> 与 <code>UPDATE</code> 语句使用的 column 创建索引。</li>\n</ul>\n<p><em>事务隔离级别不影响死锁产生的可能性，因为事务隔离级别只改变读的行为，而死锁产生来源于写操作。</em></p>\n<p>当死锁产生且死锁检测打开（默认打开状态），InnoDB 会检测死锁状态并回滚其中一个事务。如果使用配置 <code>innodb_deadlock_detect</code> 关闭了死锁检测，发生死锁时，InnoDB 根据配置 <code>innodb_lock_wait_timeout</code> 回滚事务。所以就算应用逻辑是正确的，也必须处理这种事务必须重试的场景。使用命令行 <code>SHOW ENGINE INNODB STATUS</code> 可以查看 InnoDB 用户事务的最后一个死锁。如果事务结构或应用错误处理伴随着高频的死锁，使用 <code>innodb_print_all_deadlocks=1</code> 将所有的死锁信息打印到 mysqld 错误日志中。</p>\n<h2 id=\"1-An-InnoDB-Deadlock-Example\"><a href=\"#1-An-InnoDB-Deadlock-Example\" class=\"headerlink\" title=\".1. An InnoDB Deadlock Example\"></a>.1. An InnoDB Deadlock Example</h2><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-example.html\">reference</a></p>\n<blockquote>\n<p>一个死锁例子。其中有两个客户端分别访问按以下顺序执行命令。</p>\n</blockquote>\n<ol>\n<li>clientA 创建表并在其中插入一条记录；</li>\n<li>clientA 开启新事务并使用 <code>SELECT * FROM t WHERE id = 1 LOCK IN SHARE MODE</code> 查询出这条数据；</li>\n<li>clientB 开启事务并执行删除这条数据的命令：<code>DELETE FROM t WHERE id = 1;</code>这个时候，因为 clientA 持有该行数据的 s-lock ，clientB 的 x-lock 不能立即获取，只会产生一个 x-lock 的请求放入到队列中。</li>\n<li>clientA 这时执行 <code>DELETE FROM t WHERE ID = 1;</code>。这个时候产生死锁。产生原因：clientA 需要一个 x-lock，但 clientB 已经有一个 x-lock 请求在队列中同时它又在等待　clientA 释放其正持有 s-lock 。A 正持有的 s-lock 也因为 B 优先的 x-lock 请求而不能升级为 x-lock 。最终结果是，InnoDB 为其中一个 client 生成一个 error，并释放其所持有的锁。这个 client 返回错误：<code>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code>，同时，另外的 client 的锁请求得到响应而删除这行数据。</li>\n</ol>\n<h2 id=\"2-Deadlock-Detection\"><a href=\"#2-Deadlock-Detection\" class=\"headerlink\" title=\".2. Deadlock Detection\"></a>.2. Deadlock Detection</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html\">死锁检测</a></p>\n</blockquote>\n<p>当死锁检测打开（默认），InnoDB 会自动检测死锁并回滚基中一个或多个事务以打断死锁链条。InnoDB 会尝试回滚最小的事务，事务的大小取决于 inserted,updated,deleted 的行数。</p>\n<p>当 innodb_table_locks = 1 且 autocommit = 0 时， InnoDB 对表锁有感知，并且 InnoDB 之上的 MYSQL 层也感知行级锁。否则，InnoDB 不能对 MYSQL <code>LOCK TABLES</code> 语句加的表锁或 InnoDB 之外的存储引擎设置的锁进行死锁检测。这些场景下可以用设置系统变量 <code>innodb_lock_wait_timeout</code> 来解决。</p>\n<p>如果 InnoDB 监听的 LASTED DETECTED DEADLOCK 输出包含 “TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,” 的信息，这表明 wait-for list 上等待的事务数量超过了限制数量 200　。当等待列表事务数量超过 200 时直接当作死锁发生，并且尝试检查等待列表的事务是回滚过的。同样，如果等待列表上事务所拥有的加锁线程必须加超过 1000000 个锁也会产生这个错误。</p>\n<h3 id=\"2-1-Disabling-Deadlock-Detection\"><a href=\"#2-1-Disabling-Deadlock-Detection\" class=\"headerlink\" title=\".2.1. Disabling Deadlock Detection\"></a>.2.1. Disabling Deadlock Detection</h3><p>在高并发系统中，死锁检测在一定数量线程等待相同的锁时会造成响应延迟。这种情况下，关闭死锁检测在死锁发生时根据 <code>innodb_lock_wait_timeout</code> 设置来回滚事务会更高效。关闭死锁检测使用 <code>innodb_deadlock_detect</code> 配置项。</p>"},{"title":"How to Minimize and Handle Deadlocks","layout":"post","description":"How to Minimize and Handle Deadlocks?","date":"2021-01-13T14:06:00.000Z","_content":"\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html)\n>\n> 死锁最小化建立在[死锁检测](./Deadlocks%20in%20InnoDB.md)之上。\n\n死锁是事务型中经典问题，如果出现死锁的频率不高不是一个危险的问题。通常来讲，需要在应用中为死锁场景下事务重试做好准备。<!--more-->\n\nInnoDB 自动使用行级锁。可能仅仅是在插入修改单行就出现死锁，这是因为这些操作并非真正的原子操作，它们会自动地在插入或修改的 index record（可能多个）上设置锁。（设置锁并非直接加锁，而是先请求锁，获得锁后再持有锁。）\n\n降低死锁概念的技术：\n\n1. 每次都使用 `SHOW ENGINE INNODB STATUS` 命令查看最近死锁的来源，这样可以帮助微调应用避免死锁。\n2. 如果高频出现死锁警告，打开 `innodb_print_all_deadlocks` 配置以收集更多 debug 信息。每个死锁的信息都记录在 MYSQL 的 error log 中。当完成 debug 后关闭此配置。\n3. 应用中随便为死锁准备重新发布事务，死锁并不危险，只会重试。\n4. 尽量精简事务以降低其发生冲突的可能。\n5. 更新完相应的记录立即提交事务以降低其冲突的可能。实际操作中，不要让一个交互式的 mysql session 长时间不提交。\n6. 如果使用锁读（locking read: SELECT ... FOR UPDATE/SELECT ... LOCK IN SHARE MODE），尝试使用更低的事务隔离级别，如：READ COMMITTED。\n7. 当在同一个事务中修改多个表数据或单表多行数据时，保证每次（业务中不同的代码块）操作顺序的一致。这样事务会形成很好的队列而不出现死锁。例如：在应用中组织数据库的操作在 function 中或调用存储过程，而不是在应用不同的地方编写多个类似的增删改的 sql 语句。\n8. 在表中添加合适的索引。这样可以减少查询扫描的 index records 记录，因而添加更少的锁。使用 [EXPLAIN SELECT](https://dev.mysql.com/doc/refman/5.7/en/explain.html) 来让 MYSQL server 决定查询的最适索引。\n9. 尽量少加锁。如果允许 SELECT 语句返回老版本快照，就不要选择添加 FOR UPDATE/LOCK IN SHARE MODE 子句进入锁读。使用 READ COMMITTED 隔离级别对一致性读也有帮助，因为在事务中都能读取到最新的快照。\n10. 如果别无他法，可以将事务序列化到表级锁上。使用示例（注意语句顺序）：\n\n    ```sql\n    SET autocommit=0;\n    LOCK TABLES t1 WRITE, t2 READ, ...;\n    ... do something with tables t1 and t2 here ...\n    COMMIT;\n    UNLOCK TABLES;\n    ```\n\n    表级锁阻止表上的并发更新，可以避免忙系统少响应的消耗上的死锁。\n11. 另外一个序列化事务的方法是创建一个辅助标识表，这个表只有一条数据。使每一个事务在访问其他表前必须先更新这行数据。这样可以保证所有事务都排列执行。需要注意的是，InnoDB 死锁检测算法在这种场景下依然工作，因为这个序列化锁是个行级锁。在 MYSQL 表级锁情况下，死锁问题使用超时方法来解决。\n","source":"_posts/Mysql/How to Minimize and Handle Deadlocks.md","raw":"---\ntitle: How to Minimize and Handle Deadlocks\nlayout: post\ntag: [mysql, InnoDB, Deadlock]\ncategories: [Mysql]\ndescription: How to Minimize and Handle Deadlocks?\ndate: \"2021-1-13 22:6:00\"\n---\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html)\n>\n> 死锁最小化建立在[死锁检测](./Deadlocks%20in%20InnoDB.md)之上。\n\n死锁是事务型中经典问题，如果出现死锁的频率不高不是一个危险的问题。通常来讲，需要在应用中为死锁场景下事务重试做好准备。<!--more-->\n\nInnoDB 自动使用行级锁。可能仅仅是在插入修改单行就出现死锁，这是因为这些操作并非真正的原子操作，它们会自动地在插入或修改的 index record（可能多个）上设置锁。（设置锁并非直接加锁，而是先请求锁，获得锁后再持有锁。）\n\n降低死锁概念的技术：\n\n1. 每次都使用 `SHOW ENGINE INNODB STATUS` 命令查看最近死锁的来源，这样可以帮助微调应用避免死锁。\n2. 如果高频出现死锁警告，打开 `innodb_print_all_deadlocks` 配置以收集更多 debug 信息。每个死锁的信息都记录在 MYSQL 的 error log 中。当完成 debug 后关闭此配置。\n3. 应用中随便为死锁准备重新发布事务，死锁并不危险，只会重试。\n4. 尽量精简事务以降低其发生冲突的可能。\n5. 更新完相应的记录立即提交事务以降低其冲突的可能。实际操作中，不要让一个交互式的 mysql session 长时间不提交。\n6. 如果使用锁读（locking read: SELECT ... FOR UPDATE/SELECT ... LOCK IN SHARE MODE），尝试使用更低的事务隔离级别，如：READ COMMITTED。\n7. 当在同一个事务中修改多个表数据或单表多行数据时，保证每次（业务中不同的代码块）操作顺序的一致。这样事务会形成很好的队列而不出现死锁。例如：在应用中组织数据库的操作在 function 中或调用存储过程，而不是在应用不同的地方编写多个类似的增删改的 sql 语句。\n8. 在表中添加合适的索引。这样可以减少查询扫描的 index records 记录，因而添加更少的锁。使用 [EXPLAIN SELECT](https://dev.mysql.com/doc/refman/5.7/en/explain.html) 来让 MYSQL server 决定查询的最适索引。\n9. 尽量少加锁。如果允许 SELECT 语句返回老版本快照，就不要选择添加 FOR UPDATE/LOCK IN SHARE MODE 子句进入锁读。使用 READ COMMITTED 隔离级别对一致性读也有帮助，因为在事务中都能读取到最新的快照。\n10. 如果别无他法，可以将事务序列化到表级锁上。使用示例（注意语句顺序）：\n\n    ```sql\n    SET autocommit=0;\n    LOCK TABLES t1 WRITE, t2 READ, ...;\n    ... do something with tables t1 and t2 here ...\n    COMMIT;\n    UNLOCK TABLES;\n    ```\n\n    表级锁阻止表上的并发更新，可以避免忙系统少响应的消耗上的死锁。\n11. 另外一个序列化事务的方法是创建一个辅助标识表，这个表只有一条数据。使每一个事务在访问其他表前必须先更新这行数据。这样可以保证所有事务都排列执行。需要注意的是，InnoDB 死锁检测算法在这种场景下依然工作，因为这个序列化锁是个行级锁。在 MYSQL 表级锁情况下，死锁问题使用超时方法来解决。\n","slug":"Mysql/How to Minimize and Handle Deadlocks","published":1,"updated":"2021-02-24T15:22:22.872Z","comments":1,"photos":[],"link":"","_id":"ckljnokr500172bhbeesi1ob9","content":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html\">reference</a></p>\n<p>死锁最小化建立在<a href=\"./Deadlocks%20in%20InnoDB.md\">死锁检测</a>之上。</p>\n</blockquote>\n<p>死锁是事务型中经典问题，如果出现死锁的频率不高不是一个危险的问题。通常来讲，需要在应用中为死锁场景下事务重试做好准备。<span id=\"more\"></span></p>\n<p>InnoDB 自动使用行级锁。可能仅仅是在插入修改单行就出现死锁，这是因为这些操作并非真正的原子操作，它们会自动地在插入或修改的 index record（可能多个）上设置锁。（设置锁并非直接加锁，而是先请求锁，获得锁后再持有锁。）</p>\n<p>降低死锁概念的技术：</p>\n<ol>\n<li><p>每次都使用 <code>SHOW ENGINE INNODB STATUS</code> 命令查看最近死锁的来源，这样可以帮助微调应用避免死锁。</p>\n</li>\n<li><p>如果高频出现死锁警告，打开 <code>innodb_print_all_deadlocks</code> 配置以收集更多 debug 信息。每个死锁的信息都记录在 MYSQL 的 error log 中。当完成 debug 后关闭此配置。</p>\n</li>\n<li><p>应用中随便为死锁准备重新发布事务，死锁并不危险，只会重试。</p>\n</li>\n<li><p>尽量精简事务以降低其发生冲突的可能。</p>\n</li>\n<li><p>更新完相应的记录立即提交事务以降低其冲突的可能。实际操作中，不要让一个交互式的 mysql session 长时间不提交。</p>\n</li>\n<li><p>如果使用锁读（locking read: SELECT … FOR UPDATE/SELECT … LOCK IN SHARE MODE），尝试使用更低的事务隔离级别，如：READ COMMITTED。</p>\n</li>\n<li><p>当在同一个事务中修改多个表数据或单表多行数据时，保证每次（业务中不同的代码块）操作顺序的一致。这样事务会形成很好的队列而不出现死锁。例如：在应用中组织数据库的操作在 function 中或调用存储过程，而不是在应用不同的地方编写多个类似的增删改的 sql 语句。</p>\n</li>\n<li><p>在表中添加合适的索引。这样可以减少查询扫描的 index records 记录，因而添加更少的锁。使用 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain.html\">EXPLAIN SELECT</a> 来让 MYSQL server 决定查询的最适索引。</p>\n</li>\n<li><p>尽量少加锁。如果允许 SELECT 语句返回老版本快照，就不要选择添加 FOR UPDATE/LOCK IN SHARE MODE 子句进入锁读。使用 READ COMMITTED 隔离级别对一致性读也有帮助，因为在事务中都能读取到最新的快照。</p>\n</li>\n<li><p>如果别无他法，可以将事务序列化到表级锁上。使用示例（注意语句顺序）：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class=\"line\">... do something <span class=\"keyword\">with</span> tables t1 <span class=\"keyword\">and</span> t2 here ...</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n\n<p>表级锁阻止表上的并发更新，可以避免忙系统少响应的消耗上的死锁。</p>\n</li>\n<li><p>另外一个序列化事务的方法是创建一个辅助标识表，这个表只有一条数据。使每一个事务在访问其他表前必须先更新这行数据。这样可以保证所有事务都排列执行。需要注意的是，InnoDB 死锁检测算法在这种场景下依然工作，因为这个序列化锁是个行级锁。在 MYSQL 表级锁情况下，死锁问题使用超时方法来解决。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html\">reference</a></p>\n<p>死锁最小化建立在<a href=\"./Deadlocks%20in%20InnoDB.md\">死锁检测</a>之上。</p>\n</blockquote>\n<p>死锁是事务型中经典问题，如果出现死锁的频率不高不是一个危险的问题。通常来讲，需要在应用中为死锁场景下事务重试做好准备。","more":"</p>\n<p>InnoDB 自动使用行级锁。可能仅仅是在插入修改单行就出现死锁，这是因为这些操作并非真正的原子操作，它们会自动地在插入或修改的 index record（可能多个）上设置锁。（设置锁并非直接加锁，而是先请求锁，获得锁后再持有锁。）</p>\n<p>降低死锁概念的技术：</p>\n<ol>\n<li><p>每次都使用 <code>SHOW ENGINE INNODB STATUS</code> 命令查看最近死锁的来源，这样可以帮助微调应用避免死锁。</p>\n</li>\n<li><p>如果高频出现死锁警告，打开 <code>innodb_print_all_deadlocks</code> 配置以收集更多 debug 信息。每个死锁的信息都记录在 MYSQL 的 error log 中。当完成 debug 后关闭此配置。</p>\n</li>\n<li><p>应用中随便为死锁准备重新发布事务，死锁并不危险，只会重试。</p>\n</li>\n<li><p>尽量精简事务以降低其发生冲突的可能。</p>\n</li>\n<li><p>更新完相应的记录立即提交事务以降低其冲突的可能。实际操作中，不要让一个交互式的 mysql session 长时间不提交。</p>\n</li>\n<li><p>如果使用锁读（locking read: SELECT … FOR UPDATE/SELECT … LOCK IN SHARE MODE），尝试使用更低的事务隔离级别，如：READ COMMITTED。</p>\n</li>\n<li><p>当在同一个事务中修改多个表数据或单表多行数据时，保证每次（业务中不同的代码块）操作顺序的一致。这样事务会形成很好的队列而不出现死锁。例如：在应用中组织数据库的操作在 function 中或调用存储过程，而不是在应用不同的地方编写多个类似的增删改的 sql 语句。</p>\n</li>\n<li><p>在表中添加合适的索引。这样可以减少查询扫描的 index records 记录，因而添加更少的锁。使用 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain.html\">EXPLAIN SELECT</a> 来让 MYSQL server 决定查询的最适索引。</p>\n</li>\n<li><p>尽量少加锁。如果允许 SELECT 语句返回老版本快照，就不要选择添加 FOR UPDATE/LOCK IN SHARE MODE 子句进入锁读。使用 READ COMMITTED 隔离级别对一致性读也有帮助，因为在事务中都能读取到最新的快照。</p>\n</li>\n<li><p>如果别无他法，可以将事务序列化到表级锁上。使用示例（注意语句顺序）：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class=\"line\">... do something <span class=\"keyword\">with</span> tables t1 <span class=\"keyword\">and</span> t2 here ...</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n\n<p>表级锁阻止表上的并发更新，可以避免忙系统少响应的消耗上的死锁。</p>\n</li>\n<li><p>另外一个序列化事务的方法是创建一个辅助标识表，这个表只有一条数据。使每一个事务在访问其他表前必须先更新这行数据。这样可以保证所有事务都排列执行。需要注意的是，InnoDB 死锁检测算法在这种场景下依然工作，因为这个序列化锁是个行级锁。在 MYSQL 表级锁情况下，死锁问题使用超时方法来解决。</p>\n</li>\n</ol>"},{"title":"InnoDB Indexes On-Disk Structures","layout":"post","description":"The On-disk structures of Index in the InnoDB","date":"2021-01-07T02:04:00.000Z","_content":"\n## .1. Clustered and Secondary Indexes\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)\n>\n> InnoDB 中每张都有聚簇索引用以存储行数据。一般来讲，聚簇索引等于主键。为获取更好的查询修改性能， 需要了解使用聚簇索引优化每张表的常用查询与 DML 操作。<!--more-->\n\n- 当为表定义一个主键 PRIMARY KEY，InnoDB 会使用主键作为聚簇索引。为创建的每张表定义主键，如果没有逻辑上唯一并非空的列（或多个列），创建一个自增列，其值是自动填充的。\n- 如果没有定义主键，Mysql会设置第一个唯一索引列（其key非空），InnoDB 以此列为聚簇索引。\n- 如果表未设置主键也没有合适的唯一索引，InnoDB 将在内部生成一个名为 GEN_CLUST_INDEX 的聚簇索引，此索引在一个包含原生 ID 值的组合列上。表中各列使用这个 ID 值排序，这个原生 ID 占 6-byte，新行插入时自增，因此这些行都按物理插入顺序排列。\n\n### .1.1. How to Clustered Index Speed Up Queries\n\n因为聚簇索引查询直接访问所有源数据页，所以通过聚簇索引访问行更快速。如果表够大，相对于将原数据与索引记录分在不同页存储的存储结构，聚簇索引结构会节省磁盘 I/O 操作。\n\n### .1.2. How Secondary Indexes Relate to the Clustered Index\n\n除聚簇索引外的索引都叫二级索引。在 InnoDB 中，一个二级索引包含行的主键，类似二级索引的列。InnoDB 使用主键值去查询聚簇索引中的行。\n\n如果主键过长，二级索引将占用更多空间，所以尽量使用短的主键。\n\n## .2. The Physical Structure of an InnoDB Index\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-structure.html)\n\n> 除空间索引使用 R-tree 数据结构索引多维度数据外，InnoDB 都使用 B-tree 数据结构。两种类型索引记录都存储在树的叶子页，叶子页默认大小是 16KB 。\n\n- 当 InnoDB 插入新记录到聚簇索引中时， InnoDB 会尝试为后来的插入或更新保留 1/16 的页空间。如果 InnoDB 插入新记录是顺序的，索引记录页是到 15/16 就当作已满，如果新记录是无序插入的，索引记录面到 1/2~15/16 就满。\n- InnoDB 在创建与重建 B-tree 索引执行批量加载。这是一种创建顺序索引的方法。顺序索引创建每个 B-tree 页的空间占比的配置项是 `innodb_fill_factor` （设置为 100 时，聚簇索引页保留 1/16 的剩余空间），剩下的空间留给索引增长。顺序索引创建不支持空间索引的创建。\n- 如果 InnoDB 的空间占用率低于了 `MERGE_THRESHOLD` (可以设置，也应用于空间索引，默认 50%),InnoDB 会尝试重构 B-tree 索引以释放这个页。\n- InnoDB 的索引页大小可以通过配置项 `innodb_page_size`　设置，配置优先于 MYSQL 实例的初始化，一旦设置需要重新初始化实例才能修改。配置支持的值包括：64KB,32KB,16KB(default),8KB,4KB。\n- 一个 MYSQL 实例使用了一个特定的 page_size 后，不能使用另一个使用不同 page_size 的实例的数据文件与日志文件。（数据文件与日志文件也就是说可以共用）\n\n## .3. Sorted Index Builds\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/sorted-index-builds.html)\n\n> InnoDB 在创建或重建索引时用批量加载而不是一次只插入一条索引记录。这种方法也叫顺序索引创建，顺序索引创建不支持空间索引。\n\n- 索引的创建有三个阶段，第一阶段，扫描聚簇索引，一个索引项生成后被加入到排序的缓存中，当序列缓存变满时，索引项被排序并写入到一个临时文件中。这个过程也叫做“run”。第二阶段，一个或多个“run”写到临时文件时，临时文件中的所有索引项执行合并排序。第三阶段，排好序的索引项插入到 B-tree。\n- 在引进顺序索引（sorted index）构建之前，InnoDB 使用 insert API 一次只插入一个索引记录。这种方法是打开一个 B-tree 索引指针找到插入位置，然后用积极策略（optimistic）插入索引项到 B-tree 页。如果因为页已满而插入失败，将会执行消极插入策略（pessimistic），消极策略将打开一个 B-tree 指针，为找到索引项的插入空间分离合并 B-tree 节点。这种从上至下（top-down）的构建索引方式的缺点是查找一个插入位置的成本且需要固定的分离与合并节点。\n- 顺序索引构建使用自下到上（bottom-up）的方式构建索引。这种方式中， B-tree 的每一级都持有一个最右叶子页（right-most leaf page）的引用，最右叶子页在需要的 B-tree 深度都有，索引项插入的顺序由这些叶子页的排列顺序决定。一旦一个叶子页满了，节点指点追加在其父页上，兄弟叶子页安排于后面的插入。这个过程持续到所有项被插入，插入可能上升到根节点。当兄弟页被插入好，前叶子页的引用就释放，并且新的叶子页变成最右叶子页和新的插入位置。\n","source":"_posts/Mysql/InnoDB Indexes On-Disk Structures.md","raw":"---\ntitle: InnoDB Indexes On-Disk Structures\nlayout: post\ntag: [mysql, InnoDB, index]\ncategories: [Mysql]\ndescription: The On-disk structures of Index in the InnoDB\ndate: \"2021-1-7 10:4:00\"\n---\n\n## .1. Clustered and Secondary Indexes\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)\n>\n> InnoDB 中每张都有聚簇索引用以存储行数据。一般来讲，聚簇索引等于主键。为获取更好的查询修改性能， 需要了解使用聚簇索引优化每张表的常用查询与 DML 操作。<!--more-->\n\n- 当为表定义一个主键 PRIMARY KEY，InnoDB 会使用主键作为聚簇索引。为创建的每张表定义主键，如果没有逻辑上唯一并非空的列（或多个列），创建一个自增列，其值是自动填充的。\n- 如果没有定义主键，Mysql会设置第一个唯一索引列（其key非空），InnoDB 以此列为聚簇索引。\n- 如果表未设置主键也没有合适的唯一索引，InnoDB 将在内部生成一个名为 GEN_CLUST_INDEX 的聚簇索引，此索引在一个包含原生 ID 值的组合列上。表中各列使用这个 ID 值排序，这个原生 ID 占 6-byte，新行插入时自增，因此这些行都按物理插入顺序排列。\n\n### .1.1. How to Clustered Index Speed Up Queries\n\n因为聚簇索引查询直接访问所有源数据页，所以通过聚簇索引访问行更快速。如果表够大，相对于将原数据与索引记录分在不同页存储的存储结构，聚簇索引结构会节省磁盘 I/O 操作。\n\n### .1.2. How Secondary Indexes Relate to the Clustered Index\n\n除聚簇索引外的索引都叫二级索引。在 InnoDB 中，一个二级索引包含行的主键，类似二级索引的列。InnoDB 使用主键值去查询聚簇索引中的行。\n\n如果主键过长，二级索引将占用更多空间，所以尽量使用短的主键。\n\n## .2. The Physical Structure of an InnoDB Index\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-structure.html)\n\n> 除空间索引使用 R-tree 数据结构索引多维度数据外，InnoDB 都使用 B-tree 数据结构。两种类型索引记录都存储在树的叶子页，叶子页默认大小是 16KB 。\n\n- 当 InnoDB 插入新记录到聚簇索引中时， InnoDB 会尝试为后来的插入或更新保留 1/16 的页空间。如果 InnoDB 插入新记录是顺序的，索引记录页是到 15/16 就当作已满，如果新记录是无序插入的，索引记录面到 1/2~15/16 就满。\n- InnoDB 在创建与重建 B-tree 索引执行批量加载。这是一种创建顺序索引的方法。顺序索引创建每个 B-tree 页的空间占比的配置项是 `innodb_fill_factor` （设置为 100 时，聚簇索引页保留 1/16 的剩余空间），剩下的空间留给索引增长。顺序索引创建不支持空间索引的创建。\n- 如果 InnoDB 的空间占用率低于了 `MERGE_THRESHOLD` (可以设置，也应用于空间索引，默认 50%),InnoDB 会尝试重构 B-tree 索引以释放这个页。\n- InnoDB 的索引页大小可以通过配置项 `innodb_page_size`　设置，配置优先于 MYSQL 实例的初始化，一旦设置需要重新初始化实例才能修改。配置支持的值包括：64KB,32KB,16KB(default),8KB,4KB。\n- 一个 MYSQL 实例使用了一个特定的 page_size 后，不能使用另一个使用不同 page_size 的实例的数据文件与日志文件。（数据文件与日志文件也就是说可以共用）\n\n## .3. Sorted Index Builds\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/sorted-index-builds.html)\n\n> InnoDB 在创建或重建索引时用批量加载而不是一次只插入一条索引记录。这种方法也叫顺序索引创建，顺序索引创建不支持空间索引。\n\n- 索引的创建有三个阶段，第一阶段，扫描聚簇索引，一个索引项生成后被加入到排序的缓存中，当序列缓存变满时，索引项被排序并写入到一个临时文件中。这个过程也叫做“run”。第二阶段，一个或多个“run”写到临时文件时，临时文件中的所有索引项执行合并排序。第三阶段，排好序的索引项插入到 B-tree。\n- 在引进顺序索引（sorted index）构建之前，InnoDB 使用 insert API 一次只插入一个索引记录。这种方法是打开一个 B-tree 索引指针找到插入位置，然后用积极策略（optimistic）插入索引项到 B-tree 页。如果因为页已满而插入失败，将会执行消极插入策略（pessimistic），消极策略将打开一个 B-tree 指针，为找到索引项的插入空间分离合并 B-tree 节点。这种从上至下（top-down）的构建索引方式的缺点是查找一个插入位置的成本且需要固定的分离与合并节点。\n- 顺序索引构建使用自下到上（bottom-up）的方式构建索引。这种方式中， B-tree 的每一级都持有一个最右叶子页（right-most leaf page）的引用，最右叶子页在需要的 B-tree 深度都有，索引项插入的顺序由这些叶子页的排列顺序决定。一旦一个叶子页满了，节点指点追加在其父页上，兄弟叶子页安排于后面的插入。这个过程持续到所有项被插入，插入可能上升到根节点。当兄弟页被插入好，前叶子页的引用就释放，并且新的叶子页变成最右叶子页和新的插入位置。\n","slug":"Mysql/InnoDB Indexes On-Disk Structures","published":1,"updated":"2021-02-24T15:22:22.884Z","comments":1,"photos":[],"link":"","_id":"ckljnokr6001b2bhbaqbt41uf","content":"<h2 id=\"1-Clustered-and-Secondary-Indexes\"><a href=\"#1-Clustered-and-Secondary-Indexes\" class=\"headerlink\" title=\".1. Clustered and Secondary Indexes\"></a>.1. Clustered and Secondary Indexes</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html\">reference</a></p>\n<p>InnoDB 中每张都有聚簇索引用以存储行数据。一般来讲，聚簇索引等于主键。为获取更好的查询修改性能， 需要了解使用聚簇索引优化每张表的常用查询与 DML 操作。<span id=\"more\"></span></p>\n</blockquote>\n<ul>\n<li>当为表定义一个主键 PRIMARY KEY，InnoDB 会使用主键作为聚簇索引。为创建的每张表定义主键，如果没有逻辑上唯一并非空的列（或多个列），创建一个自增列，其值是自动填充的。</li>\n<li>如果没有定义主键，Mysql会设置第一个唯一索引列（其key非空），InnoDB 以此列为聚簇索引。</li>\n<li>如果表未设置主键也没有合适的唯一索引，InnoDB 将在内部生成一个名为 GEN_CLUST_INDEX 的聚簇索引，此索引在一个包含原生 ID 值的组合列上。表中各列使用这个 ID 值排序，这个原生 ID 占 6-byte，新行插入时自增，因此这些行都按物理插入顺序排列。</li>\n</ul>\n<h3 id=\"1-1-How-to-Clustered-Index-Speed-Up-Queries\"><a href=\"#1-1-How-to-Clustered-Index-Speed-Up-Queries\" class=\"headerlink\" title=\".1.1. How to Clustered Index Speed Up Queries\"></a>.1.1. How to Clustered Index Speed Up Queries</h3><p>因为聚簇索引查询直接访问所有源数据页，所以通过聚簇索引访问行更快速。如果表够大，相对于将原数据与索引记录分在不同页存储的存储结构，聚簇索引结构会节省磁盘 I/O 操作。</p>\n<h3 id=\"1-2-How-Secondary-Indexes-Relate-to-the-Clustered-Index\"><a href=\"#1-2-How-Secondary-Indexes-Relate-to-the-Clustered-Index\" class=\"headerlink\" title=\".1.2. How Secondary Indexes Relate to the Clustered Index\"></a>.1.2. How Secondary Indexes Relate to the Clustered Index</h3><p>除聚簇索引外的索引都叫二级索引。在 InnoDB 中，一个二级索引包含行的主键，类似二级索引的列。InnoDB 使用主键值去查询聚簇索引中的行。</p>\n<p>如果主键过长，二级索引将占用更多空间，所以尽量使用短的主键。</p>\n<h2 id=\"2-The-Physical-Structure-of-an-InnoDB-Index\"><a href=\"#2-The-Physical-Structure-of-an-InnoDB-Index\" class=\"headerlink\" title=\".2. The Physical Structure of an InnoDB Index\"></a>.2. The Physical Structure of an InnoDB Index</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-structure.html\">reference</a></p>\n</blockquote>\n<blockquote>\n<p>除空间索引使用 R-tree 数据结构索引多维度数据外，InnoDB 都使用 B-tree 数据结构。两种类型索引记录都存储在树的叶子页，叶子页默认大小是 16KB 。</p>\n</blockquote>\n<ul>\n<li>当 InnoDB 插入新记录到聚簇索引中时， InnoDB 会尝试为后来的插入或更新保留 1/16 的页空间。如果 InnoDB 插入新记录是顺序的，索引记录页是到 15/16 就当作已满，如果新记录是无序插入的，索引记录面到 1/2~15/16 就满。</li>\n<li>InnoDB 在创建与重建 B-tree 索引执行批量加载。这是一种创建顺序索引的方法。顺序索引创建每个 B-tree 页的空间占比的配置项是 <code>innodb_fill_factor</code> （设置为 100 时，聚簇索引页保留 1/16 的剩余空间），剩下的空间留给索引增长。顺序索引创建不支持空间索引的创建。</li>\n<li>如果 InnoDB 的空间占用率低于了 <code>MERGE_THRESHOLD</code> (可以设置，也应用于空间索引，默认 50%),InnoDB 会尝试重构 B-tree 索引以释放这个页。</li>\n<li>InnoDB 的索引页大小可以通过配置项 <code>innodb_page_size</code>　设置，配置优先于 MYSQL 实例的初始化，一旦设置需要重新初始化实例才能修改。配置支持的值包括：64KB,32KB,16KB(default),8KB,4KB。</li>\n<li>一个 MYSQL 实例使用了一个特定的 page_size 后，不能使用另一个使用不同 page_size 的实例的数据文件与日志文件。（数据文件与日志文件也就是说可以共用）</li>\n</ul>\n<h2 id=\"3-Sorted-Index-Builds\"><a href=\"#3-Sorted-Index-Builds\" class=\"headerlink\" title=\".3. Sorted Index Builds\"></a>.3. Sorted Index Builds</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/sorted-index-builds.html\">reference</a></p>\n</blockquote>\n<blockquote>\n<p>InnoDB 在创建或重建索引时用批量加载而不是一次只插入一条索引记录。这种方法也叫顺序索引创建，顺序索引创建不支持空间索引。</p>\n</blockquote>\n<ul>\n<li>索引的创建有三个阶段，第一阶段，扫描聚簇索引，一个索引项生成后被加入到排序的缓存中，当序列缓存变满时，索引项被排序并写入到一个临时文件中。这个过程也叫做“run”。第二阶段，一个或多个“run”写到临时文件时，临时文件中的所有索引项执行合并排序。第三阶段，排好序的索引项插入到 B-tree。</li>\n<li>在引进顺序索引（sorted index）构建之前，InnoDB 使用 insert API 一次只插入一个索引记录。这种方法是打开一个 B-tree 索引指针找到插入位置，然后用积极策略（optimistic）插入索引项到 B-tree 页。如果因为页已满而插入失败，将会执行消极插入策略（pessimistic），消极策略将打开一个 B-tree 指针，为找到索引项的插入空间分离合并 B-tree 节点。这种从上至下（top-down）的构建索引方式的缺点是查找一个插入位置的成本且需要固定的分离与合并节点。</li>\n<li>顺序索引构建使用自下到上（bottom-up）的方式构建索引。这种方式中， B-tree 的每一级都持有一个最右叶子页（right-most leaf page）的引用，最右叶子页在需要的 B-tree 深度都有，索引项插入的顺序由这些叶子页的排列顺序决定。一旦一个叶子页满了，节点指点追加在其父页上，兄弟叶子页安排于后面的插入。这个过程持续到所有项被插入，插入可能上升到根节点。当兄弟页被插入好，前叶子页的引用就释放，并且新的叶子页变成最右叶子页和新的插入位置。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Clustered-and-Secondary-Indexes\"><a href=\"#1-Clustered-and-Secondary-Indexes\" class=\"headerlink\" title=\".1. Clustered and Secondary Indexes\"></a>.1. Clustered and Secondary Indexes</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html\">reference</a></p>\n<p>InnoDB 中每张都有聚簇索引用以存储行数据。一般来讲，聚簇索引等于主键。为获取更好的查询修改性能， 需要了解使用聚簇索引优化每张表的常用查询与 DML 操作。","more":"</p>\n</blockquote>\n<ul>\n<li>当为表定义一个主键 PRIMARY KEY，InnoDB 会使用主键作为聚簇索引。为创建的每张表定义主键，如果没有逻辑上唯一并非空的列（或多个列），创建一个自增列，其值是自动填充的。</li>\n<li>如果没有定义主键，Mysql会设置第一个唯一索引列（其key非空），InnoDB 以此列为聚簇索引。</li>\n<li>如果表未设置主键也没有合适的唯一索引，InnoDB 将在内部生成一个名为 GEN_CLUST_INDEX 的聚簇索引，此索引在一个包含原生 ID 值的组合列上。表中各列使用这个 ID 值排序，这个原生 ID 占 6-byte，新行插入时自增，因此这些行都按物理插入顺序排列。</li>\n</ul>\n<h3 id=\"1-1-How-to-Clustered-Index-Speed-Up-Queries\"><a href=\"#1-1-How-to-Clustered-Index-Speed-Up-Queries\" class=\"headerlink\" title=\".1.1. How to Clustered Index Speed Up Queries\"></a>.1.1. How to Clustered Index Speed Up Queries</h3><p>因为聚簇索引查询直接访问所有源数据页，所以通过聚簇索引访问行更快速。如果表够大，相对于将原数据与索引记录分在不同页存储的存储结构，聚簇索引结构会节省磁盘 I/O 操作。</p>\n<h3 id=\"1-2-How-Secondary-Indexes-Relate-to-the-Clustered-Index\"><a href=\"#1-2-How-Secondary-Indexes-Relate-to-the-Clustered-Index\" class=\"headerlink\" title=\".1.2. How Secondary Indexes Relate to the Clustered Index\"></a>.1.2. How Secondary Indexes Relate to the Clustered Index</h3><p>除聚簇索引外的索引都叫二级索引。在 InnoDB 中，一个二级索引包含行的主键，类似二级索引的列。InnoDB 使用主键值去查询聚簇索引中的行。</p>\n<p>如果主键过长，二级索引将占用更多空间，所以尽量使用短的主键。</p>\n<h2 id=\"2-The-Physical-Structure-of-an-InnoDB-Index\"><a href=\"#2-The-Physical-Structure-of-an-InnoDB-Index\" class=\"headerlink\" title=\".2. The Physical Structure of an InnoDB Index\"></a>.2. The Physical Structure of an InnoDB Index</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-structure.html\">reference</a></p>\n</blockquote>\n<blockquote>\n<p>除空间索引使用 R-tree 数据结构索引多维度数据外，InnoDB 都使用 B-tree 数据结构。两种类型索引记录都存储在树的叶子页，叶子页默认大小是 16KB 。</p>\n</blockquote>\n<ul>\n<li>当 InnoDB 插入新记录到聚簇索引中时， InnoDB 会尝试为后来的插入或更新保留 1/16 的页空间。如果 InnoDB 插入新记录是顺序的，索引记录页是到 15/16 就当作已满，如果新记录是无序插入的，索引记录面到 1/2~15/16 就满。</li>\n<li>InnoDB 在创建与重建 B-tree 索引执行批量加载。这是一种创建顺序索引的方法。顺序索引创建每个 B-tree 页的空间占比的配置项是 <code>innodb_fill_factor</code> （设置为 100 时，聚簇索引页保留 1/16 的剩余空间），剩下的空间留给索引增长。顺序索引创建不支持空间索引的创建。</li>\n<li>如果 InnoDB 的空间占用率低于了 <code>MERGE_THRESHOLD</code> (可以设置，也应用于空间索引，默认 50%),InnoDB 会尝试重构 B-tree 索引以释放这个页。</li>\n<li>InnoDB 的索引页大小可以通过配置项 <code>innodb_page_size</code>　设置，配置优先于 MYSQL 实例的初始化，一旦设置需要重新初始化实例才能修改。配置支持的值包括：64KB,32KB,16KB(default),8KB,4KB。</li>\n<li>一个 MYSQL 实例使用了一个特定的 page_size 后，不能使用另一个使用不同 page_size 的实例的数据文件与日志文件。（数据文件与日志文件也就是说可以共用）</li>\n</ul>\n<h2 id=\"3-Sorted-Index-Builds\"><a href=\"#3-Sorted-Index-Builds\" class=\"headerlink\" title=\".3. Sorted Index Builds\"></a>.3. Sorted Index Builds</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/sorted-index-builds.html\">reference</a></p>\n</blockquote>\n<blockquote>\n<p>InnoDB 在创建或重建索引时用批量加载而不是一次只插入一条索引记录。这种方法也叫顺序索引创建，顺序索引创建不支持空间索引。</p>\n</blockquote>\n<ul>\n<li>索引的创建有三个阶段，第一阶段，扫描聚簇索引，一个索引项生成后被加入到排序的缓存中，当序列缓存变满时，索引项被排序并写入到一个临时文件中。这个过程也叫做“run”。第二阶段，一个或多个“run”写到临时文件时，临时文件中的所有索引项执行合并排序。第三阶段，排好序的索引项插入到 B-tree。</li>\n<li>在引进顺序索引（sorted index）构建之前，InnoDB 使用 insert API 一次只插入一个索引记录。这种方法是打开一个 B-tree 索引指针找到插入位置，然后用积极策略（optimistic）插入索引项到 B-tree 页。如果因为页已满而插入失败，将会执行消极插入策略（pessimistic），消极策略将打开一个 B-tree 指针，为找到索引项的插入空间分离合并 B-tree 节点。这种从上至下（top-down）的构建索引方式的缺点是查找一个插入位置的成本且需要固定的分离与合并节点。</li>\n<li>顺序索引构建使用自下到上（bottom-up）的方式构建索引。这种方式中， B-tree 的每一级都持有一个最右叶子页（right-most leaf page）的引用，最右叶子页在需要的 B-tree 深度都有，索引项插入的顺序由这些叶子页的排列顺序决定。一旦一个叶子页满了，节点指点追加在其父页上，兄弟叶子页安排于后面的插入。这个过程持续到所有项被插入，插入可能上升到根节点。当兄弟页被插入好，前叶子页的引用就释放，并且新的叶子页变成最右叶子页和新的插入位置。</li>\n</ul>"},{"title":"InnoDB Transaction Isolation Level","layout":"post","description":"The InnoDB Glory","date":"2021-01-06T02:59:00.000Z","_content":"\n> [InnoDB 事务模型](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html)\n>\n> InnoDB 事务模型的目标是联合数据库多视图属性与传统的多阶段锁。InnoDB 类似 Oracle ，其执行锁到行级别，同时默认执行查询不加锁并保持一致性读。InnoDB 锁数据存储空间效率高，不随锁数量增加而剧增。锁表全行也不用担心 InnoDB 内存耗尽。<!--more-->\n>\n> [InnoDB 隔离级别](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html)\n>\n> Transactions Isolation Levels, 事务隔离级别是多个事务在同一时间执行查询、修改时，微调性能、可用性、一致性、数据复用性的平衡手段。\n\n事务三种隐患\n\n1. 脏读，事务A读到其他事务B未提交的内容，B中数据回滚或其他更新后，A就会读到脏数据。\n2. 不可重复读，事务A分别在事务B（更改了数据）提交前后的数据，发现数据前后不一致。\n3. 幻读，事务A读事务B（新插入了数据）提交后，发现前面读到的数据比之后读到的数据少了一部分。\n\n可以设置全局，也可以设置到 session ，设置后开启新的 session 即可生效。\n\n## .1. REPEATABLE READ\n\n可重复读，事务在执行语句之初就去读取需要查询的数据并放在视图中，在事务提交之前保存之前都不更新此视图（**新插入的数据还是会再读取到视图中**）。所以这样可以防止不可重复读，不能防止幻读。\n\n1. 对于一致性非锁读（普通查询），同一事务内会保持一致性，第一次读数据会产生快照。（如果查询条件不一样呢？会再查询出新的快照出来还是会对后面新查询进行优化先在已有快照里匹配呢？）\n2. 对于锁读（select ... for update/lock in share mode）/update/delete 语句，加锁的情况取决于查询条件：\n   1. 唯一索引作为唯一查询条件进行查询：InnoDB 只会锁住查询到的唯一记录，不会添加 gap-lock\n   2. 对于其他查询: InnoDB 会锁住扫描到的范围内所有索引记录，同时会在其前加上 next-key-lock 或 gap－lock 以阻止其他事务在其间隙插入新的记录（幻读）。\n\n## .2. READ COMMITTED\n\n读已提交，事务提交后才去读。事务在执行每一条查询前都会查询结果放到事务的视图中，可以防止脏读，不能防止不可重复读与幻读\n\n1. 一致性非锁读(consistent non-locking reads,　普通查询)　事务内所有的 sets and reads 都在其快照中。\n2. 锁读（locking reads, select ... for update/lock in share mode）/update/delete, InnoDB 只会锁索引记录，而不会在数据行前添加 gap-lock ，因而允许了添加新数据行在锁行前（幻读）。这种隔离级别下 gap-lock 只会对外键约束检查与重复　key　检查生效。\n   1. 此隔离级别下 gap－lock 关闭，只有基于行的二进制日志被支持。在 READ COMMITTED 隔离下，且 binlog_format=MIXED ，服务器自动使用基于行的日志 。\n3. 使用 READ COMMITTED 隔离级别两个额外效果：\n   1. 对于 UPDATE／DELETE 语句，InnoDB 只对更新、删除的行加锁。对于未匹配的行的 record－lock 在 MYSQL 计算出 where 条件后即释放。这可以降低死锁发生的概率。\n   2. 对于 UPDATE 语句，如果某行数据已经被锁，InnoDB **执行半一致性读**返回最新提交的到 MYSQL，这样 MYSQL 才能用以决定该行是否满足 WHERE 条件。如果某行匹配，MYSQL 会再次读取此行，且这次 InnoDB 要么锁住要么等待此行的锁。\n4. 数据库属性 `innodb_locks_unsafe_for_binlog`　（以下简称　locks_unsafe） 与 READ COMMITTED 效果一致，其区别在于：\n   1. lock_unsafe 是全局配置，而　READ COMMITTED 可以设置到 session　级别;\n   2. lock_unsafe 只能数据库启动时设置，而 READ COMMITTED 可以在数据库服务器运行中设置。\n\n### .2.1. 案例\n\n```sql\nCREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;\nINSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);\nCOMMIT;\n```\n\n创建表 t ，但**没有索引**，所以**查询与索引扫描使用记录锁隐藏的聚簇索引而非索引列**。\n\n```sql\n# Session A\nSTART TRANSACTION;\nUPDATE t SET b = 5 WHERE b = 3;\n```\n\nsession A 执行更新语句。\n\n```sql\n# Session B\nUPDATE t SET b = 4 WHERE b = 2;\n```\n\nsession B 在 session A 后执行更新语句。\n\n- InnoDB 执行每一个 UPDATE 会先获取每一行的排他锁，然后决定是否更改，如果 InnoDB 发现了不需要更改的行会立即释放其锁，而其他需要更改的行的锁需要等待到事务结束释放。而其作用的事务进程如下：\n    - 当使用 REPEATABLE READ 隔离级别时\n        - 第一个 UPDATE 会获取所有行的 x-lock 且不释放。\n\n            ```sql\n            x-lock(1,2); retain x-lock\n            x-lock(2,3); update(2,3) to (2,5); retain x-lock\n            x-lock(3,2); retain x-lock\n            x-lock(4,3); update(4,3) to (4,5); retain x-lock\n            x-lock(5,2); retain x-lock\n            ```\n\n        - 第二个 UPDATE 执行时一尝试获取锁立即被阻塞，因为第一个 UPDATE 正持有所有的锁，直到第一个 UPDATE 提交或回滚：\n\n            ```sql\n            x-lock(1,2); block and wait for first UPDATE to commit or roll back\n            ```\n\n    - 当在 READ COMMITTED 隔离级别下\n        - 第一个 UPDATE 在获取了所有行锁后会释放其不需要修改的行锁：\n\n            ```sql\n            x-lock(1,2); unlock(1,2)\n            x-lock(2,3); update(2,3) to (2,5); retain x-lock\n            x-lock(3,2); unlock(3,2)\n            x-lock(4,3); update(4,3) to (4,5); retain x-lock\n            x-lock(5,2); unlock(5,2)\n            ```\n\n        - 第二个 UPDATE 执行半一致性读，返回每行被提交的最新版本到 MYSQL ，以让 MYSQL 能决定这些行是否匹配 UPDATE 条件：\n\n            ```sql\n            x-lock(1,2); update(1,2) to (1,4); retain x-lock\n            x-lock(2,3); unlock(2,3)\n            x-lock(3,2); update(3,2) to (3,4); retain x-lock\n            x-lock(4,3); unlock(4,3)\n            x-lock(5,2); update(5,2) to (5,4); retain x-lock\n            ```\n\n- 如果 **WHERE 条件中包含了索引列**，InnoDB 会使用索引，只有索引列被纳入获取释放记录锁的考虑范围。eg:\n\n    ```sql\n    CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;\n    INSERT INTO t VALUES (1,2,3),(2,2,4);\n    COMMIT;\n\n    # Session A\n    START TRANSACTION;\n    UPDATE t SET b = 3 WHERE b = 2 AND c = 3;\n\n    # Session B\n    UPDATE t SET b = 4 WHERE b = 2 AND c = 4;\n    ```\n\n    - 第一个 UPDATE 将获取并持有 b=2 的行，而第二个 UPDATE 在获取相同记录的 x-lock 时被阻塞。\n\n## .3. READ UNCOMMITTED\n\n- SELECT 语句执行不加锁，但早期版本可能会在行上加锁。使用用此隔离级别不能保证读一致性，俗称“脏读”。而在其他方面此隔离级别与 READ COMMITTED 一致。*读未提交，事务未提交就可以读到数据更新，不能阻止以上三种任何隐患，直接读取事务中修改后的值，没有视图概念。*\n\n## .4. SERIALIZABLE\n\n> 串行化，事务之间排队执行，防止一切隐患。\n\n串行化类似 REPEATABLE READ ，但如果 autocommit=OFF ,InnoDB 会隐式地将普通 SELECT 语句转换成 SELECT ... FOR SHARE 。如果 autocommit=ON ,SELECT 在自己的事务中，这是只读且如果执行一致性读（不加锁）能被串行化的，并且也不需要为其他事务加锁。如果需要强迫一个普通 SELECT 为其他事务修改的行阻塞，关闭 autocommit 。\n","source":"_posts/Mysql/InnoDB Transaction Isolation Level.md","raw":"---\ntitle: InnoDB Transaction Isolation Level\nlayout: post\ntag: [mysql, InnoDB]\ncategories: [Mysql]\ndescription: The InnoDB Glory\ndate: \"2021-1-6 10:59:00\"\n---\n\n> [InnoDB 事务模型](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html)\n>\n> InnoDB 事务模型的目标是联合数据库多视图属性与传统的多阶段锁。InnoDB 类似 Oracle ，其执行锁到行级别，同时默认执行查询不加锁并保持一致性读。InnoDB 锁数据存储空间效率高，不随锁数量增加而剧增。锁表全行也不用担心 InnoDB 内存耗尽。<!--more-->\n>\n> [InnoDB 隔离级别](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html)\n>\n> Transactions Isolation Levels, 事务隔离级别是多个事务在同一时间执行查询、修改时，微调性能、可用性、一致性、数据复用性的平衡手段。\n\n事务三种隐患\n\n1. 脏读，事务A读到其他事务B未提交的内容，B中数据回滚或其他更新后，A就会读到脏数据。\n2. 不可重复读，事务A分别在事务B（更改了数据）提交前后的数据，发现数据前后不一致。\n3. 幻读，事务A读事务B（新插入了数据）提交后，发现前面读到的数据比之后读到的数据少了一部分。\n\n可以设置全局，也可以设置到 session ，设置后开启新的 session 即可生效。\n\n## .1. REPEATABLE READ\n\n可重复读，事务在执行语句之初就去读取需要查询的数据并放在视图中，在事务提交之前保存之前都不更新此视图（**新插入的数据还是会再读取到视图中**）。所以这样可以防止不可重复读，不能防止幻读。\n\n1. 对于一致性非锁读（普通查询），同一事务内会保持一致性，第一次读数据会产生快照。（如果查询条件不一样呢？会再查询出新的快照出来还是会对后面新查询进行优化先在已有快照里匹配呢？）\n2. 对于锁读（select ... for update/lock in share mode）/update/delete 语句，加锁的情况取决于查询条件：\n   1. 唯一索引作为唯一查询条件进行查询：InnoDB 只会锁住查询到的唯一记录，不会添加 gap-lock\n   2. 对于其他查询: InnoDB 会锁住扫描到的范围内所有索引记录，同时会在其前加上 next-key-lock 或 gap－lock 以阻止其他事务在其间隙插入新的记录（幻读）。\n\n## .2. READ COMMITTED\n\n读已提交，事务提交后才去读。事务在执行每一条查询前都会查询结果放到事务的视图中，可以防止脏读，不能防止不可重复读与幻读\n\n1. 一致性非锁读(consistent non-locking reads,　普通查询)　事务内所有的 sets and reads 都在其快照中。\n2. 锁读（locking reads, select ... for update/lock in share mode）/update/delete, InnoDB 只会锁索引记录，而不会在数据行前添加 gap-lock ，因而允许了添加新数据行在锁行前（幻读）。这种隔离级别下 gap-lock 只会对外键约束检查与重复　key　检查生效。\n   1. 此隔离级别下 gap－lock 关闭，只有基于行的二进制日志被支持。在 READ COMMITTED 隔离下，且 binlog_format=MIXED ，服务器自动使用基于行的日志 。\n3. 使用 READ COMMITTED 隔离级别两个额外效果：\n   1. 对于 UPDATE／DELETE 语句，InnoDB 只对更新、删除的行加锁。对于未匹配的行的 record－lock 在 MYSQL 计算出 where 条件后即释放。这可以降低死锁发生的概率。\n   2. 对于 UPDATE 语句，如果某行数据已经被锁，InnoDB **执行半一致性读**返回最新提交的到 MYSQL，这样 MYSQL 才能用以决定该行是否满足 WHERE 条件。如果某行匹配，MYSQL 会再次读取此行，且这次 InnoDB 要么锁住要么等待此行的锁。\n4. 数据库属性 `innodb_locks_unsafe_for_binlog`　（以下简称　locks_unsafe） 与 READ COMMITTED 效果一致，其区别在于：\n   1. lock_unsafe 是全局配置，而　READ COMMITTED 可以设置到 session　级别;\n   2. lock_unsafe 只能数据库启动时设置，而 READ COMMITTED 可以在数据库服务器运行中设置。\n\n### .2.1. 案例\n\n```sql\nCREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;\nINSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);\nCOMMIT;\n```\n\n创建表 t ，但**没有索引**，所以**查询与索引扫描使用记录锁隐藏的聚簇索引而非索引列**。\n\n```sql\n# Session A\nSTART TRANSACTION;\nUPDATE t SET b = 5 WHERE b = 3;\n```\n\nsession A 执行更新语句。\n\n```sql\n# Session B\nUPDATE t SET b = 4 WHERE b = 2;\n```\n\nsession B 在 session A 后执行更新语句。\n\n- InnoDB 执行每一个 UPDATE 会先获取每一行的排他锁，然后决定是否更改，如果 InnoDB 发现了不需要更改的行会立即释放其锁，而其他需要更改的行的锁需要等待到事务结束释放。而其作用的事务进程如下：\n    - 当使用 REPEATABLE READ 隔离级别时\n        - 第一个 UPDATE 会获取所有行的 x-lock 且不释放。\n\n            ```sql\n            x-lock(1,2); retain x-lock\n            x-lock(2,3); update(2,3) to (2,5); retain x-lock\n            x-lock(3,2); retain x-lock\n            x-lock(4,3); update(4,3) to (4,5); retain x-lock\n            x-lock(5,2); retain x-lock\n            ```\n\n        - 第二个 UPDATE 执行时一尝试获取锁立即被阻塞，因为第一个 UPDATE 正持有所有的锁，直到第一个 UPDATE 提交或回滚：\n\n            ```sql\n            x-lock(1,2); block and wait for first UPDATE to commit or roll back\n            ```\n\n    - 当在 READ COMMITTED 隔离级别下\n        - 第一个 UPDATE 在获取了所有行锁后会释放其不需要修改的行锁：\n\n            ```sql\n            x-lock(1,2); unlock(1,2)\n            x-lock(2,3); update(2,3) to (2,5); retain x-lock\n            x-lock(3,2); unlock(3,2)\n            x-lock(4,3); update(4,3) to (4,5); retain x-lock\n            x-lock(5,2); unlock(5,2)\n            ```\n\n        - 第二个 UPDATE 执行半一致性读，返回每行被提交的最新版本到 MYSQL ，以让 MYSQL 能决定这些行是否匹配 UPDATE 条件：\n\n            ```sql\n            x-lock(1,2); update(1,2) to (1,4); retain x-lock\n            x-lock(2,3); unlock(2,3)\n            x-lock(3,2); update(3,2) to (3,4); retain x-lock\n            x-lock(4,3); unlock(4,3)\n            x-lock(5,2); update(5,2) to (5,4); retain x-lock\n            ```\n\n- 如果 **WHERE 条件中包含了索引列**，InnoDB 会使用索引，只有索引列被纳入获取释放记录锁的考虑范围。eg:\n\n    ```sql\n    CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;\n    INSERT INTO t VALUES (1,2,3),(2,2,4);\n    COMMIT;\n\n    # Session A\n    START TRANSACTION;\n    UPDATE t SET b = 3 WHERE b = 2 AND c = 3;\n\n    # Session B\n    UPDATE t SET b = 4 WHERE b = 2 AND c = 4;\n    ```\n\n    - 第一个 UPDATE 将获取并持有 b=2 的行，而第二个 UPDATE 在获取相同记录的 x-lock 时被阻塞。\n\n## .3. READ UNCOMMITTED\n\n- SELECT 语句执行不加锁，但早期版本可能会在行上加锁。使用用此隔离级别不能保证读一致性，俗称“脏读”。而在其他方面此隔离级别与 READ COMMITTED 一致。*读未提交，事务未提交就可以读到数据更新，不能阻止以上三种任何隐患，直接读取事务中修改后的值，没有视图概念。*\n\n## .4. SERIALIZABLE\n\n> 串行化，事务之间排队执行，防止一切隐患。\n\n串行化类似 REPEATABLE READ ，但如果 autocommit=OFF ,InnoDB 会隐式地将普通 SELECT 语句转换成 SELECT ... FOR SHARE 。如果 autocommit=ON ,SELECT 在自己的事务中，这是只读且如果执行一致性读（不加锁）能被串行化的，并且也不需要为其他事务加锁。如果需要强迫一个普通 SELECT 为其他事务修改的行阻塞，关闭 autocommit 。\n","slug":"Mysql/InnoDB Transaction Isolation Level","published":1,"updated":"2021-02-24T15:22:22.884Z","comments":1,"photos":[],"link":"","_id":"ckljnokr8001f2bhbghbxgeg5","content":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html\">InnoDB 事务模型</a></p>\n<p>InnoDB 事务模型的目标是联合数据库多视图属性与传统的多阶段锁。InnoDB 类似 Oracle ，其执行锁到行级别，同时默认执行查询不加锁并保持一致性读。InnoDB 锁数据存储空间效率高，不随锁数量增加而剧增。锁表全行也不用担心 InnoDB 内存耗尽。<span id=\"more\"></span></p>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html\">InnoDB 隔离级别</a></p>\n<p>Transactions Isolation Levels, 事务隔离级别是多个事务在同一时间执行查询、修改时，微调性能、可用性、一致性、数据复用性的平衡手段。</p>\n</blockquote>\n<p>事务三种隐患</p>\n<ol>\n<li>脏读，事务A读到其他事务B未提交的内容，B中数据回滚或其他更新后，A就会读到脏数据。</li>\n<li>不可重复读，事务A分别在事务B（更改了数据）提交前后的数据，发现数据前后不一致。</li>\n<li>幻读，事务A读事务B（新插入了数据）提交后，发现前面读到的数据比之后读到的数据少了一部分。</li>\n</ol>\n<p>可以设置全局，也可以设置到 session ，设置后开启新的 session 即可生效。</p>\n<h2 id=\"1-REPEATABLE-READ\"><a href=\"#1-REPEATABLE-READ\" class=\"headerlink\" title=\".1. REPEATABLE READ\"></a>.1. REPEATABLE READ</h2><p>可重复读，事务在执行语句之初就去读取需要查询的数据并放在视图中，在事务提交之前保存之前都不更新此视图（<strong>新插入的数据还是会再读取到视图中</strong>）。所以这样可以防止不可重复读，不能防止幻读。</p>\n<ol>\n<li>对于一致性非锁读（普通查询），同一事务内会保持一致性，第一次读数据会产生快照。（如果查询条件不一样呢？会再查询出新的快照出来还是会对后面新查询进行优化先在已有快照里匹配呢？）</li>\n<li>对于锁读（select … for update/lock in share mode）/update/delete 语句，加锁的情况取决于查询条件：<ol>\n<li>唯一索引作为唯一查询条件进行查询：InnoDB 只会锁住查询到的唯一记录，不会添加 gap-lock</li>\n<li>对于其他查询: InnoDB 会锁住扫描到的范围内所有索引记录，同时会在其前加上 next-key-lock 或 gap－lock 以阻止其他事务在其间隙插入新的记录（幻读）。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-READ-COMMITTED\"><a href=\"#2-READ-COMMITTED\" class=\"headerlink\" title=\".2. READ COMMITTED\"></a>.2. READ COMMITTED</h2><p>读已提交，事务提交后才去读。事务在执行每一条查询前都会查询结果放到事务的视图中，可以防止脏读，不能防止不可重复读与幻读</p>\n<ol>\n<li>一致性非锁读(consistent non-locking reads,　普通查询)　事务内所有的 sets and reads 都在其快照中。</li>\n<li>锁读（locking reads, select … for update/lock in share mode）/update/delete, InnoDB 只会锁索引记录，而不会在数据行前添加 gap-lock ，因而允许了添加新数据行在锁行前（幻读）。这种隔离级别下 gap-lock 只会对外键约束检查与重复　key　检查生效。<ol>\n<li>此隔离级别下 gap－lock 关闭，只有基于行的二进制日志被支持。在 READ COMMITTED 隔离下，且 binlog_format=MIXED ，服务器自动使用基于行的日志 。</li>\n</ol>\n</li>\n<li>使用 READ COMMITTED 隔离级别两个额外效果：<ol>\n<li>对于 UPDATE／DELETE 语句，InnoDB 只对更新、删除的行加锁。对于未匹配的行的 record－lock 在 MYSQL 计算出 where 条件后即释放。这可以降低死锁发生的概率。</li>\n<li>对于 UPDATE 语句，如果某行数据已经被锁，InnoDB <strong>执行半一致性读</strong>返回最新提交的到 MYSQL，这样 MYSQL 才能用以决定该行是否满足 WHERE 条件。如果某行匹配，MYSQL 会再次读取此行，且这次 InnoDB 要么锁住要么等待此行的锁。</li>\n</ol>\n</li>\n<li>数据库属性 <code>innodb_locks_unsafe_for_binlog</code>　（以下简称　locks_unsafe） 与 READ COMMITTED 效果一致，其区别在于：<ol>\n<li>lock_unsafe 是全局配置，而　READ COMMITTED 可以设置到 session　级别;</li>\n<li>lock_unsafe 只能数据库启动时设置，而 READ COMMITTED 可以在数据库服务器运行中设置。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-1-案例\"><a href=\"#2-1-案例\" class=\"headerlink\" title=\".2.1. 案例\"></a>.2.1. 案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t (a <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>, b <span class=\"type\">INT</span>) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>),(<span class=\"number\">2</span>,<span class=\"number\">3</span>),(<span class=\"number\">3</span>,<span class=\"number\">2</span>),(<span class=\"number\">4</span>,<span class=\"number\">3</span>),(<span class=\"number\">5</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<p>创建表 t ，但<strong>没有索引</strong>，所以<strong>查询与索引扫描使用记录锁隐藏的聚簇索引而非索引列</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Session A</span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">5</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>session A 执行更新语句。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Session B</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">4</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>session B 在 session A 后执行更新语句。</p>\n<ul>\n<li><p>InnoDB 执行每一个 UPDATE 会先获取每一行的排他锁，然后决定是否更改，如果 InnoDB 发现了不需要更改的行会立即释放其锁，而其他需要更改的行的锁需要等待到事务结束释放。而其作用的事务进程如下：</p>\n<ul>\n<li><p>当使用 REPEATABLE READ 隔离级别时</p>\n<ul>\n<li><p>第一个 UPDATE 会获取所有行的 x-lock 且不释放。</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">2</span>,<span class=\"number\">3</span>); update(<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">2</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">3</span>,<span class=\"number\">2</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">4</span>,<span class=\"number\">3</span>); update(<span class=\"number\">4</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">4</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">5</span>,<span class=\"number\">2</span>); retain x<span class=\"operator\">-</span>lock</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个 UPDATE 执行时一尝试获取锁立即被阻塞，因为第一个 UPDATE 正持有所有的锁，直到第一个 UPDATE 提交或回滚：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); block <span class=\"keyword\">and</span> wait <span class=\"keyword\">for</span> <span class=\"keyword\">first</span> UPDATE <span class=\"keyword\">to</span> <span class=\"keyword\">commit</span> <span class=\"keyword\">or</span> roll back</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>当在 READ COMMITTED 隔离级别下</p>\n<ul>\n<li><p>第一个 UPDATE 在获取了所有行锁后会释放其不需要修改的行锁：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); unlock(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">2</span>,<span class=\"number\">3</span>); update(<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">2</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">3</span>,<span class=\"number\">2</span>); unlock(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">4</span>,<span class=\"number\">3</span>); update(<span class=\"number\">4</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">4</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">5</span>,<span class=\"number\">2</span>); unlock(<span class=\"number\">5</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个 UPDATE 执行半一致性读，返回每行被提交的最新版本到 MYSQL ，以让 MYSQL 能决定这些行是否匹配 UPDATE 条件：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); update(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"keyword\">to</span> (<span class=\"number\">1</span>,<span class=\"number\">4</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">2</span>,<span class=\"number\">3</span>); unlock(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">3</span>,<span class=\"number\">2</span>); update(<span class=\"number\">3</span>,<span class=\"number\">2</span>) <span class=\"keyword\">to</span> (<span class=\"number\">3</span>,<span class=\"number\">4</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">4</span>,<span class=\"number\">3</span>); unlock(<span class=\"number\">4</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">5</span>,<span class=\"number\">2</span>); update(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">to</span> (<span class=\"number\">5</span>,<span class=\"number\">4</span>); retain x<span class=\"operator\">-</span>lock</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如果 <strong>WHERE 条件中包含了索引列</strong>，InnoDB 会使用索引，只有索引列被纳入获取释放记录锁的考虑范围。eg:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t (a <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>, b <span class=\"type\">INT</span>, c <span class=\"type\">INT</span>, INDEX (b)) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>),(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"># Session A</span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">3</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"># Session B</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">4</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第一个 UPDATE 将获取并持有 b=2 的行，而第二个 UPDATE 在获取相同记录的 x-lock 时被阻塞。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-READ-UNCOMMITTED\"><a href=\"#3-READ-UNCOMMITTED\" class=\"headerlink\" title=\".3. READ UNCOMMITTED\"></a>.3. READ UNCOMMITTED</h2><ul>\n<li>SELECT 语句执行不加锁，但早期版本可能会在行上加锁。使用用此隔离级别不能保证读一致性，俗称“脏读”。而在其他方面此隔离级别与 READ COMMITTED 一致。<em>读未提交，事务未提交就可以读到数据更新，不能阻止以上三种任何隐患，直接读取事务中修改后的值，没有视图概念。</em></li>\n</ul>\n<h2 id=\"4-SERIALIZABLE\"><a href=\"#4-SERIALIZABLE\" class=\"headerlink\" title=\".4. SERIALIZABLE\"></a>.4. SERIALIZABLE</h2><blockquote>\n<p>串行化，事务之间排队执行，防止一切隐患。</p>\n</blockquote>\n<p>串行化类似 REPEATABLE READ ，但如果 autocommit=OFF ,InnoDB 会隐式地将普通 SELECT 语句转换成 SELECT … FOR SHARE 。如果 autocommit=ON ,SELECT 在自己的事务中，这是只读且如果执行一致性读（不加锁）能被串行化的，并且也不需要为其他事务加锁。如果需要强迫一个普通 SELECT 为其他事务修改的行阻塞，关闭 autocommit 。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html\">InnoDB 事务模型</a></p>\n<p>InnoDB 事务模型的目标是联合数据库多视图属性与传统的多阶段锁。InnoDB 类似 Oracle ，其执行锁到行级别，同时默认执行查询不加锁并保持一致性读。InnoDB 锁数据存储空间效率高，不随锁数量增加而剧增。锁表全行也不用担心 InnoDB 内存耗尽。","more":"</p>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html\">InnoDB 隔离级别</a></p>\n<p>Transactions Isolation Levels, 事务隔离级别是多个事务在同一时间执行查询、修改时，微调性能、可用性、一致性、数据复用性的平衡手段。</p>\n</blockquote>\n<p>事务三种隐患</p>\n<ol>\n<li>脏读，事务A读到其他事务B未提交的内容，B中数据回滚或其他更新后，A就会读到脏数据。</li>\n<li>不可重复读，事务A分别在事务B（更改了数据）提交前后的数据，发现数据前后不一致。</li>\n<li>幻读，事务A读事务B（新插入了数据）提交后，发现前面读到的数据比之后读到的数据少了一部分。</li>\n</ol>\n<p>可以设置全局，也可以设置到 session ，设置后开启新的 session 即可生效。</p>\n<h2 id=\"1-REPEATABLE-READ\"><a href=\"#1-REPEATABLE-READ\" class=\"headerlink\" title=\".1. REPEATABLE READ\"></a>.1. REPEATABLE READ</h2><p>可重复读，事务在执行语句之初就去读取需要查询的数据并放在视图中，在事务提交之前保存之前都不更新此视图（<strong>新插入的数据还是会再读取到视图中</strong>）。所以这样可以防止不可重复读，不能防止幻读。</p>\n<ol>\n<li>对于一致性非锁读（普通查询），同一事务内会保持一致性，第一次读数据会产生快照。（如果查询条件不一样呢？会再查询出新的快照出来还是会对后面新查询进行优化先在已有快照里匹配呢？）</li>\n<li>对于锁读（select … for update/lock in share mode）/update/delete 语句，加锁的情况取决于查询条件：<ol>\n<li>唯一索引作为唯一查询条件进行查询：InnoDB 只会锁住查询到的唯一记录，不会添加 gap-lock</li>\n<li>对于其他查询: InnoDB 会锁住扫描到的范围内所有索引记录，同时会在其前加上 next-key-lock 或 gap－lock 以阻止其他事务在其间隙插入新的记录（幻读）。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-READ-COMMITTED\"><a href=\"#2-READ-COMMITTED\" class=\"headerlink\" title=\".2. READ COMMITTED\"></a>.2. READ COMMITTED</h2><p>读已提交，事务提交后才去读。事务在执行每一条查询前都会查询结果放到事务的视图中，可以防止脏读，不能防止不可重复读与幻读</p>\n<ol>\n<li>一致性非锁读(consistent non-locking reads,　普通查询)　事务内所有的 sets and reads 都在其快照中。</li>\n<li>锁读（locking reads, select … for update/lock in share mode）/update/delete, InnoDB 只会锁索引记录，而不会在数据行前添加 gap-lock ，因而允许了添加新数据行在锁行前（幻读）。这种隔离级别下 gap-lock 只会对外键约束检查与重复　key　检查生效。<ol>\n<li>此隔离级别下 gap－lock 关闭，只有基于行的二进制日志被支持。在 READ COMMITTED 隔离下，且 binlog_format=MIXED ，服务器自动使用基于行的日志 。</li>\n</ol>\n</li>\n<li>使用 READ COMMITTED 隔离级别两个额外效果：<ol>\n<li>对于 UPDATE／DELETE 语句，InnoDB 只对更新、删除的行加锁。对于未匹配的行的 record－lock 在 MYSQL 计算出 where 条件后即释放。这可以降低死锁发生的概率。</li>\n<li>对于 UPDATE 语句，如果某行数据已经被锁，InnoDB <strong>执行半一致性读</strong>返回最新提交的到 MYSQL，这样 MYSQL 才能用以决定该行是否满足 WHERE 条件。如果某行匹配，MYSQL 会再次读取此行，且这次 InnoDB 要么锁住要么等待此行的锁。</li>\n</ol>\n</li>\n<li>数据库属性 <code>innodb_locks_unsafe_for_binlog</code>　（以下简称　locks_unsafe） 与 READ COMMITTED 效果一致，其区别在于：<ol>\n<li>lock_unsafe 是全局配置，而　READ COMMITTED 可以设置到 session　级别;</li>\n<li>lock_unsafe 只能数据库启动时设置，而 READ COMMITTED 可以在数据库服务器运行中设置。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-1-案例\"><a href=\"#2-1-案例\" class=\"headerlink\" title=\".2.1. 案例\"></a>.2.1. 案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t (a <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>, b <span class=\"type\">INT</span>) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>),(<span class=\"number\">2</span>,<span class=\"number\">3</span>),(<span class=\"number\">3</span>,<span class=\"number\">2</span>),(<span class=\"number\">4</span>,<span class=\"number\">3</span>),(<span class=\"number\">5</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<p>创建表 t ，但<strong>没有索引</strong>，所以<strong>查询与索引扫描使用记录锁隐藏的聚簇索引而非索引列</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Session A</span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">5</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>session A 执行更新语句。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Session B</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">4</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>session B 在 session A 后执行更新语句。</p>\n<ul>\n<li><p>InnoDB 执行每一个 UPDATE 会先获取每一行的排他锁，然后决定是否更改，如果 InnoDB 发现了不需要更改的行会立即释放其锁，而其他需要更改的行的锁需要等待到事务结束释放。而其作用的事务进程如下：</p>\n<ul>\n<li><p>当使用 REPEATABLE READ 隔离级别时</p>\n<ul>\n<li><p>第一个 UPDATE 会获取所有行的 x-lock 且不释放。</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">2</span>,<span class=\"number\">3</span>); update(<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">2</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">3</span>,<span class=\"number\">2</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">4</span>,<span class=\"number\">3</span>); update(<span class=\"number\">4</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">4</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">5</span>,<span class=\"number\">2</span>); retain x<span class=\"operator\">-</span>lock</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个 UPDATE 执行时一尝试获取锁立即被阻塞，因为第一个 UPDATE 正持有所有的锁，直到第一个 UPDATE 提交或回滚：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); block <span class=\"keyword\">and</span> wait <span class=\"keyword\">for</span> <span class=\"keyword\">first</span> UPDATE <span class=\"keyword\">to</span> <span class=\"keyword\">commit</span> <span class=\"keyword\">or</span> roll back</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>当在 READ COMMITTED 隔离级别下</p>\n<ul>\n<li><p>第一个 UPDATE 在获取了所有行锁后会释放其不需要修改的行锁：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); unlock(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">2</span>,<span class=\"number\">3</span>); update(<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">2</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">3</span>,<span class=\"number\">2</span>); unlock(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">4</span>,<span class=\"number\">3</span>); update(<span class=\"number\">4</span>,<span class=\"number\">3</span>) <span class=\"keyword\">to</span> (<span class=\"number\">4</span>,<span class=\"number\">5</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">5</span>,<span class=\"number\">2</span>); unlock(<span class=\"number\">5</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个 UPDATE 执行半一致性读，返回每行被提交的最新版本到 MYSQL ，以让 MYSQL 能决定这些行是否匹配 UPDATE 条件：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">1</span>,<span class=\"number\">2</span>); update(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"keyword\">to</span> (<span class=\"number\">1</span>,<span class=\"number\">4</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">2</span>,<span class=\"number\">3</span>); unlock(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">3</span>,<span class=\"number\">2</span>); update(<span class=\"number\">3</span>,<span class=\"number\">2</span>) <span class=\"keyword\">to</span> (<span class=\"number\">3</span>,<span class=\"number\">4</span>); retain x<span class=\"operator\">-</span>lock</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">4</span>,<span class=\"number\">3</span>); unlock(<span class=\"number\">4</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">x<span class=\"operator\">-</span>lock(<span class=\"number\">5</span>,<span class=\"number\">2</span>); update(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">to</span> (<span class=\"number\">5</span>,<span class=\"number\">4</span>); retain x<span class=\"operator\">-</span>lock</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如果 <strong>WHERE 条件中包含了索引列</strong>，InnoDB 会使用索引，只有索引列被纳入获取释放记录锁的考虑范围。eg:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t (a <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>, b <span class=\"type\">INT</span>, c <span class=\"type\">INT</span>, INDEX (b)) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>),(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"># Session A</span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">3</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"># Session B</span><br><span class=\"line\">UPDATE t <span class=\"keyword\">SET</span> b <span class=\"operator\">=</span> <span class=\"number\">4</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第一个 UPDATE 将获取并持有 b=2 的行，而第二个 UPDATE 在获取相同记录的 x-lock 时被阻塞。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-READ-UNCOMMITTED\"><a href=\"#3-READ-UNCOMMITTED\" class=\"headerlink\" title=\".3. READ UNCOMMITTED\"></a>.3. READ UNCOMMITTED</h2><ul>\n<li>SELECT 语句执行不加锁，但早期版本可能会在行上加锁。使用用此隔离级别不能保证读一致性，俗称“脏读”。而在其他方面此隔离级别与 READ COMMITTED 一致。<em>读未提交，事务未提交就可以读到数据更新，不能阻止以上三种任何隐患，直接读取事务中修改后的值，没有视图概念。</em></li>\n</ul>\n<h2 id=\"4-SERIALIZABLE\"><a href=\"#4-SERIALIZABLE\" class=\"headerlink\" title=\".4. SERIALIZABLE\"></a>.4. SERIALIZABLE</h2><blockquote>\n<p>串行化，事务之间排队执行，防止一切隐患。</p>\n</blockquote>\n<p>串行化类似 REPEATABLE READ ，但如果 autocommit=OFF ,InnoDB 会隐式地将普通 SELECT 语句转换成 SELECT … FOR SHARE 。如果 autocommit=ON ,SELECT 在自己的事务中，这是只读且如果执行一致性读（不加锁）能被串行化的，并且也不需要为其他事务加锁。如果需要强迫一个普通 SELECT 为其他事务修改的行阻塞，关闭 autocommit 。</p>"},{"title":"InnoDB Transaction Model","layout":"post","description":"The InnoDB transactions' commit & rollback","date":"2021-01-06T05:52:00.000Z","_content":"\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html)\n\n[InnoDB Isolation Level Note](./InnoDB%20Transaction%20Isolation%20Level.md)\n\n## .1. Autocommit commit rollback\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html)\n\n> 在 InnoDB 中所有用户的活动都在事务之中，如果 autocommit＝ON 每个 SQL 语句都会形成一个自有的事务。默认情况下 Ｍysql 开启一个session都会在每个连接都会设置autocommit＝on，MYSQL 只要语句没有返回错误都会提交。<!--more-->\n\n- 一个 session 可以在 autocommit=on 时在同一个事务中执行多个语句，只要显示地以 `START TRANSACTION` 或者 `BEGIN` 开始并以 `COMMIT`/`ROLLBACK` 结束语句。\n- 如果 autocommit=0 , session 也设置了 autocommit=0 ，那么这个 session 总会有一个事务处于打开状态。`COMMIT` `ROLLBACK` 语句会结束当前事务并开始一个新的事务。\n- 如果一个 session autocommit=0，没有显式地提交最后一个事务，MYSQL 会自动圆滚这个事务。\n- 某些语句会[隐式地结束一个事务](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html)，在你执行语句之前好像提交过一样。\n\n## .2. Consistent Nonlocking Reads\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html)\n\n> 一致性读指 InnoDB 使用多视图给数据库某时间点快照响应查询。此查询能看到在此时间点前提交的事务的更新，在此时间点后提交的事务或未提交的更新不能被看到。此规则例外：本事务内之前语句的更新将被查询到。此类异常情况会造成：更新某表内部分行，SELECT 能够看到这些被更新的行，但也可以看到任何行的老版本。如果其他 sessions 同时更新了这张表，那么就等到了表在数据库内从未出现的状态。\n\n- 如果在默认的 REPEATABLE READ 隔离级别下，在相同事务中所有的一致性读都会读取第一次查询建立的快照。若要获取到更新的快照，提交当前事务并开启一个新的。\n- 在 READ COMMITTED 隔离级别下，同一个事务中每个一致性读的 SETS 与 READS 都在其自己的更新的快照中进行。\n- InnoDB 在 REPEATABLE READ/READ COMMITTED 隔离级别下处理 SELECT 语句默认使用一致性读。一致性读在访问表数据时不加任何锁，所以其他 session 可以同时修改同一张表数据。\n- 默认 REPEATABLE READ 隔离级别下，发起一个一致性读（普通 SELECT 语句），InnoDB 给事务的快照时间点(timepoint)取决于查询到达数据库，如果另外一个事务在此时间点后提交了插入、删除或更新，原事务是无感知的。\n\n    > **Note**\n    >\n    > 在一个事务中，对 SELECT 语句使用这种数据库状态快照的做法并不需要使用在 DML 语句上。如果你在事务A插入修改了一些行并提交了事务，另外一个并发的 REPEATABLE READ 事务可以影响修改这些刚提交的行，尽管有可以这个并发的事务所在的 session 还不能查询到这些事务A刚提交的修改。\n    >\n    > 一个事务修改删除了刚被另一个事务提交的数据，这些修改对当前事务都会可见。\n\n    ```sql\n    SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';\n    -- Returns 0: no rows match.\n    DELETE FROM t1 WHERE c1 = 'xyz';\n    -- Deletes several rows recently committed by other transaction.\n\n    SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';\n    -- Returns 0: no rows match.\n    UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';\n    -- Affects 10 rows: another txn just committed 10 rows with 'abc' values.\n    SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';\n    -- Returns 10: this txn can now see the rows it just updated.\n    ```\n\n- 若要将 timepoint 提前，可以提交当前事务，并开启另一个 `SELECT` / `START TRANSACTION WITH CONSISTENT SNAPSHOT`\n- 这一切都叫做**多视图并发控制（multi-version concurrency control）**。\n\n    ```sql\n                 Session A              Session B\n\n                SET autocommit=0;       SET autocommit=0;\n    time\n    |           SELECT * FROM t;\n    |           empty set\n    |                                   INSERT INTO t VALUES (1, 2);\n    |\n    v           SELECT * FROM t;\n                empty set\n                                        COMMIT;\n\n                SELECT * FROM t;\n                empty set\n\n                COMMIT;\n\n                SELECT * FROM t;\n                ---------------------\n                |    1    |    2    |\n                ---------------------\n    ```sql\n\n- 如果需要数据库最新状态，要么使用 READ COMMITTED ，要么使用 locking read: `SELECT * FROM t FOR SHARE;`\n    - 在 READ COMMITTED 隔离级别下，事务内所有的读写都使用使用自己的快照。而对于 FOR SHARE 将使用锁读（locking read），SELECT 将阻塞直到包含最新行数据的事务结束。\n- 一致性读在特定的 DDL 语句中失效：\n    - DROP TABLE 语句，因为 MYSQL 不能使用被删除的表且 InnoDB 将销毁此表。\n    - ALTER TABLE 操作，此操作将复制表的临时拷贝并在临时拷贝建立成功时删除原表。当事务中重新发起一个一致性读，新表中的数据行在事务中快照并不存在。这种情况下事务会返回错误：ER_TABLE_DEF_CHANGED,\"Table definition has changed, please retry transaction\".\n- 对子查询如：`INSERT INTO ... SELECT` `UPDATE ... (SELECT)` `CREATE TABLE ... SELECT` 并未指定加锁（for update / for share）:\n    - InnoDB 默认对这引起语句使用更严格的锁且 `SELECT` 部分使用 READ COMMITTED （在相同事务内，一致性读 sets gets 都针对其自有快照）。\n    - 执行非锁读的场景，设置事务隔离级别为 READ COMMITTED / READ UNCOMMITTED 以避免对所选表中数据行加锁。\n\n## .3. Locking Reads\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)\n\n如果你在同一个事务中查询并插入修改数据,常规的 SELECT 语句并不能提供足够的防御.其他事务能够修改或删除你查询到的数据.InnoDB 提供两种类型锁读 locking-read 以增强这类防御:\n\n- SELECT ... FOR SHARE\n    - 在读取到的行上设置一个共享模式的锁.其他 session 可以读取这些行,但不能修改,直到你的事务提交.如果查询的这些行被其他事务修改并未提交,查询将等待到这些事务结束而获取到最新的值.\n\n        > **Note**\n        >\n        > `SELECT ... FOR SHARE` 是 `SELECT ... LOCK IN SHARE MODE` 的替换版本,但 `LOCK IN SHARE MODE` 保留了向后兼容性,两者相等.然后 `FOR SHARE` 支持 `OF table_name`, `NOWAIT`, `SKIP LOCKED` 选项.\n\n    - 在 mysql 版本 8.0.22 之前, SELECT ... FOR SHARE 需要 `select` 权限与 DELETE/LOCK TABLES/UPDATE 权限之一.在 8.0.22 版本只需要 SELECT 权限.且在 8.0 前都语法是：`SELECT ... LOCK IN SHARE MODE`\n    - MYSQL 8.0.22 , SELECT ... FOR SHARE 在 grant tables 上不再获取读锁.\n- SELECT ... FOR UPDATE:\n    - 对于查询到的索引记录,将锁住行和与其相关的索引项,与对这些行执行 UPDATE 语句一样.其他事务将被阻塞,这些事务可能是执行 `SELECT ... FOR SHARE`/更新这些行/某些隔离级别下的读取数据.一致性读将忽略在其视图中数据上的任何锁.(老版本记录不能被锁,对数据记录在内存备份应用 undo_log 重构能得到老版本数据.)\n    - `SELECT ... FOR UPDATE` 需要 SELECT 权限加至少一个 `DELETE` `LOCK TABLES` `UPDATE` 权限.\n- 这些子句主要在处理树状或图状结构数据时有用,要么单表要么跨表.You traverse edges or tree branches from one place to another, while reserving the right to come back and change any of these “pointer” values.\n- 所有 SELECT FOR UPDATE 与 SELECT FOR SHARE 查询的锁都在事务提交或回滚时释放.\n\n    > **Note**\n    >\n    > 锁读(locking read) 只有在 autocommit=0 时才能实现(要么使用 `START TRANSACTION`, 要么设置 `autocommit=0`)\n\n- 外部语句中的锁读子句不会对子查询语句的数据行生效. eg:\n\n    ```sql\n    SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;\n    ```\n\n    - 子查询需要单独加自己的锁读子句. eg:\n\n        ```sql\n        SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;\n        ```\n\n### .3.1. Locking Read Examples\n\n> 假设你想在表 child 中插入一条新数据,并保证子表数据在父表 parent 表中有相应的行.你的应用代码能保证以下操作相对完整.\n\n- 首先,使用一致性读取 parent 表中数据以验证其数据是存在的,但还现在插入新数据到 child 表并不安全.因为其他 session 可以在查询 parent 表与插入 child 表两次操作之间将所查询到的数据删除掉.为避免此问题需要执行 SELECT ... FOR SHARE :\n\n    ```sql\n    SELECT * FROM parent WHERE NAME = 'Jones' FOR SHARE;\n    ```\n\n    - 使用 FOR SHARE 查询语句将等待其他修改 parent 数据的事务执行完,在此之后读取到 parent 数据后将加锁对后来的删除修改操作阻塞到当前事务在 child 表中添加数据完成.\n- 另一个场景: child_codes 表中有个 counter 整数计数字段用以指定 child 表中的 id .这时就算是使用 FOR SHARE 查询此字段一样会有问题.因为多个事务会读取到相同的 counter 值,使用相同的值作为 id 插入到 child 表会触发 duplicate-key error,同时当这些事务更新 counter 字段时至少有一个会以死锁收场(多个事务去更新 counter 字段但因为都执行 FOR SHARE 查询而进入等待彼此释放锁.*业务开发中如果需要先读取再更新就不能使用 SELECT ... FOR SHARE ,因为只要在事务中先查询再更改,只要并发就会出现多个 session 都获取到 s-lock 然后再等待对方释放这个 s-lock 以执行更新语句，这就产生死锁*).\n    - SELECT ... FOR UPDATE  将读取最新可得的数据,并在读到的行上加上排他锁.因此其回锁类似 UPDATE 语句.使用此类锁读即可解决上述问题:\n\n        ```sql\n        SELECT counter_field FROM child_codes FOR UPDATE;\n        UPDATE child_codes SET counter_field = counter_field + 1;\n        ```\n\n    - 上述场景在 MYSQL 中可以通过单次访问表实现生成唯一 id:\n\n        ```sql\n        UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);\n        SELECT LAST_INSERT_ID();\n        ```\n\n        - 其中 SELECT 语句仅仅是获取当前连接的 id 信息,不访问任何表.\n\n### .3.2. Locking Read Concurrency with NOWAIT and SKIP LOCKED\n\n> MYSQL 8.0 版本才开始有此选项。\n>\n> 使用 SELECT ... FOR UPDATE / SELECT FOR SHARE 在查询被其他事务锁住的行时必须等待到这些事务释放锁,这类规则在你想查询请求快速结束与可以接受被锁的查询目标不被返回到结果集的场景中是不恰当的.为满足以上两种场景,可以在 SELECT FOR UPDATE / SELECT FOR SHARE 中添加选项: NOWAIT / SKIP LOCKED。\n\n- NOWAIT，不等待被锁住的行，直接返回失败。\n- SKIP LOCKED,跳过被锁住的行，返回的结果集中不包括被锁住的行。\n\n    > Note\n    >\n    > 使用 SKIP LOCKED 返回数据不能保证一致性。因此对于一般的事务不适用，但在多 session 访问类队列的表时可以用来避开锁的概念。\n\n- NOWAIT 与 SKIP LOCKED 都只应用在行级锁上。\n- NOWAIT 与 SKIP LOCKED 语句对于基于复制的语句并不安全。\n- EXAMPLE：\n\n    ```sql\n    # Session 1: 查询并锁住 2\n\n    mysql> CREATE TABLE t (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;\n\n    mysql> INSERT INTO t (i) VALUES(1),(2),(3);\n\n    mysql> START TRANSACTION;\n\n    mysql> SELECT * FROM t WHERE i = 2 FOR UPDATE;\n    +---+\n    | i |\n    +---+\n    | 2 |\n    +---+\n\n    # Session 2: NOWAIT 并发查询使用 而直接返回错误\n\n    mysql> START TRANSACTION;\n\n    mysql> SELECT * FROM t WHERE i = 2 FOR UPDATE NOWAIT;\n    ERROR 3572 (HY000): Do not wait for lock.\n\n    # Session 3: SKIP LOCKED 并发查询路过 2\n\n    mysql> START TRANSACTION;\n\n    mysql> SELECT * FROM t FOR UPDATE SKIP LOCKED;\n    +---+\n    | i |\n    +---+\n    | 1 |\n    | 3 |\n    +---+\n    ```\n","source":"_posts/Mysql/InnoDB Transaction Model.md","raw":"---\ntitle: InnoDB Transaction Model\nlayout: post\ntag: [mysql, InnoDB, commit]\ncategories: [Mysql]\ndescription: The InnoDB transactions' commit & rollback\ndate: \"2021-1-6 13:52:00\"\n---\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html)\n\n[InnoDB Isolation Level Note](./InnoDB%20Transaction%20Isolation%20Level.md)\n\n## .1. Autocommit commit rollback\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html)\n\n> 在 InnoDB 中所有用户的活动都在事务之中，如果 autocommit＝ON 每个 SQL 语句都会形成一个自有的事务。默认情况下 Ｍysql 开启一个session都会在每个连接都会设置autocommit＝on，MYSQL 只要语句没有返回错误都会提交。<!--more-->\n\n- 一个 session 可以在 autocommit=on 时在同一个事务中执行多个语句，只要显示地以 `START TRANSACTION` 或者 `BEGIN` 开始并以 `COMMIT`/`ROLLBACK` 结束语句。\n- 如果 autocommit=0 , session 也设置了 autocommit=0 ，那么这个 session 总会有一个事务处于打开状态。`COMMIT` `ROLLBACK` 语句会结束当前事务并开始一个新的事务。\n- 如果一个 session autocommit=0，没有显式地提交最后一个事务，MYSQL 会自动圆滚这个事务。\n- 某些语句会[隐式地结束一个事务](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html)，在你执行语句之前好像提交过一样。\n\n## .2. Consistent Nonlocking Reads\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html)\n\n> 一致性读指 InnoDB 使用多视图给数据库某时间点快照响应查询。此查询能看到在此时间点前提交的事务的更新，在此时间点后提交的事务或未提交的更新不能被看到。此规则例外：本事务内之前语句的更新将被查询到。此类异常情况会造成：更新某表内部分行，SELECT 能够看到这些被更新的行，但也可以看到任何行的老版本。如果其他 sessions 同时更新了这张表，那么就等到了表在数据库内从未出现的状态。\n\n- 如果在默认的 REPEATABLE READ 隔离级别下，在相同事务中所有的一致性读都会读取第一次查询建立的快照。若要获取到更新的快照，提交当前事务并开启一个新的。\n- 在 READ COMMITTED 隔离级别下，同一个事务中每个一致性读的 SETS 与 READS 都在其自己的更新的快照中进行。\n- InnoDB 在 REPEATABLE READ/READ COMMITTED 隔离级别下处理 SELECT 语句默认使用一致性读。一致性读在访问表数据时不加任何锁，所以其他 session 可以同时修改同一张表数据。\n- 默认 REPEATABLE READ 隔离级别下，发起一个一致性读（普通 SELECT 语句），InnoDB 给事务的快照时间点(timepoint)取决于查询到达数据库，如果另外一个事务在此时间点后提交了插入、删除或更新，原事务是无感知的。\n\n    > **Note**\n    >\n    > 在一个事务中，对 SELECT 语句使用这种数据库状态快照的做法并不需要使用在 DML 语句上。如果你在事务A插入修改了一些行并提交了事务，另外一个并发的 REPEATABLE READ 事务可以影响修改这些刚提交的行，尽管有可以这个并发的事务所在的 session 还不能查询到这些事务A刚提交的修改。\n    >\n    > 一个事务修改删除了刚被另一个事务提交的数据，这些修改对当前事务都会可见。\n\n    ```sql\n    SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';\n    -- Returns 0: no rows match.\n    DELETE FROM t1 WHERE c1 = 'xyz';\n    -- Deletes several rows recently committed by other transaction.\n\n    SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';\n    -- Returns 0: no rows match.\n    UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';\n    -- Affects 10 rows: another txn just committed 10 rows with 'abc' values.\n    SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';\n    -- Returns 10: this txn can now see the rows it just updated.\n    ```\n\n- 若要将 timepoint 提前，可以提交当前事务，并开启另一个 `SELECT` / `START TRANSACTION WITH CONSISTENT SNAPSHOT`\n- 这一切都叫做**多视图并发控制（multi-version concurrency control）**。\n\n    ```sql\n                 Session A              Session B\n\n                SET autocommit=0;       SET autocommit=0;\n    time\n    |           SELECT * FROM t;\n    |           empty set\n    |                                   INSERT INTO t VALUES (1, 2);\n    |\n    v           SELECT * FROM t;\n                empty set\n                                        COMMIT;\n\n                SELECT * FROM t;\n                empty set\n\n                COMMIT;\n\n                SELECT * FROM t;\n                ---------------------\n                |    1    |    2    |\n                ---------------------\n    ```sql\n\n- 如果需要数据库最新状态，要么使用 READ COMMITTED ，要么使用 locking read: `SELECT * FROM t FOR SHARE;`\n    - 在 READ COMMITTED 隔离级别下，事务内所有的读写都使用使用自己的快照。而对于 FOR SHARE 将使用锁读（locking read），SELECT 将阻塞直到包含最新行数据的事务结束。\n- 一致性读在特定的 DDL 语句中失效：\n    - DROP TABLE 语句，因为 MYSQL 不能使用被删除的表且 InnoDB 将销毁此表。\n    - ALTER TABLE 操作，此操作将复制表的临时拷贝并在临时拷贝建立成功时删除原表。当事务中重新发起一个一致性读，新表中的数据行在事务中快照并不存在。这种情况下事务会返回错误：ER_TABLE_DEF_CHANGED,\"Table definition has changed, please retry transaction\".\n- 对子查询如：`INSERT INTO ... SELECT` `UPDATE ... (SELECT)` `CREATE TABLE ... SELECT` 并未指定加锁（for update / for share）:\n    - InnoDB 默认对这引起语句使用更严格的锁且 `SELECT` 部分使用 READ COMMITTED （在相同事务内，一致性读 sets gets 都针对其自有快照）。\n    - 执行非锁读的场景，设置事务隔离级别为 READ COMMITTED / READ UNCOMMITTED 以避免对所选表中数据行加锁。\n\n## .3. Locking Reads\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)\n\n如果你在同一个事务中查询并插入修改数据,常规的 SELECT 语句并不能提供足够的防御.其他事务能够修改或删除你查询到的数据.InnoDB 提供两种类型锁读 locking-read 以增强这类防御:\n\n- SELECT ... FOR SHARE\n    - 在读取到的行上设置一个共享模式的锁.其他 session 可以读取这些行,但不能修改,直到你的事务提交.如果查询的这些行被其他事务修改并未提交,查询将等待到这些事务结束而获取到最新的值.\n\n        > **Note**\n        >\n        > `SELECT ... FOR SHARE` 是 `SELECT ... LOCK IN SHARE MODE` 的替换版本,但 `LOCK IN SHARE MODE` 保留了向后兼容性,两者相等.然后 `FOR SHARE` 支持 `OF table_name`, `NOWAIT`, `SKIP LOCKED` 选项.\n\n    - 在 mysql 版本 8.0.22 之前, SELECT ... FOR SHARE 需要 `select` 权限与 DELETE/LOCK TABLES/UPDATE 权限之一.在 8.0.22 版本只需要 SELECT 权限.且在 8.0 前都语法是：`SELECT ... LOCK IN SHARE MODE`\n    - MYSQL 8.0.22 , SELECT ... FOR SHARE 在 grant tables 上不再获取读锁.\n- SELECT ... FOR UPDATE:\n    - 对于查询到的索引记录,将锁住行和与其相关的索引项,与对这些行执行 UPDATE 语句一样.其他事务将被阻塞,这些事务可能是执行 `SELECT ... FOR SHARE`/更新这些行/某些隔离级别下的读取数据.一致性读将忽略在其视图中数据上的任何锁.(老版本记录不能被锁,对数据记录在内存备份应用 undo_log 重构能得到老版本数据.)\n    - `SELECT ... FOR UPDATE` 需要 SELECT 权限加至少一个 `DELETE` `LOCK TABLES` `UPDATE` 权限.\n- 这些子句主要在处理树状或图状结构数据时有用,要么单表要么跨表.You traverse edges or tree branches from one place to another, while reserving the right to come back and change any of these “pointer” values.\n- 所有 SELECT FOR UPDATE 与 SELECT FOR SHARE 查询的锁都在事务提交或回滚时释放.\n\n    > **Note**\n    >\n    > 锁读(locking read) 只有在 autocommit=0 时才能实现(要么使用 `START TRANSACTION`, 要么设置 `autocommit=0`)\n\n- 外部语句中的锁读子句不会对子查询语句的数据行生效. eg:\n\n    ```sql\n    SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;\n    ```\n\n    - 子查询需要单独加自己的锁读子句. eg:\n\n        ```sql\n        SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;\n        ```\n\n### .3.1. Locking Read Examples\n\n> 假设你想在表 child 中插入一条新数据,并保证子表数据在父表 parent 表中有相应的行.你的应用代码能保证以下操作相对完整.\n\n- 首先,使用一致性读取 parent 表中数据以验证其数据是存在的,但还现在插入新数据到 child 表并不安全.因为其他 session 可以在查询 parent 表与插入 child 表两次操作之间将所查询到的数据删除掉.为避免此问题需要执行 SELECT ... FOR SHARE :\n\n    ```sql\n    SELECT * FROM parent WHERE NAME = 'Jones' FOR SHARE;\n    ```\n\n    - 使用 FOR SHARE 查询语句将等待其他修改 parent 数据的事务执行完,在此之后读取到 parent 数据后将加锁对后来的删除修改操作阻塞到当前事务在 child 表中添加数据完成.\n- 另一个场景: child_codes 表中有个 counter 整数计数字段用以指定 child 表中的 id .这时就算是使用 FOR SHARE 查询此字段一样会有问题.因为多个事务会读取到相同的 counter 值,使用相同的值作为 id 插入到 child 表会触发 duplicate-key error,同时当这些事务更新 counter 字段时至少有一个会以死锁收场(多个事务去更新 counter 字段但因为都执行 FOR SHARE 查询而进入等待彼此释放锁.*业务开发中如果需要先读取再更新就不能使用 SELECT ... FOR SHARE ,因为只要在事务中先查询再更改,只要并发就会出现多个 session 都获取到 s-lock 然后再等待对方释放这个 s-lock 以执行更新语句，这就产生死锁*).\n    - SELECT ... FOR UPDATE  将读取最新可得的数据,并在读到的行上加上排他锁.因此其回锁类似 UPDATE 语句.使用此类锁读即可解决上述问题:\n\n        ```sql\n        SELECT counter_field FROM child_codes FOR UPDATE;\n        UPDATE child_codes SET counter_field = counter_field + 1;\n        ```\n\n    - 上述场景在 MYSQL 中可以通过单次访问表实现生成唯一 id:\n\n        ```sql\n        UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);\n        SELECT LAST_INSERT_ID();\n        ```\n\n        - 其中 SELECT 语句仅仅是获取当前连接的 id 信息,不访问任何表.\n\n### .3.2. Locking Read Concurrency with NOWAIT and SKIP LOCKED\n\n> MYSQL 8.0 版本才开始有此选项。\n>\n> 使用 SELECT ... FOR UPDATE / SELECT FOR SHARE 在查询被其他事务锁住的行时必须等待到这些事务释放锁,这类规则在你想查询请求快速结束与可以接受被锁的查询目标不被返回到结果集的场景中是不恰当的.为满足以上两种场景,可以在 SELECT FOR UPDATE / SELECT FOR SHARE 中添加选项: NOWAIT / SKIP LOCKED。\n\n- NOWAIT，不等待被锁住的行，直接返回失败。\n- SKIP LOCKED,跳过被锁住的行，返回的结果集中不包括被锁住的行。\n\n    > Note\n    >\n    > 使用 SKIP LOCKED 返回数据不能保证一致性。因此对于一般的事务不适用，但在多 session 访问类队列的表时可以用来避开锁的概念。\n\n- NOWAIT 与 SKIP LOCKED 都只应用在行级锁上。\n- NOWAIT 与 SKIP LOCKED 语句对于基于复制的语句并不安全。\n- EXAMPLE：\n\n    ```sql\n    # Session 1: 查询并锁住 2\n\n    mysql> CREATE TABLE t (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;\n\n    mysql> INSERT INTO t (i) VALUES(1),(2),(3);\n\n    mysql> START TRANSACTION;\n\n    mysql> SELECT * FROM t WHERE i = 2 FOR UPDATE;\n    +---+\n    | i |\n    +---+\n    | 2 |\n    +---+\n\n    # Session 2: NOWAIT 并发查询使用 而直接返回错误\n\n    mysql> START TRANSACTION;\n\n    mysql> SELECT * FROM t WHERE i = 2 FOR UPDATE NOWAIT;\n    ERROR 3572 (HY000): Do not wait for lock.\n\n    # Session 3: SKIP LOCKED 并发查询路过 2\n\n    mysql> START TRANSACTION;\n\n    mysql> SELECT * FROM t FOR UPDATE SKIP LOCKED;\n    +---+\n    | i |\n    +---+\n    | 1 |\n    | 3 |\n    +---+\n    ```\n","slug":"Mysql/InnoDB Transaction Model","published":1,"updated":"2021-02-24T15:22:22.892Z","comments":1,"photos":[],"link":"","_id":"ckljnokr9001j2bhb8yt0a5iq","content":"<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html\">reference</a></p>\n<p><a href=\"./InnoDB%20Transaction%20Isolation%20Level.md\">InnoDB Isolation Level Note</a></p>\n<h2 id=\"1-Autocommit-commit-rollback\"><a href=\"#1-Autocommit-commit-rollback\" class=\"headerlink\" title=\".1. Autocommit commit rollback\"></a>.1. Autocommit commit rollback</h2><p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html\">reference</a></p>\n<blockquote>\n<p>在 InnoDB 中所有用户的活动都在事务之中，如果 autocommit＝ON 每个 SQL 语句都会形成一个自有的事务。默认情况下 Ｍysql 开启一个session都会在每个连接都会设置autocommit＝on，MYSQL 只要语句没有返回错误都会提交。<span id=\"more\"></span></p>\n</blockquote>\n<ul>\n<li>一个 session 可以在 autocommit=on 时在同一个事务中执行多个语句，只要显示地以 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 开始并以 <code>COMMIT</code>/<code>ROLLBACK</code> 结束语句。</li>\n<li>如果 autocommit=0 , session 也设置了 autocommit=0 ，那么这个 session 总会有一个事务处于打开状态。<code>COMMIT</code> <code>ROLLBACK</code> 语句会结束当前事务并开始一个新的事务。</li>\n<li>如果一个 session autocommit=0，没有显式地提交最后一个事务，MYSQL 会自动圆滚这个事务。</li>\n<li>某些语句会<a href=\"https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html\">隐式地结束一个事务</a>，在你执行语句之前好像提交过一样。</li>\n</ul>\n<h2 id=\"2-Consistent-Nonlocking-Reads\"><a href=\"#2-Consistent-Nonlocking-Reads\" class=\"headerlink\" title=\".2. Consistent Nonlocking Reads\"></a>.2. Consistent Nonlocking Reads</h2><p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html\">reference</a></p>\n<blockquote>\n<p>一致性读指 InnoDB 使用多视图给数据库某时间点快照响应查询。此查询能看到在此时间点前提交的事务的更新，在此时间点后提交的事务或未提交的更新不能被看到。此规则例外：本事务内之前语句的更新将被查询到。此类异常情况会造成：更新某表内部分行，SELECT 能够看到这些被更新的行，但也可以看到任何行的老版本。如果其他 sessions 同时更新了这张表，那么就等到了表在数据库内从未出现的状态。</p>\n</blockquote>\n<ul>\n<li><p>如果在默认的 REPEATABLE READ 隔离级别下，在相同事务中所有的一致性读都会读取第一次查询建立的快照。若要获取到更新的快照，提交当前事务并开启一个新的。</p>\n</li>\n<li><p>在 READ COMMITTED 隔离级别下，同一个事务中每个一致性读的 SETS 与 READS 都在其自己的更新的快照中进行。</p>\n</li>\n<li><p>InnoDB 在 REPEATABLE READ/READ COMMITTED 隔离级别下处理 SELECT 语句默认使用一致性读。一致性读在访问表数据时不加任何锁，所以其他 session 可以同时修改同一张表数据。</p>\n</li>\n<li><p>默认 REPEATABLE READ 隔离级别下，发起一个一致性读（普通 SELECT 语句），InnoDB 给事务的快照时间点(timepoint)取决于查询到达数据库，如果另外一个事务在此时间点后提交了插入、删除或更新，原事务是无感知的。</p>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>在一个事务中，对 SELECT 语句使用这种数据库状态快照的做法并不需要使用在 DML 语句上。如果你在事务A插入修改了一些行并提交了事务，另外一个并发的 REPEATABLE READ 事务可以影响修改这些刚提交的行，尽管有可以这个并发的事务所在的 session 还不能查询到这些事务A刚提交的修改。</p>\n<p>一个事务修改删除了刚被另一个事务提交的数据，这些修改对当前事务都会可见。</p>\n</blockquote>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(c1) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;xyz&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Returns 0: no rows match.</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;xyz&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Deletes several rows recently committed by other transaction.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(c2) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Returns 0: no rows match.</span></span><br><span class=\"line\">UPDATE t1 <span class=\"keyword\">SET</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;cba&#x27;</span> <span class=\"keyword\">WHERE</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Affects 10 rows: another txn just committed 10 rows with &#x27;abc&#x27; values.</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(c2) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;cba&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Returns 10: this txn can now see the rows it just updated.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若要将 timepoint 提前，可以提交当前事务，并开启另一个 <code>SELECT</code> / <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code></p>\n</li>\n<li><p>这一切都叫做<strong>多视图并发控制（multi-version concurrency control）</strong>。</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                 Session A              Session B</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">SET</span> autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>;       <span class=\"keyword\">SET</span> autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">time</span></span><br><span class=\"line\">    <span class=\"operator\">|</span>           <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">    <span class=\"operator\">|</span>           <span class=\"keyword\">empty</span> <span class=\"keyword\">set</span></span><br><span class=\"line\">    <span class=\"operator\">|</span>                                   <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"operator\">|</span></span><br><span class=\"line\">    v           <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">                <span class=\"keyword\">empty</span> <span class=\"keyword\">set</span></span><br><span class=\"line\">                                        <span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">                <span class=\"keyword\">empty</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">                <span class=\"comment\">---------------------</span></span><br><span class=\"line\">                <span class=\"operator\">|</span>    <span class=\"number\">1</span>    <span class=\"operator\">|</span>    <span class=\"number\">2</span>    <span class=\"operator\">|</span></span><br><span class=\"line\">                <span class=\"comment\">---------------------</span></span><br><span class=\"line\">    ```<span class=\"keyword\">sql</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> 如果需要数据库最新状态，要么使用 READ COMMITTED ，要么使用 locking read: `<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">FOR</span> SHARE;`</span><br><span class=\"line\">    <span class=\"operator\">-</span> 在 READ COMMITTED 隔离级别下，事务内所有的读写都使用使用自己的快照。而对于 <span class=\"keyword\">FOR</span> SHARE 将使用锁读（locking read），<span class=\"keyword\">SELECT</span> 将阻塞直到包含最新行数据的事务结束。</span><br><span class=\"line\"><span class=\"operator\">-</span> 一致性读在特定的 DDL 语句中失效：</span><br><span class=\"line\">    <span class=\"operator\">-</span> <span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> 语句，因为 MYSQL 不能使用被删除的表且 InnoDB 将销毁此表。</span><br><span class=\"line\">    <span class=\"operator\">-</span> <span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 操作，此操作将复制表的临时拷贝并在临时拷贝建立成功时删除原表。当事务中重新发起一个一致性读，新表中的数据行在事务中快照并不存在。这种情况下事务会返回错误：ER_TABLE_DEF_CHANGED,&quot;Table definition has changed, please retry transaction&quot;.</span><br><span class=\"line\"><span class=\"operator\">-</span> 对子查询如：`<span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> ... <span class=\"keyword\">SELECT</span>` `UPDATE ... (<span class=\"keyword\">SELECT</span>)` `<span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> ... <span class=\"keyword\">SELECT</span>` 并未指定加锁（<span class=\"keyword\">for</span> update <span class=\"operator\">/</span> <span class=\"keyword\">for</span> share）:</span><br><span class=\"line\">    <span class=\"operator\">-</span> InnoDB 默认对这引起语句使用更严格的锁且 `<span class=\"keyword\">SELECT</span>` 部分使用 READ COMMITTED （在相同事务内，一致性读 sets gets 都针对其自有快照）。</span><br><span class=\"line\">    <span class=\"operator\">-</span> 执行非锁读的场景，设置事务隔离级别为 READ COMMITTED <span class=\"operator\">/</span> READ UNCOMMITTED 以避免对所选表中数据行加锁。</span><br><span class=\"line\"></span><br><span class=\"line\">## <span class=\"number\">.3</span>. Locking <span class=\"keyword\">Reads</span></span><br><span class=\"line\"></span><br><span class=\"line\">[reference](https:<span class=\"operator\">/</span><span class=\"operator\">/</span>dev.mysql.com<span class=\"operator\">/</span>doc<span class=\"operator\">/</span>refman<span class=\"operator\">/</span><span class=\"number\">8.0</span><span class=\"operator\">/</span>en<span class=\"operator\">/</span>innodb<span class=\"operator\">-</span>locking<span class=\"operator\">-</span>reads.html)</span><br><span class=\"line\"></span><br><span class=\"line\">如果你在同一个事务中查询并插入修改数据,常规的 <span class=\"keyword\">SELECT</span> 语句并不能提供足够的防御.其他事务能够修改或删除你查询到的数据.InnoDB 提供两种类型锁读 locking<span class=\"operator\">-</span>read 以增强这类防御:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE</span><br><span class=\"line\">    <span class=\"operator\">-</span> 在读取到的行上设置一个共享模式的锁.其他 session 可以读取这些行,但不能修改,直到你的事务提交.如果查询的这些行被其他事务修改并未提交,查询将等待到这些事务结束而获取到最新的值.</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"operator\">&gt;</span> <span class=\"operator\">*</span><span class=\"operator\">*</span>Note<span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">        <span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"operator\">&gt;</span> `<span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE` 是 `<span class=\"keyword\">SELECT</span> ... LOCK <span class=\"keyword\">IN</span> SHARE MODE` 的替换版本,但 `LOCK <span class=\"keyword\">IN</span> SHARE MODE` 保留了向后兼容性,两者相等.然后 `<span class=\"keyword\">FOR</span> SHARE` 支持 `<span class=\"keyword\">OF</span> table_name`, `NOWAIT`, `<span class=\"keyword\">SKIP</span> LOCKED` 选项.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"operator\">-</span> 在 mysql 版本 <span class=\"number\">8.0</span><span class=\"number\">.22</span> 之前, <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE 需要 `<span class=\"keyword\">select</span>` 权限与 <span class=\"keyword\">DELETE</span><span class=\"operator\">/</span>LOCK TABLES<span class=\"operator\">/</span>UPDATE 权限之一.在 <span class=\"number\">8.0</span><span class=\"number\">.22</span> 版本只需要 <span class=\"keyword\">SELECT</span> 权限.且在 <span class=\"number\">8.0</span> 前都语法是：`<span class=\"keyword\">SELECT</span> ... LOCK <span class=\"keyword\">IN</span> SHARE MODE`</span><br><span class=\"line\">    <span class=\"operator\">-</span> MYSQL <span class=\"number\">8.0</span><span class=\"number\">.22</span> , <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE 在 <span class=\"keyword\">grant</span> tables 上不再获取读锁.</span><br><span class=\"line\"><span class=\"operator\">-</span> <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> UPDATE:</span><br><span class=\"line\">    <span class=\"operator\">-</span> 对于查询到的索引记录,将锁住行和与其相关的索引项,与对这些行执行 UPDATE 语句一样.其他事务将被阻塞,这些事务可能是执行 `<span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE`<span class=\"operator\">/</span>更新这些行<span class=\"operator\">/</span>某些隔离级别下的读取数据.一致性读将忽略在其视图中数据上的任何锁.(老版本记录不能被锁,对数据记录在内存备份应用 undo_log 重构能得到老版本数据.)</span><br><span class=\"line\">    <span class=\"operator\">-</span> `<span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> UPDATE` 需要 <span class=\"keyword\">SELECT</span> 权限加至少一个 `<span class=\"keyword\">DELETE</span>` `LOCK TABLES` `UPDATE` 权限.</span><br><span class=\"line\"><span class=\"operator\">-</span> 这些子句主要在处理树状或图状结构数据时有用,要么单表要么跨表.You traverse edges <span class=\"keyword\">or</span> tree branches <span class=\"keyword\">from</span> <span class=\"keyword\">one</span> place <span class=\"keyword\">to</span> another, while reserving the <span class=\"keyword\">right</span> <span class=\"keyword\">to</span> come back <span class=\"keyword\">and</span> change <span class=\"keyword\">any</span> <span class=\"keyword\">of</span> these “pointer” values.</span><br><span class=\"line\"><span class=\"operator\">-</span> 所有 <span class=\"keyword\">SELECT</span> <span class=\"keyword\">FOR</span> UPDATE 与 <span class=\"keyword\">SELECT</span> <span class=\"keyword\">FOR</span> SHARE 查询的锁都在事务提交或回滚时释放.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"operator\">&gt;</span> <span class=\"operator\">*</span><span class=\"operator\">*</span>Note<span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">    <span class=\"operator\">&gt;</span></span><br><span class=\"line\">    <span class=\"operator\">&gt;</span> 锁读(locking read) 只有在 autocommit<span class=\"operator\">=</span><span class=\"number\">0</span> 时才能实现(要么使用 `<span class=\"keyword\">START</span> TRANSACTION`, 要么设置 `autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>`)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> 外部语句中的锁读子句不会对子查询语句的数据行生效. eg:</span><br><span class=\"line\"></span><br><span class=\"line\">    ```<span class=\"keyword\">sql</span></span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> (<span class=\"keyword\">SELECT</span> c1 <span class=\"keyword\">FROM</span> t2) <span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>子查询需要单独加自己的锁读子句. eg:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> (<span class=\"keyword\">SELECT</span> c1 <span class=\"keyword\">FROM</span> t2 <span class=\"keyword\">FOR</span> UPDATE) <span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-1-Locking-Read-Examples\"><a href=\"#3-1-Locking-Read-Examples\" class=\"headerlink\" title=\".3.1. Locking Read Examples\"></a>.3.1. Locking Read Examples</h3><blockquote>\n<p>假设你想在表 child 中插入一条新数据,并保证子表数据在父表 parent 表中有相应的行.你的应用代码能保证以下操作相对完整.</p>\n</blockquote>\n<ul>\n<li><p>首先,使用一致性读取 parent 表中数据以验证其数据是存在的,但还现在插入新数据到 child 表并不安全.因为其他 session 可以在查询 parent 表与插入 child 表两次操作之间将所查询到的数据删除掉.为避免此问题需要执行 SELECT … FOR SHARE :</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> parent <span class=\"keyword\">WHERE</span> NAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;Jones&#x27;</span> <span class=\"keyword\">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 FOR SHARE 查询语句将等待其他修改 parent 数据的事务执行完,在此之后读取到 parent 数据后将加锁对后来的删除修改操作阻塞到当前事务在 child 表中添加数据完成.</li>\n</ul>\n</li>\n<li><p>另一个场景: child_codes 表中有个 counter 整数计数字段用以指定 child 表中的 id .这时就算是使用 FOR SHARE 查询此字段一样会有问题.因为多个事务会读取到相同的 counter 值,使用相同的值作为 id 插入到 child 表会触发 duplicate-key error,同时当这些事务更新 counter 字段时至少有一个会以死锁收场(多个事务去更新 counter 字段但因为都执行 FOR SHARE 查询而进入等待彼此释放锁.<em>业务开发中如果需要先读取再更新就不能使用 SELECT … FOR SHARE ,因为只要在事务中先查询再更改,只要并发就会出现多个 session 都获取到 s-lock 然后再等待对方释放这个 s-lock 以执行更新语句，这就产生死锁</em>).</p>\n<ul>\n<li><p>SELECT … FOR UPDATE  将读取最新可得的数据,并在读到的行上加上排他锁.因此其回锁类似 UPDATE 语句.使用此类锁读即可解决上述问题:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> counter_field <span class=\"keyword\">FROM</span> child_codes <span class=\"keyword\">FOR</span> UPDATE;</span><br><span class=\"line\">UPDATE child_codes <span class=\"keyword\">SET</span> counter_field <span class=\"operator\">=</span> counter_field <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上述场景在 MYSQL 中可以通过单次访问表实现生成唯一 id:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE child_codes <span class=\"keyword\">SET</span> counter_field <span class=\"operator\">=</span> LAST_INSERT_ID(counter_field <span class=\"operator\">+</span> <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LAST_INSERT_ID();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中 SELECT 语句仅仅是获取当前连接的 id 信息,不访问任何表.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-Locking-Read-Concurrency-with-NOWAIT-and-SKIP-LOCKED\"><a href=\"#3-2-Locking-Read-Concurrency-with-NOWAIT-and-SKIP-LOCKED\" class=\"headerlink\" title=\".3.2. Locking Read Concurrency with NOWAIT and SKIP LOCKED\"></a>.3.2. Locking Read Concurrency with NOWAIT and SKIP LOCKED</h3><blockquote>\n<p>MYSQL 8.0 版本才开始有此选项。</p>\n<p>使用 SELECT … FOR UPDATE / SELECT FOR SHARE 在查询被其他事务锁住的行时必须等待到这些事务释放锁,这类规则在你想查询请求快速结束与可以接受被锁的查询目标不被返回到结果集的场景中是不恰当的.为满足以上两种场景,可以在 SELECT FOR UPDATE / SELECT FOR SHARE 中添加选项: NOWAIT / SKIP LOCKED。</p>\n</blockquote>\n<ul>\n<li><p>NOWAIT，不等待被锁住的行，直接返回失败。</p>\n</li>\n<li><p>SKIP LOCKED,跳过被锁住的行，返回的结果集中不包括被锁住的行。</p>\n<blockquote>\n<p>Note</p>\n<p>使用 SKIP LOCKED 返回数据不能保证一致性。因此对于一般的事务不适用，但在多 session 访问类队列的表时可以用来避开锁的概念。</p>\n</blockquote>\n</li>\n<li><p>NOWAIT 与 SKIP LOCKED 都只应用在行级锁上。</p>\n</li>\n<li><p>NOWAIT 与 SKIP LOCKED 语句对于基于复制的语句并不安全。</p>\n</li>\n<li><p>EXAMPLE：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Session <span class=\"number\">1</span>: 查询并锁住 <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t (i <span class=\"type\">INT</span>, <span class=\"keyword\">PRIMARY</span> KEY (i)) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t (i) <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>),(<span class=\"number\">2</span>),(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">WHERE</span> i <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">FOR</span> UPDATE;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> i <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">2</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Session <span class=\"number\">2</span>: NOWAIT 并发查询使用 而直接返回错误</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">WHERE</span> i <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">FOR</span> UPDATE NOWAIT;</span><br><span class=\"line\">ERROR <span class=\"number\">3572</span> (HY000): Do <span class=\"keyword\">not</span> wait <span class=\"keyword\">for</span> lock.</span><br><span class=\"line\"></span><br><span class=\"line\"># Session <span class=\"number\">3</span>: <span class=\"keyword\">SKIP</span> LOCKED 并发查询路过 <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">FOR</span> UPDATE <span class=\"keyword\">SKIP</span> LOCKED;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> i <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">1</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">3</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html\">reference</a></p>\n<p><a href=\"./InnoDB%20Transaction%20Isolation%20Level.md\">InnoDB Isolation Level Note</a></p>\n<h2 id=\"1-Autocommit-commit-rollback\"><a href=\"#1-Autocommit-commit-rollback\" class=\"headerlink\" title=\".1. Autocommit commit rollback\"></a>.1. Autocommit commit rollback</h2><p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html\">reference</a></p>\n<blockquote>\n<p>在 InnoDB 中所有用户的活动都在事务之中，如果 autocommit＝ON 每个 SQL 语句都会形成一个自有的事务。默认情况下 Ｍysql 开启一个session都会在每个连接都会设置autocommit＝on，MYSQL 只要语句没有返回错误都会提交。","more":"</p>\n</blockquote>\n<ul>\n<li>一个 session 可以在 autocommit=on 时在同一个事务中执行多个语句，只要显示地以 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 开始并以 <code>COMMIT</code>/<code>ROLLBACK</code> 结束语句。</li>\n<li>如果 autocommit=0 , session 也设置了 autocommit=0 ，那么这个 session 总会有一个事务处于打开状态。<code>COMMIT</code> <code>ROLLBACK</code> 语句会结束当前事务并开始一个新的事务。</li>\n<li>如果一个 session autocommit=0，没有显式地提交最后一个事务，MYSQL 会自动圆滚这个事务。</li>\n<li>某些语句会<a href=\"https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html\">隐式地结束一个事务</a>，在你执行语句之前好像提交过一样。</li>\n</ul>\n<h2 id=\"2-Consistent-Nonlocking-Reads\"><a href=\"#2-Consistent-Nonlocking-Reads\" class=\"headerlink\" title=\".2. Consistent Nonlocking Reads\"></a>.2. Consistent Nonlocking Reads</h2><p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html\">reference</a></p>\n<blockquote>\n<p>一致性读指 InnoDB 使用多视图给数据库某时间点快照响应查询。此查询能看到在此时间点前提交的事务的更新，在此时间点后提交的事务或未提交的更新不能被看到。此规则例外：本事务内之前语句的更新将被查询到。此类异常情况会造成：更新某表内部分行，SELECT 能够看到这些被更新的行，但也可以看到任何行的老版本。如果其他 sessions 同时更新了这张表，那么就等到了表在数据库内从未出现的状态。</p>\n</blockquote>\n<ul>\n<li><p>如果在默认的 REPEATABLE READ 隔离级别下，在相同事务中所有的一致性读都会读取第一次查询建立的快照。若要获取到更新的快照，提交当前事务并开启一个新的。</p>\n</li>\n<li><p>在 READ COMMITTED 隔离级别下，同一个事务中每个一致性读的 SETS 与 READS 都在其自己的更新的快照中进行。</p>\n</li>\n<li><p>InnoDB 在 REPEATABLE READ/READ COMMITTED 隔离级别下处理 SELECT 语句默认使用一致性读。一致性读在访问表数据时不加任何锁，所以其他 session 可以同时修改同一张表数据。</p>\n</li>\n<li><p>默认 REPEATABLE READ 隔离级别下，发起一个一致性读（普通 SELECT 语句），InnoDB 给事务的快照时间点(timepoint)取决于查询到达数据库，如果另外一个事务在此时间点后提交了插入、删除或更新，原事务是无感知的。</p>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>在一个事务中，对 SELECT 语句使用这种数据库状态快照的做法并不需要使用在 DML 语句上。如果你在事务A插入修改了一些行并提交了事务，另外一个并发的 REPEATABLE READ 事务可以影响修改这些刚提交的行，尽管有可以这个并发的事务所在的 session 还不能查询到这些事务A刚提交的修改。</p>\n<p>一个事务修改删除了刚被另一个事务提交的数据，这些修改对当前事务都会可见。</p>\n</blockquote>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(c1) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;xyz&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Returns 0: no rows match.</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;xyz&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Deletes several rows recently committed by other transaction.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(c2) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Returns 0: no rows match.</span></span><br><span class=\"line\">UPDATE t1 <span class=\"keyword\">SET</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;cba&#x27;</span> <span class=\"keyword\">WHERE</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Affects 10 rows: another txn just committed 10 rows with &#x27;abc&#x27; values.</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(c2) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;cba&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- Returns 10: this txn can now see the rows it just updated.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若要将 timepoint 提前，可以提交当前事务，并开启另一个 <code>SELECT</code> / <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code></p>\n</li>\n<li><p>这一切都叫做<strong>多视图并发控制（multi-version concurrency control）</strong>。</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                 Session A              Session B</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">SET</span> autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>;       <span class=\"keyword\">SET</span> autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">time</span></span><br><span class=\"line\">    <span class=\"operator\">|</span>           <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">    <span class=\"operator\">|</span>           <span class=\"keyword\">empty</span> <span class=\"keyword\">set</span></span><br><span class=\"line\">    <span class=\"operator\">|</span>                                   <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"operator\">|</span></span><br><span class=\"line\">    v           <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">                <span class=\"keyword\">empty</span> <span class=\"keyword\">set</span></span><br><span class=\"line\">                                        <span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">                <span class=\"keyword\">empty</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t;</span><br><span class=\"line\">                <span class=\"comment\">---------------------</span></span><br><span class=\"line\">                <span class=\"operator\">|</span>    <span class=\"number\">1</span>    <span class=\"operator\">|</span>    <span class=\"number\">2</span>    <span class=\"operator\">|</span></span><br><span class=\"line\">                <span class=\"comment\">---------------------</span></span><br><span class=\"line\">    ```<span class=\"keyword\">sql</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> 如果需要数据库最新状态，要么使用 READ COMMITTED ，要么使用 locking read: `<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">FOR</span> SHARE;`</span><br><span class=\"line\">    <span class=\"operator\">-</span> 在 READ COMMITTED 隔离级别下，事务内所有的读写都使用使用自己的快照。而对于 <span class=\"keyword\">FOR</span> SHARE 将使用锁读（locking read），<span class=\"keyword\">SELECT</span> 将阻塞直到包含最新行数据的事务结束。</span><br><span class=\"line\"><span class=\"operator\">-</span> 一致性读在特定的 DDL 语句中失效：</span><br><span class=\"line\">    <span class=\"operator\">-</span> <span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> 语句，因为 MYSQL 不能使用被删除的表且 InnoDB 将销毁此表。</span><br><span class=\"line\">    <span class=\"operator\">-</span> <span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 操作，此操作将复制表的临时拷贝并在临时拷贝建立成功时删除原表。当事务中重新发起一个一致性读，新表中的数据行在事务中快照并不存在。这种情况下事务会返回错误：ER_TABLE_DEF_CHANGED,&quot;Table definition has changed, please retry transaction&quot;.</span><br><span class=\"line\"><span class=\"operator\">-</span> 对子查询如：`<span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> ... <span class=\"keyword\">SELECT</span>` `UPDATE ... (<span class=\"keyword\">SELECT</span>)` `<span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> ... <span class=\"keyword\">SELECT</span>` 并未指定加锁（<span class=\"keyword\">for</span> update <span class=\"operator\">/</span> <span class=\"keyword\">for</span> share）:</span><br><span class=\"line\">    <span class=\"operator\">-</span> InnoDB 默认对这引起语句使用更严格的锁且 `<span class=\"keyword\">SELECT</span>` 部分使用 READ COMMITTED （在相同事务内，一致性读 sets gets 都针对其自有快照）。</span><br><span class=\"line\">    <span class=\"operator\">-</span> 执行非锁读的场景，设置事务隔离级别为 READ COMMITTED <span class=\"operator\">/</span> READ UNCOMMITTED 以避免对所选表中数据行加锁。</span><br><span class=\"line\"></span><br><span class=\"line\">## <span class=\"number\">.3</span>. Locking <span class=\"keyword\">Reads</span></span><br><span class=\"line\"></span><br><span class=\"line\">[reference](https:<span class=\"operator\">/</span><span class=\"operator\">/</span>dev.mysql.com<span class=\"operator\">/</span>doc<span class=\"operator\">/</span>refman<span class=\"operator\">/</span><span class=\"number\">8.0</span><span class=\"operator\">/</span>en<span class=\"operator\">/</span>innodb<span class=\"operator\">-</span>locking<span class=\"operator\">-</span>reads.html)</span><br><span class=\"line\"></span><br><span class=\"line\">如果你在同一个事务中查询并插入修改数据,常规的 <span class=\"keyword\">SELECT</span> 语句并不能提供足够的防御.其他事务能够修改或删除你查询到的数据.InnoDB 提供两种类型锁读 locking<span class=\"operator\">-</span>read 以增强这类防御:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE</span><br><span class=\"line\">    <span class=\"operator\">-</span> 在读取到的行上设置一个共享模式的锁.其他 session 可以读取这些行,但不能修改,直到你的事务提交.如果查询的这些行被其他事务修改并未提交,查询将等待到这些事务结束而获取到最新的值.</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"operator\">&gt;</span> <span class=\"operator\">*</span><span class=\"operator\">*</span>Note<span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">        <span class=\"operator\">&gt;</span></span><br><span class=\"line\">        <span class=\"operator\">&gt;</span> `<span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE` 是 `<span class=\"keyword\">SELECT</span> ... LOCK <span class=\"keyword\">IN</span> SHARE MODE` 的替换版本,但 `LOCK <span class=\"keyword\">IN</span> SHARE MODE` 保留了向后兼容性,两者相等.然后 `<span class=\"keyword\">FOR</span> SHARE` 支持 `<span class=\"keyword\">OF</span> table_name`, `NOWAIT`, `<span class=\"keyword\">SKIP</span> LOCKED` 选项.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"operator\">-</span> 在 mysql 版本 <span class=\"number\">8.0</span><span class=\"number\">.22</span> 之前, <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE 需要 `<span class=\"keyword\">select</span>` 权限与 <span class=\"keyword\">DELETE</span><span class=\"operator\">/</span>LOCK TABLES<span class=\"operator\">/</span>UPDATE 权限之一.在 <span class=\"number\">8.0</span><span class=\"number\">.22</span> 版本只需要 <span class=\"keyword\">SELECT</span> 权限.且在 <span class=\"number\">8.0</span> 前都语法是：`<span class=\"keyword\">SELECT</span> ... LOCK <span class=\"keyword\">IN</span> SHARE MODE`</span><br><span class=\"line\">    <span class=\"operator\">-</span> MYSQL <span class=\"number\">8.0</span><span class=\"number\">.22</span> , <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE 在 <span class=\"keyword\">grant</span> tables 上不再获取读锁.</span><br><span class=\"line\"><span class=\"operator\">-</span> <span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> UPDATE:</span><br><span class=\"line\">    <span class=\"operator\">-</span> 对于查询到的索引记录,将锁住行和与其相关的索引项,与对这些行执行 UPDATE 语句一样.其他事务将被阻塞,这些事务可能是执行 `<span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> SHARE`<span class=\"operator\">/</span>更新这些行<span class=\"operator\">/</span>某些隔离级别下的读取数据.一致性读将忽略在其视图中数据上的任何锁.(老版本记录不能被锁,对数据记录在内存备份应用 undo_log 重构能得到老版本数据.)</span><br><span class=\"line\">    <span class=\"operator\">-</span> `<span class=\"keyword\">SELECT</span> ... <span class=\"keyword\">FOR</span> UPDATE` 需要 <span class=\"keyword\">SELECT</span> 权限加至少一个 `<span class=\"keyword\">DELETE</span>` `LOCK TABLES` `UPDATE` 权限.</span><br><span class=\"line\"><span class=\"operator\">-</span> 这些子句主要在处理树状或图状结构数据时有用,要么单表要么跨表.You traverse edges <span class=\"keyword\">or</span> tree branches <span class=\"keyword\">from</span> <span class=\"keyword\">one</span> place <span class=\"keyword\">to</span> another, while reserving the <span class=\"keyword\">right</span> <span class=\"keyword\">to</span> come back <span class=\"keyword\">and</span> change <span class=\"keyword\">any</span> <span class=\"keyword\">of</span> these “pointer” values.</span><br><span class=\"line\"><span class=\"operator\">-</span> 所有 <span class=\"keyword\">SELECT</span> <span class=\"keyword\">FOR</span> UPDATE 与 <span class=\"keyword\">SELECT</span> <span class=\"keyword\">FOR</span> SHARE 查询的锁都在事务提交或回滚时释放.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"operator\">&gt;</span> <span class=\"operator\">*</span><span class=\"operator\">*</span>Note<span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">    <span class=\"operator\">&gt;</span></span><br><span class=\"line\">    <span class=\"operator\">&gt;</span> 锁读(locking read) 只有在 autocommit<span class=\"operator\">=</span><span class=\"number\">0</span> 时才能实现(要么使用 `<span class=\"keyword\">START</span> TRANSACTION`, 要么设置 `autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>`)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> 外部语句中的锁读子句不会对子查询语句的数据行生效. eg:</span><br><span class=\"line\"></span><br><span class=\"line\">    ```<span class=\"keyword\">sql</span></span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> (<span class=\"keyword\">SELECT</span> c1 <span class=\"keyword\">FROM</span> t2) <span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>子查询需要单独加自己的锁读子句. eg:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> c1 <span class=\"operator\">=</span> (<span class=\"keyword\">SELECT</span> c1 <span class=\"keyword\">FROM</span> t2 <span class=\"keyword\">FOR</span> UPDATE) <span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-1-Locking-Read-Examples\"><a href=\"#3-1-Locking-Read-Examples\" class=\"headerlink\" title=\".3.1. Locking Read Examples\"></a>.3.1. Locking Read Examples</h3><blockquote>\n<p>假设你想在表 child 中插入一条新数据,并保证子表数据在父表 parent 表中有相应的行.你的应用代码能保证以下操作相对完整.</p>\n</blockquote>\n<ul>\n<li><p>首先,使用一致性读取 parent 表中数据以验证其数据是存在的,但还现在插入新数据到 child 表并不安全.因为其他 session 可以在查询 parent 表与插入 child 表两次操作之间将所查询到的数据删除掉.为避免此问题需要执行 SELECT … FOR SHARE :</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> parent <span class=\"keyword\">WHERE</span> NAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;Jones&#x27;</span> <span class=\"keyword\">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 FOR SHARE 查询语句将等待其他修改 parent 数据的事务执行完,在此之后读取到 parent 数据后将加锁对后来的删除修改操作阻塞到当前事务在 child 表中添加数据完成.</li>\n</ul>\n</li>\n<li><p>另一个场景: child_codes 表中有个 counter 整数计数字段用以指定 child 表中的 id .这时就算是使用 FOR SHARE 查询此字段一样会有问题.因为多个事务会读取到相同的 counter 值,使用相同的值作为 id 插入到 child 表会触发 duplicate-key error,同时当这些事务更新 counter 字段时至少有一个会以死锁收场(多个事务去更新 counter 字段但因为都执行 FOR SHARE 查询而进入等待彼此释放锁.<em>业务开发中如果需要先读取再更新就不能使用 SELECT … FOR SHARE ,因为只要在事务中先查询再更改,只要并发就会出现多个 session 都获取到 s-lock 然后再等待对方释放这个 s-lock 以执行更新语句，这就产生死锁</em>).</p>\n<ul>\n<li><p>SELECT … FOR UPDATE  将读取最新可得的数据,并在读到的行上加上排他锁.因此其回锁类似 UPDATE 语句.使用此类锁读即可解决上述问题:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> counter_field <span class=\"keyword\">FROM</span> child_codes <span class=\"keyword\">FOR</span> UPDATE;</span><br><span class=\"line\">UPDATE child_codes <span class=\"keyword\">SET</span> counter_field <span class=\"operator\">=</span> counter_field <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上述场景在 MYSQL 中可以通过单次访问表实现生成唯一 id:</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE child_codes <span class=\"keyword\">SET</span> counter_field <span class=\"operator\">=</span> LAST_INSERT_ID(counter_field <span class=\"operator\">+</span> <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LAST_INSERT_ID();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中 SELECT 语句仅仅是获取当前连接的 id 信息,不访问任何表.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-Locking-Read-Concurrency-with-NOWAIT-and-SKIP-LOCKED\"><a href=\"#3-2-Locking-Read-Concurrency-with-NOWAIT-and-SKIP-LOCKED\" class=\"headerlink\" title=\".3.2. Locking Read Concurrency with NOWAIT and SKIP LOCKED\"></a>.3.2. Locking Read Concurrency with NOWAIT and SKIP LOCKED</h3><blockquote>\n<p>MYSQL 8.0 版本才开始有此选项。</p>\n<p>使用 SELECT … FOR UPDATE / SELECT FOR SHARE 在查询被其他事务锁住的行时必须等待到这些事务释放锁,这类规则在你想查询请求快速结束与可以接受被锁的查询目标不被返回到结果集的场景中是不恰当的.为满足以上两种场景,可以在 SELECT FOR UPDATE / SELECT FOR SHARE 中添加选项: NOWAIT / SKIP LOCKED。</p>\n</blockquote>\n<ul>\n<li><p>NOWAIT，不等待被锁住的行，直接返回失败。</p>\n</li>\n<li><p>SKIP LOCKED,跳过被锁住的行，返回的结果集中不包括被锁住的行。</p>\n<blockquote>\n<p>Note</p>\n<p>使用 SKIP LOCKED 返回数据不能保证一致性。因此对于一般的事务不适用，但在多 session 访问类队列的表时可以用来避开锁的概念。</p>\n</blockquote>\n</li>\n<li><p>NOWAIT 与 SKIP LOCKED 都只应用在行级锁上。</p>\n</li>\n<li><p>NOWAIT 与 SKIP LOCKED 语句对于基于复制的语句并不安全。</p>\n</li>\n<li><p>EXAMPLE：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Session <span class=\"number\">1</span>: 查询并锁住 <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t (i <span class=\"type\">INT</span>, <span class=\"keyword\">PRIMARY</span> KEY (i)) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t (i) <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>),(<span class=\"number\">2</span>),(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">WHERE</span> i <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">FOR</span> UPDATE;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> i <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">2</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Session <span class=\"number\">2</span>: NOWAIT 并发查询使用 而直接返回错误</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">WHERE</span> i <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">FOR</span> UPDATE NOWAIT;</span><br><span class=\"line\">ERROR <span class=\"number\">3572</span> (HY000): Do <span class=\"keyword\">not</span> wait <span class=\"keyword\">for</span> lock.</span><br><span class=\"line\"></span><br><span class=\"line\"># Session <span class=\"number\">3</span>: <span class=\"keyword\">SKIP</span> LOCKED 并发查询路过 <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t <span class=\"keyword\">FOR</span> UPDATE <span class=\"keyword\">SKIP</span> LOCKED;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> i <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">1</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">3</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---+</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"InnoDB","layout":"post","description":"The InnoDB Glossary","date":"2020-12-29T07:58:00.000Z","_content":"\n> [官方文档](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)\n>\n> [美团文档](https://tech.meituan.com/2014/08/20/innodb-lock.html)\n>\n> [查看Innodb引擎数据](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)\n\n## .1. Locking Readings\n\n> [锁读](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)\n\n## .2. 并发写问题\n\n> [CSDN](https://www.cnblogs.com/fengzheng/p/12557762.html)\n\n- 在并发写同一行数据时，如果 where 条件字段没有加索引，innoDB 会对所有行加行锁，再对条件进行筛选，不符合条件的行再释放锁。一锁一放损耗极大，所以建议适当添加索引。\n- 在可重复读隔离级别下，InnoDB 加间隙锁可以防止幻读，同理，如果没有索引将会把所在行之外所有列都加上间隙锁，而导致范围外的行也需要阻塞到当前锁释放才能插入。\n- 意向锁是表锁，只用来表示该表有没行正被锁住，而以免有行被锁住时想要加表锁修改表结构，需要每行查询是否有行锁。<!--more-->\n\n### .2.1. Consistent Read\n\n> [一致性读](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read)\n\n- 在事务中使用一致性读可以避免并发，在读已提交和可重复读隔离级别中，默认是使用一致性读的。\n\n## .3. Multi-Versioning\n\n> [多版本](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)\n\n- 覆盖索引 cover-index 在查询的字段都在索引结构中，而不需要通过回表查询主键\n    - 普通二级索引就是一种覆盖索引，其除索引字段外还包括了主键。\n    - 当二级索引记录被标记为删除或被其他事务更新，覆盖索引技术不能被应用。\n\n## .4. InnoDB Locking\n\n> [锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)\n\n### .4.1. 共享锁与排他锁\n\n> Shared and Exclusive Locks。Innodb 实现两种标准行锁：shared（S） lock 与 exclusive（X） lock。\n\n- S 锁允许获取到锁的事务读取该行\n- X 锁允许获取到锁的事务修改、更新该行\n- 如果一个事务T1获取到行 r 的 S 锁，另一个事务T2需要获取 r 的锁的规则：\n    - T2请求获取 r 的 S 锁，能够马上得到\n    - T2 请求获取 r 的 X 锁，不能立即成功\n- 如果 T1 获取到的是 r 的X 锁，其他事务想要获取 r 的任何类型锁都需要等待 T1 释放了 r 的锁才行。\n\n### .4.2. 意向锁\n\n> Intention lock，分为排他意向锁 IX 与共享意向锁 IS。用以支撑 InnoDB 多粒度锁控制（行锁与表锁同时存在）。\n> `LOCK TABLES ... WRITE` 语句持有指定表的排他 X 锁。\n\n- 表级锁，用以标明事务在之后的行操作上所需要的锁类型。\n- 意向锁的两种形式：\n    - IS 表明一个事务要设置一个 S 锁到表中某（多）行数据；\n    - IX 表明一个事务要设置一个 X 锁到表中某（多）行数据。\n- `SELECT ... FOR SHARE` 将设置一个 IS 锁，而 `SELECT ... FOR UPDATE` 将设置一个 IX 锁。\n- 意向锁协议：\n    - 事务获取行 S 锁前需要获取该表的一个 IS 锁或更强的锁 （IX）；\n    - 事务要获取表中行的 X 锁 前，需要先取得该表的一个 IX 锁。\n- 表级锁兼容性矩阵表：\n\n|   |X       |IX        |S         |IS        |\n|:-:|--------|----------|----------|----------|\n|X  |conflict|conflict  |conflict  |conflict  |\n|IX |conflict|compatible|conflict  |compatible|\n|S  |conflict|conflict  |compatible|compatible|\n|IS |conflict|compatible|compatible|compatible|\n\n- 如果一个事务想获取一个已存在的锁且不能被获取到，将产生**死锁**。\n- 意向锁不阻塞其他，但若要请求全表除外（`LOCK TABLES ... WRITE`）。\n\n### .4.3. 记录锁\n\n> record_lock：`select * from t where f = 10 for update;`\n\n- 用于锁住单行数据，阻止其他事务**插入**、**更新**、**删除**（不阻止其他事务读取） f ＝ 10 的行。\n- record_lock 只会锁索引记录，如果表中没有建索引，Innodb 将会创建一个隐藏的聚簇索引，并使用此索引来锁住行。\n\n### .4.4. 间隙锁\n\n> Gap Locks, 间隙锁是加在索引记录之间的锁，或在间隙记录之前或之后。`SELECT c1 FROM t WHERE c1 BETWEEN 10 AND 20 FOR UPDATE;`，此语句所加的间隙锁阻止了其他事务的插入一个 t.c1 = 15 的行，不管表 t 中是否已有一条同值记录，因为间隙锁将锁住范围内的所有行。\n\n- **使用唯一索引作为查询条件的单行查询是不需要添加间隙锁的**（查询条件包含多个键组成的唯一索引中部分列名除外）。eg：对于列 id 有唯一索引的表执行的语句：`SELECT * FROM t WHERE id = 10;` 只会添加 record lock 到行，不管是否有其他会话在该行间隙前插入新行。如果 id 列并未加唯一索引，此语句将锁住间隙前。\n- 间隙锁是纯抑制性的，排它锁与共享锁在 gap-lock 这儿没有区别，同时，同一个 gap 可以有多个 gap-lock，**只用来抑制其他事务在间隙插入新的数据**。冲突的锁能在 gap 这儿并存的原因是如果索引记录被清除，记录上不同事务的间隙锁必须被合并。\n- 在读已提交隔离级别下，间隙锁对查询、索引扫描无效，仅对外键约束、重复键检查有效。\n    - 在 READ COMMITTED 隔离级别下，不匹配行的 record－lock 在 mysql 计算出 where 条件后就释放。对于 UPDATE 语句，Innodb 只保持半一致性：返回最近提交的版本给 Mysql，以让 Mysql 可以决定各行是否满足 UPdate 条件。\n\n### .4.5. Next-Key Lock\n\n> 后键锁，是一个 record-lock 与 gap-lock 的组合。\n\n- record-lock 用以锁住索引所在行数据，而 gap-lock 锁住当前行前的间隙，以防止前面部分插入新的数据。\n- 默认情况下,InoDB 在可重复读的隔离级别下查询与索引扫描会使用 Next-Key lock 防止幻读。*由此可推断 InnoDB 索引 B+ tree 中叶子节点中的数据排列界限是左开右闭的，只有这样才做到只使用左界加间隙锁就可以防止幻读。同时插入已存在的数据时是从左边插入的。*\n- 假设某索引包括值: 10,11,13,20 .那么在此索引上可能被 next-key lock 锁住的区间就包括:(负无穷大, 10] (10,12] (11,13] (13,20] (20,正无穷大) 4个区间\n    - 对于任何一个区间, next-key lock 会用一个 record-lock 锁住其右界值,同时在右界值到左界(不包含)的区间加上 gap-lock 防止插入新值.\n    - 对于最后一个区间, InnoDB 会使用一个伪最大值 supremum (大于此索引中任何一个值), 这个 supremum 并不真实存在于索引中,所以对于最后一个区间只使用了 gap-lock.\n\n### .4.6. Insert intention locks\n\n> 插入意向锁, 用在插入操作中插入行前设置的一种间隙锁. 此锁用来标识插入同一个索引间隙的多个事务之间如果不插入在同一个位置,那么事务之间无需等待彼此.eg:假设现有索引值 4 与 7 ,另有两个事务尝试各自插入 5 与 6 .**插入意向锁的获取优先于插入行的排他锁获取**,但彼此不阻塞因为各行并不冲突.\n\n对于包含一个索引值有 90 和 102 的表,client A 先在 id > 100 的索引记录上添加了排他锁,这个排他锁包含了 (90, 102] 的 gap-lock\n\n```sql\nmysql> CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;\nmysql> INSERT INTO child (id) values (90),(102);\n\nmysql> START TRANSACTION;\nmysql> SELECT * FROM child WHERE id > 100 FOR UPDATE;\n```\n\nclient B 执行:\n\n```sql\nmysql> START TRANSACTION;\nmysql> INSERT INTO child (id) VALUES (101);\n```\n\nclient B 在间隙中插入新数据,这个事务将会拿到 insert-intention-lock 同时等待获取排他锁.\n\n### .4.7. Auto-inc Locks\n\n> 自增锁,事务在插入包含自增列 AUTO_INCREMENT 的表数据时所持有的表级锁.在最简单的场景,如果一个事务在往表中插入数据,其他插入数据的事务必须等待,以保证前事务能获取到连续的主键值.\n\ninnodb_autoinc_lock_mode 配置控制自增锁的算法.此配置值用以在自增值的有序性与插入操作的并发性上平衡.\n\n```sql\nCREATE PROCEDURE reTry(IN count INT, OUT res INT)\nBEGIN\n  DECLARE v1 INT DEFAULT 0;\n  WHILE v1 < count DO\n    UPDATE test SET value = value + 1;\n    set v1 = v1 + 1;\n  END WHILE;\nEND;\n```\n","source":"_posts/Mysql/InnoDB.md","raw":"---\ntitle: InnoDB\nlayout: post\ntag: [mysql, InnoDB, InnoDB Locking]\ncategories: [Mysql]\ndescription: The InnoDB Glossary\ndate: \"2020-12-29 15:58:00\"\n---\n\n> [官方文档](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)\n>\n> [美团文档](https://tech.meituan.com/2014/08/20/innodb-lock.html)\n>\n> [查看Innodb引擎数据](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)\n\n## .1. Locking Readings\n\n> [锁读](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)\n\n## .2. 并发写问题\n\n> [CSDN](https://www.cnblogs.com/fengzheng/p/12557762.html)\n\n- 在并发写同一行数据时，如果 where 条件字段没有加索引，innoDB 会对所有行加行锁，再对条件进行筛选，不符合条件的行再释放锁。一锁一放损耗极大，所以建议适当添加索引。\n- 在可重复读隔离级别下，InnoDB 加间隙锁可以防止幻读，同理，如果没有索引将会把所在行之外所有列都加上间隙锁，而导致范围外的行也需要阻塞到当前锁释放才能插入。\n- 意向锁是表锁，只用来表示该表有没行正被锁住，而以免有行被锁住时想要加表锁修改表结构，需要每行查询是否有行锁。<!--more-->\n\n### .2.1. Consistent Read\n\n> [一致性读](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read)\n\n- 在事务中使用一致性读可以避免并发，在读已提交和可重复读隔离级别中，默认是使用一致性读的。\n\n## .3. Multi-Versioning\n\n> [多版本](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)\n\n- 覆盖索引 cover-index 在查询的字段都在索引结构中，而不需要通过回表查询主键\n    - 普通二级索引就是一种覆盖索引，其除索引字段外还包括了主键。\n    - 当二级索引记录被标记为删除或被其他事务更新，覆盖索引技术不能被应用。\n\n## .4. InnoDB Locking\n\n> [锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)\n\n### .4.1. 共享锁与排他锁\n\n> Shared and Exclusive Locks。Innodb 实现两种标准行锁：shared（S） lock 与 exclusive（X） lock。\n\n- S 锁允许获取到锁的事务读取该行\n- X 锁允许获取到锁的事务修改、更新该行\n- 如果一个事务T1获取到行 r 的 S 锁，另一个事务T2需要获取 r 的锁的规则：\n    - T2请求获取 r 的 S 锁，能够马上得到\n    - T2 请求获取 r 的 X 锁，不能立即成功\n- 如果 T1 获取到的是 r 的X 锁，其他事务想要获取 r 的任何类型锁都需要等待 T1 释放了 r 的锁才行。\n\n### .4.2. 意向锁\n\n> Intention lock，分为排他意向锁 IX 与共享意向锁 IS。用以支撑 InnoDB 多粒度锁控制（行锁与表锁同时存在）。\n> `LOCK TABLES ... WRITE` 语句持有指定表的排他 X 锁。\n\n- 表级锁，用以标明事务在之后的行操作上所需要的锁类型。\n- 意向锁的两种形式：\n    - IS 表明一个事务要设置一个 S 锁到表中某（多）行数据；\n    - IX 表明一个事务要设置一个 X 锁到表中某（多）行数据。\n- `SELECT ... FOR SHARE` 将设置一个 IS 锁，而 `SELECT ... FOR UPDATE` 将设置一个 IX 锁。\n- 意向锁协议：\n    - 事务获取行 S 锁前需要获取该表的一个 IS 锁或更强的锁 （IX）；\n    - 事务要获取表中行的 X 锁 前，需要先取得该表的一个 IX 锁。\n- 表级锁兼容性矩阵表：\n\n|   |X       |IX        |S         |IS        |\n|:-:|--------|----------|----------|----------|\n|X  |conflict|conflict  |conflict  |conflict  |\n|IX |conflict|compatible|conflict  |compatible|\n|S  |conflict|conflict  |compatible|compatible|\n|IS |conflict|compatible|compatible|compatible|\n\n- 如果一个事务想获取一个已存在的锁且不能被获取到，将产生**死锁**。\n- 意向锁不阻塞其他，但若要请求全表除外（`LOCK TABLES ... WRITE`）。\n\n### .4.3. 记录锁\n\n> record_lock：`select * from t where f = 10 for update;`\n\n- 用于锁住单行数据，阻止其他事务**插入**、**更新**、**删除**（不阻止其他事务读取） f ＝ 10 的行。\n- record_lock 只会锁索引记录，如果表中没有建索引，Innodb 将会创建一个隐藏的聚簇索引，并使用此索引来锁住行。\n\n### .4.4. 间隙锁\n\n> Gap Locks, 间隙锁是加在索引记录之间的锁，或在间隙记录之前或之后。`SELECT c1 FROM t WHERE c1 BETWEEN 10 AND 20 FOR UPDATE;`，此语句所加的间隙锁阻止了其他事务的插入一个 t.c1 = 15 的行，不管表 t 中是否已有一条同值记录，因为间隙锁将锁住范围内的所有行。\n\n- **使用唯一索引作为查询条件的单行查询是不需要添加间隙锁的**（查询条件包含多个键组成的唯一索引中部分列名除外）。eg：对于列 id 有唯一索引的表执行的语句：`SELECT * FROM t WHERE id = 10;` 只会添加 record lock 到行，不管是否有其他会话在该行间隙前插入新行。如果 id 列并未加唯一索引，此语句将锁住间隙前。\n- 间隙锁是纯抑制性的，排它锁与共享锁在 gap-lock 这儿没有区别，同时，同一个 gap 可以有多个 gap-lock，**只用来抑制其他事务在间隙插入新的数据**。冲突的锁能在 gap 这儿并存的原因是如果索引记录被清除，记录上不同事务的间隙锁必须被合并。\n- 在读已提交隔离级别下，间隙锁对查询、索引扫描无效，仅对外键约束、重复键检查有效。\n    - 在 READ COMMITTED 隔离级别下，不匹配行的 record－lock 在 mysql 计算出 where 条件后就释放。对于 UPDATE 语句，Innodb 只保持半一致性：返回最近提交的版本给 Mysql，以让 Mysql 可以决定各行是否满足 UPdate 条件。\n\n### .4.5. Next-Key Lock\n\n> 后键锁，是一个 record-lock 与 gap-lock 的组合。\n\n- record-lock 用以锁住索引所在行数据，而 gap-lock 锁住当前行前的间隙，以防止前面部分插入新的数据。\n- 默认情况下,InoDB 在可重复读的隔离级别下查询与索引扫描会使用 Next-Key lock 防止幻读。*由此可推断 InnoDB 索引 B+ tree 中叶子节点中的数据排列界限是左开右闭的，只有这样才做到只使用左界加间隙锁就可以防止幻读。同时插入已存在的数据时是从左边插入的。*\n- 假设某索引包括值: 10,11,13,20 .那么在此索引上可能被 next-key lock 锁住的区间就包括:(负无穷大, 10] (10,12] (11,13] (13,20] (20,正无穷大) 4个区间\n    - 对于任何一个区间, next-key lock 会用一个 record-lock 锁住其右界值,同时在右界值到左界(不包含)的区间加上 gap-lock 防止插入新值.\n    - 对于最后一个区间, InnoDB 会使用一个伪最大值 supremum (大于此索引中任何一个值), 这个 supremum 并不真实存在于索引中,所以对于最后一个区间只使用了 gap-lock.\n\n### .4.6. Insert intention locks\n\n> 插入意向锁, 用在插入操作中插入行前设置的一种间隙锁. 此锁用来标识插入同一个索引间隙的多个事务之间如果不插入在同一个位置,那么事务之间无需等待彼此.eg:假设现有索引值 4 与 7 ,另有两个事务尝试各自插入 5 与 6 .**插入意向锁的获取优先于插入行的排他锁获取**,但彼此不阻塞因为各行并不冲突.\n\n对于包含一个索引值有 90 和 102 的表,client A 先在 id > 100 的索引记录上添加了排他锁,这个排他锁包含了 (90, 102] 的 gap-lock\n\n```sql\nmysql> CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;\nmysql> INSERT INTO child (id) values (90),(102);\n\nmysql> START TRANSACTION;\nmysql> SELECT * FROM child WHERE id > 100 FOR UPDATE;\n```\n\nclient B 执行:\n\n```sql\nmysql> START TRANSACTION;\nmysql> INSERT INTO child (id) VALUES (101);\n```\n\nclient B 在间隙中插入新数据,这个事务将会拿到 insert-intention-lock 同时等待获取排他锁.\n\n### .4.7. Auto-inc Locks\n\n> 自增锁,事务在插入包含自增列 AUTO_INCREMENT 的表数据时所持有的表级锁.在最简单的场景,如果一个事务在往表中插入数据,其他插入数据的事务必须等待,以保证前事务能获取到连续的主键值.\n\ninnodb_autoinc_lock_mode 配置控制自增锁的算法.此配置值用以在自增值的有序性与插入操作的并发性上平衡.\n\n```sql\nCREATE PROCEDURE reTry(IN count INT, OUT res INT)\nBEGIN\n  DECLARE v1 INT DEFAULT 0;\n  WHILE v1 < count DO\n    UPDATE test SET value = value + 1;\n    set v1 = v1 + 1;\n  END WHILE;\nEND;\n```\n","slug":"Mysql/InnoDB","published":1,"updated":"2021-02-24T15:22:22.896Z","comments":1,"photos":[],"link":"","_id":"ckljnokrb001m2bhb9ayyexuk","content":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html\">官方文档</a></p>\n<p><a href=\"https://tech.meituan.com/2014/08/20/innodb-lock.html\">美团文档</a></p>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/show-engine.html\">查看Innodb引擎数据</a></p>\n</blockquote>\n<h2 id=\"1-Locking-Readings\"><a href=\"#1-Locking-Readings\" class=\"headerlink\" title=\".1. Locking Readings\"></a>.1. Locking Readings</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html\">锁读</a></p>\n</blockquote>\n<h2 id=\"2-并发写问题\"><a href=\"#2-并发写问题\" class=\"headerlink\" title=\".2. 并发写问题\"></a>.2. 并发写问题</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/fengzheng/p/12557762.html\">CSDN</a></p>\n</blockquote>\n<ul>\n<li>在并发写同一行数据时，如果 where 条件字段没有加索引，innoDB 会对所有行加行锁，再对条件进行筛选，不符合条件的行再释放锁。一锁一放损耗极大，所以建议适当添加索引。</li>\n<li>在可重复读隔离级别下，InnoDB 加间隙锁可以防止幻读，同理，如果没有索引将会把所在行之外所有列都加上间隙锁，而导致范围外的行也需要阻塞到当前锁释放才能插入。</li>\n<li>意向锁是表锁，只用来表示该表有没行正被锁住，而以免有行被锁住时想要加表锁修改表结构，需要每行查询是否有行锁。<span id=\"more\"></span></li>\n</ul>\n<h3 id=\"2-1-Consistent-Read\"><a href=\"#2-1-Consistent-Read\" class=\"headerlink\" title=\".2.1. Consistent Read\"></a>.2.1. Consistent Read</h3><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read\">一致性读</a></p>\n</blockquote>\n<ul>\n<li>在事务中使用一致性读可以避免并发，在读已提交和可重复读隔离级别中，默认是使用一致性读的。</li>\n</ul>\n<h2 id=\"3-Multi-Versioning\"><a href=\"#3-Multi-Versioning\" class=\"headerlink\" title=\".3. Multi-Versioning\"></a>.3. Multi-Versioning</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html\">多版本</a></p>\n</blockquote>\n<ul>\n<li>覆盖索引 cover-index 在查询的字段都在索引结构中，而不需要通过回表查询主键<ul>\n<li>普通二级索引就是一种覆盖索引，其除索引字段外还包括了主键。</li>\n<li>当二级索引记录被标记为删除或被其他事务更新，覆盖索引技术不能被应用。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-InnoDB-Locking\"><a href=\"#4-InnoDB-Locking\" class=\"headerlink\" title=\".4. InnoDB Locking\"></a>.4. InnoDB Locking</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html\">锁</a></p>\n</blockquote>\n<h3 id=\"4-1-共享锁与排他锁\"><a href=\"#4-1-共享锁与排他锁\" class=\"headerlink\" title=\".4.1. 共享锁与排他锁\"></a>.4.1. 共享锁与排他锁</h3><blockquote>\n<p>Shared and Exclusive Locks。Innodb 实现两种标准行锁：shared（S） lock 与 exclusive（X） lock。</p>\n</blockquote>\n<ul>\n<li>S 锁允许获取到锁的事务读取该行</li>\n<li>X 锁允许获取到锁的事务修改、更新该行</li>\n<li>如果一个事务T1获取到行 r 的 S 锁，另一个事务T2需要获取 r 的锁的规则：<ul>\n<li>T2请求获取 r 的 S 锁，能够马上得到</li>\n<li>T2 请求获取 r 的 X 锁，不能立即成功</li>\n</ul>\n</li>\n<li>如果 T1 获取到的是 r 的X 锁，其他事务想要获取 r 的任何类型锁都需要等待 T1 释放了 r 的锁才行。</li>\n</ul>\n<h3 id=\"4-2-意向锁\"><a href=\"#4-2-意向锁\" class=\"headerlink\" title=\".4.2. 意向锁\"></a>.4.2. 意向锁</h3><blockquote>\n<p>Intention lock，分为排他意向锁 IX 与共享意向锁 IS。用以支撑 InnoDB 多粒度锁控制（行锁与表锁同时存在）。<br><code>LOCK TABLES ... WRITE</code> 语句持有指定表的排他 X 锁。</p>\n</blockquote>\n<ul>\n<li>表级锁，用以标明事务在之后的行操作上所需要的锁类型。</li>\n<li>意向锁的两种形式：<ul>\n<li>IS 表明一个事务要设置一个 S 锁到表中某（多）行数据；</li>\n<li>IX 表明一个事务要设置一个 X 锁到表中某（多）行数据。</li>\n</ul>\n</li>\n<li><code>SELECT ... FOR SHARE</code> 将设置一个 IS 锁，而 <code>SELECT ... FOR UPDATE</code> 将设置一个 IX 锁。</li>\n<li>意向锁协议：<ul>\n<li>事务获取行 S 锁前需要获取该表的一个 IS 锁或更强的锁 （IX）；</li>\n<li>事务要获取表中行的 X 锁 前，需要先取得该表的一个 IX 锁。</li>\n</ul>\n</li>\n<li>表级锁兼容性矩阵表：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th>X</th>\n<th>IX</th>\n<th>S</th>\n<th>IS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">X</td>\n<td>conflict</td>\n<td>conflict</td>\n<td>conflict</td>\n<td>conflict</td>\n</tr>\n<tr>\n<td align=\"center\">IX</td>\n<td>conflict</td>\n<td>compatible</td>\n<td>conflict</td>\n<td>compatible</td>\n</tr>\n<tr>\n<td align=\"center\">S</td>\n<td>conflict</td>\n<td>conflict</td>\n<td>compatible</td>\n<td>compatible</td>\n</tr>\n<tr>\n<td align=\"center\">IS</td>\n<td>conflict</td>\n<td>compatible</td>\n<td>compatible</td>\n<td>compatible</td>\n</tr>\n</tbody></table>\n<ul>\n<li>如果一个事务想获取一个已存在的锁且不能被获取到，将产生<strong>死锁</strong>。</li>\n<li>意向锁不阻塞其他，但若要请求全表除外（<code>LOCK TABLES ... WRITE</code>）。</li>\n</ul>\n<h3 id=\"4-3-记录锁\"><a href=\"#4-3-记录锁\" class=\"headerlink\" title=\".4.3. 记录锁\"></a>.4.3. 记录锁</h3><blockquote>\n<p>record_lock：<code>select * from t where f = 10 for update;</code></p>\n</blockquote>\n<ul>\n<li>用于锁住单行数据，阻止其他事务<strong>插入</strong>、<strong>更新</strong>、<strong>删除</strong>（不阻止其他事务读取） f ＝ 10 的行。</li>\n<li>record_lock 只会锁索引记录，如果表中没有建索引，Innodb 将会创建一个隐藏的聚簇索引，并使用此索引来锁住行。</li>\n</ul>\n<h3 id=\"4-4-间隙锁\"><a href=\"#4-4-间隙锁\" class=\"headerlink\" title=\".4.4. 间隙锁\"></a>.4.4. 间隙锁</h3><blockquote>\n<p>Gap Locks, 间隙锁是加在索引记录之间的锁，或在间隙记录之前或之后。<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 AND 20 FOR UPDATE;</code>，此语句所加的间隙锁阻止了其他事务的插入一个 t.c1 = 15 的行，不管表 t 中是否已有一条同值记录，因为间隙锁将锁住范围内的所有行。</p>\n</blockquote>\n<ul>\n<li><strong>使用唯一索引作为查询条件的单行查询是不需要添加间隙锁的</strong>（查询条件包含多个键组成的唯一索引中部分列名除外）。eg：对于列 id 有唯一索引的表执行的语句：<code>SELECT * FROM t WHERE id = 10;</code> 只会添加 record lock 到行，不管是否有其他会话在该行间隙前插入新行。如果 id 列并未加唯一索引，此语句将锁住间隙前。</li>\n<li>间隙锁是纯抑制性的，排它锁与共享锁在 gap-lock 这儿没有区别，同时，同一个 gap 可以有多个 gap-lock，<strong>只用来抑制其他事务在间隙插入新的数据</strong>。冲突的锁能在 gap 这儿并存的原因是如果索引记录被清除，记录上不同事务的间隙锁必须被合并。</li>\n<li>在读已提交隔离级别下，间隙锁对查询、索引扫描无效，仅对外键约束、重复键检查有效。<ul>\n<li>在 READ COMMITTED 隔离级别下，不匹配行的 record－lock 在 mysql 计算出 where 条件后就释放。对于 UPDATE 语句，Innodb 只保持半一致性：返回最近提交的版本给 Mysql，以让 Mysql 可以决定各行是否满足 UPdate 条件。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-Next-Key-Lock\"><a href=\"#4-5-Next-Key-Lock\" class=\"headerlink\" title=\".4.5. Next-Key Lock\"></a>.4.5. Next-Key Lock</h3><blockquote>\n<p>后键锁，是一个 record-lock 与 gap-lock 的组合。</p>\n</blockquote>\n<ul>\n<li>record-lock 用以锁住索引所在行数据，而 gap-lock 锁住当前行前的间隙，以防止前面部分插入新的数据。</li>\n<li>默认情况下,InoDB 在可重复读的隔离级别下查询与索引扫描会使用 Next-Key lock 防止幻读。<em>由此可推断 InnoDB 索引 B+ tree 中叶子节点中的数据排列界限是左开右闭的，只有这样才做到只使用左界加间隙锁就可以防止幻读。同时插入已存在的数据时是从左边插入的。</em></li>\n<li>假设某索引包括值: 10,11,13,20 .那么在此索引上可能被 next-key lock 锁住的区间就包括:(负无穷大, 10] (10,12] (11,13] (13,20] (20,正无穷大) 4个区间<ul>\n<li>对于任何一个区间, next-key lock 会用一个 record-lock 锁住其右界值,同时在右界值到左界(不包含)的区间加上 gap-lock 防止插入新值.</li>\n<li>对于最后一个区间, InnoDB 会使用一个伪最大值 supremum (大于此索引中任何一个值), 这个 supremum 并不真实存在于索引中,所以对于最后一个区间只使用了 gap-lock.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-6-Insert-intention-locks\"><a href=\"#4-6-Insert-intention-locks\" class=\"headerlink\" title=\".4.6. Insert intention locks\"></a>.4.6. Insert intention locks</h3><blockquote>\n<p>插入意向锁, 用在插入操作中插入行前设置的一种间隙锁. 此锁用来标识插入同一个索引间隙的多个事务之间如果不插入在同一个位置,那么事务之间无需等待彼此.eg:假设现有索引值 4 与 7 ,另有两个事务尝试各自插入 5 与 6 .<strong>插入意向锁的获取优先于插入行的排他锁获取</strong>,但彼此不阻塞因为各行并不冲突.</p>\n</blockquote>\n<p>对于包含一个索引值有 90 和 102 的表,client A 先在 id &gt; 100 的索引记录上添加了排他锁,这个排他锁包含了 (90, 102] 的 gap-lock</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> child (id <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>, <span class=\"keyword\">PRIMARY</span> KEY(id)) ENGINE<span class=\"operator\">=</span>InnoDB;</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> child (id) <span class=\"keyword\">values</span> (<span class=\"number\">90</span>),(<span class=\"number\">102</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> child <span class=\"keyword\">WHERE</span> id <span class=\"operator\">&gt;</span> <span class=\"number\">100</span> <span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n\n<p>client B 执行:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> child (id) <span class=\"keyword\">VALUES</span> (<span class=\"number\">101</span>);</span><br></pre></td></tr></table></figure>\n\n<p>client B 在间隙中插入新数据,这个事务将会拿到 insert-intention-lock 同时等待获取排他锁.</p>\n<h3 id=\"4-7-Auto-inc-Locks\"><a href=\"#4-7-Auto-inc-Locks\" class=\"headerlink\" title=\".4.7. Auto-inc Locks\"></a>.4.7. Auto-inc Locks</h3><blockquote>\n<p>自增锁,事务在插入包含自增列 AUTO_INCREMENT 的表数据时所持有的表级锁.在最简单的场景,如果一个事务在往表中插入数据,其他插入数据的事务必须等待,以保证前事务能获取到连续的主键值.</p>\n</blockquote>\n<p>innodb_autoinc_lock_mode 配置控制自增锁的算法.此配置值用以在自增值的有序性与插入操作的并发性上平衡.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> reTry(<span class=\"keyword\">IN</span> count <span class=\"type\">INT</span>, <span class=\"keyword\">OUT</span> res <span class=\"type\">INT</span>)</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">  <span class=\"keyword\">DECLARE</span> v1 <span class=\"type\">INT</span> <span class=\"keyword\">DEFAULT</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  WHILE v1 <span class=\"operator\">&lt;</span> count DO</span><br><span class=\"line\">    UPDATE test <span class=\"keyword\">SET</span> <span class=\"keyword\">value</span> <span class=\"operator\">=</span> <span class=\"keyword\">value</span> <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> v1 <span class=\"operator\">=</span> v1 <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">END</span> WHILE;</span><br><span class=\"line\"><span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html\">官方文档</a></p>\n<p><a href=\"https://tech.meituan.com/2014/08/20/innodb-lock.html\">美团文档</a></p>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/show-engine.html\">查看Innodb引擎数据</a></p>\n</blockquote>\n<h2 id=\"1-Locking-Readings\"><a href=\"#1-Locking-Readings\" class=\"headerlink\" title=\".1. Locking Readings\"></a>.1. Locking Readings</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html\">锁读</a></p>\n</blockquote>\n<h2 id=\"2-并发写问题\"><a href=\"#2-并发写问题\" class=\"headerlink\" title=\".2. 并发写问题\"></a>.2. 并发写问题</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/fengzheng/p/12557762.html\">CSDN</a></p>\n</blockquote>\n<ul>\n<li>在并发写同一行数据时，如果 where 条件字段没有加索引，innoDB 会对所有行加行锁，再对条件进行筛选，不符合条件的行再释放锁。一锁一放损耗极大，所以建议适当添加索引。</li>\n<li>在可重复读隔离级别下，InnoDB 加间隙锁可以防止幻读，同理，如果没有索引将会把所在行之外所有列都加上间隙锁，而导致范围外的行也需要阻塞到当前锁释放才能插入。</li>\n<li>意向锁是表锁，只用来表示该表有没行正被锁住，而以免有行被锁住时想要加表锁修改表结构，需要每行查询是否有行锁。","more":"</li>\n</ul>\n<h3 id=\"2-1-Consistent-Read\"><a href=\"#2-1-Consistent-Read\" class=\"headerlink\" title=\".2.1. Consistent Read\"></a>.2.1. Consistent Read</h3><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read\">一致性读</a></p>\n</blockquote>\n<ul>\n<li>在事务中使用一致性读可以避免并发，在读已提交和可重复读隔离级别中，默认是使用一致性读的。</li>\n</ul>\n<h2 id=\"3-Multi-Versioning\"><a href=\"#3-Multi-Versioning\" class=\"headerlink\" title=\".3. Multi-Versioning\"></a>.3. Multi-Versioning</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html\">多版本</a></p>\n</blockquote>\n<ul>\n<li>覆盖索引 cover-index 在查询的字段都在索引结构中，而不需要通过回表查询主键<ul>\n<li>普通二级索引就是一种覆盖索引，其除索引字段外还包括了主键。</li>\n<li>当二级索引记录被标记为删除或被其他事务更新，覆盖索引技术不能被应用。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-InnoDB-Locking\"><a href=\"#4-InnoDB-Locking\" class=\"headerlink\" title=\".4. InnoDB Locking\"></a>.4. InnoDB Locking</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html\">锁</a></p>\n</blockquote>\n<h3 id=\"4-1-共享锁与排他锁\"><a href=\"#4-1-共享锁与排他锁\" class=\"headerlink\" title=\".4.1. 共享锁与排他锁\"></a>.4.1. 共享锁与排他锁</h3><blockquote>\n<p>Shared and Exclusive Locks。Innodb 实现两种标准行锁：shared（S） lock 与 exclusive（X） lock。</p>\n</blockquote>\n<ul>\n<li>S 锁允许获取到锁的事务读取该行</li>\n<li>X 锁允许获取到锁的事务修改、更新该行</li>\n<li>如果一个事务T1获取到行 r 的 S 锁，另一个事务T2需要获取 r 的锁的规则：<ul>\n<li>T2请求获取 r 的 S 锁，能够马上得到</li>\n<li>T2 请求获取 r 的 X 锁，不能立即成功</li>\n</ul>\n</li>\n<li>如果 T1 获取到的是 r 的X 锁，其他事务想要获取 r 的任何类型锁都需要等待 T1 释放了 r 的锁才行。</li>\n</ul>\n<h3 id=\"4-2-意向锁\"><a href=\"#4-2-意向锁\" class=\"headerlink\" title=\".4.2. 意向锁\"></a>.4.2. 意向锁</h3><blockquote>\n<p>Intention lock，分为排他意向锁 IX 与共享意向锁 IS。用以支撑 InnoDB 多粒度锁控制（行锁与表锁同时存在）。<br><code>LOCK TABLES ... WRITE</code> 语句持有指定表的排他 X 锁。</p>\n</blockquote>\n<ul>\n<li>表级锁，用以标明事务在之后的行操作上所需要的锁类型。</li>\n<li>意向锁的两种形式：<ul>\n<li>IS 表明一个事务要设置一个 S 锁到表中某（多）行数据；</li>\n<li>IX 表明一个事务要设置一个 X 锁到表中某（多）行数据。</li>\n</ul>\n</li>\n<li><code>SELECT ... FOR SHARE</code> 将设置一个 IS 锁，而 <code>SELECT ... FOR UPDATE</code> 将设置一个 IX 锁。</li>\n<li>意向锁协议：<ul>\n<li>事务获取行 S 锁前需要获取该表的一个 IS 锁或更强的锁 （IX）；</li>\n<li>事务要获取表中行的 X 锁 前，需要先取得该表的一个 IX 锁。</li>\n</ul>\n</li>\n<li>表级锁兼容性矩阵表：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th>X</th>\n<th>IX</th>\n<th>S</th>\n<th>IS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">X</td>\n<td>conflict</td>\n<td>conflict</td>\n<td>conflict</td>\n<td>conflict</td>\n</tr>\n<tr>\n<td align=\"center\">IX</td>\n<td>conflict</td>\n<td>compatible</td>\n<td>conflict</td>\n<td>compatible</td>\n</tr>\n<tr>\n<td align=\"center\">S</td>\n<td>conflict</td>\n<td>conflict</td>\n<td>compatible</td>\n<td>compatible</td>\n</tr>\n<tr>\n<td align=\"center\">IS</td>\n<td>conflict</td>\n<td>compatible</td>\n<td>compatible</td>\n<td>compatible</td>\n</tr>\n</tbody></table>\n<ul>\n<li>如果一个事务想获取一个已存在的锁且不能被获取到，将产生<strong>死锁</strong>。</li>\n<li>意向锁不阻塞其他，但若要请求全表除外（<code>LOCK TABLES ... WRITE</code>）。</li>\n</ul>\n<h3 id=\"4-3-记录锁\"><a href=\"#4-3-记录锁\" class=\"headerlink\" title=\".4.3. 记录锁\"></a>.4.3. 记录锁</h3><blockquote>\n<p>record_lock：<code>select * from t where f = 10 for update;</code></p>\n</blockquote>\n<ul>\n<li>用于锁住单行数据，阻止其他事务<strong>插入</strong>、<strong>更新</strong>、<strong>删除</strong>（不阻止其他事务读取） f ＝ 10 的行。</li>\n<li>record_lock 只会锁索引记录，如果表中没有建索引，Innodb 将会创建一个隐藏的聚簇索引，并使用此索引来锁住行。</li>\n</ul>\n<h3 id=\"4-4-间隙锁\"><a href=\"#4-4-间隙锁\" class=\"headerlink\" title=\".4.4. 间隙锁\"></a>.4.4. 间隙锁</h3><blockquote>\n<p>Gap Locks, 间隙锁是加在索引记录之间的锁，或在间隙记录之前或之后。<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 AND 20 FOR UPDATE;</code>，此语句所加的间隙锁阻止了其他事务的插入一个 t.c1 = 15 的行，不管表 t 中是否已有一条同值记录，因为间隙锁将锁住范围内的所有行。</p>\n</blockquote>\n<ul>\n<li><strong>使用唯一索引作为查询条件的单行查询是不需要添加间隙锁的</strong>（查询条件包含多个键组成的唯一索引中部分列名除外）。eg：对于列 id 有唯一索引的表执行的语句：<code>SELECT * FROM t WHERE id = 10;</code> 只会添加 record lock 到行，不管是否有其他会话在该行间隙前插入新行。如果 id 列并未加唯一索引，此语句将锁住间隙前。</li>\n<li>间隙锁是纯抑制性的，排它锁与共享锁在 gap-lock 这儿没有区别，同时，同一个 gap 可以有多个 gap-lock，<strong>只用来抑制其他事务在间隙插入新的数据</strong>。冲突的锁能在 gap 这儿并存的原因是如果索引记录被清除，记录上不同事务的间隙锁必须被合并。</li>\n<li>在读已提交隔离级别下，间隙锁对查询、索引扫描无效，仅对外键约束、重复键检查有效。<ul>\n<li>在 READ COMMITTED 隔离级别下，不匹配行的 record－lock 在 mysql 计算出 where 条件后就释放。对于 UPDATE 语句，Innodb 只保持半一致性：返回最近提交的版本给 Mysql，以让 Mysql 可以决定各行是否满足 UPdate 条件。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-Next-Key-Lock\"><a href=\"#4-5-Next-Key-Lock\" class=\"headerlink\" title=\".4.5. Next-Key Lock\"></a>.4.5. Next-Key Lock</h3><blockquote>\n<p>后键锁，是一个 record-lock 与 gap-lock 的组合。</p>\n</blockquote>\n<ul>\n<li>record-lock 用以锁住索引所在行数据，而 gap-lock 锁住当前行前的间隙，以防止前面部分插入新的数据。</li>\n<li>默认情况下,InoDB 在可重复读的隔离级别下查询与索引扫描会使用 Next-Key lock 防止幻读。<em>由此可推断 InnoDB 索引 B+ tree 中叶子节点中的数据排列界限是左开右闭的，只有这样才做到只使用左界加间隙锁就可以防止幻读。同时插入已存在的数据时是从左边插入的。</em></li>\n<li>假设某索引包括值: 10,11,13,20 .那么在此索引上可能被 next-key lock 锁住的区间就包括:(负无穷大, 10] (10,12] (11,13] (13,20] (20,正无穷大) 4个区间<ul>\n<li>对于任何一个区间, next-key lock 会用一个 record-lock 锁住其右界值,同时在右界值到左界(不包含)的区间加上 gap-lock 防止插入新值.</li>\n<li>对于最后一个区间, InnoDB 会使用一个伪最大值 supremum (大于此索引中任何一个值), 这个 supremum 并不真实存在于索引中,所以对于最后一个区间只使用了 gap-lock.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-6-Insert-intention-locks\"><a href=\"#4-6-Insert-intention-locks\" class=\"headerlink\" title=\".4.6. Insert intention locks\"></a>.4.6. Insert intention locks</h3><blockquote>\n<p>插入意向锁, 用在插入操作中插入行前设置的一种间隙锁. 此锁用来标识插入同一个索引间隙的多个事务之间如果不插入在同一个位置,那么事务之间无需等待彼此.eg:假设现有索引值 4 与 7 ,另有两个事务尝试各自插入 5 与 6 .<strong>插入意向锁的获取优先于插入行的排他锁获取</strong>,但彼此不阻塞因为各行并不冲突.</p>\n</blockquote>\n<p>对于包含一个索引值有 90 和 102 的表,client A 先在 id &gt; 100 的索引记录上添加了排他锁,这个排他锁包含了 (90, 102] 的 gap-lock</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> child (id <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>, <span class=\"keyword\">PRIMARY</span> KEY(id)) ENGINE<span class=\"operator\">=</span>InnoDB;</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> child (id) <span class=\"keyword\">values</span> (<span class=\"number\">90</span>),(<span class=\"number\">102</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> child <span class=\"keyword\">WHERE</span> id <span class=\"operator\">&gt;</span> <span class=\"number\">100</span> <span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n\n<p>client B 执行:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> child (id) <span class=\"keyword\">VALUES</span> (<span class=\"number\">101</span>);</span><br></pre></td></tr></table></figure>\n\n<p>client B 在间隙中插入新数据,这个事务将会拿到 insert-intention-lock 同时等待获取排他锁.</p>\n<h3 id=\"4-7-Auto-inc-Locks\"><a href=\"#4-7-Auto-inc-Locks\" class=\"headerlink\" title=\".4.7. Auto-inc Locks\"></a>.4.7. Auto-inc Locks</h3><blockquote>\n<p>自增锁,事务在插入包含自增列 AUTO_INCREMENT 的表数据时所持有的表级锁.在最简单的场景,如果一个事务在往表中插入数据,其他插入数据的事务必须等待,以保证前事务能获取到连续的主键值.</p>\n</blockquote>\n<p>innodb_autoinc_lock_mode 配置控制自增锁的算法.此配置值用以在自增值的有序性与插入操作的并发性上平衡.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> reTry(<span class=\"keyword\">IN</span> count <span class=\"type\">INT</span>, <span class=\"keyword\">OUT</span> res <span class=\"type\">INT</span>)</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">  <span class=\"keyword\">DECLARE</span> v1 <span class=\"type\">INT</span> <span class=\"keyword\">DEFAULT</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  WHILE v1 <span class=\"operator\">&lt;</span> count DO</span><br><span class=\"line\">    UPDATE test <span class=\"keyword\">SET</span> <span class=\"keyword\">value</span> <span class=\"operator\">=</span> <span class=\"keyword\">value</span> <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> v1 <span class=\"operator\">=</span> v1 <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">END</span> WHILE;</span><br><span class=\"line\"><span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure>"},{"title":"Locks set by different SQL","layout":"post","description":"Locks set by different SQL in the InnoDB","date":"2021-01-07T02:04:00.000Z","_content":"\n> [reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html)\n>\n> 对于一个　locking－read、UPDATE、DELETE 的处理过程中通常只对被扫描到的索引记录加锁，不管 where 条件中其他条件所排除的行。InnoDB 不记忆具体 WHERE 条件，只记忆被扫描的索引范围。所加之锁一般为 next－key lock ，除对表记录行加锁外还在其前加上 gap－lock 。gap－lock 可被显示地禁用造成 next-key lock 失效，另外事务隔离级别也会影响锁。<!--more-->\n\n- 如果二级索引在查询中被使用且不设置 record_lock ，InnoDB 将会查出聚簇索引并把锁加在上面。\n- 如果语句中没有合适的索引，MYSQL 处理语句时必须扫描全表，表中每行数据将被锁住，这就意味着其他用户的插入与更新都会被阻塞。所以恰当的索引对于查询性能举足轻重。\n\n## .1. InnoDB 加锁类型\n\n- `SELECT ... FROM` 是一致性读，一般情况下只读取数据库快照，不会加锁。在事务隔离级别为 SERIALIZABLE 时会被转换成 LOCK IN SHARE MODE，查询将会在其找到的记录前加上 next-key lock 。如果使用唯一索引查询单条记录，就只需要一个 index-record lock。\n- `SELECT ... FOR UPDATE`/`SELECT ... LOCK IN SHARE MODE` 被扫描的索引记录都将加锁，并期望尽快地释放不匹配 WHERE 条件的行的锁。在某些场景，结果集与源数据之间的关系在查询中丢失，将导致这些行的锁不能立即释放。如：在 UNION 被扫描到的行在被计算出是否匹配结果集前可能会被插入到一张临时表中。这种情况下，临时表的行与源数据行的关系会丢失，并且源数据行在查询执行结束前不会解锁。\n- `SELECT ... LOCK IN SHARE MODE` 在其查询到的索引记录加**共享 next-key lock** ，如果查询语句只使用唯一索引查询唯一的行，只需要加一个 index-record lock。\n- `SELECT ... FOR UPDATE` 对查询到的索引记录加**排他 next-key lock**。当使用唯一索引查询单行时只对该行加锁。\n    - `FOR UPDATE` 排他锁会阻塞其他 session 的 `LOCK IN SHARE MODE` 或者在某些特定隔离级别（SERIALIZABLE ?）的读取。一致性读忽略任何在所查询索引记录上的锁。\n- `UPDATE ... WHERE ...` 对查询到的索引记录加排他 next-key lock ,如果使用唯一索引查询单行，只需要加一个 index-record lock。\n- 当 `UPDATE` 修改一条聚簇索引记录时，所影响到的二级索引记录会被隐式地加锁。UPDATE 操作会在执行插入新二级索引时与这之前的重复检查扫描所针对的二级索引加 s-lock。\n- `DELETE FROM ... WHERE ...` 会设置一个排他的 next-key lock 在每个查询到的行上。但如果是使用唯一索引查询单行就只会添加一个 index-record lock 在所查询行上。\n\n### .1.1. 插入语句\n\n- `INSERT` 会在所插入的行添加 x-lock 。这个锁是一个 index-record lock，而非　 next-key lock （没有 gap-lock）。不能阻止其他 session 在插入行的前面执行插入新记录。\n- 在插入行之前，会加一种叫插入意向间隙锁（insert-intention gap lock）的锁。这类锁用以标明[多个事务要在同一个 gap 中不同位置插入记录时无需等待彼此](./InnoDB.md)。\n- 如果发生 duplicate-key error，会在 duplicate-key 记录请求上安排一个 s-lock (在请求插入的事务上安排，将请求一个 s-lock)。如果另有一个 session 已经有了 x-lock，而另外多个 session 请求插入同一行将产生死锁。\n\n#### .1.1.1. examples\n\n    ```sql\n    -- create table t1\n    CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;\n\n    -- Now suppose that three sessions perform the following operations in order:\n    -- session1:\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session 2:\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session 3:\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session 1 :\n    ROLLBACK;\n    ```\n\n    - 第一个操作 session 1 将获取到 x-lock。session2 与 session3 执行时都先产生 duplicate-key error，都请求获取该行的 s-lock 。当 session1 回滚，释放 x-lock，session２ 与 session3 的 s-lock 请求将获取成功。这时 session2 与 session3 进入死锁，因为都因为对方持有 s-lock 不能获取到 x-lock。\n\n    又如：\n\n    ```sql\n    -- A similar situation occurs if the table already contains a row with key value 1 and three sessions perform the following operations in order:\n    -- session1\n    START TRANSACTION;\n    DELETE FROM t1 WHERE i = 1;\n    -- session2\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session3\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session1\n    COMMIT;\n    ```\n\n    - session1 获取到 x-lock ，而 session2，session3 执行时发生 duplicate-key error 并请求 s-lock 。当 session1 committed 释放锁，session２,session3 获取到 s-lock 进入到死锁状态，因为对方持有 s-lock 而都不能获取到需要的 x-lock 。\n","source":"_posts/Mysql/Locks set by Different Sql Statements in InnoDB.md","raw":"---\ntitle: Locks set by different SQL\nlayout: post\ntag: [mysql, InnoDB, lock, SQL]\ncategories: [Mysql]\ndescription: Locks set by different SQL in the InnoDB\ndate: \"2021-1-7 10:04:00\"\n---\n\n> [reference](https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html)\n>\n> 对于一个　locking－read、UPDATE、DELETE 的处理过程中通常只对被扫描到的索引记录加锁，不管 where 条件中其他条件所排除的行。InnoDB 不记忆具体 WHERE 条件，只记忆被扫描的索引范围。所加之锁一般为 next－key lock ，除对表记录行加锁外还在其前加上 gap－lock 。gap－lock 可被显示地禁用造成 next-key lock 失效，另外事务隔离级别也会影响锁。<!--more-->\n\n- 如果二级索引在查询中被使用且不设置 record_lock ，InnoDB 将会查出聚簇索引并把锁加在上面。\n- 如果语句中没有合适的索引，MYSQL 处理语句时必须扫描全表，表中每行数据将被锁住，这就意味着其他用户的插入与更新都会被阻塞。所以恰当的索引对于查询性能举足轻重。\n\n## .1. InnoDB 加锁类型\n\n- `SELECT ... FROM` 是一致性读，一般情况下只读取数据库快照，不会加锁。在事务隔离级别为 SERIALIZABLE 时会被转换成 LOCK IN SHARE MODE，查询将会在其找到的记录前加上 next-key lock 。如果使用唯一索引查询单条记录，就只需要一个 index-record lock。\n- `SELECT ... FOR UPDATE`/`SELECT ... LOCK IN SHARE MODE` 被扫描的索引记录都将加锁，并期望尽快地释放不匹配 WHERE 条件的行的锁。在某些场景，结果集与源数据之间的关系在查询中丢失，将导致这些行的锁不能立即释放。如：在 UNION 被扫描到的行在被计算出是否匹配结果集前可能会被插入到一张临时表中。这种情况下，临时表的行与源数据行的关系会丢失，并且源数据行在查询执行结束前不会解锁。\n- `SELECT ... LOCK IN SHARE MODE` 在其查询到的索引记录加**共享 next-key lock** ，如果查询语句只使用唯一索引查询唯一的行，只需要加一个 index-record lock。\n- `SELECT ... FOR UPDATE` 对查询到的索引记录加**排他 next-key lock**。当使用唯一索引查询单行时只对该行加锁。\n    - `FOR UPDATE` 排他锁会阻塞其他 session 的 `LOCK IN SHARE MODE` 或者在某些特定隔离级别（SERIALIZABLE ?）的读取。一致性读忽略任何在所查询索引记录上的锁。\n- `UPDATE ... WHERE ...` 对查询到的索引记录加排他 next-key lock ,如果使用唯一索引查询单行，只需要加一个 index-record lock。\n- 当 `UPDATE` 修改一条聚簇索引记录时，所影响到的二级索引记录会被隐式地加锁。UPDATE 操作会在执行插入新二级索引时与这之前的重复检查扫描所针对的二级索引加 s-lock。\n- `DELETE FROM ... WHERE ...` 会设置一个排他的 next-key lock 在每个查询到的行上。但如果是使用唯一索引查询单行就只会添加一个 index-record lock 在所查询行上。\n\n### .1.1. 插入语句\n\n- `INSERT` 会在所插入的行添加 x-lock 。这个锁是一个 index-record lock，而非　 next-key lock （没有 gap-lock）。不能阻止其他 session 在插入行的前面执行插入新记录。\n- 在插入行之前，会加一种叫插入意向间隙锁（insert-intention gap lock）的锁。这类锁用以标明[多个事务要在同一个 gap 中不同位置插入记录时无需等待彼此](./InnoDB.md)。\n- 如果发生 duplicate-key error，会在 duplicate-key 记录请求上安排一个 s-lock (在请求插入的事务上安排，将请求一个 s-lock)。如果另有一个 session 已经有了 x-lock，而另外多个 session 请求插入同一行将产生死锁。\n\n#### .1.1.1. examples\n\n    ```sql\n    -- create table t1\n    CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;\n\n    -- Now suppose that three sessions perform the following operations in order:\n    -- session1:\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session 2:\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session 3:\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session 1 :\n    ROLLBACK;\n    ```\n\n    - 第一个操作 session 1 将获取到 x-lock。session2 与 session3 执行时都先产生 duplicate-key error，都请求获取该行的 s-lock 。当 session1 回滚，释放 x-lock，session２ 与 session3 的 s-lock 请求将获取成功。这时 session2 与 session3 进入死锁，因为都因为对方持有 s-lock 不能获取到 x-lock。\n\n    又如：\n\n    ```sql\n    -- A similar situation occurs if the table already contains a row with key value 1 and three sessions perform the following operations in order:\n    -- session1\n    START TRANSACTION;\n    DELETE FROM t1 WHERE i = 1;\n    -- session2\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session3\n    START TRANSACTION;\n    INSERT INTO t1 VALUES(1);\n    -- session1\n    COMMIT;\n    ```\n\n    - session1 获取到 x-lock ，而 session2，session3 执行时发生 duplicate-key error 并请求 s-lock 。当 session1 committed 释放锁，session２,session3 获取到 s-lock 进入到死锁状态，因为对方持有 s-lock 而都不能获取到需要的 x-lock 。\n","slug":"Mysql/Locks set by Different Sql Statements in InnoDB","published":1,"updated":"2021-02-24T15:22:22.896Z","comments":1,"photos":[],"link":"","_id":"ckljnokre001o2bhbat7u4ome","content":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html\">reference</a></p>\n<p>对于一个　locking－read、UPDATE、DELETE 的处理过程中通常只对被扫描到的索引记录加锁，不管 where 条件中其他条件所排除的行。InnoDB 不记忆具体 WHERE 条件，只记忆被扫描的索引范围。所加之锁一般为 next－key lock ，除对表记录行加锁外还在其前加上 gap－lock 。gap－lock 可被显示地禁用造成 next-key lock 失效，另外事务隔离级别也会影响锁。<span id=\"more\"></span></p>\n</blockquote>\n<ul>\n<li>如果二级索引在查询中被使用且不设置 record_lock ，InnoDB 将会查出聚簇索引并把锁加在上面。</li>\n<li>如果语句中没有合适的索引，MYSQL 处理语句时必须扫描全表，表中每行数据将被锁住，这就意味着其他用户的插入与更新都会被阻塞。所以恰当的索引对于查询性能举足轻重。</li>\n</ul>\n<h2 id=\"1-InnoDB-加锁类型\"><a href=\"#1-InnoDB-加锁类型\" class=\"headerlink\" title=\".1. InnoDB 加锁类型\"></a>.1. InnoDB 加锁类型</h2><ul>\n<li><code>SELECT ... FROM</code> 是一致性读，一般情况下只读取数据库快照，不会加锁。在事务隔离级别为 SERIALIZABLE 时会被转换成 LOCK IN SHARE MODE，查询将会在其找到的记录前加上 next-key lock 。如果使用唯一索引查询单条记录，就只需要一个 index-record lock。</li>\n<li><code>SELECT ... FOR UPDATE</code>/<code>SELECT ... LOCK IN SHARE MODE</code> 被扫描的索引记录都将加锁，并期望尽快地释放不匹配 WHERE 条件的行的锁。在某些场景，结果集与源数据之间的关系在查询中丢失，将导致这些行的锁不能立即释放。如：在 UNION 被扫描到的行在被计算出是否匹配结果集前可能会被插入到一张临时表中。这种情况下，临时表的行与源数据行的关系会丢失，并且源数据行在查询执行结束前不会解锁。</li>\n<li><code>SELECT ... LOCK IN SHARE MODE</code> 在其查询到的索引记录加<strong>共享 next-key lock</strong> ，如果查询语句只使用唯一索引查询唯一的行，只需要加一个 index-record lock。</li>\n<li><code>SELECT ... FOR UPDATE</code> 对查询到的索引记录加<strong>排他 next-key lock</strong>。当使用唯一索引查询单行时只对该行加锁。<ul>\n<li><code>FOR UPDATE</code> 排他锁会阻塞其他 session 的 <code>LOCK IN SHARE MODE</code> 或者在某些特定隔离级别（SERIALIZABLE ?）的读取。一致性读忽略任何在所查询索引记录上的锁。</li>\n</ul>\n</li>\n<li><code>UPDATE ... WHERE ...</code> 对查询到的索引记录加排他 next-key lock ,如果使用唯一索引查询单行，只需要加一个 index-record lock。</li>\n<li>当 <code>UPDATE</code> 修改一条聚簇索引记录时，所影响到的二级索引记录会被隐式地加锁。UPDATE 操作会在执行插入新二级索引时与这之前的重复检查扫描所针对的二级索引加 s-lock。</li>\n<li><code>DELETE FROM ... WHERE ...</code> 会设置一个排他的 next-key lock 在每个查询到的行上。但如果是使用唯一索引查询单行就只会添加一个 index-record lock 在所查询行上。</li>\n</ul>\n<h3 id=\"1-1-插入语句\"><a href=\"#1-1-插入语句\" class=\"headerlink\" title=\".1.1. 插入语句\"></a>.1.1. 插入语句</h3><ul>\n<li><code>INSERT</code> 会在所插入的行添加 x-lock 。这个锁是一个 index-record lock，而非　 next-key lock （没有 gap-lock）。不能阻止其他 session 在插入行的前面执行插入新记录。</li>\n<li>在插入行之前，会加一种叫插入意向间隙锁（insert-intention gap lock）的锁。这类锁用以标明<a href=\"./InnoDB.md\">多个事务要在同一个 gap 中不同位置插入记录时无需等待彼此</a>。</li>\n<li>如果发生 duplicate-key error，会在 duplicate-key 记录请求上安排一个 s-lock (在请求插入的事务上安排，将请求一个 s-lock)。如果另有一个 session 已经有了 x-lock，而另外多个 session 请求插入同一行将产生死锁。</li>\n</ul>\n<h4 id=\"1-1-1-examples\"><a href=\"#1-1-1-examples\" class=\"headerlink\" title=\".1.1.1. examples\"></a>.1.1.1. examples</h4><pre><code><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- create table t1</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t1 (i <span class=\"type\">INT</span>, <span class=\"keyword\">PRIMARY</span> KEY (i)) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Now suppose that three sessions perform the following operations in order:</span></span><br><span class=\"line\"><span class=\"comment\">-- session1:</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session 2:</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session 3:</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session 1 :</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>\n\n- 第一个操作 session 1 将获取到 x-lock。session2 与 session3 执行时都先产生 duplicate-key error，都请求获取该行的 s-lock 。当 session1 回滚，释放 x-lock，session２ 与 session3 的 s-lock 请求将获取成功。这时 session2 与 session3 进入死锁，因为都因为对方持有 s-lock 不能获取到 x-lock。\n\n又如：\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- A similar situation occurs if the table already contains a row with key value 1 and three sessions perform the following operations in order:</span></span><br><span class=\"line\"><span class=\"comment\">-- session1</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> i <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">-- session2</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session3</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session1</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n- session1 获取到 x-lock ，而 session2，session3 执行时发生 duplicate-key error 并请求 s-lock 。当 session1 committed 释放锁，session２,session3 获取到 s-lock 进入到死锁状态，因为对方持有 s-lock 而都不能获取到需要的 x-lock 。\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html\">reference</a></p>\n<p>对于一个　locking－read、UPDATE、DELETE 的处理过程中通常只对被扫描到的索引记录加锁，不管 where 条件中其他条件所排除的行。InnoDB 不记忆具体 WHERE 条件，只记忆被扫描的索引范围。所加之锁一般为 next－key lock ，除对表记录行加锁外还在其前加上 gap－lock 。gap－lock 可被显示地禁用造成 next-key lock 失效，另外事务隔离级别也会影响锁。","more":"</p>\n</blockquote>\n<ul>\n<li>如果二级索引在查询中被使用且不设置 record_lock ，InnoDB 将会查出聚簇索引并把锁加在上面。</li>\n<li>如果语句中没有合适的索引，MYSQL 处理语句时必须扫描全表，表中每行数据将被锁住，这就意味着其他用户的插入与更新都会被阻塞。所以恰当的索引对于查询性能举足轻重。</li>\n</ul>\n<h2 id=\"1-InnoDB-加锁类型\"><a href=\"#1-InnoDB-加锁类型\" class=\"headerlink\" title=\".1. InnoDB 加锁类型\"></a>.1. InnoDB 加锁类型</h2><ul>\n<li><code>SELECT ... FROM</code> 是一致性读，一般情况下只读取数据库快照，不会加锁。在事务隔离级别为 SERIALIZABLE 时会被转换成 LOCK IN SHARE MODE，查询将会在其找到的记录前加上 next-key lock 。如果使用唯一索引查询单条记录，就只需要一个 index-record lock。</li>\n<li><code>SELECT ... FOR UPDATE</code>/<code>SELECT ... LOCK IN SHARE MODE</code> 被扫描的索引记录都将加锁，并期望尽快地释放不匹配 WHERE 条件的行的锁。在某些场景，结果集与源数据之间的关系在查询中丢失，将导致这些行的锁不能立即释放。如：在 UNION 被扫描到的行在被计算出是否匹配结果集前可能会被插入到一张临时表中。这种情况下，临时表的行与源数据行的关系会丢失，并且源数据行在查询执行结束前不会解锁。</li>\n<li><code>SELECT ... LOCK IN SHARE MODE</code> 在其查询到的索引记录加<strong>共享 next-key lock</strong> ，如果查询语句只使用唯一索引查询唯一的行，只需要加一个 index-record lock。</li>\n<li><code>SELECT ... FOR UPDATE</code> 对查询到的索引记录加<strong>排他 next-key lock</strong>。当使用唯一索引查询单行时只对该行加锁。<ul>\n<li><code>FOR UPDATE</code> 排他锁会阻塞其他 session 的 <code>LOCK IN SHARE MODE</code> 或者在某些特定隔离级别（SERIALIZABLE ?）的读取。一致性读忽略任何在所查询索引记录上的锁。</li>\n</ul>\n</li>\n<li><code>UPDATE ... WHERE ...</code> 对查询到的索引记录加排他 next-key lock ,如果使用唯一索引查询单行，只需要加一个 index-record lock。</li>\n<li>当 <code>UPDATE</code> 修改一条聚簇索引记录时，所影响到的二级索引记录会被隐式地加锁。UPDATE 操作会在执行插入新二级索引时与这之前的重复检查扫描所针对的二级索引加 s-lock。</li>\n<li><code>DELETE FROM ... WHERE ...</code> 会设置一个排他的 next-key lock 在每个查询到的行上。但如果是使用唯一索引查询单行就只会添加一个 index-record lock 在所查询行上。</li>\n</ul>\n<h3 id=\"1-1-插入语句\"><a href=\"#1-1-插入语句\" class=\"headerlink\" title=\".1.1. 插入语句\"></a>.1.1. 插入语句</h3><ul>\n<li><code>INSERT</code> 会在所插入的行添加 x-lock 。这个锁是一个 index-record lock，而非　 next-key lock （没有 gap-lock）。不能阻止其他 session 在插入行的前面执行插入新记录。</li>\n<li>在插入行之前，会加一种叫插入意向间隙锁（insert-intention gap lock）的锁。这类锁用以标明<a href=\"./InnoDB.md\">多个事务要在同一个 gap 中不同位置插入记录时无需等待彼此</a>。</li>\n<li>如果发生 duplicate-key error，会在 duplicate-key 记录请求上安排一个 s-lock (在请求插入的事务上安排，将请求一个 s-lock)。如果另有一个 session 已经有了 x-lock，而另外多个 session 请求插入同一行将产生死锁。</li>\n</ul>\n<h4 id=\"1-1-1-examples\"><a href=\"#1-1-1-examples\" class=\"headerlink\" title=\".1.1.1. examples\"></a>.1.1.1. examples</h4><pre><code><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- create table t1</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t1 (i <span class=\"type\">INT</span>, <span class=\"keyword\">PRIMARY</span> KEY (i)) ENGINE <span class=\"operator\">=</span> InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Now suppose that three sessions perform the following operations in order:</span></span><br><span class=\"line\"><span class=\"comment\">-- session1:</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session 2:</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session 3:</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session 1 :</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>\n\n- 第一个操作 session 1 将获取到 x-lock。session2 与 session3 执行时都先产生 duplicate-key error，都请求获取该行的 s-lock 。当 session1 回滚，释放 x-lock，session２ 与 session3 的 s-lock 请求将获取成功。这时 session2 与 session3 进入死锁，因为都因为对方持有 s-lock 不能获取到 x-lock。\n\n又如：\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- A similar situation occurs if the table already contains a row with key value 1 and three sessions perform the following operations in order:</span></span><br><span class=\"line\"><span class=\"comment\">-- session1</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">WHERE</span> i <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">-- session2</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session3</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t1 <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- session1</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n- session1 获取到 x-lock ，而 session2，session3 执行时发生 duplicate-key error 并请求 s-lock 。当 session1 committed 释放锁，session２,session3 获取到 s-lock 进入到死锁状态，因为对方持有 s-lock 而都不能获取到需要的 x-lock 。\n</code></pre>"},{"title":"Phantom Rows","layout":"post","description":"Phantom rows && prevention","date":"2021-01-12T13:12:00.000Z","_content":"\n# 1. Phantom Rows\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html)\n>\n> 在一个事务中执行相同的查询得到不同的数据谓之为*幻读*。比如：在一个 SELECT 两次执行中，第二次查询到一行第一次查询时没有行。这一行就叫*幻读行*。<!--more-->\n\n假如表 child 中定义了索引行 id，现在需要读取 id 大于100并加锁以在后面更新一些行，其 sql 语句：`SELECT * FROM child WHERE id > 100 FOR UPDATE;`\n\n假设现在这张表中有 id=90,102 两行数据，如果只加 index-lock 但不对 gap-lock （90,102]，其他 session 则可以插入新行 id=101。这个时候原事务中如果再执行查询语句将会读取到 id=101 这行新数据。如果我们将多行数据示为一个数据项，这条幻行数据就打破了事务运行的隔离原则（数据在事务运行期间不改变）。\n\nInnoDB 使用 next-key lock 算法来阻止幻读。next-key lock 由 index-row lock 与 gap-lock 组成。当 InnoDB 执行查询或表索引扫描时设置 s-lock 或 x-lock 在其查询到（encounter）的 索引记录（index-record）上。因此这个 row-level lock 实际就是 index-record lock。此外还有一个 gap-lock 加在记录前的 gap 。\n\n当 InnoDB 扫描一个索引时，也会在最后一个记录之后加上 gap-lock 。对上面的例子，为阻止其他 session 插入 id>100 的数据，InnoDB 会在 id=102 记录后的 gap 加上锁。\n\n可以使用 next-key lock 实现唯一性检查：如果使用 share 模式读取未查询到想要插入的重复行，那就可以安全地插入行，next-key lock 会在读取时设置到行上以阻止同时想要插入的重复行。也就是说，next-key lock 锁住了表中并不存在的行。","source":"_posts/Mysql/Phantom Rows.md","raw":"---\ntitle: Phantom Rows\nlayout: post\ntag: [mysql, InnoDB, Lock]\ncategories: [Mysql]\ndescription: Phantom rows && prevention\ndate: \"2021-1-12 21:12:00\"\n---\n\n# 1. Phantom Rows\n\n> [reference](https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html)\n>\n> 在一个事务中执行相同的查询得到不同的数据谓之为*幻读*。比如：在一个 SELECT 两次执行中，第二次查询到一行第一次查询时没有行。这一行就叫*幻读行*。<!--more-->\n\n假如表 child 中定义了索引行 id，现在需要读取 id 大于100并加锁以在后面更新一些行，其 sql 语句：`SELECT * FROM child WHERE id > 100 FOR UPDATE;`\n\n假设现在这张表中有 id=90,102 两行数据，如果只加 index-lock 但不对 gap-lock （90,102]，其他 session 则可以插入新行 id=101。这个时候原事务中如果再执行查询语句将会读取到 id=101 这行新数据。如果我们将多行数据示为一个数据项，这条幻行数据就打破了事务运行的隔离原则（数据在事务运行期间不改变）。\n\nInnoDB 使用 next-key lock 算法来阻止幻读。next-key lock 由 index-row lock 与 gap-lock 组成。当 InnoDB 执行查询或表索引扫描时设置 s-lock 或 x-lock 在其查询到（encounter）的 索引记录（index-record）上。因此这个 row-level lock 实际就是 index-record lock。此外还有一个 gap-lock 加在记录前的 gap 。\n\n当 InnoDB 扫描一个索引时，也会在最后一个记录之后加上 gap-lock 。对上面的例子，为阻止其他 session 插入 id>100 的数据，InnoDB 会在 id=102 记录后的 gap 加上锁。\n\n可以使用 next-key lock 实现唯一性检查：如果使用 share 模式读取未查询到想要插入的重复行，那就可以安全地插入行，next-key lock 会在读取时设置到行上以阻止同时想要插入的重复行。也就是说，next-key lock 锁住了表中并不存在的行。","slug":"Mysql/Phantom Rows","published":1,"updated":"2021-02-24T15:22:22.896Z","comments":1,"photos":[],"link":"","_id":"ckljnokrf001q2bhb7rc8g4pv","content":"<h1 id=\"1-Phantom-Rows\"><a href=\"#1-Phantom-Rows\" class=\"headerlink\" title=\"1. Phantom Rows\"></a>1. Phantom Rows</h1><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html\">reference</a></p>\n<p>在一个事务中执行相同的查询得到不同的数据谓之为<em>幻读</em>。比如：在一个 SELECT 两次执行中，第二次查询到一行第一次查询时没有行。这一行就叫<em>幻读行</em>。<span id=\"more\"></span></p>\n</blockquote>\n<p>假如表 child 中定义了索引行 id，现在需要读取 id 大于100并加锁以在后面更新一些行，其 sql 语句：<code>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</code></p>\n<p>假设现在这张表中有 id=90,102 两行数据，如果只加 index-lock 但不对 gap-lock （90,102]，其他 session 则可以插入新行 id=101。这个时候原事务中如果再执行查询语句将会读取到 id=101 这行新数据。如果我们将多行数据示为一个数据项，这条幻行数据就打破了事务运行的隔离原则（数据在事务运行期间不改变）。</p>\n<p>InnoDB 使用 next-key lock 算法来阻止幻读。next-key lock 由 index-row lock 与 gap-lock 组成。当 InnoDB 执行查询或表索引扫描时设置 s-lock 或 x-lock 在其查询到（encounter）的 索引记录（index-record）上。因此这个 row-level lock 实际就是 index-record lock。此外还有一个 gap-lock 加在记录前的 gap 。</p>\n<p>当 InnoDB 扫描一个索引时，也会在最后一个记录之后加上 gap-lock 。对上面的例子，为阻止其他 session 插入 id&gt;100 的数据，InnoDB 会在 id=102 记录后的 gap 加上锁。</p>\n<p>可以使用 next-key lock 实现唯一性检查：如果使用 share 模式读取未查询到想要插入的重复行，那就可以安全地插入行，next-key lock 会在读取时设置到行上以阻止同时想要插入的重复行。也就是说，next-key lock 锁住了表中并不存在的行。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Phantom-Rows\"><a href=\"#1-Phantom-Rows\" class=\"headerlink\" title=\"1. Phantom Rows\"></a>1. Phantom Rows</h1><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html\">reference</a></p>\n<p>在一个事务中执行相同的查询得到不同的数据谓之为<em>幻读</em>。比如：在一个 SELECT 两次执行中，第二次查询到一行第一次查询时没有行。这一行就叫<em>幻读行</em>。","more":"</p>\n</blockquote>\n<p>假如表 child 中定义了索引行 id，现在需要读取 id 大于100并加锁以在后面更新一些行，其 sql 语句：<code>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</code></p>\n<p>假设现在这张表中有 id=90,102 两行数据，如果只加 index-lock 但不对 gap-lock （90,102]，其他 session 则可以插入新行 id=101。这个时候原事务中如果再执行查询语句将会读取到 id=101 这行新数据。如果我们将多行数据示为一个数据项，这条幻行数据就打破了事务运行的隔离原则（数据在事务运行期间不改变）。</p>\n<p>InnoDB 使用 next-key lock 算法来阻止幻读。next-key lock 由 index-row lock 与 gap-lock 组成。当 InnoDB 执行查询或表索引扫描时设置 s-lock 或 x-lock 在其查询到（encounter）的 索引记录（index-record）上。因此这个 row-level lock 实际就是 index-record lock。此外还有一个 gap-lock 加在记录前的 gap 。</p>\n<p>当 InnoDB 扫描一个索引时，也会在最后一个记录之后加上 gap-lock 。对上面的例子，为阻止其他 session 插入 id&gt;100 的数据，InnoDB 会在 id=102 记录后的 gap 加上锁。</p>\n<p>可以使用 next-key lock 实现唯一性检查：如果使用 share 模式读取未查询到想要插入的重复行，那就可以安全地插入行，next-key lock 会在读取时设置到行上以阻止同时想要插入的重复行。也就是说，next-key lock 锁住了表中并不存在的行。</p>"},{"title":"SELECT in Mysql","layout":"post","description":"SELECT statements in Mysql","date":"2021-01-15T06:53:00.000Z","_content":"\n> Mysql 中查询语句\n\n## .1. Join Clause\n\n[reference](https://dev.mysql.com/doc/refman/5.7/en/join.html)<!--more-->\n\n- 在 MYSQL 中，`JOIN`, `CROSS JOIN` 与 `INNER JOIN` 在语法是等同的，彼此之间可以相互替换。但在标准 sql 中它们有所区别，inner join 使用 on 子句，而 cross join 使用其他的。<!--more-->\n- 表引用 table_reference 可使用别名：`tbl_name as alias_name` 或 `tbl_name alias_name`。\n- table_subquery 也叫派生表或子查询，这样的一个子查询必须有一个结果集表名：`SELECT * FROM (SELECT 1, 2, 3) AS t1;`\n- 单次 join 最多引用 61 张表，这其中包括派生表和外部查询块的 FROM 子句视图。\n- `INNER JOIN` 与 `,` 在语义上等价于没有 join 条件，都会在指定表间结果产生笛卡尔积结果。（Cartesian product 每张表的数据互相匹配）。但同时也可以在其后加上 on join条件。\n    - 但 `,` 的优先级低于其他 INNER JOIN,CROSS JOIN,LEFT JOIN 等。如果与这些操作符混用，an error of the form Unknown column 'col_name' in 'on clause' may occur。\n- 在 ON 的查询条件 search_condition 可以是 where 子句中可以使用的任何条件表达式。但一般来讲，ON 子句用来指定怎么 join ，而 WHERE 用来指定哪些行进入到结果集中。\n- 如果使用了 LEFT JOIN ON／USING 且右表没有数据行可匹配，则右表字段都会是 NULL.可以使用这种形式语句查询表中在另外一张表中没有匹配的数据。\n\n    ```sql\n    SELECT left_tbl.* FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id WHERE right_tbl.id IS NULL;\n    ```\n\n- USING 语法：在 LEFT JOIN 语句中，与 `ON` 作用类似，但 USING 不用指定 l.id = r.id，是直接要求两个表字段名一致而直接指定多表共有的字段值一致就 JOIN 成功。eg：`SELECT * FROM left_table LEFT JOIN right_table USING(id);` = `SELECT * FROM left_table LEFT JOIN right_table ON left_table.id = right_table.id;`\n- `USING(join_column_list)` 子句将多个列放入参数中，这样要求多表都有这些列名存在。\n- `NATURAL [LEFT] JOIN` 等同于使用 `INNER JOIN` 或 `LEFT JOIN` 并使用 `USING` 子句指定两表同名的列在其中。\n- `RIGHT JOIN` 与 `left join` 工作原理类似，但为保持代码跨库端口化，推荐使用 `left join`。\n- [PARTITION](https://dev.mysql.com/doc/refman/5.7/en/partitioning-selection.html)在写DDL时将表分片，指定范围内为一片，查询时可以直接查询片内数据。（不知道这样是否可以将索引单片内查询而提高查询效率？）\n","source":"_posts/Mysql/SELECT Statement.md","raw":"---\ntitle: SELECT in Mysql\nlayout: post\ntag: [mysql, InnoDB]\ncategories: [Mysql]\ndescription: SELECT statements in Mysql\ndate: \"2021-1-15 14:53:00\"\n---\n\n> Mysql 中查询语句\n\n## .1. Join Clause\n\n[reference](https://dev.mysql.com/doc/refman/5.7/en/join.html)<!--more-->\n\n- 在 MYSQL 中，`JOIN`, `CROSS JOIN` 与 `INNER JOIN` 在语法是等同的，彼此之间可以相互替换。但在标准 sql 中它们有所区别，inner join 使用 on 子句，而 cross join 使用其他的。<!--more-->\n- 表引用 table_reference 可使用别名：`tbl_name as alias_name` 或 `tbl_name alias_name`。\n- table_subquery 也叫派生表或子查询，这样的一个子查询必须有一个结果集表名：`SELECT * FROM (SELECT 1, 2, 3) AS t1;`\n- 单次 join 最多引用 61 张表，这其中包括派生表和外部查询块的 FROM 子句视图。\n- `INNER JOIN` 与 `,` 在语义上等价于没有 join 条件，都会在指定表间结果产生笛卡尔积结果。（Cartesian product 每张表的数据互相匹配）。但同时也可以在其后加上 on join条件。\n    - 但 `,` 的优先级低于其他 INNER JOIN,CROSS JOIN,LEFT JOIN 等。如果与这些操作符混用，an error of the form Unknown column 'col_name' in 'on clause' may occur。\n- 在 ON 的查询条件 search_condition 可以是 where 子句中可以使用的任何条件表达式。但一般来讲，ON 子句用来指定怎么 join ，而 WHERE 用来指定哪些行进入到结果集中。\n- 如果使用了 LEFT JOIN ON／USING 且右表没有数据行可匹配，则右表字段都会是 NULL.可以使用这种形式语句查询表中在另外一张表中没有匹配的数据。\n\n    ```sql\n    SELECT left_tbl.* FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id WHERE right_tbl.id IS NULL;\n    ```\n\n- USING 语法：在 LEFT JOIN 语句中，与 `ON` 作用类似，但 USING 不用指定 l.id = r.id，是直接要求两个表字段名一致而直接指定多表共有的字段值一致就 JOIN 成功。eg：`SELECT * FROM left_table LEFT JOIN right_table USING(id);` = `SELECT * FROM left_table LEFT JOIN right_table ON left_table.id = right_table.id;`\n- `USING(join_column_list)` 子句将多个列放入参数中，这样要求多表都有这些列名存在。\n- `NATURAL [LEFT] JOIN` 等同于使用 `INNER JOIN` 或 `LEFT JOIN` 并使用 `USING` 子句指定两表同名的列在其中。\n- `RIGHT JOIN` 与 `left join` 工作原理类似，但为保持代码跨库端口化，推荐使用 `left join`。\n- [PARTITION](https://dev.mysql.com/doc/refman/5.7/en/partitioning-selection.html)在写DDL时将表分片，指定范围内为一片，查询时可以直接查询片内数据。（不知道这样是否可以将索引单片内查询而提高查询效率？）\n","slug":"Mysql/SELECT Statement","published":1,"updated":"2021-02-24T15:22:22.900Z","comments":1,"photos":[],"link":"","_id":"ckljnokrh001s2bhb7q72buqn","content":"<blockquote>\n<p>Mysql 中查询语句</p>\n</blockquote>\n<h2 id=\"1-Join-Clause\"><a href=\"#1-Join-Clause\" class=\"headerlink\" title=\".1. Join Clause\"></a>.1. Join Clause</h2><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/join.html\">reference</a><span id=\"more\"></span></p>\n<ul>\n<li><p>在 MYSQL 中，<code>JOIN</code>, <code>CROSS JOIN</code> 与 <code>INNER JOIN</code> 在语法是等同的，彼此之间可以相互替换。但在标准 sql 中它们有所区别，inner join 使用 on 子句，而 cross join 使用其他的。<!--more--></p>\n</li>\n<li><p>表引用 table_reference 可使用别名：<code>tbl_name as alias_name</code> 或 <code>tbl_name alias_name</code>。</p>\n</li>\n<li><p>table_subquery 也叫派生表或子查询，这样的一个子查询必须有一个结果集表名：<code>SELECT * FROM (SELECT 1, 2, 3) AS t1;</code></p>\n</li>\n<li><p>单次 join 最多引用 61 张表，这其中包括派生表和外部查询块的 FROM 子句视图。</p>\n</li>\n<li><p><code>INNER JOIN</code> 与 <code>,</code> 在语义上等价于没有 join 条件，都会在指定表间结果产生笛卡尔积结果。（Cartesian product 每张表的数据互相匹配）。但同时也可以在其后加上 on join条件。</p>\n<ul>\n<li>但 <code>,</code> 的优先级低于其他 INNER JOIN,CROSS JOIN,LEFT JOIN 等。如果与这些操作符混用，an error of the form Unknown column ‘col_name’ in ‘on clause’ may occur。</li>\n</ul>\n</li>\n<li><p>在 ON 的查询条件 search_condition 可以是 where 子句中可以使用的任何条件表达式。但一般来讲，ON 子句用来指定怎么 join ，而 WHERE 用来指定哪些行进入到结果集中。</p>\n</li>\n<li><p>如果使用了 LEFT JOIN ON／USING 且右表没有数据行可匹配，则右表字段都会是 NULL.可以使用这种形式语句查询表中在另外一张表中没有匹配的数据。</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> left_tbl.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> left_tbl <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> right_tbl <span class=\"keyword\">ON</span> left_tbl.id <span class=\"operator\">=</span> right_tbl.id <span class=\"keyword\">WHERE</span> right_tbl.id <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>USING 语法：在 LEFT JOIN 语句中，与 <code>ON</code> 作用类似，但 USING 不用指定 l.id = r.id，是直接要求两个表字段名一致而直接指定多表共有的字段值一致就 JOIN 成功。eg：<code>SELECT * FROM left_table LEFT JOIN right_table USING(id);</code> = <code>SELECT * FROM left_table LEFT JOIN right_table ON left_table.id = right_table.id;</code></p>\n</li>\n<li><p><code>USING(join_column_list)</code> 子句将多个列放入参数中，这样要求多表都有这些列名存在。</p>\n</li>\n<li><p><code>NATURAL [LEFT] JOIN</code> 等同于使用 <code>INNER JOIN</code> 或 <code>LEFT JOIN</code> 并使用 <code>USING</code> 子句指定两表同名的列在其中。</p>\n</li>\n<li><p><code>RIGHT JOIN</code> 与 <code>left join</code> 工作原理类似，但为保持代码跨库端口化，推荐使用 <code>left join</code>。</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/partitioning-selection.html\">PARTITION</a>在写DDL时将表分片，指定范围内为一片，查询时可以直接查询片内数据。（不知道这样是否可以将索引单片内查询而提高查询效率？）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Mysql 中查询语句</p>\n</blockquote>\n<h2 id=\"1-Join-Clause\"><a href=\"#1-Join-Clause\" class=\"headerlink\" title=\".1. Join Clause\"></a>.1. Join Clause</h2><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/join.html\">reference</a>","more":"</p>\n<ul>\n<li><p>在 MYSQL 中，<code>JOIN</code>, <code>CROSS JOIN</code> 与 <code>INNER JOIN</code> 在语法是等同的，彼此之间可以相互替换。但在标准 sql 中它们有所区别，inner join 使用 on 子句，而 cross join 使用其他的。<!--more--></p>\n</li>\n<li><p>表引用 table_reference 可使用别名：<code>tbl_name as alias_name</code> 或 <code>tbl_name alias_name</code>。</p>\n</li>\n<li><p>table_subquery 也叫派生表或子查询，这样的一个子查询必须有一个结果集表名：<code>SELECT * FROM (SELECT 1, 2, 3) AS t1;</code></p>\n</li>\n<li><p>单次 join 最多引用 61 张表，这其中包括派生表和外部查询块的 FROM 子句视图。</p>\n</li>\n<li><p><code>INNER JOIN</code> 与 <code>,</code> 在语义上等价于没有 join 条件，都会在指定表间结果产生笛卡尔积结果。（Cartesian product 每张表的数据互相匹配）。但同时也可以在其后加上 on join条件。</p>\n<ul>\n<li>但 <code>,</code> 的优先级低于其他 INNER JOIN,CROSS JOIN,LEFT JOIN 等。如果与这些操作符混用，an error of the form Unknown column ‘col_name’ in ‘on clause’ may occur。</li>\n</ul>\n</li>\n<li><p>在 ON 的查询条件 search_condition 可以是 where 子句中可以使用的任何条件表达式。但一般来讲，ON 子句用来指定怎么 join ，而 WHERE 用来指定哪些行进入到结果集中。</p>\n</li>\n<li><p>如果使用了 LEFT JOIN ON／USING 且右表没有数据行可匹配，则右表字段都会是 NULL.可以使用这种形式语句查询表中在另外一张表中没有匹配的数据。</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> left_tbl.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> left_tbl <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> right_tbl <span class=\"keyword\">ON</span> left_tbl.id <span class=\"operator\">=</span> right_tbl.id <span class=\"keyword\">WHERE</span> right_tbl.id <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>USING 语法：在 LEFT JOIN 语句中，与 <code>ON</code> 作用类似，但 USING 不用指定 l.id = r.id，是直接要求两个表字段名一致而直接指定多表共有的字段值一致就 JOIN 成功。eg：<code>SELECT * FROM left_table LEFT JOIN right_table USING(id);</code> = <code>SELECT * FROM left_table LEFT JOIN right_table ON left_table.id = right_table.id;</code></p>\n</li>\n<li><p><code>USING(join_column_list)</code> 子句将多个列放入参数中，这样要求多表都有这些列名存在。</p>\n</li>\n<li><p><code>NATURAL [LEFT] JOIN</code> 等同于使用 <code>INNER JOIN</code> 或 <code>LEFT JOIN</code> 并使用 <code>USING</code> 子句指定两表同名的列在其中。</p>\n</li>\n<li><p><code>RIGHT JOIN</code> 与 <code>left join</code> 工作原理类似，但为保持代码跨库端口化，推荐使用 <code>left join</code>。</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/partitioning-selection.html\">PARTITION</a>在写DDL时将表分片，指定范围内为一片，查询时可以直接查询片内数据。（不知道这样是否可以将索引单片内查询而提高查询效率？）</p>\n</li>\n</ul>"},{"title":"Mysql Overview","layout":"post","date":"2018-11-01T02:13:00.000Z","_content":"\n> mysql 部署 server 及 client 请求\n\n## .1. mysql server\n\n> mysql server 的部署及请求[参考](http://www.cnblogs.com/QingXiaxu/p/7987302.html)<!--more-->\n\nlocalhost 的 testing 尝试：\n\n- 下载 mysql 安装包，解压后将 bin 添加到环境变量中。\n- 在其根目录添加 data 文件夹及 my.ini 配置文件\n- 初始化 mysql 服务 `mysqld --initialize --user=mysql --console`\n    - 初始化后，data 文件夹中会生成相应的各个文件\n    - 生成临时账户及密码： root@localhost: W>pg*LYv>6up\n- 添加 MySQL 服务到电脑系统服务中： `sc create MySQL binPath= \"C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin\\mysqld.exe\"`\n    - 添加错了时，可以使用命令删除服务 `sc delete serviceName`\n- 启动服务 `NET START MySQL`（到此，MySQL 的 server 算是启动完成，可以使用 client 命令进行登录访问了）\n- mysql 服务： `net stop MySQL`\n- 删除 mysql 服务（需要先停止服务）： `mysqld -remove`\n    - 以上添加 mysql 到电脑服务系统步骤可以不用做一样可以启动 mysql 服务：\n        - 需要的操作是：控制台进入到 mysql 安装目录 bin 中\n            - 直接启动 mysqld.exe `mysqld --console` --console 打开日志记录\n            - 关闭服务：`mysqladmin -uroot shutdown`\n- 查看当前 mysql server 连接情况命令： `show processlist` 将会看到当前 mysql server 连接的各个 client 的 ip/port/status/user/db 等\n\n## .2. mysql client operate\n\n> 在 mysql 控制台操作数据库\n\n_note: mysql server 命令行都必须使用 `;`  或 `\\g` 结尾，否则不会执行。_\n\n- 登录：`mysql -h host_address -u username [-p]` -p 决定是否带上密码\n登录全更改初始密码：\n- `SET PASSWORD FOR 'root'@'localhost' = PASSWORD('password');`\n- `UPDATE mysql.user SET authentication_string = PASSWORD('password'), password_expired = 'N' WHERE User = 'root' AND Host = 'localhost';`\n    - （office laptop sql root password: `111`; desktop mysql database root password:''）\n    - 从此行更改用户密码的命令可以得出：\n        - `mysql` 库 `user` 表是存放用户的表\n        - 其中的 `authentication_string` 字段用于存放密码\n        - 密码格式：PASSWORD('password')\n        - 需要 **注意** 的是： mysql 5.7 后不再支持 PASSWORD() 函数，取而代之的是 MD%()\n- 退出控制台：`exit|quit`\n\n常用命令：\n\n- 查找库内所有的表名： `SELECT table_name FROM information_schema.tables WHERE table_schema = 'databaseName' AND table_type='base TABLE';`\n- 选择库：`USE database`\n- 查看库内所有表名：`SHOW TABLES;`\n- 添加库： `CREATE DATABASE db_name character set {字符集};`\n- 删除库： `DROP database;`\n- 删除表：`DROP TABLE (TABLE name);`\n- 查看库创建信息 ： `show create database (database name);`\n- 查看表创建信息： `show create TABLE (TABLE name);`\n- 查看表所有 column : `SHOW COLUMNS FROM (TABLE name);`\n- 查看表所有 index : `SHOW INDEX FROM TABLE`\n- 查看表状态信息： `SHOW TABLE STATUS [FROM db_name] [LIKE 'TABLE'] [\\G]`\n- 查看表：`desc (table_name);`\n- 修改表名：`rename TABLE 表名 to 新表名;`\n\n### .2.1. mysql 服务添加新用户\n\n> 当 mysql 服务初始化完成并启动后，登录 root 账户后可以在 client 使用命令添加用户，只需要在 mysql 库 user 表中插入数据即可。\n\n执行命令：\n\n```sql\nINSERT INTO user\n  (host, user, password,select_priv, insert_priv, update_priv)\n  VALUES ('localhost', 'guest', PASSWORD('guest123'), 'Y', 'Y', 'Y');\n```\n\n_note: user 表中所有的以 `_priv` 结尾的字段都是表示相关的权限（privilege），`Y` 表示有， `N` 表示无此权限。_\n\n## .3. DDL\n\n> 对表属性字段进行更改的操作\n\n创建表：\n\n> CREATE TABLE (table name) ((field name) (字段类型) (字段长度) [约束]));\n\n```sql\ncreate TABLE if not exists `user`(\n    `id` int unsigned  not null auto_increment,`username` varchar(20) NOT null,\n    `remark` varchar(30), primary key (`id`)\n    )\n    engine=innodb default charset=utf8mb4 COMMENT='用户表';\n```\n\n- 修改表名: `rename TABLE 原表名 TO 新表名;`\n- 添加列：`ALTER TABLE 表名 ADD 字段名 类型(长度) [约束] COMMENT 备注;`\n- 修改列：`ALTER TABLE 表名 MODIFY 字段名 类型(长度) [约束] COMMENT 备注;` 可指定列字符集，在其中加入: `CHARSET (utf8mb4)`;\n- 修改列名：`ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [约束] COMMENT 备注;`\n- 删除列：`ALTER TABLE 表名 DROP 列名;`\n- 修改表字符集：`ALTER TABLE 表名 CHARSET (charsetname);`\n- 修改表备注：`ALTER TABLE 表名 COMMENT='your comments';` 表备注与列备注不同，使用了 `=`\n\n### .3.1. DML\n\n> 对表中行数据进行更改\n\n- 表插入数据：\n    - `INSERT into 表名 （字段名...） values (value1), (value2), (value3);` 插入指定字段名数据\n    - `INSERT into 表名 values (row1, row2, row3);` 此各必须插入所有字段\n- 修改行数据 `UPDATE 表名 SET field1=value, field2=value2 [WHERE condition];`\n- 删除行数据： `DELETE FROM 表名 [WHERE condition];`\n- 删除表内所有数据： `TRUNCATE TABLE tablename;` 与 delete 不加 WHERE 条件区别在于 此命令将删除所有后新建一张同样的表所有其新行 id 从 0 开始，而 delete 将从之前删除的最大的 id 开始。\n\n## .4. DQL\n\n> mysql 查询 DQL\n\n- 查询：\n    - 模糊查询：今天（Feb 18 2020才知道：除了 `%` 可以指定多个点位符外， `_` 还可以当作单个占位符使用。\n    - 顺序： select >> from >> WHERE >> group by >> having >> order by\n  \n### .4.1. 多表查询\n\n> 多表联接查询\n\n分类：\n\n1. 交叉连接查询 `SELECT * from tableA,tableB;` （不推荐使用，其算法会将两张表每行数据进行组合得到一个行数之积的结果再 select）\n2. 内连接查询 `INNER JOIN` ，其中 `INNER` 可省略\n   1. 隐式内连接 `SELECT * FROM A,B [WHERE condition];`\n   2. 显式内连接 `SELECT * FROM A JOIN B [ON condition];`\n3. 外连接查询 keywork: `OUTER JOIN` , `OUTER` 可省略\n   1. 左外连接: `LEFT OUTER JOIN` eg: `SELECT * FROM A LEFT OUTER JOIN B [WHERE condition];`\n   2. 右外连接：`RIGHT OUTER JOIN` eg: `SELECT * FROM A RIGHT OUTER JOIN B [WHERE condition];`\n\n## .5. mysql engine\n\n[参考博客](http://www.cnblogs.com/0201zcr/p/5296843.html)\n\n- mysql数据库引擎类别有：\n    - ISAM：\n        - 读取速度很快，不占用大量内存资源；\n        - 不足之处：不支持事务，不能容错（如果硬盘崩溃，则不能恢复了）；\n    - MYISAM：\n        - Mysql的默认引擎，是ISAM的扩展格式，提供了ISAM没有的索引和字段管理功能外，还使用表格锁定的机制，达到人优化多个并发的读写操作，代价是要常用`OPTIMIZE TABLE`来恢复被更新机制浪费的空间。\n        - MYISAM强调用ISAM所有的快速读取操作，这也让MYISAM在WEB开发中受到青睐；\n    - HEAP：\n        - HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。\n        - 在数据行被删除的时候，HEAP也不会浪费大量的空间。\n        - HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格；\n    - INNODB和BEAKLEYDB（BDB)：\n        - INNODB和BERKLEYDB（BDB）数据库引擎都是造就MYSQL灵活性的技术的直接产品，这项技术就是MYSQL++ API。\n        - 在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MYISAM数据库引擎不支持事务处理也不支持外键。\n        - 尽管要比ISAM和MYISAM引擎慢很多，但是INNODB和BDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。\n\n### .5.1. 关于 INNODB 引擎\n\n**InnoDB:**\n\n- Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别；\n    - **ACID**\n        - A  事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.\n        - C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.\n        - I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.\n        - D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.\n    - 该引擎还提供了行级锁和外键约束，它的设计目标是**处理大容量数据库系统**，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。\n- 与MYISAM相比：\n    - MyIASM是MySQL**默认的引擎**，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，**MyIASM中存储了表的行数**，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。\n    - 如果表的**读操作远远多于写操作且不需要数据库事务的支持**，那么MyIASM也是很好的选择。\n    - **大尺寸的数据集趋向于选择InnoDB引擎**，因为它支持事务处理和故障恢复。\n    - 数据库的大小决定了故障恢复的时间长短，**InnoDB可以利用事务日志进行数据恢复**，这会比较快。\n    - 主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。\n\n### .5.2. Index 索引\n\n> **索引（Index）是帮助MySQL高效获取数据的数据结构。**\n\n- MyIASM和Innodb都使用了树这种数据结构做为索引。谈到树，就不得不谈到B-tree与B+tree；\n- MyISAM引擎中用到的索引结构：\n    - MyISAM引擎的索引结构为B+Tree，其中B+Tree的数据域存储的内容为实际数据的地址，也就是说它的**索引和实际的数据是分开的**，只不过是用索引指向了实际的数据，这种索引就是所谓的**非聚集索引**。\n- Innodb引擎的索引结构：\n    - 与MyISAM引擎的索引结构同样也是B+Tree，但是**Innodb的索引文件本身就是数据文件**，即**B+Tree的数据域存储的就是实际的数据**，这种索引就是**聚集索引**。\n    - 这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。\n    - 和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。\n    - 所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。\n    - InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。\n    - 这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。\n- 这两种引擎都使用B+tree，不同之处在于：\n    - MyISAM的的索引使用的是**非聚集索引**，而**InnoDB使用的是聚集索引**；\n    - 所谓**非聚集索引就是索引与实际的数据是分开的**，索引只是指向了实际的数据；\n    - **聚集索引指索引就是索引文件本身就是数据**，数据域存储的就是实际的数据；\n\n## .6. mysql transaction\n\nmysql 的事务\n\n### .6.1. 语法\n\n- 开启事务：`start transaction;`\n- 提交事务：`commit;`\n- 回滚事务：`rollback;`\n\n### .6.2. 事务相关\n\n- mysql 默认开启事务，一条语句执行时默认开启一个事务，根据结果自动提交或回滚。开启事务语句一执行，便开启了手动事务；\n- oracle 事务默认手动开启；\n- mysql 事务提交或回滚前，在同一个连接内能查询到此事务内前面执行 sql 的结果。其他连接不行；这应该是事务隔离级别决定的，待确认。\n\n### .6.3. 数据库的事务隔离级别\n\n#### .6.3.1. 并发事务下\n\n- 先引入并发事务出现错误的概念：\n    - 脏读：T1 更新了数据，但未提交，这时 T2 读取 T1 事务中未提交的数据，但 T1 回滚操作，T2 读取就无效，这就叫脏读；\n    - 不可重复读：T1 读取，T2 修改了数据，T1 再次读时就讲到修改过的数据，这叫不可重复读\n    - 幻读：事务 T1 读取一条 where 条件语句，T2 插入一行也符合的，这时 T1 再次查询可以看到新数据，这叫幻读\n- 事务隔离级别：用以解决并发事务中出现的错误\n    - READ UNCOMMITED,允许以上三种\n    - READ COMMITED,允许幻想读、不可重复读，不允许脏读\n    - REPEATABLE READ:允许幻想读，不允许不可重复读与脏读\n    - SERIALIAZABLE，串行事务，性能最低三者都不允许\n- Oracle 不支持脏读，默认使用 READ COMMITED，支持 READ COMMITED/SERIALIZABLE\n- MySQL 标准定义的默认事务隔离级别是 REPEATABLE READ\n\n## .7. 分类\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_data_warehouse)\n\nOLTP: Online Transaction Process 多写类类型\ndata warehouse 多读少写类型\n","source":"_posts/Mysql/mysql.md","raw":"---\ntitle: Mysql Overview\nlayout: \"post\"\ntag: \"mysql\"\ndate: \"2018-11-01 10:13\"\ncategories: [Mysql]\n---\n\n> mysql 部署 server 及 client 请求\n\n## .1. mysql server\n\n> mysql server 的部署及请求[参考](http://www.cnblogs.com/QingXiaxu/p/7987302.html)<!--more-->\n\nlocalhost 的 testing 尝试：\n\n- 下载 mysql 安装包，解压后将 bin 添加到环境变量中。\n- 在其根目录添加 data 文件夹及 my.ini 配置文件\n- 初始化 mysql 服务 `mysqld --initialize --user=mysql --console`\n    - 初始化后，data 文件夹中会生成相应的各个文件\n    - 生成临时账户及密码： root@localhost: W>pg*LYv>6up\n- 添加 MySQL 服务到电脑系统服务中： `sc create MySQL binPath= \"C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin\\mysqld.exe\"`\n    - 添加错了时，可以使用命令删除服务 `sc delete serviceName`\n- 启动服务 `NET START MySQL`（到此，MySQL 的 server 算是启动完成，可以使用 client 命令进行登录访问了）\n- mysql 服务： `net stop MySQL`\n- 删除 mysql 服务（需要先停止服务）： `mysqld -remove`\n    - 以上添加 mysql 到电脑服务系统步骤可以不用做一样可以启动 mysql 服务：\n        - 需要的操作是：控制台进入到 mysql 安装目录 bin 中\n            - 直接启动 mysqld.exe `mysqld --console` --console 打开日志记录\n            - 关闭服务：`mysqladmin -uroot shutdown`\n- 查看当前 mysql server 连接情况命令： `show processlist` 将会看到当前 mysql server 连接的各个 client 的 ip/port/status/user/db 等\n\n## .2. mysql client operate\n\n> 在 mysql 控制台操作数据库\n\n_note: mysql server 命令行都必须使用 `;`  或 `\\g` 结尾，否则不会执行。_\n\n- 登录：`mysql -h host_address -u username [-p]` -p 决定是否带上密码\n登录全更改初始密码：\n- `SET PASSWORD FOR 'root'@'localhost' = PASSWORD('password');`\n- `UPDATE mysql.user SET authentication_string = PASSWORD('password'), password_expired = 'N' WHERE User = 'root' AND Host = 'localhost';`\n    - （office laptop sql root password: `111`; desktop mysql database root password:''）\n    - 从此行更改用户密码的命令可以得出：\n        - `mysql` 库 `user` 表是存放用户的表\n        - 其中的 `authentication_string` 字段用于存放密码\n        - 密码格式：PASSWORD('password')\n        - 需要 **注意** 的是： mysql 5.7 后不再支持 PASSWORD() 函数，取而代之的是 MD%()\n- 退出控制台：`exit|quit`\n\n常用命令：\n\n- 查找库内所有的表名： `SELECT table_name FROM information_schema.tables WHERE table_schema = 'databaseName' AND table_type='base TABLE';`\n- 选择库：`USE database`\n- 查看库内所有表名：`SHOW TABLES;`\n- 添加库： `CREATE DATABASE db_name character set {字符集};`\n- 删除库： `DROP database;`\n- 删除表：`DROP TABLE (TABLE name);`\n- 查看库创建信息 ： `show create database (database name);`\n- 查看表创建信息： `show create TABLE (TABLE name);`\n- 查看表所有 column : `SHOW COLUMNS FROM (TABLE name);`\n- 查看表所有 index : `SHOW INDEX FROM TABLE`\n- 查看表状态信息： `SHOW TABLE STATUS [FROM db_name] [LIKE 'TABLE'] [\\G]`\n- 查看表：`desc (table_name);`\n- 修改表名：`rename TABLE 表名 to 新表名;`\n\n### .2.1. mysql 服务添加新用户\n\n> 当 mysql 服务初始化完成并启动后，登录 root 账户后可以在 client 使用命令添加用户，只需要在 mysql 库 user 表中插入数据即可。\n\n执行命令：\n\n```sql\nINSERT INTO user\n  (host, user, password,select_priv, insert_priv, update_priv)\n  VALUES ('localhost', 'guest', PASSWORD('guest123'), 'Y', 'Y', 'Y');\n```\n\n_note: user 表中所有的以 `_priv` 结尾的字段都是表示相关的权限（privilege），`Y` 表示有， `N` 表示无此权限。_\n\n## .3. DDL\n\n> 对表属性字段进行更改的操作\n\n创建表：\n\n> CREATE TABLE (table name) ((field name) (字段类型) (字段长度) [约束]));\n\n```sql\ncreate TABLE if not exists `user`(\n    `id` int unsigned  not null auto_increment,`username` varchar(20) NOT null,\n    `remark` varchar(30), primary key (`id`)\n    )\n    engine=innodb default charset=utf8mb4 COMMENT='用户表';\n```\n\n- 修改表名: `rename TABLE 原表名 TO 新表名;`\n- 添加列：`ALTER TABLE 表名 ADD 字段名 类型(长度) [约束] COMMENT 备注;`\n- 修改列：`ALTER TABLE 表名 MODIFY 字段名 类型(长度) [约束] COMMENT 备注;` 可指定列字符集，在其中加入: `CHARSET (utf8mb4)`;\n- 修改列名：`ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [约束] COMMENT 备注;`\n- 删除列：`ALTER TABLE 表名 DROP 列名;`\n- 修改表字符集：`ALTER TABLE 表名 CHARSET (charsetname);`\n- 修改表备注：`ALTER TABLE 表名 COMMENT='your comments';` 表备注与列备注不同，使用了 `=`\n\n### .3.1. DML\n\n> 对表中行数据进行更改\n\n- 表插入数据：\n    - `INSERT into 表名 （字段名...） values (value1), (value2), (value3);` 插入指定字段名数据\n    - `INSERT into 表名 values (row1, row2, row3);` 此各必须插入所有字段\n- 修改行数据 `UPDATE 表名 SET field1=value, field2=value2 [WHERE condition];`\n- 删除行数据： `DELETE FROM 表名 [WHERE condition];`\n- 删除表内所有数据： `TRUNCATE TABLE tablename;` 与 delete 不加 WHERE 条件区别在于 此命令将删除所有后新建一张同样的表所有其新行 id 从 0 开始，而 delete 将从之前删除的最大的 id 开始。\n\n## .4. DQL\n\n> mysql 查询 DQL\n\n- 查询：\n    - 模糊查询：今天（Feb 18 2020才知道：除了 `%` 可以指定多个点位符外， `_` 还可以当作单个占位符使用。\n    - 顺序： select >> from >> WHERE >> group by >> having >> order by\n  \n### .4.1. 多表查询\n\n> 多表联接查询\n\n分类：\n\n1. 交叉连接查询 `SELECT * from tableA,tableB;` （不推荐使用，其算法会将两张表每行数据进行组合得到一个行数之积的结果再 select）\n2. 内连接查询 `INNER JOIN` ，其中 `INNER` 可省略\n   1. 隐式内连接 `SELECT * FROM A,B [WHERE condition];`\n   2. 显式内连接 `SELECT * FROM A JOIN B [ON condition];`\n3. 外连接查询 keywork: `OUTER JOIN` , `OUTER` 可省略\n   1. 左外连接: `LEFT OUTER JOIN` eg: `SELECT * FROM A LEFT OUTER JOIN B [WHERE condition];`\n   2. 右外连接：`RIGHT OUTER JOIN` eg: `SELECT * FROM A RIGHT OUTER JOIN B [WHERE condition];`\n\n## .5. mysql engine\n\n[参考博客](http://www.cnblogs.com/0201zcr/p/5296843.html)\n\n- mysql数据库引擎类别有：\n    - ISAM：\n        - 读取速度很快，不占用大量内存资源；\n        - 不足之处：不支持事务，不能容错（如果硬盘崩溃，则不能恢复了）；\n    - MYISAM：\n        - Mysql的默认引擎，是ISAM的扩展格式，提供了ISAM没有的索引和字段管理功能外，还使用表格锁定的机制，达到人优化多个并发的读写操作，代价是要常用`OPTIMIZE TABLE`来恢复被更新机制浪费的空间。\n        - MYISAM强调用ISAM所有的快速读取操作，这也让MYISAM在WEB开发中受到青睐；\n    - HEAP：\n        - HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。\n        - 在数据行被删除的时候，HEAP也不会浪费大量的空间。\n        - HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格；\n    - INNODB和BEAKLEYDB（BDB)：\n        - INNODB和BERKLEYDB（BDB）数据库引擎都是造就MYSQL灵活性的技术的直接产品，这项技术就是MYSQL++ API。\n        - 在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MYISAM数据库引擎不支持事务处理也不支持外键。\n        - 尽管要比ISAM和MYISAM引擎慢很多，但是INNODB和BDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。\n\n### .5.1. 关于 INNODB 引擎\n\n**InnoDB:**\n\n- Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别；\n    - **ACID**\n        - A  事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.\n        - C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.\n        - I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.\n        - D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.\n    - 该引擎还提供了行级锁和外键约束，它的设计目标是**处理大容量数据库系统**，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。\n- 与MYISAM相比：\n    - MyIASM是MySQL**默认的引擎**，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，**MyIASM中存储了表的行数**，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。\n    - 如果表的**读操作远远多于写操作且不需要数据库事务的支持**，那么MyIASM也是很好的选择。\n    - **大尺寸的数据集趋向于选择InnoDB引擎**，因为它支持事务处理和故障恢复。\n    - 数据库的大小决定了故障恢复的时间长短，**InnoDB可以利用事务日志进行数据恢复**，这会比较快。\n    - 主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。\n\n### .5.2. Index 索引\n\n> **索引（Index）是帮助MySQL高效获取数据的数据结构。**\n\n- MyIASM和Innodb都使用了树这种数据结构做为索引。谈到树，就不得不谈到B-tree与B+tree；\n- MyISAM引擎中用到的索引结构：\n    - MyISAM引擎的索引结构为B+Tree，其中B+Tree的数据域存储的内容为实际数据的地址，也就是说它的**索引和实际的数据是分开的**，只不过是用索引指向了实际的数据，这种索引就是所谓的**非聚集索引**。\n- Innodb引擎的索引结构：\n    - 与MyISAM引擎的索引结构同样也是B+Tree，但是**Innodb的索引文件本身就是数据文件**，即**B+Tree的数据域存储的就是实际的数据**，这种索引就是**聚集索引**。\n    - 这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。\n    - 和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。\n    - 所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。\n    - InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。\n    - 这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。\n- 这两种引擎都使用B+tree，不同之处在于：\n    - MyISAM的的索引使用的是**非聚集索引**，而**InnoDB使用的是聚集索引**；\n    - 所谓**非聚集索引就是索引与实际的数据是分开的**，索引只是指向了实际的数据；\n    - **聚集索引指索引就是索引文件本身就是数据**，数据域存储的就是实际的数据；\n\n## .6. mysql transaction\n\nmysql 的事务\n\n### .6.1. 语法\n\n- 开启事务：`start transaction;`\n- 提交事务：`commit;`\n- 回滚事务：`rollback;`\n\n### .6.2. 事务相关\n\n- mysql 默认开启事务，一条语句执行时默认开启一个事务，根据结果自动提交或回滚。开启事务语句一执行，便开启了手动事务；\n- oracle 事务默认手动开启；\n- mysql 事务提交或回滚前，在同一个连接内能查询到此事务内前面执行 sql 的结果。其他连接不行；这应该是事务隔离级别决定的，待确认。\n\n### .6.3. 数据库的事务隔离级别\n\n#### .6.3.1. 并发事务下\n\n- 先引入并发事务出现错误的概念：\n    - 脏读：T1 更新了数据，但未提交，这时 T2 读取 T1 事务中未提交的数据，但 T1 回滚操作，T2 读取就无效，这就叫脏读；\n    - 不可重复读：T1 读取，T2 修改了数据，T1 再次读时就讲到修改过的数据，这叫不可重复读\n    - 幻读：事务 T1 读取一条 where 条件语句，T2 插入一行也符合的，这时 T1 再次查询可以看到新数据，这叫幻读\n- 事务隔离级别：用以解决并发事务中出现的错误\n    - READ UNCOMMITED,允许以上三种\n    - READ COMMITED,允许幻想读、不可重复读，不允许脏读\n    - REPEATABLE READ:允许幻想读，不允许不可重复读与脏读\n    - SERIALIAZABLE，串行事务，性能最低三者都不允许\n- Oracle 不支持脏读，默认使用 READ COMMITED，支持 READ COMMITED/SERIALIZABLE\n- MySQL 标准定义的默认事务隔离级别是 REPEATABLE READ\n\n## .7. 分类\n\n[reference](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_data_warehouse)\n\nOLTP: Online Transaction Process 多写类类型\ndata warehouse 多读少写类型\n","slug":"Mysql/mysql","published":1,"updated":"2021-02-24T15:22:22.900Z","comments":1,"photos":[],"link":"","_id":"ckljnokri001v2bhb60jabt8u","content":"<blockquote>\n<p>mysql 部署 server 及 client 请求</p>\n</blockquote>\n<h2 id=\"1-mysql-server\"><a href=\"#1-mysql-server\" class=\"headerlink\" title=\".1. mysql server\"></a>.1. mysql server</h2><blockquote>\n<p>mysql server 的部署及请求<a href=\"http://www.cnblogs.com/QingXiaxu/p/7987302.html\">参考</a><span id=\"more\"></span></p>\n</blockquote>\n<p>localhost 的 testing 尝试：</p>\n<ul>\n<li>下载 mysql 安装包，解压后将 bin 添加到环境变量中。</li>\n<li>在其根目录添加 data 文件夹及 my.ini 配置文件</li>\n<li>初始化 mysql 服务 <code>mysqld --initialize --user=mysql --console</code><ul>\n<li>初始化后，data 文件夹中会生成相应的各个文件</li>\n<li>生成临时账户及密码： root@localhost: W&gt;pg*LYv&gt;6up</li>\n</ul>\n</li>\n<li>添加 MySQL 服务到电脑系统服务中： <code>sc create MySQL binPath= &quot;C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin\\mysqld.exe&quot;</code><ul>\n<li>添加错了时，可以使用命令删除服务 <code>sc delete serviceName</code></li>\n</ul>\n</li>\n<li>启动服务 <code>NET START MySQL</code>（到此，MySQL 的 server 算是启动完成，可以使用 client 命令进行登录访问了）</li>\n<li>mysql 服务： <code>net stop MySQL</code></li>\n<li>删除 mysql 服务（需要先停止服务）： <code>mysqld -remove</code><ul>\n<li>以上添加 mysql 到电脑服务系统步骤可以不用做一样可以启动 mysql 服务：<ul>\n<li>需要的操作是：控制台进入到 mysql 安装目录 bin 中<ul>\n<li>直接启动 mysqld.exe <code>mysqld --console</code> –console 打开日志记录</li>\n<li>关闭服务：<code>mysqladmin -uroot shutdown</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>查看当前 mysql server 连接情况命令： <code>show processlist</code> 将会看到当前 mysql server 连接的各个 client 的 ip/port/status/user/db 等</li>\n</ul>\n<h2 id=\"2-mysql-client-operate\"><a href=\"#2-mysql-client-operate\" class=\"headerlink\" title=\".2. mysql client operate\"></a>.2. mysql client operate</h2><blockquote>\n<p>在 mysql 控制台操作数据库</p>\n</blockquote>\n<p><em>note: mysql server 命令行都必须使用 <code>;</code>  或 <code>\\g</code> 结尾，否则不会执行。</em></p>\n<ul>\n<li>登录：<code>mysql -h host_address -u username [-p]</code> -p 决定是否带上密码<br>登录全更改初始密码：</li>\n<li><code>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;password&#39;);</code></li>\n<li><code>UPDATE mysql.user SET authentication_string = PASSWORD(&#39;password&#39;), password_expired = &#39;N&#39; WHERE User = &#39;root&#39; AND Host = &#39;localhost&#39;;</code><ul>\n<li>（office laptop sql root password: <code>111</code>; desktop mysql database root password:’’）</li>\n<li>从此行更改用户密码的命令可以得出：<ul>\n<li><code>mysql</code> 库 <code>user</code> 表是存放用户的表</li>\n<li>其中的 <code>authentication_string</code> 字段用于存放密码</li>\n<li>密码格式：PASSWORD(‘password’)</li>\n<li>需要 <strong>注意</strong> 的是： mysql 5.7 后不再支持 PASSWORD() 函数，取而代之的是 MD%()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>退出控制台：<code>exit|quit</code></li>\n</ul>\n<p>常用命令：</p>\n<ul>\n<li>查找库内所有的表名： <code>SELECT table_name FROM information_schema.tables WHERE table_schema = &#39;databaseName&#39; AND table_type=&#39;base TABLE&#39;;</code></li>\n<li>选择库：<code>USE database</code></li>\n<li>查看库内所有表名：<code>SHOW TABLES;</code></li>\n<li>添加库： <code>CREATE DATABASE db_name character set &#123;字符集&#125;;</code></li>\n<li>删除库： <code>DROP database;</code></li>\n<li>删除表：<code>DROP TABLE (TABLE name);</code></li>\n<li>查看库创建信息 ： <code>show create database (database name);</code></li>\n<li>查看表创建信息： <code>show create TABLE (TABLE name);</code></li>\n<li>查看表所有 column : <code>SHOW COLUMNS FROM (TABLE name);</code></li>\n<li>查看表所有 index : <code>SHOW INDEX FROM TABLE</code></li>\n<li>查看表状态信息： <code>SHOW TABLE STATUS [FROM db_name] [LIKE &#39;TABLE&#39;] [\\G]</code></li>\n<li>查看表：<code>desc (table_name);</code></li>\n<li>修改表名：<code>rename TABLE 表名 to 新表名;</code></li>\n</ul>\n<h3 id=\"2-1-mysql-服务添加新用户\"><a href=\"#2-1-mysql-服务添加新用户\" class=\"headerlink\" title=\".2.1. mysql 服务添加新用户\"></a>.2.1. mysql 服务添加新用户</h3><blockquote>\n<p>当 mysql 服务初始化完成并启动后，登录 root 账户后可以在 client 使用命令添加用户，只需要在 mysql 库 user 表中插入数据即可。</p>\n</blockquote>\n<p>执行命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\">  (host, <span class=\"keyword\">user</span>, password,select_priv, insert_priv, update_priv)</span><br><span class=\"line\">  <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"string\">&#x27;guest&#x27;</span>, PASSWORD(<span class=\"string\">&#x27;guest123&#x27;</span>), <span class=\"string\">&#x27;Y&#x27;</span>, <span class=\"string\">&#x27;Y&#x27;</span>, <span class=\"string\">&#x27;Y&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>note: user 表中所有的以 <code>_priv</code> 结尾的字段都是表示相关的权限（privilege），<code>Y</code> 表示有， <code>N</code> 表示无此权限。</em></p>\n<h2 id=\"3-DDL\"><a href=\"#3-DDL\" class=\"headerlink\" title=\".3. DDL\"></a>.3. DDL</h2><blockquote>\n<p>对表属性字段进行更改的操作</p>\n</blockquote>\n<p>创建表：</p>\n<blockquote>\n<p>CREATE TABLE (table name) ((field name) (字段类型) (字段长度) [约束]));</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">TABLE</span> if <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> `<span class=\"keyword\">user</span>`(</span><br><span class=\"line\">    `id` <span class=\"type\">int</span> unsigned  <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> auto_increment,`username` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    `remark` <span class=\"type\">varchar</span>(<span class=\"number\">30</span>), <span class=\"keyword\">primary</span> key (`id`)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    engine<span class=\"operator\">=</span>innodb <span class=\"keyword\">default</span> charset<span class=\"operator\">=</span>utf8mb4 COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改表名: <code>rename TABLE 原表名 TO 新表名;</code></li>\n<li>添加列：<code>ALTER TABLE 表名 ADD 字段名 类型(长度) [约束] COMMENT 备注;</code></li>\n<li>修改列：<code>ALTER TABLE 表名 MODIFY 字段名 类型(长度) [约束] COMMENT 备注;</code> 可指定列字符集，在其中加入: <code>CHARSET (utf8mb4)</code>;</li>\n<li>修改列名：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [约束] COMMENT 备注;</code></li>\n<li>删除列：<code>ALTER TABLE 表名 DROP 列名;</code></li>\n<li>修改表字符集：<code>ALTER TABLE 表名 CHARSET (charsetname);</code></li>\n<li>修改表备注：<code>ALTER TABLE 表名 COMMENT=&#39;your comments&#39;;</code> 表备注与列备注不同，使用了 <code>=</code></li>\n</ul>\n<h3 id=\"3-1-DML\"><a href=\"#3-1-DML\" class=\"headerlink\" title=\".3.1. DML\"></a>.3.1. DML</h3><blockquote>\n<p>对表中行数据进行更改</p>\n</blockquote>\n<ul>\n<li>表插入数据：<ul>\n<li><code>INSERT into 表名 （字段名...） values (value1), (value2), (value3);</code> 插入指定字段名数据</li>\n<li><code>INSERT into 表名 values (row1, row2, row3);</code> 此各必须插入所有字段</li>\n</ul>\n</li>\n<li>修改行数据 <code>UPDATE 表名 SET field1=value, field2=value2 [WHERE condition];</code></li>\n<li>删除行数据： <code>DELETE FROM 表名 [WHERE condition];</code></li>\n<li>删除表内所有数据： <code>TRUNCATE TABLE tablename;</code> 与 delete 不加 WHERE 条件区别在于 此命令将删除所有后新建一张同样的表所有其新行 id 从 0 开始，而 delete 将从之前删除的最大的 id 开始。</li>\n</ul>\n<h2 id=\"4-DQL\"><a href=\"#4-DQL\" class=\"headerlink\" title=\".4. DQL\"></a>.4. DQL</h2><blockquote>\n<p>mysql 查询 DQL</p>\n</blockquote>\n<ul>\n<li><p>查询：</p>\n<ul>\n<li>模糊查询：今天（Feb 18 2020才知道：除了 <code>%</code> 可以指定多个点位符外， <code>_</code> 还可以当作单个占位符使用。</li>\n<li>顺序： select &gt;&gt; from &gt;&gt; WHERE &gt;&gt; group by &gt;&gt; having &gt;&gt; order by</li>\n</ul>\n<h3 id=\"4-1-多表查询\"><a href=\"#4-1-多表查询\" class=\"headerlink\" title=\".4.1. 多表查询\"></a>.4.1. 多表查询</h3></li>\n</ul>\n<blockquote>\n<p>多表联接查询</p>\n</blockquote>\n<p>分类：</p>\n<ol>\n<li>交叉连接查询 <code>SELECT * from tableA,tableB;</code> （不推荐使用，其算法会将两张表每行数据进行组合得到一个行数之积的结果再 select）</li>\n<li>内连接查询 <code>INNER JOIN</code> ，其中 <code>INNER</code> 可省略<ol>\n<li>隐式内连接 <code>SELECT * FROM A,B [WHERE condition];</code></li>\n<li>显式内连接 <code>SELECT * FROM A JOIN B [ON condition];</code></li>\n</ol>\n</li>\n<li>外连接查询 keywork: <code>OUTER JOIN</code> , <code>OUTER</code> 可省略<ol>\n<li>左外连接: <code>LEFT OUTER JOIN</code> eg: <code>SELECT * FROM A LEFT OUTER JOIN B [WHERE condition];</code></li>\n<li>右外连接：<code>RIGHT OUTER JOIN</code> eg: <code>SELECT * FROM A RIGHT OUTER JOIN B [WHERE condition];</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"5-mysql-engine\"><a href=\"#5-mysql-engine\" class=\"headerlink\" title=\".5. mysql engine\"></a>.5. mysql engine</h2><p><a href=\"http://www.cnblogs.com/0201zcr/p/5296843.html\">参考博客</a></p>\n<ul>\n<li>mysql数据库引擎类别有：<ul>\n<li>ISAM：<ul>\n<li>读取速度很快，不占用大量内存资源；</li>\n<li>不足之处：不支持事务，不能容错（如果硬盘崩溃，则不能恢复了）；</li>\n</ul>\n</li>\n<li>MYISAM：<ul>\n<li>Mysql的默认引擎，是ISAM的扩展格式，提供了ISAM没有的索引和字段管理功能外，还使用表格锁定的机制，达到人优化多个并发的读写操作，代价是要常用<code>OPTIMIZE TABLE</code>来恢复被更新机制浪费的空间。</li>\n<li>MYISAM强调用ISAM所有的快速读取操作，这也让MYISAM在WEB开发中受到青睐；</li>\n</ul>\n</li>\n<li>HEAP：<ul>\n<li>HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。</li>\n<li>在数据行被删除的时候，HEAP也不会浪费大量的空间。</li>\n<li>HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格；</li>\n</ul>\n</li>\n<li>INNODB和BEAKLEYDB（BDB)：<ul>\n<li>INNODB和BERKLEYDB（BDB）数据库引擎都是造就MYSQL灵活性的技术的直接产品，这项技术就是MYSQL++ API。</li>\n<li>在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MYISAM数据库引擎不支持事务处理也不支持外键。</li>\n<li>尽管要比ISAM和MYISAM引擎慢很多，但是INNODB和BDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-1-关于-INNODB-引擎\"><a href=\"#5-1-关于-INNODB-引擎\" class=\"headerlink\" title=\".5.1. 关于 INNODB 引擎\"></a>.5.1. 关于 INNODB 引擎</h3><p><strong>InnoDB:</strong></p>\n<ul>\n<li>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别；<ul>\n<li><strong>ACID</strong><ul>\n<li>A  事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.</li>\n<li>C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.</li>\n<li>I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.</li>\n<li>D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</li>\n</ul>\n</li>\n<li>该引擎还提供了行级锁和外键约束，它的设计目标是<strong>处理大容量数据库系统</strong>，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。</li>\n</ul>\n</li>\n<li>与MYISAM相比：<ul>\n<li>MyIASM是MySQL<strong>默认的引擎</strong>，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，<strong>MyIASM中存储了表的行数</strong>，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。</li>\n<li>如果表的<strong>读操作远远多于写操作且不需要数据库事务的支持</strong>，那么MyIASM也是很好的选择。</li>\n<li><strong>大尺寸的数据集趋向于选择InnoDB引擎</strong>，因为它支持事务处理和故障恢复。</li>\n<li>数据库的大小决定了故障恢复的时间长短，<strong>InnoDB可以利用事务日志进行数据恢复</strong>，这会比较快。</li>\n<li>主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-Index-索引\"><a href=\"#5-2-Index-索引\" class=\"headerlink\" title=\".5.2. Index 索引\"></a>.5.2. Index 索引</h3><blockquote>\n<p><strong>索引（Index）是帮助MySQL高效获取数据的数据结构。</strong></p>\n</blockquote>\n<ul>\n<li>MyIASM和Innodb都使用了树这种数据结构做为索引。谈到树，就不得不谈到B-tree与B+tree；</li>\n<li>MyISAM引擎中用到的索引结构：<ul>\n<li>MyISAM引擎的索引结构为B+Tree，其中B+Tree的数据域存储的内容为实际数据的地址，也就是说它的<strong>索引和实际的数据是分开的</strong>，只不过是用索引指向了实际的数据，这种索引就是所谓的<strong>非聚集索引</strong>。</li>\n</ul>\n</li>\n<li>Innodb引擎的索引结构：<ul>\n<li>与MyISAM引擎的索引结构同样也是B+Tree，但是<strong>Innodb的索引文件本身就是数据文件</strong>，即<strong>B+Tree的数据域存储的就是实际的数据</strong>，这种索引就是<strong>聚集索引</strong>。</li>\n<li>这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</li>\n<li>和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。</li>\n<li>所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</li>\n<li>InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。</li>\n<li>这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</li>\n</ul>\n</li>\n<li>这两种引擎都使用B+tree，不同之处在于：<ul>\n<li>MyISAM的的索引使用的是<strong>非聚集索引</strong>，而<strong>InnoDB使用的是聚集索引</strong>；</li>\n<li>所谓<strong>非聚集索引就是索引与实际的数据是分开的</strong>，索引只是指向了实际的数据；</li>\n<li><strong>聚集索引指索引就是索引文件本身就是数据</strong>，数据域存储的就是实际的数据；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-mysql-transaction\"><a href=\"#6-mysql-transaction\" class=\"headerlink\" title=\".6. mysql transaction\"></a>.6. mysql transaction</h2><p>mysql 的事务</p>\n<h3 id=\"6-1-语法\"><a href=\"#6-1-语法\" class=\"headerlink\" title=\".6.1. 语法\"></a>.6.1. 语法</h3><ul>\n<li>开启事务：<code>start transaction;</code></li>\n<li>提交事务：<code>commit;</code></li>\n<li>回滚事务：<code>rollback;</code></li>\n</ul>\n<h3 id=\"6-2-事务相关\"><a href=\"#6-2-事务相关\" class=\"headerlink\" title=\".6.2. 事务相关\"></a>.6.2. 事务相关</h3><ul>\n<li>mysql 默认开启事务，一条语句执行时默认开启一个事务，根据结果自动提交或回滚。开启事务语句一执行，便开启了手动事务；</li>\n<li>oracle 事务默认手动开启；</li>\n<li>mysql 事务提交或回滚前，在同一个连接内能查询到此事务内前面执行 sql 的结果。其他连接不行；这应该是事务隔离级别决定的，待确认。</li>\n</ul>\n<h3 id=\"6-3-数据库的事务隔离级别\"><a href=\"#6-3-数据库的事务隔离级别\" class=\"headerlink\" title=\".6.3. 数据库的事务隔离级别\"></a>.6.3. 数据库的事务隔离级别</h3><h4 id=\"6-3-1-并发事务下\"><a href=\"#6-3-1-并发事务下\" class=\"headerlink\" title=\".6.3.1. 并发事务下\"></a>.6.3.1. 并发事务下</h4><ul>\n<li>先引入并发事务出现错误的概念：<ul>\n<li>脏读：T1 更新了数据，但未提交，这时 T2 读取 T1 事务中未提交的数据，但 T1 回滚操作，T2 读取就无效，这就叫脏读；</li>\n<li>不可重复读：T1 读取，T2 修改了数据，T1 再次读时就讲到修改过的数据，这叫不可重复读</li>\n<li>幻读：事务 T1 读取一条 where 条件语句，T2 插入一行也符合的，这时 T1 再次查询可以看到新数据，这叫幻读</li>\n</ul>\n</li>\n<li>事务隔离级别：用以解决并发事务中出现的错误<ul>\n<li>READ UNCOMMITED,允许以上三种</li>\n<li>READ COMMITED,允许幻想读、不可重复读，不允许脏读</li>\n<li>REPEATABLE READ:允许幻想读，不允许不可重复读与脏读</li>\n<li>SERIALIAZABLE，串行事务，性能最低三者都不允许</li>\n</ul>\n</li>\n<li>Oracle 不支持脏读，默认使用 READ COMMITED，支持 READ COMMITED/SERIALIZABLE</li>\n<li>MySQL 标准定义的默认事务隔离级别是 REPEATABLE READ</li>\n</ul>\n<h2 id=\"7-分类\"><a href=\"#7-分类\" class=\"headerlink\" title=\".7. 分类\"></a>.7. 分类</h2><p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_data_warehouse\">reference</a></p>\n<p>OLTP: Online Transaction Process 多写类类型<br>data warehouse 多读少写类型</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>mysql 部署 server 及 client 请求</p>\n</blockquote>\n<h2 id=\"1-mysql-server\"><a href=\"#1-mysql-server\" class=\"headerlink\" title=\".1. mysql server\"></a>.1. mysql server</h2><blockquote>\n<p>mysql server 的部署及请求<a href=\"http://www.cnblogs.com/QingXiaxu/p/7987302.html\">参考</a>","more":"</p>\n</blockquote>\n<p>localhost 的 testing 尝试：</p>\n<ul>\n<li>下载 mysql 安装包，解压后将 bin 添加到环境变量中。</li>\n<li>在其根目录添加 data 文件夹及 my.ini 配置文件</li>\n<li>初始化 mysql 服务 <code>mysqld --initialize --user=mysql --console</code><ul>\n<li>初始化后，data 文件夹中会生成相应的各个文件</li>\n<li>生成临时账户及密码： root@localhost: W&gt;pg*LYv&gt;6up</li>\n</ul>\n</li>\n<li>添加 MySQL 服务到电脑系统服务中： <code>sc create MySQL binPath= &quot;C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin\\mysqld.exe&quot;</code><ul>\n<li>添加错了时，可以使用命令删除服务 <code>sc delete serviceName</code></li>\n</ul>\n</li>\n<li>启动服务 <code>NET START MySQL</code>（到此，MySQL 的 server 算是启动完成，可以使用 client 命令进行登录访问了）</li>\n<li>mysql 服务： <code>net stop MySQL</code></li>\n<li>删除 mysql 服务（需要先停止服务）： <code>mysqld -remove</code><ul>\n<li>以上添加 mysql 到电脑服务系统步骤可以不用做一样可以启动 mysql 服务：<ul>\n<li>需要的操作是：控制台进入到 mysql 安装目录 bin 中<ul>\n<li>直接启动 mysqld.exe <code>mysqld --console</code> –console 打开日志记录</li>\n<li>关闭服务：<code>mysqladmin -uroot shutdown</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>查看当前 mysql server 连接情况命令： <code>show processlist</code> 将会看到当前 mysql server 连接的各个 client 的 ip/port/status/user/db 等</li>\n</ul>\n<h2 id=\"2-mysql-client-operate\"><a href=\"#2-mysql-client-operate\" class=\"headerlink\" title=\".2. mysql client operate\"></a>.2. mysql client operate</h2><blockquote>\n<p>在 mysql 控制台操作数据库</p>\n</blockquote>\n<p><em>note: mysql server 命令行都必须使用 <code>;</code>  或 <code>\\g</code> 结尾，否则不会执行。</em></p>\n<ul>\n<li>登录：<code>mysql -h host_address -u username [-p]</code> -p 决定是否带上密码<br>登录全更改初始密码：</li>\n<li><code>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;password&#39;);</code></li>\n<li><code>UPDATE mysql.user SET authentication_string = PASSWORD(&#39;password&#39;), password_expired = &#39;N&#39; WHERE User = &#39;root&#39; AND Host = &#39;localhost&#39;;</code><ul>\n<li>（office laptop sql root password: <code>111</code>; desktop mysql database root password:’’）</li>\n<li>从此行更改用户密码的命令可以得出：<ul>\n<li><code>mysql</code> 库 <code>user</code> 表是存放用户的表</li>\n<li>其中的 <code>authentication_string</code> 字段用于存放密码</li>\n<li>密码格式：PASSWORD(‘password’)</li>\n<li>需要 <strong>注意</strong> 的是： mysql 5.7 后不再支持 PASSWORD() 函数，取而代之的是 MD%()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>退出控制台：<code>exit|quit</code></li>\n</ul>\n<p>常用命令：</p>\n<ul>\n<li>查找库内所有的表名： <code>SELECT table_name FROM information_schema.tables WHERE table_schema = &#39;databaseName&#39; AND table_type=&#39;base TABLE&#39;;</code></li>\n<li>选择库：<code>USE database</code></li>\n<li>查看库内所有表名：<code>SHOW TABLES;</code></li>\n<li>添加库： <code>CREATE DATABASE db_name character set &#123;字符集&#125;;</code></li>\n<li>删除库： <code>DROP database;</code></li>\n<li>删除表：<code>DROP TABLE (TABLE name);</code></li>\n<li>查看库创建信息 ： <code>show create database (database name);</code></li>\n<li>查看表创建信息： <code>show create TABLE (TABLE name);</code></li>\n<li>查看表所有 column : <code>SHOW COLUMNS FROM (TABLE name);</code></li>\n<li>查看表所有 index : <code>SHOW INDEX FROM TABLE</code></li>\n<li>查看表状态信息： <code>SHOW TABLE STATUS [FROM db_name] [LIKE &#39;TABLE&#39;] [\\G]</code></li>\n<li>查看表：<code>desc (table_name);</code></li>\n<li>修改表名：<code>rename TABLE 表名 to 新表名;</code></li>\n</ul>\n<h3 id=\"2-1-mysql-服务添加新用户\"><a href=\"#2-1-mysql-服务添加新用户\" class=\"headerlink\" title=\".2.1. mysql 服务添加新用户\"></a>.2.1. mysql 服务添加新用户</h3><blockquote>\n<p>当 mysql 服务初始化完成并启动后，登录 root 账户后可以在 client 使用命令添加用户，只需要在 mysql 库 user 表中插入数据即可。</p>\n</blockquote>\n<p>执行命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\">  (host, <span class=\"keyword\">user</span>, password,select_priv, insert_priv, update_priv)</span><br><span class=\"line\">  <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"string\">&#x27;guest&#x27;</span>, PASSWORD(<span class=\"string\">&#x27;guest123&#x27;</span>), <span class=\"string\">&#x27;Y&#x27;</span>, <span class=\"string\">&#x27;Y&#x27;</span>, <span class=\"string\">&#x27;Y&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>note: user 表中所有的以 <code>_priv</code> 结尾的字段都是表示相关的权限（privilege），<code>Y</code> 表示有， <code>N</code> 表示无此权限。</em></p>\n<h2 id=\"3-DDL\"><a href=\"#3-DDL\" class=\"headerlink\" title=\".3. DDL\"></a>.3. DDL</h2><blockquote>\n<p>对表属性字段进行更改的操作</p>\n</blockquote>\n<p>创建表：</p>\n<blockquote>\n<p>CREATE TABLE (table name) ((field name) (字段类型) (字段长度) [约束]));</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">TABLE</span> if <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> `<span class=\"keyword\">user</span>`(</span><br><span class=\"line\">    `id` <span class=\"type\">int</span> unsigned  <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> auto_increment,`username` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    `remark` <span class=\"type\">varchar</span>(<span class=\"number\">30</span>), <span class=\"keyword\">primary</span> key (`id`)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    engine<span class=\"operator\">=</span>innodb <span class=\"keyword\">default</span> charset<span class=\"operator\">=</span>utf8mb4 COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改表名: <code>rename TABLE 原表名 TO 新表名;</code></li>\n<li>添加列：<code>ALTER TABLE 表名 ADD 字段名 类型(长度) [约束] COMMENT 备注;</code></li>\n<li>修改列：<code>ALTER TABLE 表名 MODIFY 字段名 类型(长度) [约束] COMMENT 备注;</code> 可指定列字符集，在其中加入: <code>CHARSET (utf8mb4)</code>;</li>\n<li>修改列名：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [约束] COMMENT 备注;</code></li>\n<li>删除列：<code>ALTER TABLE 表名 DROP 列名;</code></li>\n<li>修改表字符集：<code>ALTER TABLE 表名 CHARSET (charsetname);</code></li>\n<li>修改表备注：<code>ALTER TABLE 表名 COMMENT=&#39;your comments&#39;;</code> 表备注与列备注不同，使用了 <code>=</code></li>\n</ul>\n<h3 id=\"3-1-DML\"><a href=\"#3-1-DML\" class=\"headerlink\" title=\".3.1. DML\"></a>.3.1. DML</h3><blockquote>\n<p>对表中行数据进行更改</p>\n</blockquote>\n<ul>\n<li>表插入数据：<ul>\n<li><code>INSERT into 表名 （字段名...） values (value1), (value2), (value3);</code> 插入指定字段名数据</li>\n<li><code>INSERT into 表名 values (row1, row2, row3);</code> 此各必须插入所有字段</li>\n</ul>\n</li>\n<li>修改行数据 <code>UPDATE 表名 SET field1=value, field2=value2 [WHERE condition];</code></li>\n<li>删除行数据： <code>DELETE FROM 表名 [WHERE condition];</code></li>\n<li>删除表内所有数据： <code>TRUNCATE TABLE tablename;</code> 与 delete 不加 WHERE 条件区别在于 此命令将删除所有后新建一张同样的表所有其新行 id 从 0 开始，而 delete 将从之前删除的最大的 id 开始。</li>\n</ul>\n<h2 id=\"4-DQL\"><a href=\"#4-DQL\" class=\"headerlink\" title=\".4. DQL\"></a>.4. DQL</h2><blockquote>\n<p>mysql 查询 DQL</p>\n</blockquote>\n<ul>\n<li><p>查询：</p>\n<ul>\n<li>模糊查询：今天（Feb 18 2020才知道：除了 <code>%</code> 可以指定多个点位符外， <code>_</code> 还可以当作单个占位符使用。</li>\n<li>顺序： select &gt;&gt; from &gt;&gt; WHERE &gt;&gt; group by &gt;&gt; having &gt;&gt; order by</li>\n</ul>\n<h3 id=\"4-1-多表查询\"><a href=\"#4-1-多表查询\" class=\"headerlink\" title=\".4.1. 多表查询\"></a>.4.1. 多表查询</h3></li>\n</ul>\n<blockquote>\n<p>多表联接查询</p>\n</blockquote>\n<p>分类：</p>\n<ol>\n<li>交叉连接查询 <code>SELECT * from tableA,tableB;</code> （不推荐使用，其算法会将两张表每行数据进行组合得到一个行数之积的结果再 select）</li>\n<li>内连接查询 <code>INNER JOIN</code> ，其中 <code>INNER</code> 可省略<ol>\n<li>隐式内连接 <code>SELECT * FROM A,B [WHERE condition];</code></li>\n<li>显式内连接 <code>SELECT * FROM A JOIN B [ON condition];</code></li>\n</ol>\n</li>\n<li>外连接查询 keywork: <code>OUTER JOIN</code> , <code>OUTER</code> 可省略<ol>\n<li>左外连接: <code>LEFT OUTER JOIN</code> eg: <code>SELECT * FROM A LEFT OUTER JOIN B [WHERE condition];</code></li>\n<li>右外连接：<code>RIGHT OUTER JOIN</code> eg: <code>SELECT * FROM A RIGHT OUTER JOIN B [WHERE condition];</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"5-mysql-engine\"><a href=\"#5-mysql-engine\" class=\"headerlink\" title=\".5. mysql engine\"></a>.5. mysql engine</h2><p><a href=\"http://www.cnblogs.com/0201zcr/p/5296843.html\">参考博客</a></p>\n<ul>\n<li>mysql数据库引擎类别有：<ul>\n<li>ISAM：<ul>\n<li>读取速度很快，不占用大量内存资源；</li>\n<li>不足之处：不支持事务，不能容错（如果硬盘崩溃，则不能恢复了）；</li>\n</ul>\n</li>\n<li>MYISAM：<ul>\n<li>Mysql的默认引擎，是ISAM的扩展格式，提供了ISAM没有的索引和字段管理功能外，还使用表格锁定的机制，达到人优化多个并发的读写操作，代价是要常用<code>OPTIMIZE TABLE</code>来恢复被更新机制浪费的空间。</li>\n<li>MYISAM强调用ISAM所有的快速读取操作，这也让MYISAM在WEB开发中受到青睐；</li>\n</ul>\n</li>\n<li>HEAP：<ul>\n<li>HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。</li>\n<li>在数据行被删除的时候，HEAP也不会浪费大量的空间。</li>\n<li>HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格；</li>\n</ul>\n</li>\n<li>INNODB和BEAKLEYDB（BDB)：<ul>\n<li>INNODB和BERKLEYDB（BDB）数据库引擎都是造就MYSQL灵活性的技术的直接产品，这项技术就是MYSQL++ API。</li>\n<li>在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MYISAM数据库引擎不支持事务处理也不支持外键。</li>\n<li>尽管要比ISAM和MYISAM引擎慢很多，但是INNODB和BDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-1-关于-INNODB-引擎\"><a href=\"#5-1-关于-INNODB-引擎\" class=\"headerlink\" title=\".5.1. 关于 INNODB 引擎\"></a>.5.1. 关于 INNODB 引擎</h3><p><strong>InnoDB:</strong></p>\n<ul>\n<li>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别；<ul>\n<li><strong>ACID</strong><ul>\n<li>A  事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.</li>\n<li>C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.</li>\n<li>I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.</li>\n<li>D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</li>\n</ul>\n</li>\n<li>该引擎还提供了行级锁和外键约束，它的设计目标是<strong>处理大容量数据库系统</strong>，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。</li>\n</ul>\n</li>\n<li>与MYISAM相比：<ul>\n<li>MyIASM是MySQL<strong>默认的引擎</strong>，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，<strong>MyIASM中存储了表的行数</strong>，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。</li>\n<li>如果表的<strong>读操作远远多于写操作且不需要数据库事务的支持</strong>，那么MyIASM也是很好的选择。</li>\n<li><strong>大尺寸的数据集趋向于选择InnoDB引擎</strong>，因为它支持事务处理和故障恢复。</li>\n<li>数据库的大小决定了故障恢复的时间长短，<strong>InnoDB可以利用事务日志进行数据恢复</strong>，这会比较快。</li>\n<li>主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-Index-索引\"><a href=\"#5-2-Index-索引\" class=\"headerlink\" title=\".5.2. Index 索引\"></a>.5.2. Index 索引</h3><blockquote>\n<p><strong>索引（Index）是帮助MySQL高效获取数据的数据结构。</strong></p>\n</blockquote>\n<ul>\n<li>MyIASM和Innodb都使用了树这种数据结构做为索引。谈到树，就不得不谈到B-tree与B+tree；</li>\n<li>MyISAM引擎中用到的索引结构：<ul>\n<li>MyISAM引擎的索引结构为B+Tree，其中B+Tree的数据域存储的内容为实际数据的地址，也就是说它的<strong>索引和实际的数据是分开的</strong>，只不过是用索引指向了实际的数据，这种索引就是所谓的<strong>非聚集索引</strong>。</li>\n</ul>\n</li>\n<li>Innodb引擎的索引结构：<ul>\n<li>与MyISAM引擎的索引结构同样也是B+Tree，但是<strong>Innodb的索引文件本身就是数据文件</strong>，即<strong>B+Tree的数据域存储的就是实际的数据</strong>，这种索引就是<strong>聚集索引</strong>。</li>\n<li>这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</li>\n<li>和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。</li>\n<li>所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</li>\n<li>InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。</li>\n<li>这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</li>\n</ul>\n</li>\n<li>这两种引擎都使用B+tree，不同之处在于：<ul>\n<li>MyISAM的的索引使用的是<strong>非聚集索引</strong>，而<strong>InnoDB使用的是聚集索引</strong>；</li>\n<li>所谓<strong>非聚集索引就是索引与实际的数据是分开的</strong>，索引只是指向了实际的数据；</li>\n<li><strong>聚集索引指索引就是索引文件本身就是数据</strong>，数据域存储的就是实际的数据；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-mysql-transaction\"><a href=\"#6-mysql-transaction\" class=\"headerlink\" title=\".6. mysql transaction\"></a>.6. mysql transaction</h2><p>mysql 的事务</p>\n<h3 id=\"6-1-语法\"><a href=\"#6-1-语法\" class=\"headerlink\" title=\".6.1. 语法\"></a>.6.1. 语法</h3><ul>\n<li>开启事务：<code>start transaction;</code></li>\n<li>提交事务：<code>commit;</code></li>\n<li>回滚事务：<code>rollback;</code></li>\n</ul>\n<h3 id=\"6-2-事务相关\"><a href=\"#6-2-事务相关\" class=\"headerlink\" title=\".6.2. 事务相关\"></a>.6.2. 事务相关</h3><ul>\n<li>mysql 默认开启事务，一条语句执行时默认开启一个事务，根据结果自动提交或回滚。开启事务语句一执行，便开启了手动事务；</li>\n<li>oracle 事务默认手动开启；</li>\n<li>mysql 事务提交或回滚前，在同一个连接内能查询到此事务内前面执行 sql 的结果。其他连接不行；这应该是事务隔离级别决定的，待确认。</li>\n</ul>\n<h3 id=\"6-3-数据库的事务隔离级别\"><a href=\"#6-3-数据库的事务隔离级别\" class=\"headerlink\" title=\".6.3. 数据库的事务隔离级别\"></a>.6.3. 数据库的事务隔离级别</h3><h4 id=\"6-3-1-并发事务下\"><a href=\"#6-3-1-并发事务下\" class=\"headerlink\" title=\".6.3.1. 并发事务下\"></a>.6.3.1. 并发事务下</h4><ul>\n<li>先引入并发事务出现错误的概念：<ul>\n<li>脏读：T1 更新了数据，但未提交，这时 T2 读取 T1 事务中未提交的数据，但 T1 回滚操作，T2 读取就无效，这就叫脏读；</li>\n<li>不可重复读：T1 读取，T2 修改了数据，T1 再次读时就讲到修改过的数据，这叫不可重复读</li>\n<li>幻读：事务 T1 读取一条 where 条件语句，T2 插入一行也符合的，这时 T1 再次查询可以看到新数据，这叫幻读</li>\n</ul>\n</li>\n<li>事务隔离级别：用以解决并发事务中出现的错误<ul>\n<li>READ UNCOMMITED,允许以上三种</li>\n<li>READ COMMITED,允许幻想读、不可重复读，不允许脏读</li>\n<li>REPEATABLE READ:允许幻想读，不允许不可重复读与脏读</li>\n<li>SERIALIAZABLE，串行事务，性能最低三者都不允许</li>\n</ul>\n</li>\n<li>Oracle 不支持脏读，默认使用 READ COMMITED，支持 READ COMMITED/SERIALIZABLE</li>\n<li>MySQL 标准定义的默认事务隔离级别是 REPEATABLE READ</li>\n</ul>\n<h2 id=\"7-分类\"><a href=\"#7-分类\" class=\"headerlink\" title=\".7. 分类\"></a>.7. 分类</h2><p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_data_warehouse\">reference</a></p>\n<p>OLTP: Online Transaction Process 多写类类型<br>data warehouse 多读少写类型</p>"},{"layout":"post","title":"SpEL","date":"2020-09-23T09:15:00.000Z","description":"Spring Expression Language","_content":"\n[Spring 表达式](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-beandef)\n\n## .1. SpEL Reference\n\n[reference](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-safe-navigation)\n\n### .1.1. Bean Reference\n\n[bean reference](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables)\n\n- 需要 evaluation Context 中配置上 BeanResolver 。\n- 引用 bean 时 `@something`\n- 引用 Factory Bean `&something`<!--more-->\n\n### .1.2. Ternary Operator(if-then-else)\n\n[三元运算符](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables)\n\n`\"false ? 'trueExp' : 'falseExp'\"`\n\n### .1.3. Elvis Operator\n\n[Elvis' hairstyle Operator](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-elvis)\n\n猫王运算符 `?:` 等价于 `notNull ? value:default`\n\n### .1.4. Safe Navigation Operator\n\n表达式中使用安全导引 `Members?.location` 如果是所取的数据为 null 将返回 null 而不是直接 NullPointerException 。\n\n### .1.5. Collection Selection\n\n集合 List/Map 选择器，对于一个 List 选择器作用于其每一个元素，而 Map 作用于其 Map.Entry 。\n\n- 表达式中对 list 数据进行筛选 `locations.?[city == 'Serbian']` 选择 city 为 Serbian 的数据。\n- `locations.?[value > 10]` 选择 map 中 value > 10 的数据。\n","source":"_posts/Spring/Spring Expression Language.md","raw":"---\nlayout: post\ntitle: SpEL\ndate: 2020-09-23 17:15:00\ntags: [java,Spring,SpEL]\ncategories: [Spring]\ndescription: Spring Expression Language\n---\n\n[Spring 表达式](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-beandef)\n\n## .1. SpEL Reference\n\n[reference](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-safe-navigation)\n\n### .1.1. Bean Reference\n\n[bean reference](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables)\n\n- 需要 evaluation Context 中配置上 BeanResolver 。\n- 引用 bean 时 `@something`\n- 引用 Factory Bean `&something`<!--more-->\n\n### .1.2. Ternary Operator(if-then-else)\n\n[三元运算符](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables)\n\n`\"false ? 'trueExp' : 'falseExp'\"`\n\n### .1.3. Elvis Operator\n\n[Elvis' hairstyle Operator](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-elvis)\n\n猫王运算符 `?:` 等价于 `notNull ? value:default`\n\n### .1.4. Safe Navigation Operator\n\n表达式中使用安全导引 `Members?.location` 如果是所取的数据为 null 将返回 null 而不是直接 NullPointerException 。\n\n### .1.5. Collection Selection\n\n集合 List/Map 选择器，对于一个 List 选择器作用于其每一个元素，而 Map 作用于其 Map.Entry 。\n\n- 表达式中对 list 数据进行筛选 `locations.?[city == 'Serbian']` 选择 city 为 Serbian 的数据。\n- `locations.?[value > 10]` 选择 map 中 value > 10 的数据。\n","slug":"Spring/Spring Expression Language","published":1,"updated":"2021-02-24T15:22:22.960Z","comments":1,"photos":[],"link":"","_id":"ckljnokrk001y2bhb898wb4j7","content":"<p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-beandef\">Spring 表达式</a></p>\n<h2 id=\"1-SpEL-Reference\"><a href=\"#1-SpEL-Reference\" class=\"headerlink\" title=\".1. SpEL Reference\"></a>.1. SpEL Reference</h2><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-safe-navigation\">reference</a></p>\n<h3 id=\"1-1-Bean-Reference\"><a href=\"#1-1-Bean-Reference\" class=\"headerlink\" title=\".1.1. Bean Reference\"></a>.1.1. Bean Reference</h3><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables\">bean reference</a></p>\n<ul>\n<li>需要 evaluation Context 中配置上 BeanResolver 。</li>\n<li>引用 bean 时 <code>@something</code></li>\n<li>引用 Factory Bean <code>&amp;something</code><span id=\"more\"></span></li>\n</ul>\n<h3 id=\"1-2-Ternary-Operator-if-then-else\"><a href=\"#1-2-Ternary-Operator-if-then-else\" class=\"headerlink\" title=\".1.2. Ternary Operator(if-then-else)\"></a>.1.2. Ternary Operator(if-then-else)</h3><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables\">三元运算符</a></p>\n<p><code>&quot;false ? &#39;trueExp&#39; : &#39;falseExp&#39;&quot;</code></p>\n<h3 id=\"1-3-Elvis-Operator\"><a href=\"#1-3-Elvis-Operator\" class=\"headerlink\" title=\".1.3. Elvis Operator\"></a>.1.3. Elvis Operator</h3><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-elvis\">Elvis’ hairstyle Operator</a></p>\n<p>猫王运算符 <code>?:</code> 等价于 <code>notNull ? value:default</code></p>\n<h3 id=\"1-4-Safe-Navigation-Operator\"><a href=\"#1-4-Safe-Navigation-Operator\" class=\"headerlink\" title=\".1.4. Safe Navigation Operator\"></a>.1.4. Safe Navigation Operator</h3><p>表达式中使用安全导引 <code>Members?.location</code> 如果是所取的数据为 null 将返回 null 而不是直接 NullPointerException 。</p>\n<h3 id=\"1-5-Collection-Selection\"><a href=\"#1-5-Collection-Selection\" class=\"headerlink\" title=\".1.5. Collection Selection\"></a>.1.5. Collection Selection</h3><p>集合 List/Map 选择器，对于一个 List 选择器作用于其每一个元素，而 Map 作用于其 Map.Entry 。</p>\n<ul>\n<li>表达式中对 list 数据进行筛选 <code>locations.?[city == &#39;Serbian&#39;]</code> 选择 city 为 Serbian 的数据。</li>\n<li><code>locations.?[value &gt; 10]</code> 选择 map 中 value &gt; 10 的数据。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-beandef\">Spring 表达式</a></p>\n<h2 id=\"1-SpEL-Reference\"><a href=\"#1-SpEL-Reference\" class=\"headerlink\" title=\".1. SpEL Reference\"></a>.1. SpEL Reference</h2><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-safe-navigation\">reference</a></p>\n<h3 id=\"1-1-Bean-Reference\"><a href=\"#1-1-Bean-Reference\" class=\"headerlink\" title=\".1.1. Bean Reference\"></a>.1.1. Bean Reference</h3><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables\">bean reference</a></p>\n<ul>\n<li>需要 evaluation Context 中配置上 BeanResolver 。</li>\n<li>引用 bean 时 <code>@something</code></li>\n<li>引用 Factory Bean <code>&amp;something</code>","more":"</li>\n</ul>\n<h3 id=\"1-2-Ternary-Operator-if-then-else\"><a href=\"#1-2-Ternary-Operator-if-then-else\" class=\"headerlink\" title=\".1.2. Ternary Operator(if-then-else)\"></a>.1.2. Ternary Operator(if-then-else)</h3><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-ref-variables\">三元运算符</a></p>\n<p><code>&quot;false ? &#39;trueExp&#39; : &#39;falseExp&#39;&quot;</code></p>\n<h3 id=\"1-3-Elvis-Operator\"><a href=\"#1-3-Elvis-Operator\" class=\"headerlink\" title=\".1.3. Elvis Operator\"></a>.1.3. Elvis Operator</h3><p><a href=\"https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/core.html#expressions-operator-elvis\">Elvis’ hairstyle Operator</a></p>\n<p>猫王运算符 <code>?:</code> 等价于 <code>notNull ? value:default</code></p>\n<h3 id=\"1-4-Safe-Navigation-Operator\"><a href=\"#1-4-Safe-Navigation-Operator\" class=\"headerlink\" title=\".1.4. Safe Navigation Operator\"></a>.1.4. Safe Navigation Operator</h3><p>表达式中使用安全导引 <code>Members?.location</code> 如果是所取的数据为 null 将返回 null 而不是直接 NullPointerException 。</p>\n<h3 id=\"1-5-Collection-Selection\"><a href=\"#1-5-Collection-Selection\" class=\"headerlink\" title=\".1.5. Collection Selection\"></a>.1.5. Collection Selection</h3><p>集合 List/Map 选择器，对于一个 List 选择器作用于其每一个元素，而 Map 作用于其 Map.Entry 。</p>\n<ul>\n<li>表达式中对 list 数据进行筛选 <code>locations.?[city == &#39;Serbian&#39;]</code> 选择 city 为 Serbian 的数据。</li>\n<li><code>locations.?[value &gt; 10]</code> 选择 map 中 value &gt; 10 的数据。</li>\n</ul>"},{"layout":"post","title":"AOP","date":"2018-11-26T02:50:00.000Z","_content":"\n> aop aspect oriented programming 。面向切面编程，常用于具有横切性质的系统级服务，如：事务管理、安全检查、缓存、对象池管理。\n> **需要说明的是** aop 是一种编程思想，并不仅限于 java 更不仅限于 spring 。但这儿主要针对 java spring aop 进行讨论。纵向重复代码在横向上抽取。<!--more-->\n\nAspectJ 是基于 java 语言的 aop 框架，提供了强大的 aop 功能，其他众多的 aop 框架都借鉴了其思想。包括两个部分：\n\n- 定义如何表达/定义 aop 语法规范。用于解决 java 中的交叉关注点问题。\n- 工具部分：编译/调试。\n\n## .1. AOP Concepts\n\nAspect Oriented Programming 基本概念\n\n1. Aspect: 多个类间的模块化的事物。企业应用中的事务管理就是很好的跨类切面的例子。在 Spring AOP 中通过常规类（schema 途径）或注解 `@AspectsJ` 实现切面。\n2. Join Point: 程序执行中的某一点，如一个方法执行或异常处理。在 Spring AOP 中，一个 Joint Point 通常代表一个方法执行。\n3. Advice: 切面在入点（Joint Point）所采用的动作。大多框架（包括 Spring AOP）将 Advice 建模成拦截器，并为 Join Point 维护一个拦截器链。Advice 类型有：\"Around\" \"Before\" \"After\" 。Spring AOP 包括以下类型：\n    1. Before Advice：在 Join Point 前执行的增强。除非抛出异常，此类型的 Advice 并不能阻止 Joint Point 流程的执行。\n    2. After Returning Advice：在 Join Point 正常流程执行完成（未抛出异常）后执行。\n    3. After Throwing Advice: 在方法因异常退出时执行\n    4. After(finally) advice: 在 join point 方法结束后执行（不管是正常结束还是异常结束）。\n    5. Around advice：在 join point 前后都可执行的 advice。最强势的 advice ，可自定义方法调用前后的行为，也可以决定 join point 是否执行或通过返回自定义的结果（或抛出异常）实现增强方法的快捷执行。\n4. Pointcut： 匹配 Join Point 的判断。Advice 关联一个 Pointcut 表达式，并在每一个匹配上 Pointcut 的切点处执行（eg：执行有某个特定名字的方法）。匹配上 Pointcut 表达式的 Join Point 的概念是 AOP 的核心，Spring 默认使用使用 AspectJ pointcut 表达式语言。\n5. Introduction: 引入外部方法或字段到一个类。Spring AOP 可以引入新的接口与相应的实现到被增强的类。在 AspectJ 社区中，introduction 通常被当作一个内部类的定义。\n6. Target Object:被一个或多个增加的对象。也被当作被增强的对象。Spring AOP 通过运行时代理实现，所以 Target Object 也是一个代理对象。\n7. AOP Proxy：AOP 框架实现 aspect 规约（增加方法执行等等）而创建的对象。在 Spring AOP 中，AOP proxy 通常为 JDK 动态代理或 CGlib 代理。\n8. Weaving: 将 aspect 与其他应用的类型或对象连接以创建增加类。此动作可在编译期（通过 AspectJ Compiler）、加载期、运行时进行。Spring AOP 与大多 Java AOP 框架一样都在编译期执行 weaving。\n\n## .2. aop 实现分为两类\n\n- 静态 AOP 实现：在编译阶段就对程序进行修改，即实现对目标类的增强，生成静态的 AOP 代理类，以 aspcetj 为代表。具有良好的性能，但需要特殊的编译器。\n- 动态 AOP 实现：AOP 框架在运行阶段动态生成 AOP 代理，以实现对目标对象的增加，如： spring AOP 。纯java 实现，无需特殊编译器，性能相对略差。\n\n**基本概念**：\n\n- Aspect 切面：用于组织多个 advice ， advice 就放在 aspect 中定义；\n- Joinpoint 连接点：程序执行过程中明确的点，如：方法的调用/异常的拋出。 在 Spring AOP 中，连接点总是 方法调用。\n- Advice 增强：AOP 框架支持在特定的切入点执行的增加处理。类型有：Before Around After\n- Pointcut 切入点：中以插入增强处理的连接点。当连接点满足指定要求时，该连接点将被添加增加处理，该连接点也就说变成了切点。\n\n## .3. spring aop\n\n- Spring AOP 代理由 IoC 容器负责生成、管理，其依赖关系也由 IoC 窗口负责管理。\n- 在 Spring 使用 Aspectj 支持需要添加三个库：\n    - aspcetjweaver.jar\n    - aspectjrt.jar\n    - aopalliance.jar\n- 配置文件加如下配置：\n\n  ```xml\n  <!--启动@AspectJ支持-->\n  <aop:aspectj-autoproxy/>\n\n  <!--指定自动搜索Bean组件、自动搜索切面类-->\n  <context:component-scan base-package=\"edu.shu.sprint.service\">\n      <context:include-filter type=\"annotation\" expression=\"org.aspectj.lang.annotation.Aspect\"/>\n  </context:component-scan>\n  ```\n\n### .3.1. AOP Proxies\n\n- Spring AOP 默认使用 JDK 动态代理，也可以使用 CGLIB 代理，一般在被代理对象没有实现接口的情况下使用。\n\n## .4. @AspectJ Support\n\n### .4.1. Enable @AspectJ Support\n\n- 在 `@Configuration` 上添加 `@EnableAspectJAutoProxy` 注解，让被增加的 bean 自动代理。\n- 使用 XML 配置 添加标签 `<aop:aspectj-autoproxy />`\n\n### .4.2. Declaring an Aspect\n\n当 @AspectJ 打开后，Spring 会自动检测容器中定义的 Aspect 。定义 Aspect 的方法有两种：\n\n1. 使用 XML 配置添加了 `@Aspect` 的 bean\n2. 使用自动扫描注解 `@Aspect` 的 bean，使用自动扫描 bean 方式时需要在 bean 上添加额外的 `@Component` 或自定义的扫描组件注解。\n\n- 使用 `@Aspect` 注解后的 bean 与其它类一样可以有自己的字段方法，同样可以定义 pointcut/advice\n- Aspects 不能成为其他 aspect 增强的目标，因为 aspect 已经被 `@Aspect` 注解为一个 Aspect 被自动代理排除在外。\n\n### .4.3. Declaring a Pointcut\n\n一个 Pointcut 的定义包括两部分:\n\n1. 由名与任意参数组成的签名（由一个方法定义，此方法签名的返回值必须为 `void`）；\n2. 使用 `@Pointcut` 注解表达的 pointcut 表达式。\n\n#### .4.3.1. Supported Pointcut Designators\n\n支持 Pointcut 的标识符（PCD pointcut designators 用来匹配符合的 join point，限制 Spring AOP 方法执行）\n\n- execution: 匹配 join points，主要的 pointcut 标识符\n- within: 限制 join points 所在的类需要是特定类型\n- this: bean reference（Spring AOP 代理对象）为指定类型的实例限定 join points 匹配\n- target: 目标对象（被代理的应用对象）是指定 type 的实例\n- args: 限制参数（arguments）为指定类型（type） 的实例\n- @target：限制执行对象需要有指定类型的注解\n- @args: 限制运行时被传递的参数必须有指定类型的注解\n- @within: 限制 join points 所在的类需要有指定的注解\n- @annotation: 限制 join points (AOP 中所执行的方法) 需要有指定的注解。\n\n##### .4.3.1.1. Spring AOP 与 AspectJ 不同之处\n\n- 除以上几个标志符外，AspectJ 还有其他的 Designator（如：`call`,`withinCode`,`@withinCode`, etc.），但若在 Spring 中使用这些标志符会抛出 `IllegalArgumentException`。\n- Spring AOP 窄化了 AspectJ 中标志符的定义，join points 只匹配了方法执行。\n- AspectJ 还有基于类型的语义（type-based semantics），且其标志符 `this` `target` 都是指相同的对象：执行方法的对象。而在 Spring AOP 是基于代理的系统，其代理（与 `this` 绑定）与其在代理之后的目标对象（与 `target` 绑定）是不同的。\n- 因为 Spring AOP is proxy-based 框架本质，所以直接调用其目标对象，并不能实现 AOP 拦截。JDK 动态代理只能对 public interface method 进行拦截，而CGLIB 代理 public/protected （如果需要，package-visible  方法也可以）都可被代理。\n- `bean` Spring AOP 有一个原生 AspectJ 所没有的 PCD ： `bean`。通过 bean name 匹配 bean ，也可加上通配符 `*` 匹配 bean 集合。与其他标签符一样， bean 可以使用 `&&` `||` `!` 运算符。  \n    - `bean` 是针对 Spring 扩展的 PCD ，因此在 `@Aspect` 模式中无效。 `bean` PCD 在实例级别上运行不仅仅是在类型级别上，instance-based PCD 是 Spring 基于代理的 AOP 框架的功能，与 Spring bean 工厂紧密整合，因此能自然而直接地通过 name 识别 bean。\n\n##### .4.3.1.2. Notes\n\n- 切点定义通常与任何拦截的方法相匹配。如果切入点被严格定义为只公开的，那么即使在 CGLIB 代理场景中，通过代理进行潜在的非公开交互，也需要相应地定义它。\n- 如果拦截需要包含目标对象的方法调用或构造器，需要使用 Spring 驱动的 native AspectJ weaving 而不是 Spring AOP 代理驱动的框架。\n\n#### .4.3.2. Combining Pointcut Expressions\n\n[reference](https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators)\n\neg:\n\n```java\n@Pointcut(\"execution(public * *(..))\")\nprivate void anyPublicOperation() {}\n\n@Pointcut(\"within(com.xyz.someapp.trading..*)\")\nprivate void inTrading() {}\n\n@Pointcut(\"anyPublicOperation() && inTrading()\")\nprivate void tradingOperation() {}\n```\n\n- 第一个 pointcut 使用 `execution` 匹配访问级别为 public 的方法\n- 第二个 pointcut 使用 `within` 匹配 `trading` 包下的方法\n- 第三个 pointcut 使用 `&&` 运算符将前两个 pointcut 交集\n\n- 使用更小的命名组件组装一个更复杂的 pointcut expression 更为合适，通过 name 引用 pointcut 时，java 的可见性规则（private/default/protected/public）会被引入。但 visibility rules 并不影响 pointcut 匹配。\n\n#### .4.3.3. Examples\n\n最常用的 PCD : `execution`，对于此 PCD ，其标准的 pointcut expression 是：`execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) thrown-pattern?)`\n\n- 除 ret-type-pattern (返回类型字段) /name-pattern/param-pattern 外，其他字段都是可选的。\n- returning-type-pattern 指定 join points 匹配的返回类型，`*` 表示任何类型都匹配。全限定名的类型只匹配返回类型为指定类型的方法。\n- name-pattern 匹配方法名，可以使用 `*` 通配所有或部分方法名，如果定义了 declaring-type-pattern（指定定义方法所在类），在其后追加一个 `.` 与 name-pattern 组件连用。\n- param-pattern 相对复杂一些。`()` 表示匹配无参数的方法，`(..)` 表示匹配任意数量参数的方法，`(*)` 表示匹配含一个任何类型的参数，`(*,String)` 表示匹配有两个参数的方法，其中第一个参数为任何类型，第二个参数为 String 。[Spring Reference](https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators)[AspectJ reference](https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html)\n- `execution(param)` 模式下的匹配与 `args()` 模式匹配的不同：execution 模式下表示一个方法在签名处定义的参数为指定类型，而 args() 模式表示在方法在运行时被传递的参数为指定类型。\n\n#### .4.3.4. optimize\n\n优化 PCD\n\n为了优化性能，AspectJ 在编译期处理 pointcut。检查代码并决定 join points 是否匹配(静态或动态)一个指定的 pointcut 是耗能不低的。（动态匹配指通过静态分析并不能完全决定是否匹配，需要添加一个 test 在代码处在运行时决定实际是否匹配）。当首次解析一个 pointcut 时，AspectJ 会为匹配流程将 pointcut 重写成一个最优形式。一般来说，pointcuts 会被重写成 DNF(Disjunctive Normal Form)，且 pointcut 组件会按越易计算越先检查的顺序重排序。这就意味着不需要考虑不同的 PCD 性能开销与 pointcuts 定义的顺序。\n\n已知的 PCD 自然地分为三组：\n\n1. kinded designator 选择一个类型的 join point : `execution` `get` `set` `handler`\n2. scoping designator 选择 join point 范围 : `within` `withincode`\n3. contextual designators 根据上下文匹配 join points : `this` `target` `@annotation`\n\nnotes:\n\n1. 一个优质的 pointcut 至少需要包含 kinded 与 scoping 两种类型的 designator;\n2. 仅提供 kinded designator 或 contextual desinator 能够正常工作，但性能不佳，因为需要额外的解析\n3. Scoping designator 可快速匹配，使用此类 PCD 可以快速地忽略不必要的 join points 组。\n\n### .4.4. Declaring Advice\n\n[reference](https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators)\n\nAdvice 与一个 pointcut expression 相关联，并在此 pointcut 匹配的方法执行 before/after/around 切点执行。这个 pointcut expression 要么是一个被命名的 pointcut 简单引用（_直接写 pointcut 的方法名即可_），要么是一个 advice 相应位置的 pointcut expression(_直接用这种写法不就不用再单独写 pointcut 了吗？_)。\n\n- Before Advice: `@Before(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\")`\n- After Returning Advice :  一个正常执行完成的方法执行增强。使用注解 `@AfterReturning(returning=\"retVal\")` ，可以指定方法执行的返回值为 Advice 方法的参数。指定属性 `returning` 的值与 Advice 定义的参数名要保持一致，同时 `returning` 语句也会和 advice 方法中指定的参数类型对 join points 进行约束，其方法执行与此处 advice 方法参数的类型需要匹配。\n    - 需要注意的是：使用此类型的 Advice 返回的引用不可能完全与原来的引用无关。\n- After Throwing Advice : 抛出异常的方法执行的增强。可以使用 `throwing=` 与其异常参数类型配合限制异常的匹配。同样，advice 方法参数名要与 throwing 的值一致，且参数类型也会对 pointcuts 进行约束。\n\n    ```java\n    @Aspect\n    public class AfterThrowingExample {\n        @AfterThrowing(\n            pointcut=\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\",\n            throwing=\"ex\")\n        public void doRecoveryActions(DataAccessException ex) {\n            // ...\n        }\n    }\n    ```\n\n- After Advice: 在切点正常、异常执行完后进行增强。\n- Around Advice: 在切点周围进行增强，可以在方法执行前后进行工作，用于在需要在方法执行前后在线程安全内分享状态。切记使用最小形式的 advice 满足需求，能使用 Before advice 就不要用 Around advice。\n    - 使用 @Around 注解声明，第一个参数必须是 ProceedingJoinPoint，调用其 proceed() 方法就是执行切点的方法，此方法可以传参数 Object[] ，数组中的值被用于方法执行时的参数。\n    - Advice 的参数 JoinPoint 的 proceed() 是否执行、执行任何次数都合法。\n\n#### .4.4.1. Advice Parameters\n\n[reference](https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-advice-after-throwing)\n\n- Access current JoinPoint ，任何增强方法都可以添加第一个参数 JoinPoint，ProceedingJoinPoint 是其子类。可以从 JoinPoint 调用方法获取 args/this proxy/target object/signature/toString\n- 传递参数给 Advice 。使用 `args()` 传递参数到 advice ，可以将其写在 Pointcut 中再在 Advice 中引用 pointcut，也可以直接在 pointcut expression 中添加 args 子句。\n- Advice Parameters and Generics。范型参数在 advice 中的使用，直接在 advice 中指定类型，同样会约束 pointcut。\n    - 直接在参数中指定范型类型。\n    - 如果参数是 Collection<T> ，只能指定为 Collection<?>，再手动检查其类型。\n- Determining Argument Names。指定 Advice 参数名，使用 `argNames=`,默认第一个参数 JoinPoint 不用显式指定出来。\n","source":"_posts/Spring/Spring-AOP.md","raw":"---\nlayout: \"post\"\ntitle: \"AOP\"\ntags: [Spring, AOP]\ndate: \"2018-11-26 10:50\"\ncategories: [AOP]\n---\n\n> aop aspect oriented programming 。面向切面编程，常用于具有横切性质的系统级服务，如：事务管理、安全检查、缓存、对象池管理。\n> **需要说明的是** aop 是一种编程思想，并不仅限于 java 更不仅限于 spring 。但这儿主要针对 java spring aop 进行讨论。纵向重复代码在横向上抽取。<!--more-->\n\nAspectJ 是基于 java 语言的 aop 框架，提供了强大的 aop 功能，其他众多的 aop 框架都借鉴了其思想。包括两个部分：\n\n- 定义如何表达/定义 aop 语法规范。用于解决 java 中的交叉关注点问题。\n- 工具部分：编译/调试。\n\n## .1. AOP Concepts\n\nAspect Oriented Programming 基本概念\n\n1. Aspect: 多个类间的模块化的事物。企业应用中的事务管理就是很好的跨类切面的例子。在 Spring AOP 中通过常规类（schema 途径）或注解 `@AspectsJ` 实现切面。\n2. Join Point: 程序执行中的某一点，如一个方法执行或异常处理。在 Spring AOP 中，一个 Joint Point 通常代表一个方法执行。\n3. Advice: 切面在入点（Joint Point）所采用的动作。大多框架（包括 Spring AOP）将 Advice 建模成拦截器，并为 Join Point 维护一个拦截器链。Advice 类型有：\"Around\" \"Before\" \"After\" 。Spring AOP 包括以下类型：\n    1. Before Advice：在 Join Point 前执行的增强。除非抛出异常，此类型的 Advice 并不能阻止 Joint Point 流程的执行。\n    2. After Returning Advice：在 Join Point 正常流程执行完成（未抛出异常）后执行。\n    3. After Throwing Advice: 在方法因异常退出时执行\n    4. After(finally) advice: 在 join point 方法结束后执行（不管是正常结束还是异常结束）。\n    5. Around advice：在 join point 前后都可执行的 advice。最强势的 advice ，可自定义方法调用前后的行为，也可以决定 join point 是否执行或通过返回自定义的结果（或抛出异常）实现增强方法的快捷执行。\n4. Pointcut： 匹配 Join Point 的判断。Advice 关联一个 Pointcut 表达式，并在每一个匹配上 Pointcut 的切点处执行（eg：执行有某个特定名字的方法）。匹配上 Pointcut 表达式的 Join Point 的概念是 AOP 的核心，Spring 默认使用使用 AspectJ pointcut 表达式语言。\n5. Introduction: 引入外部方法或字段到一个类。Spring AOP 可以引入新的接口与相应的实现到被增强的类。在 AspectJ 社区中，introduction 通常被当作一个内部类的定义。\n6. Target Object:被一个或多个增加的对象。也被当作被增强的对象。Spring AOP 通过运行时代理实现，所以 Target Object 也是一个代理对象。\n7. AOP Proxy：AOP 框架实现 aspect 规约（增加方法执行等等）而创建的对象。在 Spring AOP 中，AOP proxy 通常为 JDK 动态代理或 CGlib 代理。\n8. Weaving: 将 aspect 与其他应用的类型或对象连接以创建增加类。此动作可在编译期（通过 AspectJ Compiler）、加载期、运行时进行。Spring AOP 与大多 Java AOP 框架一样都在编译期执行 weaving。\n\n## .2. aop 实现分为两类\n\n- 静态 AOP 实现：在编译阶段就对程序进行修改，即实现对目标类的增强，生成静态的 AOP 代理类，以 aspcetj 为代表。具有良好的性能，但需要特殊的编译器。\n- 动态 AOP 实现：AOP 框架在运行阶段动态生成 AOP 代理，以实现对目标对象的增加，如： spring AOP 。纯java 实现，无需特殊编译器，性能相对略差。\n\n**基本概念**：\n\n- Aspect 切面：用于组织多个 advice ， advice 就放在 aspect 中定义；\n- Joinpoint 连接点：程序执行过程中明确的点，如：方法的调用/异常的拋出。 在 Spring AOP 中，连接点总是 方法调用。\n- Advice 增强：AOP 框架支持在特定的切入点执行的增加处理。类型有：Before Around After\n- Pointcut 切入点：中以插入增强处理的连接点。当连接点满足指定要求时，该连接点将被添加增加处理，该连接点也就说变成了切点。\n\n## .3. spring aop\n\n- Spring AOP 代理由 IoC 容器负责生成、管理，其依赖关系也由 IoC 窗口负责管理。\n- 在 Spring 使用 Aspectj 支持需要添加三个库：\n    - aspcetjweaver.jar\n    - aspectjrt.jar\n    - aopalliance.jar\n- 配置文件加如下配置：\n\n  ```xml\n  <!--启动@AspectJ支持-->\n  <aop:aspectj-autoproxy/>\n\n  <!--指定自动搜索Bean组件、自动搜索切面类-->\n  <context:component-scan base-package=\"edu.shu.sprint.service\">\n      <context:include-filter type=\"annotation\" expression=\"org.aspectj.lang.annotation.Aspect\"/>\n  </context:component-scan>\n  ```\n\n### .3.1. AOP Proxies\n\n- Spring AOP 默认使用 JDK 动态代理，也可以使用 CGLIB 代理，一般在被代理对象没有实现接口的情况下使用。\n\n## .4. @AspectJ Support\n\n### .4.1. Enable @AspectJ Support\n\n- 在 `@Configuration` 上添加 `@EnableAspectJAutoProxy` 注解，让被增加的 bean 自动代理。\n- 使用 XML 配置 添加标签 `<aop:aspectj-autoproxy />`\n\n### .4.2. Declaring an Aspect\n\n当 @AspectJ 打开后，Spring 会自动检测容器中定义的 Aspect 。定义 Aspect 的方法有两种：\n\n1. 使用 XML 配置添加了 `@Aspect` 的 bean\n2. 使用自动扫描注解 `@Aspect` 的 bean，使用自动扫描 bean 方式时需要在 bean 上添加额外的 `@Component` 或自定义的扫描组件注解。\n\n- 使用 `@Aspect` 注解后的 bean 与其它类一样可以有自己的字段方法，同样可以定义 pointcut/advice\n- Aspects 不能成为其他 aspect 增强的目标，因为 aspect 已经被 `@Aspect` 注解为一个 Aspect 被自动代理排除在外。\n\n### .4.3. Declaring a Pointcut\n\n一个 Pointcut 的定义包括两部分:\n\n1. 由名与任意参数组成的签名（由一个方法定义，此方法签名的返回值必须为 `void`）；\n2. 使用 `@Pointcut` 注解表达的 pointcut 表达式。\n\n#### .4.3.1. Supported Pointcut Designators\n\n支持 Pointcut 的标识符（PCD pointcut designators 用来匹配符合的 join point，限制 Spring AOP 方法执行）\n\n- execution: 匹配 join points，主要的 pointcut 标识符\n- within: 限制 join points 所在的类需要是特定类型\n- this: bean reference（Spring AOP 代理对象）为指定类型的实例限定 join points 匹配\n- target: 目标对象（被代理的应用对象）是指定 type 的实例\n- args: 限制参数（arguments）为指定类型（type） 的实例\n- @target：限制执行对象需要有指定类型的注解\n- @args: 限制运行时被传递的参数必须有指定类型的注解\n- @within: 限制 join points 所在的类需要有指定的注解\n- @annotation: 限制 join points (AOP 中所执行的方法) 需要有指定的注解。\n\n##### .4.3.1.1. Spring AOP 与 AspectJ 不同之处\n\n- 除以上几个标志符外，AspectJ 还有其他的 Designator（如：`call`,`withinCode`,`@withinCode`, etc.），但若在 Spring 中使用这些标志符会抛出 `IllegalArgumentException`。\n- Spring AOP 窄化了 AspectJ 中标志符的定义，join points 只匹配了方法执行。\n- AspectJ 还有基于类型的语义（type-based semantics），且其标志符 `this` `target` 都是指相同的对象：执行方法的对象。而在 Spring AOP 是基于代理的系统，其代理（与 `this` 绑定）与其在代理之后的目标对象（与 `target` 绑定）是不同的。\n- 因为 Spring AOP is proxy-based 框架本质，所以直接调用其目标对象，并不能实现 AOP 拦截。JDK 动态代理只能对 public interface method 进行拦截，而CGLIB 代理 public/protected （如果需要，package-visible  方法也可以）都可被代理。\n- `bean` Spring AOP 有一个原生 AspectJ 所没有的 PCD ： `bean`。通过 bean name 匹配 bean ，也可加上通配符 `*` 匹配 bean 集合。与其他标签符一样， bean 可以使用 `&&` `||` `!` 运算符。  \n    - `bean` 是针对 Spring 扩展的 PCD ，因此在 `@Aspect` 模式中无效。 `bean` PCD 在实例级别上运行不仅仅是在类型级别上，instance-based PCD 是 Spring 基于代理的 AOP 框架的功能，与 Spring bean 工厂紧密整合，因此能自然而直接地通过 name 识别 bean。\n\n##### .4.3.1.2. Notes\n\n- 切点定义通常与任何拦截的方法相匹配。如果切入点被严格定义为只公开的，那么即使在 CGLIB 代理场景中，通过代理进行潜在的非公开交互，也需要相应地定义它。\n- 如果拦截需要包含目标对象的方法调用或构造器，需要使用 Spring 驱动的 native AspectJ weaving 而不是 Spring AOP 代理驱动的框架。\n\n#### .4.3.2. Combining Pointcut Expressions\n\n[reference](https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators)\n\neg:\n\n```java\n@Pointcut(\"execution(public * *(..))\")\nprivate void anyPublicOperation() {}\n\n@Pointcut(\"within(com.xyz.someapp.trading..*)\")\nprivate void inTrading() {}\n\n@Pointcut(\"anyPublicOperation() && inTrading()\")\nprivate void tradingOperation() {}\n```\n\n- 第一个 pointcut 使用 `execution` 匹配访问级别为 public 的方法\n- 第二个 pointcut 使用 `within` 匹配 `trading` 包下的方法\n- 第三个 pointcut 使用 `&&` 运算符将前两个 pointcut 交集\n\n- 使用更小的命名组件组装一个更复杂的 pointcut expression 更为合适，通过 name 引用 pointcut 时，java 的可见性规则（private/default/protected/public）会被引入。但 visibility rules 并不影响 pointcut 匹配。\n\n#### .4.3.3. Examples\n\n最常用的 PCD : `execution`，对于此 PCD ，其标准的 pointcut expression 是：`execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) thrown-pattern?)`\n\n- 除 ret-type-pattern (返回类型字段) /name-pattern/param-pattern 外，其他字段都是可选的。\n- returning-type-pattern 指定 join points 匹配的返回类型，`*` 表示任何类型都匹配。全限定名的类型只匹配返回类型为指定类型的方法。\n- name-pattern 匹配方法名，可以使用 `*` 通配所有或部分方法名，如果定义了 declaring-type-pattern（指定定义方法所在类），在其后追加一个 `.` 与 name-pattern 组件连用。\n- param-pattern 相对复杂一些。`()` 表示匹配无参数的方法，`(..)` 表示匹配任意数量参数的方法，`(*)` 表示匹配含一个任何类型的参数，`(*,String)` 表示匹配有两个参数的方法，其中第一个参数为任何类型，第二个参数为 String 。[Spring Reference](https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators)[AspectJ reference](https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html)\n- `execution(param)` 模式下的匹配与 `args()` 模式匹配的不同：execution 模式下表示一个方法在签名处定义的参数为指定类型，而 args() 模式表示在方法在运行时被传递的参数为指定类型。\n\n#### .4.3.4. optimize\n\n优化 PCD\n\n为了优化性能，AspectJ 在编译期处理 pointcut。检查代码并决定 join points 是否匹配(静态或动态)一个指定的 pointcut 是耗能不低的。（动态匹配指通过静态分析并不能完全决定是否匹配，需要添加一个 test 在代码处在运行时决定实际是否匹配）。当首次解析一个 pointcut 时，AspectJ 会为匹配流程将 pointcut 重写成一个最优形式。一般来说，pointcuts 会被重写成 DNF(Disjunctive Normal Form)，且 pointcut 组件会按越易计算越先检查的顺序重排序。这就意味着不需要考虑不同的 PCD 性能开销与 pointcuts 定义的顺序。\n\n已知的 PCD 自然地分为三组：\n\n1. kinded designator 选择一个类型的 join point : `execution` `get` `set` `handler`\n2. scoping designator 选择 join point 范围 : `within` `withincode`\n3. contextual designators 根据上下文匹配 join points : `this` `target` `@annotation`\n\nnotes:\n\n1. 一个优质的 pointcut 至少需要包含 kinded 与 scoping 两种类型的 designator;\n2. 仅提供 kinded designator 或 contextual desinator 能够正常工作，但性能不佳，因为需要额外的解析\n3. Scoping designator 可快速匹配，使用此类 PCD 可以快速地忽略不必要的 join points 组。\n\n### .4.4. Declaring Advice\n\n[reference](https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators)\n\nAdvice 与一个 pointcut expression 相关联，并在此 pointcut 匹配的方法执行 before/after/around 切点执行。这个 pointcut expression 要么是一个被命名的 pointcut 简单引用（_直接写 pointcut 的方法名即可_），要么是一个 advice 相应位置的 pointcut expression(_直接用这种写法不就不用再单独写 pointcut 了吗？_)。\n\n- Before Advice: `@Before(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\")`\n- After Returning Advice :  一个正常执行完成的方法执行增强。使用注解 `@AfterReturning(returning=\"retVal\")` ，可以指定方法执行的返回值为 Advice 方法的参数。指定属性 `returning` 的值与 Advice 定义的参数名要保持一致，同时 `returning` 语句也会和 advice 方法中指定的参数类型对 join points 进行约束，其方法执行与此处 advice 方法参数的类型需要匹配。\n    - 需要注意的是：使用此类型的 Advice 返回的引用不可能完全与原来的引用无关。\n- After Throwing Advice : 抛出异常的方法执行的增强。可以使用 `throwing=` 与其异常参数类型配合限制异常的匹配。同样，advice 方法参数名要与 throwing 的值一致，且参数类型也会对 pointcuts 进行约束。\n\n    ```java\n    @Aspect\n    public class AfterThrowingExample {\n        @AfterThrowing(\n            pointcut=\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\",\n            throwing=\"ex\")\n        public void doRecoveryActions(DataAccessException ex) {\n            // ...\n        }\n    }\n    ```\n\n- After Advice: 在切点正常、异常执行完后进行增强。\n- Around Advice: 在切点周围进行增强，可以在方法执行前后进行工作，用于在需要在方法执行前后在线程安全内分享状态。切记使用最小形式的 advice 满足需求，能使用 Before advice 就不要用 Around advice。\n    - 使用 @Around 注解声明，第一个参数必须是 ProceedingJoinPoint，调用其 proceed() 方法就是执行切点的方法，此方法可以传参数 Object[] ，数组中的值被用于方法执行时的参数。\n    - Advice 的参数 JoinPoint 的 proceed() 是否执行、执行任何次数都合法。\n\n#### .4.4.1. Advice Parameters\n\n[reference](https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-advice-after-throwing)\n\n- Access current JoinPoint ，任何增强方法都可以添加第一个参数 JoinPoint，ProceedingJoinPoint 是其子类。可以从 JoinPoint 调用方法获取 args/this proxy/target object/signature/toString\n- 传递参数给 Advice 。使用 `args()` 传递参数到 advice ，可以将其写在 Pointcut 中再在 Advice 中引用 pointcut，也可以直接在 pointcut expression 中添加 args 子句。\n- Advice Parameters and Generics。范型参数在 advice 中的使用，直接在 advice 中指定类型，同样会约束 pointcut。\n    - 直接在参数中指定范型类型。\n    - 如果参数是 Collection<T> ，只能指定为 Collection<?>，再手动检查其类型。\n- Determining Argument Names。指定 Advice 参数名，使用 `argNames=`,默认第一个参数 JoinPoint 不用显式指定出来。\n","slug":"Spring/Spring-AOP","published":1,"updated":"2021-02-24T15:22:22.964Z","comments":1,"photos":[],"link":"","_id":"ckljnokrl00222bhbdev0eu3s","content":"<blockquote>\n<p>aop aspect oriented programming 。面向切面编程，常用于具有横切性质的系统级服务，如：事务管理、安全检查、缓存、对象池管理。<br><strong>需要说明的是</strong> aop 是一种编程思想，并不仅限于 java 更不仅限于 spring 。但这儿主要针对 java spring aop 进行讨论。纵向重复代码在横向上抽取。<span id=\"more\"></span></p>\n</blockquote>\n<p>AspectJ 是基于 java 语言的 aop 框架，提供了强大的 aop 功能，其他众多的 aop 框架都借鉴了其思想。包括两个部分：</p>\n<ul>\n<li>定义如何表达/定义 aop 语法规范。用于解决 java 中的交叉关注点问题。</li>\n<li>工具部分：编译/调试。</li>\n</ul>\n<h2 id=\"1-AOP-Concepts\"><a href=\"#1-AOP-Concepts\" class=\"headerlink\" title=\".1. AOP Concepts\"></a>.1. AOP Concepts</h2><p>Aspect Oriented Programming 基本概念</p>\n<ol>\n<li>Aspect: 多个类间的模块化的事物。企业应用中的事务管理就是很好的跨类切面的例子。在 Spring AOP 中通过常规类（schema 途径）或注解 <code>@AspectsJ</code> 实现切面。</li>\n<li>Join Point: 程序执行中的某一点，如一个方法执行或异常处理。在 Spring AOP 中，一个 Joint Point 通常代表一个方法执行。</li>\n<li>Advice: 切面在入点（Joint Point）所采用的动作。大多框架（包括 Spring AOP）将 Advice 建模成拦截器，并为 Join Point 维护一个拦截器链。Advice 类型有：”Around” “Before” “After” 。Spring AOP 包括以下类型：<ol>\n<li>Before Advice：在 Join Point 前执行的增强。除非抛出异常，此类型的 Advice 并不能阻止 Joint Point 流程的执行。</li>\n<li>After Returning Advice：在 Join Point 正常流程执行完成（未抛出异常）后执行。</li>\n<li>After Throwing Advice: 在方法因异常退出时执行</li>\n<li>After(finally) advice: 在 join point 方法结束后执行（不管是正常结束还是异常结束）。</li>\n<li>Around advice：在 join point 前后都可执行的 advice。最强势的 advice ，可自定义方法调用前后的行为，也可以决定 join point 是否执行或通过返回自定义的结果（或抛出异常）实现增强方法的快捷执行。</li>\n</ol>\n</li>\n<li>Pointcut： 匹配 Join Point 的判断。Advice 关联一个 Pointcut 表达式，并在每一个匹配上 Pointcut 的切点处执行（eg：执行有某个特定名字的方法）。匹配上 Pointcut 表达式的 Join Point 的概念是 AOP 的核心，Spring 默认使用使用 AspectJ pointcut 表达式语言。</li>\n<li>Introduction: 引入外部方法或字段到一个类。Spring AOP 可以引入新的接口与相应的实现到被增强的类。在 AspectJ 社区中，introduction 通常被当作一个内部类的定义。</li>\n<li>Target Object:被一个或多个增加的对象。也被当作被增强的对象。Spring AOP 通过运行时代理实现，所以 Target Object 也是一个代理对象。</li>\n<li>AOP Proxy：AOP 框架实现 aspect 规约（增加方法执行等等）而创建的对象。在 Spring AOP 中，AOP proxy 通常为 JDK 动态代理或 CGlib 代理。</li>\n<li>Weaving: 将 aspect 与其他应用的类型或对象连接以创建增加类。此动作可在编译期（通过 AspectJ Compiler）、加载期、运行时进行。Spring AOP 与大多 Java AOP 框架一样都在编译期执行 weaving。</li>\n</ol>\n<h2 id=\"2-aop-实现分为两类\"><a href=\"#2-aop-实现分为两类\" class=\"headerlink\" title=\".2. aop 实现分为两类\"></a>.2. aop 实现分为两类</h2><ul>\n<li>静态 AOP 实现：在编译阶段就对程序进行修改，即实现对目标类的增强，生成静态的 AOP 代理类，以 aspcetj 为代表。具有良好的性能，但需要特殊的编译器。</li>\n<li>动态 AOP 实现：AOP 框架在运行阶段动态生成 AOP 代理，以实现对目标对象的增加，如： spring AOP 。纯java 实现，无需特殊编译器，性能相对略差。</li>\n</ul>\n<p><strong>基本概念</strong>：</p>\n<ul>\n<li>Aspect 切面：用于组织多个 advice ， advice 就放在 aspect 中定义；</li>\n<li>Joinpoint 连接点：程序执行过程中明确的点，如：方法的调用/异常的拋出。 在 Spring AOP 中，连接点总是 方法调用。</li>\n<li>Advice 增强：AOP 框架支持在特定的切入点执行的增加处理。类型有：Before Around After</li>\n<li>Pointcut 切入点：中以插入增强处理的连接点。当连接点满足指定要求时，该连接点将被添加增加处理，该连接点也就说变成了切点。</li>\n</ul>\n<h2 id=\"3-spring-aop\"><a href=\"#3-spring-aop\" class=\"headerlink\" title=\".3. spring aop\"></a>.3. spring aop</h2><ul>\n<li><p>Spring AOP 代理由 IoC 容器负责生成、管理，其依赖关系也由 IoC 窗口负责管理。</p>\n</li>\n<li><p>在 Spring 使用 Aspectj 支持需要添加三个库：</p>\n<ul>\n<li>aspcetjweaver.jar</li>\n<li>aspectjrt.jar</li>\n<li>aopalliance.jar</li>\n</ul>\n</li>\n<li><p>配置文件加如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--启动@AspectJ支持--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--指定自动搜索Bean组件、自动搜索切面类--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;edu.shu.sprint.service&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.aspectj.lang.annotation.Aspect&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-1-AOP-Proxies\"><a href=\"#3-1-AOP-Proxies\" class=\"headerlink\" title=\".3.1. AOP Proxies\"></a>.3.1. AOP Proxies</h3><ul>\n<li>Spring AOP 默认使用 JDK 动态代理，也可以使用 CGLIB 代理，一般在被代理对象没有实现接口的情况下使用。</li>\n</ul>\n<h2 id=\"4-AspectJ-Support\"><a href=\"#4-AspectJ-Support\" class=\"headerlink\" title=\".4. @AspectJ Support\"></a>.4. @AspectJ Support</h2><h3 id=\"4-1-Enable-AspectJ-Support\"><a href=\"#4-1-Enable-AspectJ-Support\" class=\"headerlink\" title=\".4.1. Enable @AspectJ Support\"></a>.4.1. Enable @AspectJ Support</h3><ul>\n<li>在 <code>@Configuration</code> 上添加 <code>@EnableAspectJAutoProxy</code> 注解，让被增加的 bean 自动代理。</li>\n<li>使用 XML 配置 添加标签 <code>&lt;aop:aspectj-autoproxy /&gt;</code></li>\n</ul>\n<h3 id=\"4-2-Declaring-an-Aspect\"><a href=\"#4-2-Declaring-an-Aspect\" class=\"headerlink\" title=\".4.2. Declaring an Aspect\"></a>.4.2. Declaring an Aspect</h3><p>当 @AspectJ 打开后，Spring 会自动检测容器中定义的 Aspect 。定义 Aspect 的方法有两种：</p>\n<ol>\n<li>使用 XML 配置添加了 <code>@Aspect</code> 的 bean</li>\n<li>使用自动扫描注解 <code>@Aspect</code> 的 bean，使用自动扫描 bean 方式时需要在 bean 上添加额外的 <code>@Component</code> 或自定义的扫描组件注解。</li>\n</ol>\n<ul>\n<li>使用 <code>@Aspect</code> 注解后的 bean 与其它类一样可以有自己的字段方法，同样可以定义 pointcut/advice</li>\n<li>Aspects 不能成为其他 aspect 增强的目标，因为 aspect 已经被 <code>@Aspect</code> 注解为一个 Aspect 被自动代理排除在外。</li>\n</ul>\n<h3 id=\"4-3-Declaring-a-Pointcut\"><a href=\"#4-3-Declaring-a-Pointcut\" class=\"headerlink\" title=\".4.3. Declaring a Pointcut\"></a>.4.3. Declaring a Pointcut</h3><p>一个 Pointcut 的定义包括两部分:</p>\n<ol>\n<li>由名与任意参数组成的签名（由一个方法定义，此方法签名的返回值必须为 <code>void</code>）；</li>\n<li>使用 <code>@Pointcut</code> 注解表达的 pointcut 表达式。</li>\n</ol>\n<h4 id=\"4-3-1-Supported-Pointcut-Designators\"><a href=\"#4-3-1-Supported-Pointcut-Designators\" class=\"headerlink\" title=\".4.3.1. Supported Pointcut Designators\"></a>.4.3.1. Supported Pointcut Designators</h4><p>支持 Pointcut 的标识符（PCD pointcut designators 用来匹配符合的 join point，限制 Spring AOP 方法执行）</p>\n<ul>\n<li>execution: 匹配 join points，主要的 pointcut 标识符</li>\n<li>within: 限制 join points 所在的类需要是特定类型</li>\n<li>this: bean reference（Spring AOP 代理对象）为指定类型的实例限定 join points 匹配</li>\n<li>target: 目标对象（被代理的应用对象）是指定 type 的实例</li>\n<li>args: 限制参数（arguments）为指定类型（type） 的实例</li>\n<li>@target：限制执行对象需要有指定类型的注解</li>\n<li>@args: 限制运行时被传递的参数必须有指定类型的注解</li>\n<li>@within: 限制 join points 所在的类需要有指定的注解</li>\n<li>@annotation: 限制 join points (AOP 中所执行的方法) 需要有指定的注解。</li>\n</ul>\n<h5 id=\"4-3-1-1-Spring-AOP-与-AspectJ-不同之处\"><a href=\"#4-3-1-1-Spring-AOP-与-AspectJ-不同之处\" class=\"headerlink\" title=\".4.3.1.1. Spring AOP 与 AspectJ 不同之处\"></a>.4.3.1.1. Spring AOP 与 AspectJ 不同之处</h5><ul>\n<li>除以上几个标志符外，AspectJ 还有其他的 Designator（如：<code>call</code>,<code>withinCode</code>,<code>@withinCode</code>, etc.），但若在 Spring 中使用这些标志符会抛出 <code>IllegalArgumentException</code>。</li>\n<li>Spring AOP 窄化了 AspectJ 中标志符的定义，join points 只匹配了方法执行。</li>\n<li>AspectJ 还有基于类型的语义（type-based semantics），且其标志符 <code>this</code> <code>target</code> 都是指相同的对象：执行方法的对象。而在 Spring AOP 是基于代理的系统，其代理（与 <code>this</code> 绑定）与其在代理之后的目标对象（与 <code>target</code> 绑定）是不同的。</li>\n<li>因为 Spring AOP is proxy-based 框架本质，所以直接调用其目标对象，并不能实现 AOP 拦截。JDK 动态代理只能对 public interface method 进行拦截，而CGLIB 代理 public/protected （如果需要，package-visible  方法也可以）都可被代理。</li>\n<li><code>bean</code> Spring AOP 有一个原生 AspectJ 所没有的 PCD ： <code>bean</code>。通过 bean name 匹配 bean ，也可加上通配符 <code>*</code> 匹配 bean 集合。与其他标签符一样， bean 可以使用 <code>&amp;&amp;</code> <code>||</code> <code>!</code> 运算符。  <ul>\n<li><code>bean</code> 是针对 Spring 扩展的 PCD ，因此在 <code>@Aspect</code> 模式中无效。 <code>bean</code> PCD 在实例级别上运行不仅仅是在类型级别上，instance-based PCD 是 Spring 基于代理的 AOP 框架的功能，与 Spring bean 工厂紧密整合，因此能自然而直接地通过 name 识别 bean。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"4-3-1-2-Notes\"><a href=\"#4-3-1-2-Notes\" class=\"headerlink\" title=\".4.3.1.2. Notes\"></a>.4.3.1.2. Notes</h5><ul>\n<li>切点定义通常与任何拦截的方法相匹配。如果切入点被严格定义为只公开的，那么即使在 CGLIB 代理场景中，通过代理进行潜在的非公开交互，也需要相应地定义它。</li>\n<li>如果拦截需要包含目标对象的方法调用或构造器，需要使用 Spring 驱动的 native AspectJ weaving 而不是 Spring AOP 代理驱动的框架。</li>\n</ul>\n<h4 id=\"4-3-2-Combining-Pointcut-Expressions\"><a href=\"#4-3-2-Combining-Pointcut-Expressions\" class=\"headerlink\" title=\".4.3.2. Combining Pointcut Expressions\"></a>.4.3.2. Combining Pointcut Expressions</h4><p><a href=\"https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators\">reference</a></p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">anyPublicOperation</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inTrading</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">tradingOperation</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第一个 pointcut 使用 <code>execution</code> 匹配访问级别为 public 的方法</p>\n</li>\n<li><p>第二个 pointcut 使用 <code>within</code> 匹配 <code>trading</code> 包下的方法</p>\n</li>\n<li><p>第三个 pointcut 使用 <code>&amp;&amp;</code> 运算符将前两个 pointcut 交集</p>\n</li>\n<li><p>使用更小的命名组件组装一个更复杂的 pointcut expression 更为合适，通过 name 引用 pointcut 时，java 的可见性规则（private/default/protected/public）会被引入。但 visibility rules 并不影响 pointcut 匹配。</p>\n</li>\n</ul>\n<h4 id=\"4-3-3-Examples\"><a href=\"#4-3-3-Examples\" class=\"headerlink\" title=\".4.3.3. Examples\"></a>.4.3.3. Examples</h4><p>最常用的 PCD : <code>execution</code>，对于此 PCD ，其标准的 pointcut expression 是：<code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) thrown-pattern?)</code></p>\n<ul>\n<li>除 ret-type-pattern (返回类型字段) /name-pattern/param-pattern 外，其他字段都是可选的。</li>\n<li>returning-type-pattern 指定 join points 匹配的返回类型，<code>*</code> 表示任何类型都匹配。全限定名的类型只匹配返回类型为指定类型的方法。</li>\n<li>name-pattern 匹配方法名，可以使用 <code>*</code> 通配所有或部分方法名，如果定义了 declaring-type-pattern（指定定义方法所在类），在其后追加一个 <code>.</code> 与 name-pattern 组件连用。</li>\n<li>param-pattern 相对复杂一些。<code>()</code> 表示匹配无参数的方法，<code>(..)</code> 表示匹配任意数量参数的方法，<code>(*)</code> 表示匹配含一个任何类型的参数，<code>(*,String)</code> 表示匹配有两个参数的方法，其中第一个参数为任何类型，第二个参数为 String 。<a href=\"https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators\">Spring Reference</a><a href=\"https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html\">AspectJ reference</a></li>\n<li><code>execution(param)</code> 模式下的匹配与 <code>args()</code> 模式匹配的不同：execution 模式下表示一个方法在签名处定义的参数为指定类型，而 args() 模式表示在方法在运行时被传递的参数为指定类型。</li>\n</ul>\n<h4 id=\"4-3-4-optimize\"><a href=\"#4-3-4-optimize\" class=\"headerlink\" title=\".4.3.4. optimize\"></a>.4.3.4. optimize</h4><p>优化 PCD</p>\n<p>为了优化性能，AspectJ 在编译期处理 pointcut。检查代码并决定 join points 是否匹配(静态或动态)一个指定的 pointcut 是耗能不低的。（动态匹配指通过静态分析并不能完全决定是否匹配，需要添加一个 test 在代码处在运行时决定实际是否匹配）。当首次解析一个 pointcut 时，AspectJ 会为匹配流程将 pointcut 重写成一个最优形式。一般来说，pointcuts 会被重写成 DNF(Disjunctive Normal Form)，且 pointcut 组件会按越易计算越先检查的顺序重排序。这就意味着不需要考虑不同的 PCD 性能开销与 pointcuts 定义的顺序。</p>\n<p>已知的 PCD 自然地分为三组：</p>\n<ol>\n<li>kinded designator 选择一个类型的 join point : <code>execution</code> <code>get</code> <code>set</code> <code>handler</code></li>\n<li>scoping designator 选择 join point 范围 : <code>within</code> <code>withincode</code></li>\n<li>contextual designators 根据上下文匹配 join points : <code>this</code> <code>target</code> <code>@annotation</code></li>\n</ol>\n<p>notes:</p>\n<ol>\n<li>一个优质的 pointcut 至少需要包含 kinded 与 scoping 两种类型的 designator;</li>\n<li>仅提供 kinded designator 或 contextual desinator 能够正常工作，但性能不佳，因为需要额外的解析</li>\n<li>Scoping designator 可快速匹配，使用此类 PCD 可以快速地忽略不必要的 join points 组。</li>\n</ol>\n<h3 id=\"4-4-Declaring-Advice\"><a href=\"#4-4-Declaring-Advice\" class=\"headerlink\" title=\".4.4. Declaring Advice\"></a>.4.4. Declaring Advice</h3><p><a href=\"https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators\">reference</a></p>\n<p>Advice 与一个 pointcut expression 相关联，并在此 pointcut 匹配的方法执行 before/after/around 切点执行。这个 pointcut expression 要么是一个被命名的 pointcut 简单引用（<em>直接写 pointcut 的方法名即可_），要么是一个 advice 相应位置的 pointcut expression(_直接用这种写法不就不用再单独写 pointcut 了吗？</em>)。</p>\n<ul>\n<li><p>Before Advice: <code>@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</code></p>\n</li>\n<li><p>After Returning Advice :  一个正常执行完成的方法执行增强。使用注解 <code>@AfterReturning(returning=&quot;retVal&quot;)</code> ，可以指定方法执行的返回值为 Advice 方法的参数。指定属性 <code>returning</code> 的值与 Advice 定义的参数名要保持一致，同时 <code>returning</code> 语句也会和 advice 方法中指定的参数类型对 join points 进行约束，其方法执行与此处 advice 方法参数的类型需要匹配。</p>\n<ul>\n<li>需要注意的是：使用此类型的 Advice 返回的引用不可能完全与原来的引用无关。</li>\n</ul>\n</li>\n<li><p>After Throwing Advice : 抛出异常的方法执行的增强。可以使用 <code>throwing=</code> 与其异常参数类型配合限制异常的匹配。同样，advice 方法参数名要与 throwing 的值一致，且参数类型也会对 pointcuts 进行约束。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AfterThrowingExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(</span></span><br><span class=\"line\"><span class=\"meta\">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        throwing=&quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRecoveryActions</span><span class=\"params\">(DataAccessException ex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>After Advice: 在切点正常、异常执行完后进行增强。</p>\n</li>\n<li><p>Around Advice: 在切点周围进行增强，可以在方法执行前后进行工作，用于在需要在方法执行前后在线程安全内分享状态。切记使用最小形式的 advice 满足需求，能使用 Before advice 就不要用 Around advice。</p>\n<ul>\n<li>使用 @Around 注解声明，第一个参数必须是 ProceedingJoinPoint，调用其 proceed() 方法就是执行切点的方法，此方法可以传参数 Object[] ，数组中的值被用于方法执行时的参数。</li>\n<li>Advice 的参数 JoinPoint 的 proceed() 是否执行、执行任何次数都合法。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-4-1-Advice-Parameters\"><a href=\"#4-4-1-Advice-Parameters\" class=\"headerlink\" title=\".4.4.1. Advice Parameters\"></a>.4.4.1. Advice Parameters</h4><p><a href=\"https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-advice-after-throwing\">reference</a></p>\n<ul>\n<li>Access current JoinPoint ，任何增强方法都可以添加第一个参数 JoinPoint，ProceedingJoinPoint 是其子类。可以从 JoinPoint 调用方法获取 args/this proxy/target object/signature/toString</li>\n<li>传递参数给 Advice 。使用 <code>args()</code> 传递参数到 advice ，可以将其写在 Pointcut 中再在 Advice 中引用 pointcut，也可以直接在 pointcut expression 中添加 args 子句。</li>\n<li>Advice Parameters and Generics。范型参数在 advice 中的使用，直接在 advice 中指定类型，同样会约束 pointcut。<ul>\n<li>直接在参数中指定范型类型。</li>\n<li>如果参数是 Collection<T> ，只能指定为 Collection&lt;?&gt;，再手动检查其类型。</li>\n</ul>\n</li>\n<li>Determining Argument Names。指定 Advice 参数名，使用 <code>argNames=</code>,默认第一个参数 JoinPoint 不用显式指定出来。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>aop aspect oriented programming 。面向切面编程，常用于具有横切性质的系统级服务，如：事务管理、安全检查、缓存、对象池管理。<br><strong>需要说明的是</strong> aop 是一种编程思想，并不仅限于 java 更不仅限于 spring 。但这儿主要针对 java spring aop 进行讨论。纵向重复代码在横向上抽取。","more":"</p>\n</blockquote>\n<p>AspectJ 是基于 java 语言的 aop 框架，提供了强大的 aop 功能，其他众多的 aop 框架都借鉴了其思想。包括两个部分：</p>\n<ul>\n<li>定义如何表达/定义 aop 语法规范。用于解决 java 中的交叉关注点问题。</li>\n<li>工具部分：编译/调试。</li>\n</ul>\n<h2 id=\"1-AOP-Concepts\"><a href=\"#1-AOP-Concepts\" class=\"headerlink\" title=\".1. AOP Concepts\"></a>.1. AOP Concepts</h2><p>Aspect Oriented Programming 基本概念</p>\n<ol>\n<li>Aspect: 多个类间的模块化的事物。企业应用中的事务管理就是很好的跨类切面的例子。在 Spring AOP 中通过常规类（schema 途径）或注解 <code>@AspectsJ</code> 实现切面。</li>\n<li>Join Point: 程序执行中的某一点，如一个方法执行或异常处理。在 Spring AOP 中，一个 Joint Point 通常代表一个方法执行。</li>\n<li>Advice: 切面在入点（Joint Point）所采用的动作。大多框架（包括 Spring AOP）将 Advice 建模成拦截器，并为 Join Point 维护一个拦截器链。Advice 类型有：”Around” “Before” “After” 。Spring AOP 包括以下类型：<ol>\n<li>Before Advice：在 Join Point 前执行的增强。除非抛出异常，此类型的 Advice 并不能阻止 Joint Point 流程的执行。</li>\n<li>After Returning Advice：在 Join Point 正常流程执行完成（未抛出异常）后执行。</li>\n<li>After Throwing Advice: 在方法因异常退出时执行</li>\n<li>After(finally) advice: 在 join point 方法结束后执行（不管是正常结束还是异常结束）。</li>\n<li>Around advice：在 join point 前后都可执行的 advice。最强势的 advice ，可自定义方法调用前后的行为，也可以决定 join point 是否执行或通过返回自定义的结果（或抛出异常）实现增强方法的快捷执行。</li>\n</ol>\n</li>\n<li>Pointcut： 匹配 Join Point 的判断。Advice 关联一个 Pointcut 表达式，并在每一个匹配上 Pointcut 的切点处执行（eg：执行有某个特定名字的方法）。匹配上 Pointcut 表达式的 Join Point 的概念是 AOP 的核心，Spring 默认使用使用 AspectJ pointcut 表达式语言。</li>\n<li>Introduction: 引入外部方法或字段到一个类。Spring AOP 可以引入新的接口与相应的实现到被增强的类。在 AspectJ 社区中，introduction 通常被当作一个内部类的定义。</li>\n<li>Target Object:被一个或多个增加的对象。也被当作被增强的对象。Spring AOP 通过运行时代理实现，所以 Target Object 也是一个代理对象。</li>\n<li>AOP Proxy：AOP 框架实现 aspect 规约（增加方法执行等等）而创建的对象。在 Spring AOP 中，AOP proxy 通常为 JDK 动态代理或 CGlib 代理。</li>\n<li>Weaving: 将 aspect 与其他应用的类型或对象连接以创建增加类。此动作可在编译期（通过 AspectJ Compiler）、加载期、运行时进行。Spring AOP 与大多 Java AOP 框架一样都在编译期执行 weaving。</li>\n</ol>\n<h2 id=\"2-aop-实现分为两类\"><a href=\"#2-aop-实现分为两类\" class=\"headerlink\" title=\".2. aop 实现分为两类\"></a>.2. aop 实现分为两类</h2><ul>\n<li>静态 AOP 实现：在编译阶段就对程序进行修改，即实现对目标类的增强，生成静态的 AOP 代理类，以 aspcetj 为代表。具有良好的性能，但需要特殊的编译器。</li>\n<li>动态 AOP 实现：AOP 框架在运行阶段动态生成 AOP 代理，以实现对目标对象的增加，如： spring AOP 。纯java 实现，无需特殊编译器，性能相对略差。</li>\n</ul>\n<p><strong>基本概念</strong>：</p>\n<ul>\n<li>Aspect 切面：用于组织多个 advice ， advice 就放在 aspect 中定义；</li>\n<li>Joinpoint 连接点：程序执行过程中明确的点，如：方法的调用/异常的拋出。 在 Spring AOP 中，连接点总是 方法调用。</li>\n<li>Advice 增强：AOP 框架支持在特定的切入点执行的增加处理。类型有：Before Around After</li>\n<li>Pointcut 切入点：中以插入增强处理的连接点。当连接点满足指定要求时，该连接点将被添加增加处理，该连接点也就说变成了切点。</li>\n</ul>\n<h2 id=\"3-spring-aop\"><a href=\"#3-spring-aop\" class=\"headerlink\" title=\".3. spring aop\"></a>.3. spring aop</h2><ul>\n<li><p>Spring AOP 代理由 IoC 容器负责生成、管理，其依赖关系也由 IoC 窗口负责管理。</p>\n</li>\n<li><p>在 Spring 使用 Aspectj 支持需要添加三个库：</p>\n<ul>\n<li>aspcetjweaver.jar</li>\n<li>aspectjrt.jar</li>\n<li>aopalliance.jar</li>\n</ul>\n</li>\n<li><p>配置文件加如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--启动@AspectJ支持--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--指定自动搜索Bean组件、自动搜索切面类--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;edu.shu.sprint.service&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.aspectj.lang.annotation.Aspect&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-1-AOP-Proxies\"><a href=\"#3-1-AOP-Proxies\" class=\"headerlink\" title=\".3.1. AOP Proxies\"></a>.3.1. AOP Proxies</h3><ul>\n<li>Spring AOP 默认使用 JDK 动态代理，也可以使用 CGLIB 代理，一般在被代理对象没有实现接口的情况下使用。</li>\n</ul>\n<h2 id=\"4-AspectJ-Support\"><a href=\"#4-AspectJ-Support\" class=\"headerlink\" title=\".4. @AspectJ Support\"></a>.4. @AspectJ Support</h2><h3 id=\"4-1-Enable-AspectJ-Support\"><a href=\"#4-1-Enable-AspectJ-Support\" class=\"headerlink\" title=\".4.1. Enable @AspectJ Support\"></a>.4.1. Enable @AspectJ Support</h3><ul>\n<li>在 <code>@Configuration</code> 上添加 <code>@EnableAspectJAutoProxy</code> 注解，让被增加的 bean 自动代理。</li>\n<li>使用 XML 配置 添加标签 <code>&lt;aop:aspectj-autoproxy /&gt;</code></li>\n</ul>\n<h3 id=\"4-2-Declaring-an-Aspect\"><a href=\"#4-2-Declaring-an-Aspect\" class=\"headerlink\" title=\".4.2. Declaring an Aspect\"></a>.4.2. Declaring an Aspect</h3><p>当 @AspectJ 打开后，Spring 会自动检测容器中定义的 Aspect 。定义 Aspect 的方法有两种：</p>\n<ol>\n<li>使用 XML 配置添加了 <code>@Aspect</code> 的 bean</li>\n<li>使用自动扫描注解 <code>@Aspect</code> 的 bean，使用自动扫描 bean 方式时需要在 bean 上添加额外的 <code>@Component</code> 或自定义的扫描组件注解。</li>\n</ol>\n<ul>\n<li>使用 <code>@Aspect</code> 注解后的 bean 与其它类一样可以有自己的字段方法，同样可以定义 pointcut/advice</li>\n<li>Aspects 不能成为其他 aspect 增强的目标，因为 aspect 已经被 <code>@Aspect</code> 注解为一个 Aspect 被自动代理排除在外。</li>\n</ul>\n<h3 id=\"4-3-Declaring-a-Pointcut\"><a href=\"#4-3-Declaring-a-Pointcut\" class=\"headerlink\" title=\".4.3. Declaring a Pointcut\"></a>.4.3. Declaring a Pointcut</h3><p>一个 Pointcut 的定义包括两部分:</p>\n<ol>\n<li>由名与任意参数组成的签名（由一个方法定义，此方法签名的返回值必须为 <code>void</code>）；</li>\n<li>使用 <code>@Pointcut</code> 注解表达的 pointcut 表达式。</li>\n</ol>\n<h4 id=\"4-3-1-Supported-Pointcut-Designators\"><a href=\"#4-3-1-Supported-Pointcut-Designators\" class=\"headerlink\" title=\".4.3.1. Supported Pointcut Designators\"></a>.4.3.1. Supported Pointcut Designators</h4><p>支持 Pointcut 的标识符（PCD pointcut designators 用来匹配符合的 join point，限制 Spring AOP 方法执行）</p>\n<ul>\n<li>execution: 匹配 join points，主要的 pointcut 标识符</li>\n<li>within: 限制 join points 所在的类需要是特定类型</li>\n<li>this: bean reference（Spring AOP 代理对象）为指定类型的实例限定 join points 匹配</li>\n<li>target: 目标对象（被代理的应用对象）是指定 type 的实例</li>\n<li>args: 限制参数（arguments）为指定类型（type） 的实例</li>\n<li>@target：限制执行对象需要有指定类型的注解</li>\n<li>@args: 限制运行时被传递的参数必须有指定类型的注解</li>\n<li>@within: 限制 join points 所在的类需要有指定的注解</li>\n<li>@annotation: 限制 join points (AOP 中所执行的方法) 需要有指定的注解。</li>\n</ul>\n<h5 id=\"4-3-1-1-Spring-AOP-与-AspectJ-不同之处\"><a href=\"#4-3-1-1-Spring-AOP-与-AspectJ-不同之处\" class=\"headerlink\" title=\".4.3.1.1. Spring AOP 与 AspectJ 不同之处\"></a>.4.3.1.1. Spring AOP 与 AspectJ 不同之处</h5><ul>\n<li>除以上几个标志符外，AspectJ 还有其他的 Designator（如：<code>call</code>,<code>withinCode</code>,<code>@withinCode</code>, etc.），但若在 Spring 中使用这些标志符会抛出 <code>IllegalArgumentException</code>。</li>\n<li>Spring AOP 窄化了 AspectJ 中标志符的定义，join points 只匹配了方法执行。</li>\n<li>AspectJ 还有基于类型的语义（type-based semantics），且其标志符 <code>this</code> <code>target</code> 都是指相同的对象：执行方法的对象。而在 Spring AOP 是基于代理的系统，其代理（与 <code>this</code> 绑定）与其在代理之后的目标对象（与 <code>target</code> 绑定）是不同的。</li>\n<li>因为 Spring AOP is proxy-based 框架本质，所以直接调用其目标对象，并不能实现 AOP 拦截。JDK 动态代理只能对 public interface method 进行拦截，而CGLIB 代理 public/protected （如果需要，package-visible  方法也可以）都可被代理。</li>\n<li><code>bean</code> Spring AOP 有一个原生 AspectJ 所没有的 PCD ： <code>bean</code>。通过 bean name 匹配 bean ，也可加上通配符 <code>*</code> 匹配 bean 集合。与其他标签符一样， bean 可以使用 <code>&amp;&amp;</code> <code>||</code> <code>!</code> 运算符。  <ul>\n<li><code>bean</code> 是针对 Spring 扩展的 PCD ，因此在 <code>@Aspect</code> 模式中无效。 <code>bean</code> PCD 在实例级别上运行不仅仅是在类型级别上，instance-based PCD 是 Spring 基于代理的 AOP 框架的功能，与 Spring bean 工厂紧密整合，因此能自然而直接地通过 name 识别 bean。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"4-3-1-2-Notes\"><a href=\"#4-3-1-2-Notes\" class=\"headerlink\" title=\".4.3.1.2. Notes\"></a>.4.3.1.2. Notes</h5><ul>\n<li>切点定义通常与任何拦截的方法相匹配。如果切入点被严格定义为只公开的，那么即使在 CGLIB 代理场景中，通过代理进行潜在的非公开交互，也需要相应地定义它。</li>\n<li>如果拦截需要包含目标对象的方法调用或构造器，需要使用 Spring 驱动的 native AspectJ weaving 而不是 Spring AOP 代理驱动的框架。</li>\n</ul>\n<h4 id=\"4-3-2-Combining-Pointcut-Expressions\"><a href=\"#4-3-2-Combining-Pointcut-Expressions\" class=\"headerlink\" title=\".4.3.2. Combining Pointcut Expressions\"></a>.4.3.2. Combining Pointcut Expressions</h4><p><a href=\"https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators\">reference</a></p>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">anyPublicOperation</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inTrading</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">tradingOperation</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第一个 pointcut 使用 <code>execution</code> 匹配访问级别为 public 的方法</p>\n</li>\n<li><p>第二个 pointcut 使用 <code>within</code> 匹配 <code>trading</code> 包下的方法</p>\n</li>\n<li><p>第三个 pointcut 使用 <code>&amp;&amp;</code> 运算符将前两个 pointcut 交集</p>\n</li>\n<li><p>使用更小的命名组件组装一个更复杂的 pointcut expression 更为合适，通过 name 引用 pointcut 时，java 的可见性规则（private/default/protected/public）会被引入。但 visibility rules 并不影响 pointcut 匹配。</p>\n</li>\n</ul>\n<h4 id=\"4-3-3-Examples\"><a href=\"#4-3-3-Examples\" class=\"headerlink\" title=\".4.3.3. Examples\"></a>.4.3.3. Examples</h4><p>最常用的 PCD : <code>execution</code>，对于此 PCD ，其标准的 pointcut expression 是：<code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) thrown-pattern?)</code></p>\n<ul>\n<li>除 ret-type-pattern (返回类型字段) /name-pattern/param-pattern 外，其他字段都是可选的。</li>\n<li>returning-type-pattern 指定 join points 匹配的返回类型，<code>*</code> 表示任何类型都匹配。全限定名的类型只匹配返回类型为指定类型的方法。</li>\n<li>name-pattern 匹配方法名，可以使用 <code>*</code> 通配所有或部分方法名，如果定义了 declaring-type-pattern（指定定义方法所在类），在其后追加一个 <code>.</code> 与 name-pattern 组件连用。</li>\n<li>param-pattern 相对复杂一些。<code>()</code> 表示匹配无参数的方法，<code>(..)</code> 表示匹配任意数量参数的方法，<code>(*)</code> 表示匹配含一个任何类型的参数，<code>(*,String)</code> 表示匹配有两个参数的方法，其中第一个参数为任何类型，第二个参数为 String 。<a href=\"https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators\">Spring Reference</a><a href=\"https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html\">AspectJ reference</a></li>\n<li><code>execution(param)</code> 模式下的匹配与 <code>args()</code> 模式匹配的不同：execution 模式下表示一个方法在签名处定义的参数为指定类型，而 args() 模式表示在方法在运行时被传递的参数为指定类型。</li>\n</ul>\n<h4 id=\"4-3-4-optimize\"><a href=\"#4-3-4-optimize\" class=\"headerlink\" title=\".4.3.4. optimize\"></a>.4.3.4. optimize</h4><p>优化 PCD</p>\n<p>为了优化性能，AspectJ 在编译期处理 pointcut。检查代码并决定 join points 是否匹配(静态或动态)一个指定的 pointcut 是耗能不低的。（动态匹配指通过静态分析并不能完全决定是否匹配，需要添加一个 test 在代码处在运行时决定实际是否匹配）。当首次解析一个 pointcut 时，AspectJ 会为匹配流程将 pointcut 重写成一个最优形式。一般来说，pointcuts 会被重写成 DNF(Disjunctive Normal Form)，且 pointcut 组件会按越易计算越先检查的顺序重排序。这就意味着不需要考虑不同的 PCD 性能开销与 pointcuts 定义的顺序。</p>\n<p>已知的 PCD 自然地分为三组：</p>\n<ol>\n<li>kinded designator 选择一个类型的 join point : <code>execution</code> <code>get</code> <code>set</code> <code>handler</code></li>\n<li>scoping designator 选择 join point 范围 : <code>within</code> <code>withincode</code></li>\n<li>contextual designators 根据上下文匹配 join points : <code>this</code> <code>target</code> <code>@annotation</code></li>\n</ol>\n<p>notes:</p>\n<ol>\n<li>一个优质的 pointcut 至少需要包含 kinded 与 scoping 两种类型的 designator;</li>\n<li>仅提供 kinded designator 或 contextual desinator 能够正常工作，但性能不佳，因为需要额外的解析</li>\n<li>Scoping designator 可快速匹配，使用此类 PCD 可以快速地忽略不必要的 join points 组。</li>\n</ol>\n<h3 id=\"4-4-Declaring-Advice\"><a href=\"#4-4-Declaring-Advice\" class=\"headerlink\" title=\".4.4. Declaring Advice\"></a>.4.4. Declaring Advice</h3><p><a href=\"https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators\">reference</a></p>\n<p>Advice 与一个 pointcut expression 相关联，并在此 pointcut 匹配的方法执行 before/after/around 切点执行。这个 pointcut expression 要么是一个被命名的 pointcut 简单引用（<em>直接写 pointcut 的方法名即可_），要么是一个 advice 相应位置的 pointcut expression(_直接用这种写法不就不用再单独写 pointcut 了吗？</em>)。</p>\n<ul>\n<li><p>Before Advice: <code>@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</code></p>\n</li>\n<li><p>After Returning Advice :  一个正常执行完成的方法执行增强。使用注解 <code>@AfterReturning(returning=&quot;retVal&quot;)</code> ，可以指定方法执行的返回值为 Advice 方法的参数。指定属性 <code>returning</code> 的值与 Advice 定义的参数名要保持一致，同时 <code>returning</code> 语句也会和 advice 方法中指定的参数类型对 join points 进行约束，其方法执行与此处 advice 方法参数的类型需要匹配。</p>\n<ul>\n<li>需要注意的是：使用此类型的 Advice 返回的引用不可能完全与原来的引用无关。</li>\n</ul>\n</li>\n<li><p>After Throwing Advice : 抛出异常的方法执行的增强。可以使用 <code>throwing=</code> 与其异常参数类型配合限制异常的匹配。同样，advice 方法参数名要与 throwing 的值一致，且参数类型也会对 pointcuts 进行约束。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AfterThrowingExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(</span></span><br><span class=\"line\"><span class=\"meta\">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        throwing=&quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRecoveryActions</span><span class=\"params\">(DataAccessException ex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>After Advice: 在切点正常、异常执行完后进行增强。</p>\n</li>\n<li><p>Around Advice: 在切点周围进行增强，可以在方法执行前后进行工作，用于在需要在方法执行前后在线程安全内分享状态。切记使用最小形式的 advice 满足需求，能使用 Before advice 就不要用 Around advice。</p>\n<ul>\n<li>使用 @Around 注解声明，第一个参数必须是 ProceedingJoinPoint，调用其 proceed() 方法就是执行切点的方法，此方法可以传参数 Object[] ，数组中的值被用于方法执行时的参数。</li>\n<li>Advice 的参数 JoinPoint 的 proceed() 是否执行、执行任何次数都合法。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-4-1-Advice-Parameters\"><a href=\"#4-4-1-Advice-Parameters\" class=\"headerlink\" title=\".4.4.1. Advice Parameters\"></a>.4.4.1. Advice Parameters</h4><p><a href=\"https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-advice-after-throwing\">reference</a></p>\n<ul>\n<li>Access current JoinPoint ，任何增强方法都可以添加第一个参数 JoinPoint，ProceedingJoinPoint 是其子类。可以从 JoinPoint 调用方法获取 args/this proxy/target object/signature/toString</li>\n<li>传递参数给 Advice 。使用 <code>args()</code> 传递参数到 advice ，可以将其写在 Pointcut 中再在 Advice 中引用 pointcut，也可以直接在 pointcut expression 中添加 args 子句。</li>\n<li>Advice Parameters and Generics。范型参数在 advice 中的使用，直接在 advice 中指定类型，同样会约束 pointcut。<ul>\n<li>直接在参数中指定范型类型。</li>\n<li>如果参数是 Collection<T> ，只能指定为 Collection&lt;?&gt;，再手动检查其类型。</li>\n</ul>\n</li>\n<li>Determining Argument Names。指定 Advice 参数名，使用 <code>argNames=</code>,默认第一个参数 JoinPoint 不用显式指定出来。</li>\n</ul>"},{"title":"Spring Test","layout":"post","date":"2020-04-21T04:08:38.000Z","description":"spring test 的应用","_content":"\n> 使用 `@TestPropertySource` 指定配置文件。\n\n- `Environment` `PropertyResolver` 配置信息解析基础接口。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources)<!--more-->\n\n## .1. 指定测试上下文 Spring TestContext Framework\n\n### .1.1. Context Management\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig)\n\n> @SpringJunitWebConfig 注解包含了 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class), @WebAppConfiguration ，使用此注解不用再添加 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class)\n\n- 通过注解 `@ContextConfiguration` 引入测试上下文，可以指定多个配置文件为上下文无数据：xml 配置文件(location/value 默认属性)、Groovy scripts 配置文件(location/value 默认属性)、java based configuration 文件\n- xml 与 groovy script 配置属性为 location ，省略此属性会自动检测与 Test 文件同名的配置文件。\n- 指定基于 java 注解的配置文件时，使用属性 `class`属性，只要是 SpringBean java 配置文件都可以指定，包括没有使用 Spring 注解但因为其唯一的构造器而被当作 Spring bean 的 java 文件。也包括提供 Bean 方法的类。同样如果此属性缺失，SpringTestContext 框架会自动检测默认的配置文件。`AnnotationConfigContextLoader` 与 `AnnotationWebConfigContextLoader` 会自动检测测试类内嵌的静态配置类。内嵌配置类名可以任意定，同样一个测试类中可以有任意多个内嵌配置类。\n\nMixing XML,Groovy Scripts, and Component Classes**\n\n> 混合多类型资源的上下文\n\n当需要混合三各类型的配置组件到上下文中时，第三方框架 SpringBoot 支持同时指定。但基于历史原因，Spring 标准部署并不支持。大体上 Spring 框架中 Spring-test 模块 `SmartContextLoader` 实现对每个测试上下文只支持单一资源类型，但并意味着只能使用一种资源类型。例外是 `GenericGroovyXmlContextLoader` 与 `GenericGroovyXmlWebContextLoader` 支持同时加载 **XML 配置文件与 Groovy scripts** 。此外，第三方框架 `@ContextConfiguration` 支持同时指定 `location` 与 `classes` 属性。并且就算在标准的测试框架中，也可以使用选择一种资源类型作为切入口，在切入口中添加其他类型的资源到其中来实现加载多种类型资源到上下文。\n\n#### .1.1.1. Context Configuration with Context Initializers\n\n在 `@ContextConfiguration` 注解中添加  **initializers** 属性给上下文指定**初始化器**，初始化器实现 `ApplicationContextInitializer` ，其作用在于初始化配置的上下文 ConfigurableApplicationContext （注册 Property Source ，激活 Profile 。ContextLoader 与 FrameworkServlet 分别有定义 `contextInitializersClasses` context-param init-param）。每个初始化器都需要支持其实现的 Ordered 接口或 `@Order` 注解用以保持其初始化动作的秩序。\n\n也可以在 `@ContextConfiguration` 中不指定配置文件(locations,values, classes 属性)只添加初始化器 initializers ，在初始化器中指定配置上下文数据。\n\n#### .1.1.2. Context Configuration Inheritance\n\n上下文配置层级\n\n`@ContextConfiguration` 注解属性 `inheritLocations` `inheritInitializers` 用以指定是否保留上下文配置的继承关系，默认为 true 。这意味着默认情况下，测试类间的上下文数据（resource locations,component classes, context initializers）都是自上而下继承的。如有重复，子类覆盖父类。\n\n#### .1.1.3. **[Context Configuration with Environment Profiles](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)**\n\nSpring 框架有一流的环境配置概念支持，测试中使用注解 `@ActiveProfiles` 以支持为测试加载 ApplicationContext 时激活的 Profiles 。@ActiveProfiles 支付 `SmartContextLoader` 但不支持老版的 `ContextLoader` SPI 实现。\n\n- profile 在没有指定的情况下是 `default` ，可以使用此缺省的 profile 。\n- @ActiveProfiles 激活注解同样支持上下层级继承，断开继承关系使用属性 `inheritProfiles` 属性。\n- 如果需要在运行时决定激活 profile ，可以自定义 `ActiveProfileResolver` ，并使用 `resolver` 属性注册到 @ActiveProfiles 中。\n\n#### .1.1.4. [Context Configuration with Test Property Source](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)\n\n与 @Configuration 配置上的 @PropertySource 类似，测试上下文的 @TestPropertySource 注解同样引入配置数据到上下文。\n\n- 同样在 SmartContextLoader 上支持，而老版 ContextLoader 不支持。\n\n#### .1.1.5. Declaring Test Property Source\n\n@TestPropertySource 中的 locations, value 属性用以指定配置文件。三种方式：\n\n1. 简平式 \"fig/fig.properties\" 指定包相对路径与当前测试文件同一个包\n2. 以 slash `/` 开头指定绝对路径\n3. 以资源协议开头的路径 \"classpath:,file:, http:\" 使用指定协议定位资源\n\n- 可在 @TestPropertySource 中指定 properties 属性指定 key-value 属性配置，其拥有最高优先权。key-value 语法有三种形式：\n\n1. key=value\n2. key:value\n3. key value\n\n- 从 Spring Framework 5.2 开始，同一个测试类中可以指定多个 @TestPropertySource 后者覆盖前者。\n- 还可以使用派生自 @TestPropertySource 组合多个注解添加配置数据，但原生的 @TestPropertySource 优先权更高会覆盖派生注解。\n\n#### .1.1.6. Default Properties File Detection\n\n当 @TestPropertySource 注解没有指定属性数据位置，当会按 clathpath: 协议自动检测与测试类同名的属性文件。\n\n#### .1.1.7. Precedence\n\n使用 @TestPropertySource 注解添加的配置值优先级超过系统环境变量、java 系统属性、@PropertySource 注解等方式添加的配置值，其中 properties 属性添加的 inlined 属性高于 location 引入的外部配置文件。但 @DynamicPropertySource 注解引入的配置值有更高的优先级。\n\n#### .1.1.8. Inheriting and Overriding Test Property Source\n\n@TestPropertySource 注解同样有属性 inheritLocations, inheritProperties 用以指定是否自上继承配置数据，默认为 true 。\n\n#### .1.1.9. [Context Configuration with Dynamic Property Sources](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)\n\n- @DynamicPropertySource 注解需要用在一个静态方法上，方法参数为是一个 DynamicPropertyRegistry;\n- 需要指定外部容器在测试类上 @TestContainer\n- @DynamicPropertySource 有比 @TestPropertySource 更高的优先级\n\n#### .1.1.10. [Loading a WebApplicationContext](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web)\n\n直接注入 Mock, Context 使用\n\n#### .1.1.11. [Context Cache](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web)\n\n上下文缓存，使用了缓存，后续测试会更快。\n\n使用上下文缓存只在于测试类使用了相同的上下文，且在同一次编译启动中才能使用，如果测试类使用了不同的上下文（@ContextConfiguration initializers, classes, location）profiles, properties ，或者测试之间重启了 Context 都不能使用缓存。\n","source":"_posts/Spring/Spring-Test.md","raw":"---\ntitle: Spring Test\nlayout: post\ndate: 2020-04-21 12:08:38\ntags: [Java,Spring,test]\ncategories: [Spring]\ndescription: spring test 的应用\n---\n\n> 使用 `@TestPropertySource` 指定配置文件。\n\n- `Environment` `PropertyResolver` 配置信息解析基础接口。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources)<!--more-->\n\n## .1. 指定测试上下文 Spring TestContext Framework\n\n### .1.1. Context Management\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig)\n\n> @SpringJunitWebConfig 注解包含了 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class), @WebAppConfiguration ，使用此注解不用再添加 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class)\n\n- 通过注解 `@ContextConfiguration` 引入测试上下文，可以指定多个配置文件为上下文无数据：xml 配置文件(location/value 默认属性)、Groovy scripts 配置文件(location/value 默认属性)、java based configuration 文件\n- xml 与 groovy script 配置属性为 location ，省略此属性会自动检测与 Test 文件同名的配置文件。\n- 指定基于 java 注解的配置文件时，使用属性 `class`属性，只要是 SpringBean java 配置文件都可以指定，包括没有使用 Spring 注解但因为其唯一的构造器而被当作 Spring bean 的 java 文件。也包括提供 Bean 方法的类。同样如果此属性缺失，SpringTestContext 框架会自动检测默认的配置文件。`AnnotationConfigContextLoader` 与 `AnnotationWebConfigContextLoader` 会自动检测测试类内嵌的静态配置类。内嵌配置类名可以任意定，同样一个测试类中可以有任意多个内嵌配置类。\n\nMixing XML,Groovy Scripts, and Component Classes**\n\n> 混合多类型资源的上下文\n\n当需要混合三各类型的配置组件到上下文中时，第三方框架 SpringBoot 支持同时指定。但基于历史原因，Spring 标准部署并不支持。大体上 Spring 框架中 Spring-test 模块 `SmartContextLoader` 实现对每个测试上下文只支持单一资源类型，但并意味着只能使用一种资源类型。例外是 `GenericGroovyXmlContextLoader` 与 `GenericGroovyXmlWebContextLoader` 支持同时加载 **XML 配置文件与 Groovy scripts** 。此外，第三方框架 `@ContextConfiguration` 支持同时指定 `location` 与 `classes` 属性。并且就算在标准的测试框架中，也可以使用选择一种资源类型作为切入口，在切入口中添加其他类型的资源到其中来实现加载多种类型资源到上下文。\n\n#### .1.1.1. Context Configuration with Context Initializers\n\n在 `@ContextConfiguration` 注解中添加  **initializers** 属性给上下文指定**初始化器**，初始化器实现 `ApplicationContextInitializer` ，其作用在于初始化配置的上下文 ConfigurableApplicationContext （注册 Property Source ，激活 Profile 。ContextLoader 与 FrameworkServlet 分别有定义 `contextInitializersClasses` context-param init-param）。每个初始化器都需要支持其实现的 Ordered 接口或 `@Order` 注解用以保持其初始化动作的秩序。\n\n也可以在 `@ContextConfiguration` 中不指定配置文件(locations,values, classes 属性)只添加初始化器 initializers ，在初始化器中指定配置上下文数据。\n\n#### .1.1.2. Context Configuration Inheritance\n\n上下文配置层级\n\n`@ContextConfiguration` 注解属性 `inheritLocations` `inheritInitializers` 用以指定是否保留上下文配置的继承关系，默认为 true 。这意味着默认情况下，测试类间的上下文数据（resource locations,component classes, context initializers）都是自上而下继承的。如有重复，子类覆盖父类。\n\n#### .1.1.3. **[Context Configuration with Environment Profiles](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)**\n\nSpring 框架有一流的环境配置概念支持，测试中使用注解 `@ActiveProfiles` 以支持为测试加载 ApplicationContext 时激活的 Profiles 。@ActiveProfiles 支付 `SmartContextLoader` 但不支持老版的 `ContextLoader` SPI 实现。\n\n- profile 在没有指定的情况下是 `default` ，可以使用此缺省的 profile 。\n- @ActiveProfiles 激活注解同样支持上下层级继承，断开继承关系使用属性 `inheritProfiles` 属性。\n- 如果需要在运行时决定激活 profile ，可以自定义 `ActiveProfileResolver` ，并使用 `resolver` 属性注册到 @ActiveProfiles 中。\n\n#### .1.1.4. [Context Configuration with Test Property Source](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)\n\n与 @Configuration 配置上的 @PropertySource 类似，测试上下文的 @TestPropertySource 注解同样引入配置数据到上下文。\n\n- 同样在 SmartContextLoader 上支持，而老版 ContextLoader 不支持。\n\n#### .1.1.5. Declaring Test Property Source\n\n@TestPropertySource 中的 locations, value 属性用以指定配置文件。三种方式：\n\n1. 简平式 \"fig/fig.properties\" 指定包相对路径与当前测试文件同一个包\n2. 以 slash `/` 开头指定绝对路径\n3. 以资源协议开头的路径 \"classpath:,file:, http:\" 使用指定协议定位资源\n\n- 可在 @TestPropertySource 中指定 properties 属性指定 key-value 属性配置，其拥有最高优先权。key-value 语法有三种形式：\n\n1. key=value\n2. key:value\n3. key value\n\n- 从 Spring Framework 5.2 开始，同一个测试类中可以指定多个 @TestPropertySource 后者覆盖前者。\n- 还可以使用派生自 @TestPropertySource 组合多个注解添加配置数据，但原生的 @TestPropertySource 优先权更高会覆盖派生注解。\n\n#### .1.1.6. Default Properties File Detection\n\n当 @TestPropertySource 注解没有指定属性数据位置，当会按 clathpath: 协议自动检测与测试类同名的属性文件。\n\n#### .1.1.7. Precedence\n\n使用 @TestPropertySource 注解添加的配置值优先级超过系统环境变量、java 系统属性、@PropertySource 注解等方式添加的配置值，其中 properties 属性添加的 inlined 属性高于 location 引入的外部配置文件。但 @DynamicPropertySource 注解引入的配置值有更高的优先级。\n\n#### .1.1.8. Inheriting and Overriding Test Property Source\n\n@TestPropertySource 注解同样有属性 inheritLocations, inheritProperties 用以指定是否自上继承配置数据，默认为 true 。\n\n#### .1.1.9. [Context Configuration with Dynamic Property Sources](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)\n\n- @DynamicPropertySource 注解需要用在一个静态方法上，方法参数为是一个 DynamicPropertyRegistry;\n- 需要指定外部容器在测试类上 @TestContainer\n- @DynamicPropertySource 有比 @TestPropertySource 更高的优先级\n\n#### .1.1.10. [Loading a WebApplicationContext](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web)\n\n直接注入 Mock, Context 使用\n\n#### .1.1.11. [Context Cache](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web)\n\n上下文缓存，使用了缓存，后续测试会更快。\n\n使用上下文缓存只在于测试类使用了相同的上下文，且在同一次编译启动中才能使用，如果测试类使用了不同的上下文（@ContextConfiguration initializers, classes, location）profiles, properties ，或者测试之间重启了 Context 都不能使用缓存。\n","slug":"Spring/Spring-Test","published":1,"updated":"2021-02-24T15:22:22.964Z","comments":1,"photos":[],"link":"","_id":"ckljnokrn00252bhb8pom6gmq","content":"<blockquote>\n<p>使用 <code>@TestPropertySource</code> 指定配置文件。</p>\n</blockquote>\n<ul>\n<li><code>Environment</code> <code>PropertyResolver</code> 配置信息解析基础接口。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources\">reference</a><span id=\"more\"></span></li>\n</ul>\n<h2 id=\"1-指定测试上下文-Spring-TestContext-Framework\"><a href=\"#1-指定测试上下文-Spring-TestContext-Framework\" class=\"headerlink\" title=\".1. 指定测试上下文 Spring TestContext Framework\"></a>.1. 指定测试上下文 Spring TestContext Framework</h2><h3 id=\"1-1-Context-Management\"><a href=\"#1-1-Context-Management\" class=\"headerlink\" title=\".1.1. Context Management\"></a>.1.1. Context Management</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig\">reference</a></p>\n<blockquote>\n<p>@SpringJunitWebConfig 注解包含了 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class), @WebAppConfiguration ，使用此注解不用再添加 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class)</p>\n</blockquote>\n<ul>\n<li>通过注解 <code>@ContextConfiguration</code> 引入测试上下文，可以指定多个配置文件为上下文无数据：xml 配置文件(location/value 默认属性)、Groovy scripts 配置文件(location/value 默认属性)、java based configuration 文件</li>\n<li>xml 与 groovy script 配置属性为 location ，省略此属性会自动检测与 Test 文件同名的配置文件。</li>\n<li>指定基于 java 注解的配置文件时，使用属性 <code>class</code>属性，只要是 SpringBean java 配置文件都可以指定，包括没有使用 Spring 注解但因为其唯一的构造器而被当作 Spring bean 的 java 文件。也包括提供 Bean 方法的类。同样如果此属性缺失，SpringTestContext 框架会自动检测默认的配置文件。<code>AnnotationConfigContextLoader</code> 与 <code>AnnotationWebConfigContextLoader</code> 会自动检测测试类内嵌的静态配置类。内嵌配置类名可以任意定，同样一个测试类中可以有任意多个内嵌配置类。</li>\n</ul>\n<p>Mixing XML,Groovy Scripts, and Component Classes**</p>\n<blockquote>\n<p>混合多类型资源的上下文</p>\n</blockquote>\n<p>当需要混合三各类型的配置组件到上下文中时，第三方框架 SpringBoot 支持同时指定。但基于历史原因，Spring 标准部署并不支持。大体上 Spring 框架中 Spring-test 模块 <code>SmartContextLoader</code> 实现对每个测试上下文只支持单一资源类型，但并意味着只能使用一种资源类型。例外是 <code>GenericGroovyXmlContextLoader</code> 与 <code>GenericGroovyXmlWebContextLoader</code> 支持同时加载 <strong>XML 配置文件与 Groovy scripts</strong> 。此外，第三方框架 <code>@ContextConfiguration</code> 支持同时指定 <code>location</code> 与 <code>classes</code> 属性。并且就算在标准的测试框架中，也可以使用选择一种资源类型作为切入口，在切入口中添加其他类型的资源到其中来实现加载多种类型资源到上下文。</p>\n<h4 id=\"1-1-1-Context-Configuration-with-Context-Initializers\"><a href=\"#1-1-1-Context-Configuration-with-Context-Initializers\" class=\"headerlink\" title=\".1.1.1. Context Configuration with Context Initializers\"></a>.1.1.1. Context Configuration with Context Initializers</h4><p>在 <code>@ContextConfiguration</code> 注解中添加  <strong>initializers</strong> 属性给上下文指定<strong>初始化器</strong>，初始化器实现 <code>ApplicationContextInitializer</code> ，其作用在于初始化配置的上下文 ConfigurableApplicationContext （注册 Property Source ，激活 Profile 。ContextLoader 与 FrameworkServlet 分别有定义 <code>contextInitializersClasses</code> context-param init-param）。每个初始化器都需要支持其实现的 Ordered 接口或 <code>@Order</code> 注解用以保持其初始化动作的秩序。</p>\n<p>也可以在 <code>@ContextConfiguration</code> 中不指定配置文件(locations,values, classes 属性)只添加初始化器 initializers ，在初始化器中指定配置上下文数据。</p>\n<h4 id=\"1-1-2-Context-Configuration-Inheritance\"><a href=\"#1-1-2-Context-Configuration-Inheritance\" class=\"headerlink\" title=\".1.1.2. Context Configuration Inheritance\"></a>.1.1.2. Context Configuration Inheritance</h4><p>上下文配置层级</p>\n<p><code>@ContextConfiguration</code> 注解属性 <code>inheritLocations</code> <code>inheritInitializers</code> 用以指定是否保留上下文配置的继承关系，默认为 true 。这意味着默认情况下，测试类间的上下文数据（resource locations,component classes, context initializers）都是自上而下继承的。如有重复，子类覆盖父类。</p>\n<h4 id=\"1-1-3-Context-Configuration-with-Environment-Profiles\"><a href=\"#1-1-3-Context-Configuration-with-Environment-Profiles\" class=\"headerlink\" title=\".1.1.3. Context Configuration with Environment Profiles\"></a>.1.1.3. <strong><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance\">Context Configuration with Environment Profiles</a></strong></h4><p>Spring 框架有一流的环境配置概念支持，测试中使用注解 <code>@ActiveProfiles</code> 以支持为测试加载 ApplicationContext 时激活的 Profiles 。@ActiveProfiles 支付 <code>SmartContextLoader</code> 但不支持老版的 <code>ContextLoader</code> SPI 实现。</p>\n<ul>\n<li>profile 在没有指定的情况下是 <code>default</code> ，可以使用此缺省的 profile 。</li>\n<li>@ActiveProfiles 激活注解同样支持上下层级继承，断开继承关系使用属性 <code>inheritProfiles</code> 属性。</li>\n<li>如果需要在运行时决定激活 profile ，可以自定义 <code>ActiveProfileResolver</code> ，并使用 <code>resolver</code> 属性注册到 @ActiveProfiles 中。</li>\n</ul>\n<h4 id=\"1-1-4-Context-Configuration-with-Test-Property-Source\"><a href=\"#1-1-4-Context-Configuration-with-Test-Property-Source\" class=\"headerlink\" title=\".1.1.4. Context Configuration with Test Property Source\"></a>.1.1.4. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance\">Context Configuration with Test Property Source</a></h4><p>与 @Configuration 配置上的 @PropertySource 类似，测试上下文的 @TestPropertySource 注解同样引入配置数据到上下文。</p>\n<ul>\n<li>同样在 SmartContextLoader 上支持，而老版 ContextLoader 不支持。</li>\n</ul>\n<h4 id=\"1-1-5-Declaring-Test-Property-Source\"><a href=\"#1-1-5-Declaring-Test-Property-Source\" class=\"headerlink\" title=\".1.1.5. Declaring Test Property Source\"></a>.1.1.5. Declaring Test Property Source</h4><p>@TestPropertySource 中的 locations, value 属性用以指定配置文件。三种方式：</p>\n<ol>\n<li>简平式 “fig/fig.properties” 指定包相对路径与当前测试文件同一个包</li>\n<li>以 slash <code>/</code> 开头指定绝对路径</li>\n<li>以资源协议开头的路径 “classpath:,file:, http:” 使用指定协议定位资源</li>\n</ol>\n<ul>\n<li>可在 @TestPropertySource 中指定 properties 属性指定 key-value 属性配置，其拥有最高优先权。key-value 语法有三种形式：</li>\n</ul>\n<ol>\n<li>key=value</li>\n<li>key:value</li>\n<li>key value</li>\n</ol>\n<ul>\n<li>从 Spring Framework 5.2 开始，同一个测试类中可以指定多个 @TestPropertySource 后者覆盖前者。</li>\n<li>还可以使用派生自 @TestPropertySource 组合多个注解添加配置数据，但原生的 @TestPropertySource 优先权更高会覆盖派生注解。</li>\n</ul>\n<h4 id=\"1-1-6-Default-Properties-File-Detection\"><a href=\"#1-1-6-Default-Properties-File-Detection\" class=\"headerlink\" title=\".1.1.6. Default Properties File Detection\"></a>.1.1.6. Default Properties File Detection</h4><p>当 @TestPropertySource 注解没有指定属性数据位置，当会按 clathpath: 协议自动检测与测试类同名的属性文件。</p>\n<h4 id=\"1-1-7-Precedence\"><a href=\"#1-1-7-Precedence\" class=\"headerlink\" title=\".1.1.7. Precedence\"></a>.1.1.7. Precedence</h4><p>使用 @TestPropertySource 注解添加的配置值优先级超过系统环境变量、java 系统属性、@PropertySource 注解等方式添加的配置值，其中 properties 属性添加的 inlined 属性高于 location 引入的外部配置文件。但 @DynamicPropertySource 注解引入的配置值有更高的优先级。</p>\n<h4 id=\"1-1-8-Inheriting-and-Overriding-Test-Property-Source\"><a href=\"#1-1-8-Inheriting-and-Overriding-Test-Property-Source\" class=\"headerlink\" title=\".1.1.8. Inheriting and Overriding Test Property Source\"></a>.1.1.8. Inheriting and Overriding Test Property Source</h4><p>@TestPropertySource 注解同样有属性 inheritLocations, inheritProperties 用以指定是否自上继承配置数据，默认为 true 。</p>\n<h4 id=\"1-1-9-Context-Configuration-with-Dynamic-Property-Sources\"><a href=\"#1-1-9-Context-Configuration-with-Dynamic-Property-Sources\" class=\"headerlink\" title=\".1.1.9. Context Configuration with Dynamic Property Sources\"></a>.1.1.9. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance\">Context Configuration with Dynamic Property Sources</a></h4><ul>\n<li>@DynamicPropertySource 注解需要用在一个静态方法上，方法参数为是一个 DynamicPropertyRegistry;</li>\n<li>需要指定外部容器在测试类上 @TestContainer</li>\n<li>@DynamicPropertySource 有比 @TestPropertySource 更高的优先级</li>\n</ul>\n<h4 id=\"1-1-10-Loading-a-WebApplicationContext\"><a href=\"#1-1-10-Loading-a-WebApplicationContext\" class=\"headerlink\" title=\".1.1.10. Loading a WebApplicationContext\"></a>.1.1.10. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web\">Loading a WebApplicationContext</a></h4><p>直接注入 Mock, Context 使用</p>\n<h4 id=\"1-1-11-Context-Cache\"><a href=\"#1-1-11-Context-Cache\" class=\"headerlink\" title=\".1.1.11. Context Cache\"></a>.1.1.11. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web\">Context Cache</a></h4><p>上下文缓存，使用了缓存，后续测试会更快。</p>\n<p>使用上下文缓存只在于测试类使用了相同的上下文，且在同一次编译启动中才能使用，如果测试类使用了不同的上下文（@ContextConfiguration initializers, classes, location）profiles, properties ，或者测试之间重启了 Context 都不能使用缓存。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>使用 <code>@TestPropertySource</code> 指定配置文件。</p>\n</blockquote>\n<ul>\n<li><code>Environment</code> <code>PropertyResolver</code> 配置信息解析基础接口。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources\">reference</a>","more":"</li>\n</ul>\n<h2 id=\"1-指定测试上下文-Spring-TestContext-Framework\"><a href=\"#1-指定测试上下文-Spring-TestContext-Framework\" class=\"headerlink\" title=\".1. 指定测试上下文 Spring TestContext Framework\"></a>.1. 指定测试上下文 Spring TestContext Framework</h2><h3 id=\"1-1-Context-Management\"><a href=\"#1-1-Context-Management\" class=\"headerlink\" title=\".1.1. Context Management\"></a>.1.1. Context Management</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig\">reference</a></p>\n<blockquote>\n<p>@SpringJunitWebConfig 注解包含了 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class), @WebAppConfiguration ，使用此注解不用再添加 @ContextConfiguration 与 @ExtentionWith(SpringExtention.class)</p>\n</blockquote>\n<ul>\n<li>通过注解 <code>@ContextConfiguration</code> 引入测试上下文，可以指定多个配置文件为上下文无数据：xml 配置文件(location/value 默认属性)、Groovy scripts 配置文件(location/value 默认属性)、java based configuration 文件</li>\n<li>xml 与 groovy script 配置属性为 location ，省略此属性会自动检测与 Test 文件同名的配置文件。</li>\n<li>指定基于 java 注解的配置文件时，使用属性 <code>class</code>属性，只要是 SpringBean java 配置文件都可以指定，包括没有使用 Spring 注解但因为其唯一的构造器而被当作 Spring bean 的 java 文件。也包括提供 Bean 方法的类。同样如果此属性缺失，SpringTestContext 框架会自动检测默认的配置文件。<code>AnnotationConfigContextLoader</code> 与 <code>AnnotationWebConfigContextLoader</code> 会自动检测测试类内嵌的静态配置类。内嵌配置类名可以任意定，同样一个测试类中可以有任意多个内嵌配置类。</li>\n</ul>\n<p>Mixing XML,Groovy Scripts, and Component Classes**</p>\n<blockquote>\n<p>混合多类型资源的上下文</p>\n</blockquote>\n<p>当需要混合三各类型的配置组件到上下文中时，第三方框架 SpringBoot 支持同时指定。但基于历史原因，Spring 标准部署并不支持。大体上 Spring 框架中 Spring-test 模块 <code>SmartContextLoader</code> 实现对每个测试上下文只支持单一资源类型，但并意味着只能使用一种资源类型。例外是 <code>GenericGroovyXmlContextLoader</code> 与 <code>GenericGroovyXmlWebContextLoader</code> 支持同时加载 <strong>XML 配置文件与 Groovy scripts</strong> 。此外，第三方框架 <code>@ContextConfiguration</code> 支持同时指定 <code>location</code> 与 <code>classes</code> 属性。并且就算在标准的测试框架中，也可以使用选择一种资源类型作为切入口，在切入口中添加其他类型的资源到其中来实现加载多种类型资源到上下文。</p>\n<h4 id=\"1-1-1-Context-Configuration-with-Context-Initializers\"><a href=\"#1-1-1-Context-Configuration-with-Context-Initializers\" class=\"headerlink\" title=\".1.1.1. Context Configuration with Context Initializers\"></a>.1.1.1. Context Configuration with Context Initializers</h4><p>在 <code>@ContextConfiguration</code> 注解中添加  <strong>initializers</strong> 属性给上下文指定<strong>初始化器</strong>，初始化器实现 <code>ApplicationContextInitializer</code> ，其作用在于初始化配置的上下文 ConfigurableApplicationContext （注册 Property Source ，激活 Profile 。ContextLoader 与 FrameworkServlet 分别有定义 <code>contextInitializersClasses</code> context-param init-param）。每个初始化器都需要支持其实现的 Ordered 接口或 <code>@Order</code> 注解用以保持其初始化动作的秩序。</p>\n<p>也可以在 <code>@ContextConfiguration</code> 中不指定配置文件(locations,values, classes 属性)只添加初始化器 initializers ，在初始化器中指定配置上下文数据。</p>\n<h4 id=\"1-1-2-Context-Configuration-Inheritance\"><a href=\"#1-1-2-Context-Configuration-Inheritance\" class=\"headerlink\" title=\".1.1.2. Context Configuration Inheritance\"></a>.1.1.2. Context Configuration Inheritance</h4><p>上下文配置层级</p>\n<p><code>@ContextConfiguration</code> 注解属性 <code>inheritLocations</code> <code>inheritInitializers</code> 用以指定是否保留上下文配置的继承关系，默认为 true 。这意味着默认情况下，测试类间的上下文数据（resource locations,component classes, context initializers）都是自上而下继承的。如有重复，子类覆盖父类。</p>\n<h4 id=\"1-1-3-Context-Configuration-with-Environment-Profiles\"><a href=\"#1-1-3-Context-Configuration-with-Environment-Profiles\" class=\"headerlink\" title=\".1.1.3. Context Configuration with Environment Profiles\"></a>.1.1.3. <strong><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance\">Context Configuration with Environment Profiles</a></strong></h4><p>Spring 框架有一流的环境配置概念支持，测试中使用注解 <code>@ActiveProfiles</code> 以支持为测试加载 ApplicationContext 时激活的 Profiles 。@ActiveProfiles 支付 <code>SmartContextLoader</code> 但不支持老版的 <code>ContextLoader</code> SPI 实现。</p>\n<ul>\n<li>profile 在没有指定的情况下是 <code>default</code> ，可以使用此缺省的 profile 。</li>\n<li>@ActiveProfiles 激活注解同样支持上下层级继承，断开继承关系使用属性 <code>inheritProfiles</code> 属性。</li>\n<li>如果需要在运行时决定激活 profile ，可以自定义 <code>ActiveProfileResolver</code> ，并使用 <code>resolver</code> 属性注册到 @ActiveProfiles 中。</li>\n</ul>\n<h4 id=\"1-1-4-Context-Configuration-with-Test-Property-Source\"><a href=\"#1-1-4-Context-Configuration-with-Test-Property-Source\" class=\"headerlink\" title=\".1.1.4. Context Configuration with Test Property Source\"></a>.1.1.4. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance\">Context Configuration with Test Property Source</a></h4><p>与 @Configuration 配置上的 @PropertySource 类似，测试上下文的 @TestPropertySource 注解同样引入配置数据到上下文。</p>\n<ul>\n<li>同样在 SmartContextLoader 上支持，而老版 ContextLoader 不支持。</li>\n</ul>\n<h4 id=\"1-1-5-Declaring-Test-Property-Source\"><a href=\"#1-1-5-Declaring-Test-Property-Source\" class=\"headerlink\" title=\".1.1.5. Declaring Test Property Source\"></a>.1.1.5. Declaring Test Property Source</h4><p>@TestPropertySource 中的 locations, value 属性用以指定配置文件。三种方式：</p>\n<ol>\n<li>简平式 “fig/fig.properties” 指定包相对路径与当前测试文件同一个包</li>\n<li>以 slash <code>/</code> 开头指定绝对路径</li>\n<li>以资源协议开头的路径 “classpath:,file:, http:” 使用指定协议定位资源</li>\n</ol>\n<ul>\n<li>可在 @TestPropertySource 中指定 properties 属性指定 key-value 属性配置，其拥有最高优先权。key-value 语法有三种形式：</li>\n</ul>\n<ol>\n<li>key=value</li>\n<li>key:value</li>\n<li>key value</li>\n</ol>\n<ul>\n<li>从 Spring Framework 5.2 开始，同一个测试类中可以指定多个 @TestPropertySource 后者覆盖前者。</li>\n<li>还可以使用派生自 @TestPropertySource 组合多个注解添加配置数据，但原生的 @TestPropertySource 优先权更高会覆盖派生注解。</li>\n</ul>\n<h4 id=\"1-1-6-Default-Properties-File-Detection\"><a href=\"#1-1-6-Default-Properties-File-Detection\" class=\"headerlink\" title=\".1.1.6. Default Properties File Detection\"></a>.1.1.6. Default Properties File Detection</h4><p>当 @TestPropertySource 注解没有指定属性数据位置，当会按 clathpath: 协议自动检测与测试类同名的属性文件。</p>\n<h4 id=\"1-1-7-Precedence\"><a href=\"#1-1-7-Precedence\" class=\"headerlink\" title=\".1.1.7. Precedence\"></a>.1.1.7. Precedence</h4><p>使用 @TestPropertySource 注解添加的配置值优先级超过系统环境变量、java 系统属性、@PropertySource 注解等方式添加的配置值，其中 properties 属性添加的 inlined 属性高于 location 引入的外部配置文件。但 @DynamicPropertySource 注解引入的配置值有更高的优先级。</p>\n<h4 id=\"1-1-8-Inheriting-and-Overriding-Test-Property-Source\"><a href=\"#1-1-8-Inheriting-and-Overriding-Test-Property-Source\" class=\"headerlink\" title=\".1.1.8. Inheriting and Overriding Test Property Source\"></a>.1.1.8. Inheriting and Overriding Test Property Source</h4><p>@TestPropertySource 注解同样有属性 inheritLocations, inheritProperties 用以指定是否自上继承配置数据，默认为 true 。</p>\n<h4 id=\"1-1-9-Context-Configuration-with-Dynamic-Property-Sources\"><a href=\"#1-1-9-Context-Configuration-with-Dynamic-Property-Sources\" class=\"headerlink\" title=\".1.1.9. Context Configuration with Dynamic Property Sources\"></a>.1.1.9. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance\">Context Configuration with Dynamic Property Sources</a></h4><ul>\n<li>@DynamicPropertySource 注解需要用在一个静态方法上，方法参数为是一个 DynamicPropertyRegistry;</li>\n<li>需要指定外部容器在测试类上 @TestContainer</li>\n<li>@DynamicPropertySource 有比 @TestPropertySource 更高的优先级</li>\n</ul>\n<h4 id=\"1-1-10-Loading-a-WebApplicationContext\"><a href=\"#1-1-10-Loading-a-WebApplicationContext\" class=\"headerlink\" title=\".1.1.10. Loading a WebApplicationContext\"></a>.1.1.10. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web\">Loading a WebApplicationContext</a></h4><p>直接注入 Mock, Context 使用</p>\n<h4 id=\"1-1-11-Context-Cache\"><a href=\"#1-1-11-Context-Cache\" class=\"headerlink\" title=\".1.1.11. Context Cache\"></a>.1.1.11. <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-web\">Context Cache</a></h4><p>上下文缓存，使用了缓存，后续测试会更快。</p>\n<p>使用上下文缓存只在于测试类使用了相同的上下文，且在同一次编译启动中才能使用，如果测试类使用了不同的上下文（@ContextConfiguration initializers, classes, location）profiles, properties ，或者测试之间重启了 Context 都不能使用缓存。</p>"},{"title":"Spring Boot Features","layout":"post","date":"2020-07-23T00:29:00.000Z","description":"Spring Boot Features","_content":"\n[SpringBoot 的特性](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features)\n\n## .1. Profiles\n\nSpring Profiles 提供隔离配置的功能，可以做到不同环境生效不同的配置。在 `@Component` `@Configuration` `@ConfigurationProperties` 上添加 `@Profile` 注解即可指定其生效环境。如果 `@ConfigurationProperties` 的配置 bean 是通过 `@EnableConfigurationProperties` 注册而不是通过自动扫描，`@Profile` 需要注解在配置组件 `@Configuration` 类上。\n\n指定 profile 的方式有： 添加配置 `spring.profiles.active=dev,test` 的形式，也可以是通过命令行参数添加 `--spring.profiles.active=pro`。<!--more-->\n\n## .2. SpringBoot Testing\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-mock-environment)\n\n使用 SpringBoot Test 相对于 Spring更为方便一些。如果使用 Junit5 只需要一个注解 `@SpringBootTest`\n\n- 可以使用服务端测试，也可以使用客户端测试。\n\n## .3. logging\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logging)\n\n- 使用配置 logging.file.name 与 logging.file.path 指定日志文件名与路径，如果不指定文件名仅打印到控制台，如果不指定文件路径将写文件在当前路径。\n\n### .3.1. logging level\n\n- 指定日志级别 `logging.level.<logger-name>=<level>` logger 指日志器，可以是类或包\n- 可以在环境变量中添加参数指定日志级别 `LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG` ，但这不指定类的日志器，因为环境变量中会将所有大写转换成小写。使用 SPRING_APPLICATION_JSON 变量（在命令行参数、系统变量、命令行参数中添加 Json）实现。\n\n### .3.2. Log Groups\n\n- 直接定义多个类或包到同一个组 `logging.level.tomcat=org.apache.catalina,org.apache.coyote` ，再直接指定组的日志级别 `logging.level.tomcat=DEBUG`\n- Spring Boot 预定义了日志组 sql 与 web\n\n### .3.3. Custom Log Configuration\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logback-extensions)\n\n在系统变量中指定日志系统 `org.springframework.boot.logging.LoggingSystem` ，此值必须是 LoggingSystem 的实现类全限定名。同时此属性只能在系统属性中指定，因为日志开头在 ApplicationContext 初始化完成前就会使用日志系统。\n\n- LoggingSystem 实现有三种：Logback/Log4j2/JavaUtilLogging ，其中 Logback 功能最全。\n- 通过配置文件或 Environment 属性 `logging.config` 可以自定义日志系统\n\n## .4. JSON\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-json)\n\nSpring Boot 整合了三种 JSON 映射库：\n\n1. Gson，SpringBoot 自动配置为 bean 并可以通过 spring.gson.* 配置多个属性，更详细地控制可以通过 GsonBuilderCustomizer bean 实现。\n2. Jackson，Spring 偏好并默认的。当 Jackson 在 classpath 中时， 一个 ObjectMapper bean 会自动注入，并可自定义多个配置属性。\n3. JSON-B\n\n## .5. Developing Web Applications\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-developing-web-applications)\n\n### .5.1. The Spring Web MVC Framework\n\n#### .5.1.1. Custom JSON Serializers and Deserializers\n\n@JsonComponent 注解添加 jackson 序列化反序列化器到容器中。\n","source":"_posts/Spring/SpringBoot-Features.md","raw":"---\ntitle: Spring Boot Features\nlayout: post\ndate: 2020-07-23 8:29:00\ntags: [java,SpringBoot]\ncategories: [SpringBoot]\ndescription: Spring Boot Features\n---\n\n[SpringBoot 的特性](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features)\n\n## .1. Profiles\n\nSpring Profiles 提供隔离配置的功能，可以做到不同环境生效不同的配置。在 `@Component` `@Configuration` `@ConfigurationProperties` 上添加 `@Profile` 注解即可指定其生效环境。如果 `@ConfigurationProperties` 的配置 bean 是通过 `@EnableConfigurationProperties` 注册而不是通过自动扫描，`@Profile` 需要注解在配置组件 `@Configuration` 类上。\n\n指定 profile 的方式有： 添加配置 `spring.profiles.active=dev,test` 的形式，也可以是通过命令行参数添加 `--spring.profiles.active=pro`。<!--more-->\n\n## .2. SpringBoot Testing\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-mock-environment)\n\n使用 SpringBoot Test 相对于 Spring更为方便一些。如果使用 Junit5 只需要一个注解 `@SpringBootTest`\n\n- 可以使用服务端测试，也可以使用客户端测试。\n\n## .3. logging\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logging)\n\n- 使用配置 logging.file.name 与 logging.file.path 指定日志文件名与路径，如果不指定文件名仅打印到控制台，如果不指定文件路径将写文件在当前路径。\n\n### .3.1. logging level\n\n- 指定日志级别 `logging.level.<logger-name>=<level>` logger 指日志器，可以是类或包\n- 可以在环境变量中添加参数指定日志级别 `LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG` ，但这不指定类的日志器，因为环境变量中会将所有大写转换成小写。使用 SPRING_APPLICATION_JSON 变量（在命令行参数、系统变量、命令行参数中添加 Json）实现。\n\n### .3.2. Log Groups\n\n- 直接定义多个类或包到同一个组 `logging.level.tomcat=org.apache.catalina,org.apache.coyote` ，再直接指定组的日志级别 `logging.level.tomcat=DEBUG`\n- Spring Boot 预定义了日志组 sql 与 web\n\n### .3.3. Custom Log Configuration\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logback-extensions)\n\n在系统变量中指定日志系统 `org.springframework.boot.logging.LoggingSystem` ，此值必须是 LoggingSystem 的实现类全限定名。同时此属性只能在系统属性中指定，因为日志开头在 ApplicationContext 初始化完成前就会使用日志系统。\n\n- LoggingSystem 实现有三种：Logback/Log4j2/JavaUtilLogging ，其中 Logback 功能最全。\n- 通过配置文件或 Environment 属性 `logging.config` 可以自定义日志系统\n\n## .4. JSON\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-json)\n\nSpring Boot 整合了三种 JSON 映射库：\n\n1. Gson，SpringBoot 自动配置为 bean 并可以通过 spring.gson.* 配置多个属性，更详细地控制可以通过 GsonBuilderCustomizer bean 实现。\n2. Jackson，Spring 偏好并默认的。当 Jackson 在 classpath 中时， 一个 ObjectMapper bean 会自动注入，并可自定义多个配置属性。\n3. JSON-B\n\n## .5. Developing Web Applications\n\n[reference](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-developing-web-applications)\n\n### .5.1. The Spring Web MVC Framework\n\n#### .5.1.1. Custom JSON Serializers and Deserializers\n\n@JsonComponent 注解添加 jackson 序列化反序列化器到容器中。\n","slug":"Spring/SpringBoot-Features","published":1,"updated":"2021-02-24T15:22:22.972Z","comments":1,"photos":[],"link":"","_id":"ckljnokrp002a2bhbca5gdgz8","content":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features\">SpringBoot 的特性</a></p>\n<h2 id=\"1-Profiles\"><a href=\"#1-Profiles\" class=\"headerlink\" title=\".1. Profiles\"></a>.1. Profiles</h2><p>Spring Profiles 提供隔离配置的功能，可以做到不同环境生效不同的配置。在 <code>@Component</code> <code>@Configuration</code> <code>@ConfigurationProperties</code> 上添加 <code>@Profile</code> 注解即可指定其生效环境。如果 <code>@ConfigurationProperties</code> 的配置 bean 是通过 <code>@EnableConfigurationProperties</code> 注册而不是通过自动扫描，<code>@Profile</code> 需要注解在配置组件 <code>@Configuration</code> 类上。</p>\n<p>指定 profile 的方式有： 添加配置 <code>spring.profiles.active=dev,test</code> 的形式，也可以是通过命令行参数添加 <code>--spring.profiles.active=pro</code>。<span id=\"more\"></span></p>\n<h2 id=\"2-SpringBoot-Testing\"><a href=\"#2-SpringBoot-Testing\" class=\"headerlink\" title=\".2. SpringBoot Testing\"></a>.2. SpringBoot Testing</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-mock-environment\">reference</a></p>\n<p>使用 SpringBoot Test 相对于 Spring更为方便一些。如果使用 Junit5 只需要一个注解 <code>@SpringBootTest</code></p>\n<ul>\n<li>可以使用服务端测试，也可以使用客户端测试。</li>\n</ul>\n<h2 id=\"3-logging\"><a href=\"#3-logging\" class=\"headerlink\" title=\".3. logging\"></a>.3. logging</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logging\">reference</a></p>\n<ul>\n<li>使用配置 logging.file.name 与 logging.file.path 指定日志文件名与路径，如果不指定文件名仅打印到控制台，如果不指定文件路径将写文件在当前路径。</li>\n</ul>\n<h3 id=\"3-1-logging-level\"><a href=\"#3-1-logging-level\" class=\"headerlink\" title=\".3.1. logging level\"></a>.3.1. logging level</h3><ul>\n<li>指定日志级别 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> logger 指日志器，可以是类或包</li>\n<li>可以在环境变量中添加参数指定日志级别 <code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> ，但这不指定类的日志器，因为环境变量中会将所有大写转换成小写。使用 SPRING_APPLICATION_JSON 变量（在命令行参数、系统变量、命令行参数中添加 Json）实现。</li>\n</ul>\n<h3 id=\"3-2-Log-Groups\"><a href=\"#3-2-Log-Groups\" class=\"headerlink\" title=\".3.2. Log Groups\"></a>.3.2. Log Groups</h3><ul>\n<li>直接定义多个类或包到同一个组 <code>logging.level.tomcat=org.apache.catalina,org.apache.coyote</code> ，再直接指定组的日志级别 <code>logging.level.tomcat=DEBUG</code></li>\n<li>Spring Boot 预定义了日志组 sql 与 web</li>\n</ul>\n<h3 id=\"3-3-Custom-Log-Configuration\"><a href=\"#3-3-Custom-Log-Configuration\" class=\"headerlink\" title=\".3.3. Custom Log Configuration\"></a>.3.3. Custom Log Configuration</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logback-extensions\">reference</a></p>\n<p>在系统变量中指定日志系统 <code>org.springframework.boot.logging.LoggingSystem</code> ，此值必须是 LoggingSystem 的实现类全限定名。同时此属性只能在系统属性中指定，因为日志开头在 ApplicationContext 初始化完成前就会使用日志系统。</p>\n<ul>\n<li>LoggingSystem 实现有三种：Logback/Log4j2/JavaUtilLogging ，其中 Logback 功能最全。</li>\n<li>通过配置文件或 Environment 属性 <code>logging.config</code> 可以自定义日志系统</li>\n</ul>\n<h2 id=\"4-JSON\"><a href=\"#4-JSON\" class=\"headerlink\" title=\".4. JSON\"></a>.4. JSON</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-json\">reference</a></p>\n<p>Spring Boot 整合了三种 JSON 映射库：</p>\n<ol>\n<li>Gson，SpringBoot 自动配置为 bean 并可以通过 spring.gson.* 配置多个属性，更详细地控制可以通过 GsonBuilderCustomizer bean 实现。</li>\n<li>Jackson，Spring 偏好并默认的。当 Jackson 在 classpath 中时， 一个 ObjectMapper bean 会自动注入，并可自定义多个配置属性。</li>\n<li>JSON-B</li>\n</ol>\n<h2 id=\"5-Developing-Web-Applications\"><a href=\"#5-Developing-Web-Applications\" class=\"headerlink\" title=\".5. Developing Web Applications\"></a>.5. Developing Web Applications</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-developing-web-applications\">reference</a></p>\n<h3 id=\"5-1-The-Spring-Web-MVC-Framework\"><a href=\"#5-1-The-Spring-Web-MVC-Framework\" class=\"headerlink\" title=\".5.1. The Spring Web MVC Framework\"></a>.5.1. The Spring Web MVC Framework</h3><h4 id=\"5-1-1-Custom-JSON-Serializers-and-Deserializers\"><a href=\"#5-1-1-Custom-JSON-Serializers-and-Deserializers\" class=\"headerlink\" title=\".5.1.1. Custom JSON Serializers and Deserializers\"></a>.5.1.1. Custom JSON Serializers and Deserializers</h4><p>@JsonComponent 注解添加 jackson 序列化反序列化器到容器中。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features\">SpringBoot 的特性</a></p>\n<h2 id=\"1-Profiles\"><a href=\"#1-Profiles\" class=\"headerlink\" title=\".1. Profiles\"></a>.1. Profiles</h2><p>Spring Profiles 提供隔离配置的功能，可以做到不同环境生效不同的配置。在 <code>@Component</code> <code>@Configuration</code> <code>@ConfigurationProperties</code> 上添加 <code>@Profile</code> 注解即可指定其生效环境。如果 <code>@ConfigurationProperties</code> 的配置 bean 是通过 <code>@EnableConfigurationProperties</code> 注册而不是通过自动扫描，<code>@Profile</code> 需要注解在配置组件 <code>@Configuration</code> 类上。</p>\n<p>指定 profile 的方式有： 添加配置 <code>spring.profiles.active=dev,test</code> 的形式，也可以是通过命令行参数添加 <code>--spring.profiles.active=pro</code>。","more":"</p>\n<h2 id=\"2-SpringBoot-Testing\"><a href=\"#2-SpringBoot-Testing\" class=\"headerlink\" title=\".2. SpringBoot Testing\"></a>.2. SpringBoot Testing</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-mock-environment\">reference</a></p>\n<p>使用 SpringBoot Test 相对于 Spring更为方便一些。如果使用 Junit5 只需要一个注解 <code>@SpringBootTest</code></p>\n<ul>\n<li>可以使用服务端测试，也可以使用客户端测试。</li>\n</ul>\n<h2 id=\"3-logging\"><a href=\"#3-logging\" class=\"headerlink\" title=\".3. logging\"></a>.3. logging</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logging\">reference</a></p>\n<ul>\n<li>使用配置 logging.file.name 与 logging.file.path 指定日志文件名与路径，如果不指定文件名仅打印到控制台，如果不指定文件路径将写文件在当前路径。</li>\n</ul>\n<h3 id=\"3-1-logging-level\"><a href=\"#3-1-logging-level\" class=\"headerlink\" title=\".3.1. logging level\"></a>.3.1. logging level</h3><ul>\n<li>指定日志级别 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> logger 指日志器，可以是类或包</li>\n<li>可以在环境变量中添加参数指定日志级别 <code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> ，但这不指定类的日志器，因为环境变量中会将所有大写转换成小写。使用 SPRING_APPLICATION_JSON 变量（在命令行参数、系统变量、命令行参数中添加 Json）实现。</li>\n</ul>\n<h3 id=\"3-2-Log-Groups\"><a href=\"#3-2-Log-Groups\" class=\"headerlink\" title=\".3.2. Log Groups\"></a>.3.2. Log Groups</h3><ul>\n<li>直接定义多个类或包到同一个组 <code>logging.level.tomcat=org.apache.catalina,org.apache.coyote</code> ，再直接指定组的日志级别 <code>logging.level.tomcat=DEBUG</code></li>\n<li>Spring Boot 预定义了日志组 sql 与 web</li>\n</ul>\n<h3 id=\"3-3-Custom-Log-Configuration\"><a href=\"#3-3-Custom-Log-Configuration\" class=\"headerlink\" title=\".3.3. Custom Log Configuration\"></a>.3.3. Custom Log Configuration</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logback-extensions\">reference</a></p>\n<p>在系统变量中指定日志系统 <code>org.springframework.boot.logging.LoggingSystem</code> ，此值必须是 LoggingSystem 的实现类全限定名。同时此属性只能在系统属性中指定，因为日志开头在 ApplicationContext 初始化完成前就会使用日志系统。</p>\n<ul>\n<li>LoggingSystem 实现有三种：Logback/Log4j2/JavaUtilLogging ，其中 Logback 功能最全。</li>\n<li>通过配置文件或 Environment 属性 <code>logging.config</code> 可以自定义日志系统</li>\n</ul>\n<h2 id=\"4-JSON\"><a href=\"#4-JSON\" class=\"headerlink\" title=\".4. JSON\"></a>.4. JSON</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-json\">reference</a></p>\n<p>Spring Boot 整合了三种 JSON 映射库：</p>\n<ol>\n<li>Gson，SpringBoot 自动配置为 bean 并可以通过 spring.gson.* 配置多个属性，更详细地控制可以通过 GsonBuilderCustomizer bean 实现。</li>\n<li>Jackson，Spring 偏好并默认的。当 Jackson 在 classpath 中时， 一个 ObjectMapper bean 会自动注入，并可自定义多个配置属性。</li>\n<li>JSON-B</li>\n</ol>\n<h2 id=\"5-Developing-Web-Applications\"><a href=\"#5-Developing-Web-Applications\" class=\"headerlink\" title=\".5. Developing Web Applications\"></a>.5. Developing Web Applications</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-developing-web-applications\">reference</a></p>\n<h3 id=\"5-1-The-Spring-Web-MVC-Framework\"><a href=\"#5-1-The-Spring-Web-MVC-Framework\" class=\"headerlink\" title=\".5.1. The Spring Web MVC Framework\"></a>.5.1. The Spring Web MVC Framework</h3><h4 id=\"5-1-1-Custom-JSON-Serializers-and-Deserializers\"><a href=\"#5-1-1-Custom-JSON-Serializers-and-Deserializers\" class=\"headerlink\" title=\".5.1.1. Custom JSON Serializers and Deserializers\"></a>.5.1.1. Custom JSON Serializers and Deserializers</h4><p>@JsonComponent 注解添加 jackson 序列化反序列化器到容器中。</p>"},{"title":"SpringApplication","layout":"post","date":"2020-07-22T11:45:00.000Z","description":"Spring Boot SpringApplication","_content":"\n[SpringBoot Features](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-spring-application)\n\n## .1. Application Availability\n\n[系统可用性](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability)\n\n可以通过注入 `ApplicationAvailability` 接口到 bean 中以获取应用可用性状态。<!--more-->\n\n### .1.1. Liveness State\n\n应用活性，用以表明应用内部状态是否能正常工作，或是否能从异常中自动恢复。如果不能（失活），基础平台应该重启应用。一般来说，应用活性不应该基于外部检查，否则外部检查系统（数据库、缓存、Web API）出现异常，将触发大量重启与平台累积的失败。\n\nSpring Boot 应用的内部状态一般取决于 `ApplicationContext`。如果 ApplicationContext 成功启动，Spring Boot 就将认为应用在有效的状态。只要 context  be refreshed ，应用就被认为是有活性的。\n\n### .1.2. Readiness State\n\n应用就绪状态，用以表明应用是否对处理流量准备就绪。未进入就绪状态将告诉 platform 平台此时不宜路由流量到应用。典型的场景是在应用启动阶段，当 `CommandLineRunner` 与 `ApplicationRunner` 组件正在被处理时，或者应用忙于其他流量请求时而不能处理当前流量请求时。\n\n需要在程序启动阶段添加任务可以通过将 bean 实现接口 `ApplicationRunner` 或 `CommandLineRunner`，而不是使用 Spring 组件生命周期回调 `@PostConstruct`。以上两个接口分别可获取到程序启动参数和命令行参数。\n\n### .1.3. Managing the Application Availability State\n\n1. 获取应用当前可用性状态：注入 `ApplicationAvailability` 接口并调用其方法；\n2. 监听应用可用性变化：\n\n```java\n@EventListener\npublic void onStateChange(AvailabilityChangeEvent<ReadinessState> event) {\n    switch (event.getState()) {\n    case ACCEPTING_TRAFFIC:\n        // create file /tmp/healthy\n    break;\n    case REFUSING_TRAFFIC:\n        // remove file /tmp/healthy\n    break;\n    }\n}\n```\n\n更新应用可用性状态\n\n```java\nprivate final ApplicationEventPublisher eventPublisher;\n//自动 constructor 注入 publisher\npublic LocalCacheVerifier(ApplicationEventPublisher eventPublisher) {\n    this.eventPublisher = eventPublisher;\n}\n\npublic void checkLocalCache() {\n    try {\n        //...\n    }\n    catch (CacheCompletelyBrokenException ex) {\n        //发布一个可用性更新事件\n        AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);\n    }\n}\n```\n\n## .2. Application Events and Listeners\n\n[应用事件与监听器](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability)\n\n除了常规的应用事件 `ContextRefreshedEvent`， 一个 Spring 应用还可以发送其他事件。其中一些事件在整个应用上下文 `ApplicationContext` 创建前，对于这种事件并不能注册其监听器为一个 `Bean` ，但可以通过 `SpringApplication.addListeners()` 或 `SpringApplicationBuilder.listeners()` 方法注册。如果需要不考虑上下文是否创建自动注册监听器，可以在工程中 `META-INF/spring.factories` 引入监听器，使用 key `org.springframework.context.ApplicationListener=com.myproject.MyListener` 。\n\n应用开始启动后，事件发布顺序如下：\n\n1. `ApplicationStartingEvent` 在应用刚开始启动，除 listeners initializers 已注册外，所有的其他处理工作都还未开启时。\n2. `ApplicationEnvironmentPreparedEvent` 事件发布时机：`Environment` 在上下文中已清晰但上下文还未创建时\n3. `ApplicationContextInitializedEvent` 在 `ApplicationContext` 已准备且 ApplicationInitializers 已被调用但 bean definitions 还未加载时\n4. `ApplicationPreparedEvent` refreshed 开始之前 bean definitions 加载之后\n5. `ApplicationStartedEvent`context refreshed 之后，application runners 与 command-line runners 调用之前\n6. `AvailabilityChangeEvent` 在 `LivenessState.CORRECT` 可用性表明应用程序已具活性后\n7. `ApplicationReadyEvent` 在所有的 application/command-line runner 被调用之后\n8. `AvailabilityChangeEvent` 应用已为服务请求准备就绪 `ReadinessState.ACCEPTING_TRAFFIC` 之后\n9. `ApplicationFailedEvent` 启动异常之后\n\n以上 9 个事件是与 `SpringApplication` 绑定的事件，除此外，在 `ApplicationPreparedEvent` 与 `ApplicationStartedEvent` 之间还有两个事件：\n\n1. `WebServerInitializedEvent` `WebServer` 准备就绪后。而 `ServletWebServerInitializedEvent` 与 `ReactiveWebServerInitializedEvent` 分别在 servlet 与 reactive variants 就绪后。\n2. `ContextRefreshedEvent` `ApplicationContext` 刷新后 when an ApplicationContext is refreshed.\n\nSpring Boot 就是使用以上各个事件来处理各类任务。\n\n_根据以上顺序，倒推 Spring 应用启动的处理有：_\n\n1. 注册 listeners 与 initializers\n2. 创建环境配置 `Environment`\n3. 创建上下文 ApplicationContext ，调用 ApplicationInitializers\n4. 加载 bean definitions\n5. 如果是 web 工程应用，加载相关 WebServer: ServletWebServer/ReactiveWebServer\n6. 刷新 ApplicationContext\n7. 改变应用可用性为活性 `LivenessState.CORRECT`\n8. 调用 application runner command-line runner\n9. 改变应用服务请求就绪状态为就绪 `ReadinessState.ACCEPTING_TRAFFIC`\n\nSpring Framework 的事件发布机制在子 context 发布事件后，父 context 同样会收到相应的事件发布，所以如果应用使用了 SpringApplication 层级，一个监听器会收到相同类型的 application event。为了区别来自哪里，可以将 Context 注入对比。如果 listener 是个 bean 直接使用 @AutoWired 注入，如果 listener 不是 bean 需要实现 ApplicationContextAware 接口注入。\n\n## .3. Web Environment\n\nSpringApplication 根据代码行为来创建正确的 `ApplicationContext` ，决定 `WebApplicationType` 的算法是：\n\n1. 如果存在 Spring MVC ，使用 `AnnotationConfigServletWebApplicationContext`\n2. 如果不使用 Spring MVC 使用 Spring WebFlux，则使用 `AnnotationConfigReactiveWebServerApplicationContext`\n3. 否则，使用 `AnnotationConfigApplicationContext`\n\n算法决定了，如果一个应用使用了 Spring MVC 也使用了 Spring WebFlux ，将按 Spring MVC 处理。可使用 `setWebApplicationType(WebApplicationType)` 方法直接覆盖算法决定。如果要完全控制 `ApplicationContext` 使用方法 `setApplicationContestClass(...)`。在使用 JUnit 测试时，不需要 web 层，可调方法 `sebWebApplicationType(WebApplicationType.NONE)`\n\n## .4. Accessing Application Arguments\n\n[访问应用参数](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment)\n\n在 Spring Boot 中，当需要访问应用参数时，注入一个 `ApplicationArguments` bean，即可直接访问 `String[]` 参数或编译成 option 与 not-option 形式的参数。\n\n```java\n@AutoWired\npublic MyBean(ApplicationArguments args) {\n    boolean debug = args.containsOption(\"debug\");\n    List<String> files = args.getNonOptionArgs();\n    // if run with \"--debug logfile.txt\" debug=true, files=[\"logfile.txt\"]\n}\n```\n\nSpring Boot 也注册了一个与 Environment 关联的 `CommandLinePropertySource`，这就意味着可以在程序中使用 `@Value` 注解直接注入各个命令行参数。\n\n## .5. Using the ApplicationRunner and CommandLineRunner\n\n[使用应用、命令行Runner](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment)\n\n如果需要在 SpringApplication 启动后执行某些代码，可以实现 `ApplicationRunner` 或 `CommandLineRunner` 接口，这两个接口都提供一个 `run(ApplicationArguments)` 方法定义，其实现都是在 `SpringApplication.run(...)` 方法完成之前调用。如果有多个 Runner 需要执行，可以在 Runner 上添加 `Order` 接口或 `@Order` 注解用以指定顺序。\n\n## .6. 初始化流程\n\n> spring boot 在初始化中把大量工作做了。\n\n1. 加载 environment 数据\n2. 创建 context\n3. context refresh\n   1. 其中对入口类进行数据扫描，工作在 `org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass`，大量调用 ConfigurationClassParser 进行数据解析。\n   2. org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass 该解析器方法处理所有的 configuration 配置类数据，包括各注解 @Component @ComponentScan @PropertiesSource @Import @ImportSource @Bean 内嵌类、父类、接口默认方法 数据\n   3. `org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)` 调用 beanFactoryPostProcessor ，其就包括了将所有的 component 中的 beanDefinition 注册到容器 BeanDefinitionRegistry 中，也包括调用所有的 BeanPostProcessor .\n   4. 注册 BeanFactoryProcessor 时从 BeanDefinitionRegistry 获取其 BeanDefinition 进行初始化 bean 。\n   5. org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass 使用 CGLIB 动态代理生成 bean 子类\n","source":"_posts/Spring/SpringBoot-SpringApplication.md","raw":"---\ntitle: SpringApplication\nlayout: post\ndate: 2020-07-22 19:45:00\ntags: [Java,SpringBoot]\ncategories: [SpringBoot]\ndescription: Spring Boot SpringApplication\n---\n\n[SpringBoot Features](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-spring-application)\n\n## .1. Application Availability\n\n[系统可用性](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability)\n\n可以通过注入 `ApplicationAvailability` 接口到 bean 中以获取应用可用性状态。<!--more-->\n\n### .1.1. Liveness State\n\n应用活性，用以表明应用内部状态是否能正常工作，或是否能从异常中自动恢复。如果不能（失活），基础平台应该重启应用。一般来说，应用活性不应该基于外部检查，否则外部检查系统（数据库、缓存、Web API）出现异常，将触发大量重启与平台累积的失败。\n\nSpring Boot 应用的内部状态一般取决于 `ApplicationContext`。如果 ApplicationContext 成功启动，Spring Boot 就将认为应用在有效的状态。只要 context  be refreshed ，应用就被认为是有活性的。\n\n### .1.2. Readiness State\n\n应用就绪状态，用以表明应用是否对处理流量准备就绪。未进入就绪状态将告诉 platform 平台此时不宜路由流量到应用。典型的场景是在应用启动阶段，当 `CommandLineRunner` 与 `ApplicationRunner` 组件正在被处理时，或者应用忙于其他流量请求时而不能处理当前流量请求时。\n\n需要在程序启动阶段添加任务可以通过将 bean 实现接口 `ApplicationRunner` 或 `CommandLineRunner`，而不是使用 Spring 组件生命周期回调 `@PostConstruct`。以上两个接口分别可获取到程序启动参数和命令行参数。\n\n### .1.3. Managing the Application Availability State\n\n1. 获取应用当前可用性状态：注入 `ApplicationAvailability` 接口并调用其方法；\n2. 监听应用可用性变化：\n\n```java\n@EventListener\npublic void onStateChange(AvailabilityChangeEvent<ReadinessState> event) {\n    switch (event.getState()) {\n    case ACCEPTING_TRAFFIC:\n        // create file /tmp/healthy\n    break;\n    case REFUSING_TRAFFIC:\n        // remove file /tmp/healthy\n    break;\n    }\n}\n```\n\n更新应用可用性状态\n\n```java\nprivate final ApplicationEventPublisher eventPublisher;\n//自动 constructor 注入 publisher\npublic LocalCacheVerifier(ApplicationEventPublisher eventPublisher) {\n    this.eventPublisher = eventPublisher;\n}\n\npublic void checkLocalCache() {\n    try {\n        //...\n    }\n    catch (CacheCompletelyBrokenException ex) {\n        //发布一个可用性更新事件\n        AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);\n    }\n}\n```\n\n## .2. Application Events and Listeners\n\n[应用事件与监听器](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability)\n\n除了常规的应用事件 `ContextRefreshedEvent`， 一个 Spring 应用还可以发送其他事件。其中一些事件在整个应用上下文 `ApplicationContext` 创建前，对于这种事件并不能注册其监听器为一个 `Bean` ，但可以通过 `SpringApplication.addListeners()` 或 `SpringApplicationBuilder.listeners()` 方法注册。如果需要不考虑上下文是否创建自动注册监听器，可以在工程中 `META-INF/spring.factories` 引入监听器，使用 key `org.springframework.context.ApplicationListener=com.myproject.MyListener` 。\n\n应用开始启动后，事件发布顺序如下：\n\n1. `ApplicationStartingEvent` 在应用刚开始启动，除 listeners initializers 已注册外，所有的其他处理工作都还未开启时。\n2. `ApplicationEnvironmentPreparedEvent` 事件发布时机：`Environment` 在上下文中已清晰但上下文还未创建时\n3. `ApplicationContextInitializedEvent` 在 `ApplicationContext` 已准备且 ApplicationInitializers 已被调用但 bean definitions 还未加载时\n4. `ApplicationPreparedEvent` refreshed 开始之前 bean definitions 加载之后\n5. `ApplicationStartedEvent`context refreshed 之后，application runners 与 command-line runners 调用之前\n6. `AvailabilityChangeEvent` 在 `LivenessState.CORRECT` 可用性表明应用程序已具活性后\n7. `ApplicationReadyEvent` 在所有的 application/command-line runner 被调用之后\n8. `AvailabilityChangeEvent` 应用已为服务请求准备就绪 `ReadinessState.ACCEPTING_TRAFFIC` 之后\n9. `ApplicationFailedEvent` 启动异常之后\n\n以上 9 个事件是与 `SpringApplication` 绑定的事件，除此外，在 `ApplicationPreparedEvent` 与 `ApplicationStartedEvent` 之间还有两个事件：\n\n1. `WebServerInitializedEvent` `WebServer` 准备就绪后。而 `ServletWebServerInitializedEvent` 与 `ReactiveWebServerInitializedEvent` 分别在 servlet 与 reactive variants 就绪后。\n2. `ContextRefreshedEvent` `ApplicationContext` 刷新后 when an ApplicationContext is refreshed.\n\nSpring Boot 就是使用以上各个事件来处理各类任务。\n\n_根据以上顺序，倒推 Spring 应用启动的处理有：_\n\n1. 注册 listeners 与 initializers\n2. 创建环境配置 `Environment`\n3. 创建上下文 ApplicationContext ，调用 ApplicationInitializers\n4. 加载 bean definitions\n5. 如果是 web 工程应用，加载相关 WebServer: ServletWebServer/ReactiveWebServer\n6. 刷新 ApplicationContext\n7. 改变应用可用性为活性 `LivenessState.CORRECT`\n8. 调用 application runner command-line runner\n9. 改变应用服务请求就绪状态为就绪 `ReadinessState.ACCEPTING_TRAFFIC`\n\nSpring Framework 的事件发布机制在子 context 发布事件后，父 context 同样会收到相应的事件发布，所以如果应用使用了 SpringApplication 层级，一个监听器会收到相同类型的 application event。为了区别来自哪里，可以将 Context 注入对比。如果 listener 是个 bean 直接使用 @AutoWired 注入，如果 listener 不是 bean 需要实现 ApplicationContextAware 接口注入。\n\n## .3. Web Environment\n\nSpringApplication 根据代码行为来创建正确的 `ApplicationContext` ，决定 `WebApplicationType` 的算法是：\n\n1. 如果存在 Spring MVC ，使用 `AnnotationConfigServletWebApplicationContext`\n2. 如果不使用 Spring MVC 使用 Spring WebFlux，则使用 `AnnotationConfigReactiveWebServerApplicationContext`\n3. 否则，使用 `AnnotationConfigApplicationContext`\n\n算法决定了，如果一个应用使用了 Spring MVC 也使用了 Spring WebFlux ，将按 Spring MVC 处理。可使用 `setWebApplicationType(WebApplicationType)` 方法直接覆盖算法决定。如果要完全控制 `ApplicationContext` 使用方法 `setApplicationContestClass(...)`。在使用 JUnit 测试时，不需要 web 层，可调方法 `sebWebApplicationType(WebApplicationType.NONE)`\n\n## .4. Accessing Application Arguments\n\n[访问应用参数](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment)\n\n在 Spring Boot 中，当需要访问应用参数时，注入一个 `ApplicationArguments` bean，即可直接访问 `String[]` 参数或编译成 option 与 not-option 形式的参数。\n\n```java\n@AutoWired\npublic MyBean(ApplicationArguments args) {\n    boolean debug = args.containsOption(\"debug\");\n    List<String> files = args.getNonOptionArgs();\n    // if run with \"--debug logfile.txt\" debug=true, files=[\"logfile.txt\"]\n}\n```\n\nSpring Boot 也注册了一个与 Environment 关联的 `CommandLinePropertySource`，这就意味着可以在程序中使用 `@Value` 注解直接注入各个命令行参数。\n\n## .5. Using the ApplicationRunner and CommandLineRunner\n\n[使用应用、命令行Runner](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment)\n\n如果需要在 SpringApplication 启动后执行某些代码，可以实现 `ApplicationRunner` 或 `CommandLineRunner` 接口，这两个接口都提供一个 `run(ApplicationArguments)` 方法定义，其实现都是在 `SpringApplication.run(...)` 方法完成之前调用。如果有多个 Runner 需要执行，可以在 Runner 上添加 `Order` 接口或 `@Order` 注解用以指定顺序。\n\n## .6. 初始化流程\n\n> spring boot 在初始化中把大量工作做了。\n\n1. 加载 environment 数据\n2. 创建 context\n3. context refresh\n   1. 其中对入口类进行数据扫描，工作在 `org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass`，大量调用 ConfigurationClassParser 进行数据解析。\n   2. org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass 该解析器方法处理所有的 configuration 配置类数据，包括各注解 @Component @ComponentScan @PropertiesSource @Import @ImportSource @Bean 内嵌类、父类、接口默认方法 数据\n   3. `org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)` 调用 beanFactoryPostProcessor ，其就包括了将所有的 component 中的 beanDefinition 注册到容器 BeanDefinitionRegistry 中，也包括调用所有的 BeanPostProcessor .\n   4. 注册 BeanFactoryProcessor 时从 BeanDefinitionRegistry 获取其 BeanDefinition 进行初始化 bean 。\n   5. org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass 使用 CGLIB 动态代理生成 bean 子类\n","slug":"Spring/SpringBoot-SpringApplication","published":1,"updated":"2021-02-24T15:46:16.768Z","comments":1,"photos":[],"link":"","_id":"ckljnokrq002d2bhbbjl45jxs","content":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-spring-application\">SpringBoot Features</a></p>\n<h2 id=\"1-Application-Availability\"><a href=\"#1-Application-Availability\" class=\"headerlink\" title=\".1. Application Availability\"></a>.1. Application Availability</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability\">系统可用性</a></p>\n<p>可以通过注入 <code>ApplicationAvailability</code> 接口到 bean 中以获取应用可用性状态。<span id=\"more\"></span></p>\n<h3 id=\"1-1-Liveness-State\"><a href=\"#1-1-Liveness-State\" class=\"headerlink\" title=\".1.1. Liveness State\"></a>.1.1. Liveness State</h3><p>应用活性，用以表明应用内部状态是否能正常工作，或是否能从异常中自动恢复。如果不能（失活），基础平台应该重启应用。一般来说，应用活性不应该基于外部检查，否则外部检查系统（数据库、缓存、Web API）出现异常，将触发大量重启与平台累积的失败。</p>\n<p>Spring Boot 应用的内部状态一般取决于 <code>ApplicationContext</code>。如果 ApplicationContext 成功启动，Spring Boot 就将认为应用在有效的状态。只要 context  be refreshed ，应用就被认为是有活性的。</p>\n<h3 id=\"1-2-Readiness-State\"><a href=\"#1-2-Readiness-State\" class=\"headerlink\" title=\".1.2. Readiness State\"></a>.1.2. Readiness State</h3><p>应用就绪状态，用以表明应用是否对处理流量准备就绪。未进入就绪状态将告诉 platform 平台此时不宜路由流量到应用。典型的场景是在应用启动阶段，当 <code>CommandLineRunner</code> 与 <code>ApplicationRunner</code> 组件正在被处理时，或者应用忙于其他流量请求时而不能处理当前流量请求时。</p>\n<p>需要在程序启动阶段添加任务可以通过将 bean 实现接口 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code>，而不是使用 Spring 组件生命周期回调 <code>@PostConstruct</code>。以上两个接口分别可获取到程序启动参数和命令行参数。</p>\n<h3 id=\"1-3-Managing-the-Application-Availability-State\"><a href=\"#1-3-Managing-the-Application-Availability-State\" class=\"headerlink\" title=\".1.3. Managing the Application Availability State\"></a>.1.3. Managing the Application Availability State</h3><ol>\n<li>获取应用当前可用性状态：注入 <code>ApplicationAvailability</code> 接口并调用其方法；</li>\n<li>监听应用可用性变化：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EventListener</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChange</span><span class=\"params\">(AvailabilityChangeEvent&lt;ReadinessState&gt; event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (event.getState()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ACCEPTING_TRAFFIC:</span><br><span class=\"line\">        <span class=\"comment\">// create file /tmp/healthy</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REFUSING_TRAFFIC:</span><br><span class=\"line\">        <span class=\"comment\">// remove file /tmp/healthy</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更新应用可用性状态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class=\"line\"><span class=\"comment\">//自动 constructor 注入 publisher</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LocalCacheVerifier</span><span class=\"params\">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventPublisher = eventPublisher;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkLocalCache</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (CacheCompletelyBrokenException ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发布一个可用性更新事件</span></span><br><span class=\"line\">        AvailabilityChangeEvent.publish(<span class=\"keyword\">this</span>.eventPublisher, ex, LivenessState.BROKEN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-Application-Events-and-Listeners\"><a href=\"#2-Application-Events-and-Listeners\" class=\"headerlink\" title=\".2. Application Events and Listeners\"></a>.2. Application Events and Listeners</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability\">应用事件与监听器</a></p>\n<p>除了常规的应用事件 <code>ContextRefreshedEvent</code>， 一个 Spring 应用还可以发送其他事件。其中一些事件在整个应用上下文 <code>ApplicationContext</code> 创建前，对于这种事件并不能注册其监听器为一个 <code>Bean</code> ，但可以通过 <code>SpringApplication.addListeners()</code> 或 <code>SpringApplicationBuilder.listeners()</code> 方法注册。如果需要不考虑上下文是否创建自动注册监听器，可以在工程中 <code>META-INF/spring.factories</code> 引入监听器，使用 key <code>org.springframework.context.ApplicationListener=com.myproject.MyListener</code> 。</p>\n<p>应用开始启动后，事件发布顺序如下：</p>\n<ol>\n<li><code>ApplicationStartingEvent</code> 在应用刚开始启动，除 listeners initializers 已注册外，所有的其他处理工作都还未开启时。</li>\n<li><code>ApplicationEnvironmentPreparedEvent</code> 事件发布时机：<code>Environment</code> 在上下文中已清晰但上下文还未创建时</li>\n<li><code>ApplicationContextInitializedEvent</code> 在 <code>ApplicationContext</code> 已准备且 ApplicationInitializers 已被调用但 bean definitions 还未加载时</li>\n<li><code>ApplicationPreparedEvent</code> refreshed 开始之前 bean definitions 加载之后</li>\n<li><code>ApplicationStartedEvent</code>context refreshed 之后，application runners 与 command-line runners 调用之前</li>\n<li><code>AvailabilityChangeEvent</code> 在 <code>LivenessState.CORRECT</code> 可用性表明应用程序已具活性后</li>\n<li><code>ApplicationReadyEvent</code> 在所有的 application/command-line runner 被调用之后</li>\n<li><code>AvailabilityChangeEvent</code> 应用已为服务请求准备就绪 <code>ReadinessState.ACCEPTING_TRAFFIC</code> 之后</li>\n<li><code>ApplicationFailedEvent</code> 启动异常之后</li>\n</ol>\n<p>以上 9 个事件是与 <code>SpringApplication</code> 绑定的事件，除此外，在 <code>ApplicationPreparedEvent</code> 与 <code>ApplicationStartedEvent</code> 之间还有两个事件：</p>\n<ol>\n<li><code>WebServerInitializedEvent</code> <code>WebServer</code> 准备就绪后。而 <code>ServletWebServerInitializedEvent</code> 与 <code>ReactiveWebServerInitializedEvent</code> 分别在 servlet 与 reactive variants 就绪后。</li>\n<li><code>ContextRefreshedEvent</code> <code>ApplicationContext</code> 刷新后 when an ApplicationContext is refreshed.</li>\n</ol>\n<p>Spring Boot 就是使用以上各个事件来处理各类任务。</p>\n<p><em>根据以上顺序，倒推 Spring 应用启动的处理有：</em></p>\n<ol>\n<li>注册 listeners 与 initializers</li>\n<li>创建环境配置 <code>Environment</code></li>\n<li>创建上下文 ApplicationContext ，调用 ApplicationInitializers</li>\n<li>加载 bean definitions</li>\n<li>如果是 web 工程应用，加载相关 WebServer: ServletWebServer/ReactiveWebServer</li>\n<li>刷新 ApplicationContext</li>\n<li>改变应用可用性为活性 <code>LivenessState.CORRECT</code></li>\n<li>调用 application runner command-line runner</li>\n<li>改变应用服务请求就绪状态为就绪 <code>ReadinessState.ACCEPTING_TRAFFIC</code></li>\n</ol>\n<p>Spring Framework 的事件发布机制在子 context 发布事件后，父 context 同样会收到相应的事件发布，所以如果应用使用了 SpringApplication 层级，一个监听器会收到相同类型的 application event。为了区别来自哪里，可以将 Context 注入对比。如果 listener 是个 bean 直接使用 @AutoWired 注入，如果 listener 不是 bean 需要实现 ApplicationContextAware 接口注入。</p>\n<h2 id=\"3-Web-Environment\"><a href=\"#3-Web-Environment\" class=\"headerlink\" title=\".3. Web Environment\"></a>.3. Web Environment</h2><p>SpringApplication 根据代码行为来创建正确的 <code>ApplicationContext</code> ，决定 <code>WebApplicationType</code> 的算法是：</p>\n<ol>\n<li>如果存在 Spring MVC ，使用 <code>AnnotationConfigServletWebApplicationContext</code></li>\n<li>如果不使用 Spring MVC 使用 Spring WebFlux，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>\n<li>否则，使用 <code>AnnotationConfigApplicationContext</code></li>\n</ol>\n<p>算法决定了，如果一个应用使用了 Spring MVC 也使用了 Spring WebFlux ，将按 Spring MVC 处理。可使用 <code>setWebApplicationType(WebApplicationType)</code> 方法直接覆盖算法决定。如果要完全控制 <code>ApplicationContext</code> 使用方法 <code>setApplicationContestClass(...)</code>。在使用 JUnit 测试时，不需要 web 层，可调方法 <code>sebWebApplicationType(WebApplicationType.NONE)</code></p>\n<h2 id=\"4-Accessing-Application-Arguments\"><a href=\"#4-Accessing-Application-Arguments\" class=\"headerlink\" title=\".4. Accessing Application Arguments\"></a>.4. Accessing Application Arguments</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment\">访问应用参数</a></p>\n<p>在 Spring Boot 中，当需要访问应用参数时，注入一个 <code>ApplicationArguments</code> bean，即可直接访问 <code>String[]</code> 参数或编译成 option 与 not-option 形式的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoWired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyBean</span><span class=\"params\">(ApplicationArguments args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> debug = args.containsOption(<span class=\"string\">&quot;debug&quot;</span>);</span><br><span class=\"line\">    List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class=\"line\">    <span class=\"comment\">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring Boot 也注册了一个与 Environment 关联的 <code>CommandLinePropertySource</code>，这就意味着可以在程序中使用 <code>@Value</code> 注解直接注入各个命令行参数。</p>\n<h2 id=\"5-Using-the-ApplicationRunner-and-CommandLineRunner\"><a href=\"#5-Using-the-ApplicationRunner-and-CommandLineRunner\" class=\"headerlink\" title=\".5. Using the ApplicationRunner and CommandLineRunner\"></a>.5. Using the ApplicationRunner and CommandLineRunner</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment\">使用应用、命令行Runner</a></p>\n<p>如果需要在 SpringApplication 启动后执行某些代码，可以实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口，这两个接口都提供一个 <code>run(ApplicationArguments)</code> 方法定义，其实现都是在 <code>SpringApplication.run(...)</code> 方法完成之前调用。如果有多个 Runner 需要执行，可以在 Runner 上添加 <code>Order</code> 接口或 <code>@Order</code> 注解用以指定顺序。</p>\n<h2 id=\"6-初始化流程\"><a href=\"#6-初始化流程\" class=\"headerlink\" title=\".6. 初始化流程\"></a>.6. 初始化流程</h2><blockquote>\n<p>spring boot 在初始化中把大量工作做了。</p>\n</blockquote>\n<ol>\n<li>加载 environment 数据</li>\n<li>创建 context</li>\n<li>context refresh<ol>\n<li>其中对入口类进行数据扫描，工作在 <code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code>，大量调用 ConfigurationClassParser 进行数据解析。</li>\n<li>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass 该解析器方法处理所有的 configuration 配置类数据，包括各注解 @Component @ComponentScan @PropertiesSource @Import @ImportSource @Bean 内嵌类、父类、接口默认方法 数据</li>\n<li><code>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</code> 调用 beanFactoryPostProcessor ，其就包括了将所有的 component 中的 beanDefinition 注册到容器 BeanDefinitionRegistry 中，也包括调用所有的 BeanPostProcessor .</li>\n<li>注册 BeanFactoryProcessor 时从 BeanDefinitionRegistry 获取其 BeanDefinition 进行初始化 bean 。</li>\n<li>org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass 使用 CGLIB 动态代理生成 bean 子类</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-spring-application\">SpringBoot Features</a></p>\n<h2 id=\"1-Application-Availability\"><a href=\"#1-Application-Availability\" class=\"headerlink\" title=\".1. Application Availability\"></a>.1. Application Availability</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability\">系统可用性</a></p>\n<p>可以通过注入 <code>ApplicationAvailability</code> 接口到 bean 中以获取应用可用性状态。","more":"</p>\n<h3 id=\"1-1-Liveness-State\"><a href=\"#1-1-Liveness-State\" class=\"headerlink\" title=\".1.1. Liveness State\"></a>.1.1. Liveness State</h3><p>应用活性，用以表明应用内部状态是否能正常工作，或是否能从异常中自动恢复。如果不能（失活），基础平台应该重启应用。一般来说，应用活性不应该基于外部检查，否则外部检查系统（数据库、缓存、Web API）出现异常，将触发大量重启与平台累积的失败。</p>\n<p>Spring Boot 应用的内部状态一般取决于 <code>ApplicationContext</code>。如果 ApplicationContext 成功启动，Spring Boot 就将认为应用在有效的状态。只要 context  be refreshed ，应用就被认为是有活性的。</p>\n<h3 id=\"1-2-Readiness-State\"><a href=\"#1-2-Readiness-State\" class=\"headerlink\" title=\".1.2. Readiness State\"></a>.1.2. Readiness State</h3><p>应用就绪状态，用以表明应用是否对处理流量准备就绪。未进入就绪状态将告诉 platform 平台此时不宜路由流量到应用。典型的场景是在应用启动阶段，当 <code>CommandLineRunner</code> 与 <code>ApplicationRunner</code> 组件正在被处理时，或者应用忙于其他流量请求时而不能处理当前流量请求时。</p>\n<p>需要在程序启动阶段添加任务可以通过将 bean 实现接口 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code>，而不是使用 Spring 组件生命周期回调 <code>@PostConstruct</code>。以上两个接口分别可获取到程序启动参数和命令行参数。</p>\n<h3 id=\"1-3-Managing-the-Application-Availability-State\"><a href=\"#1-3-Managing-the-Application-Availability-State\" class=\"headerlink\" title=\".1.3. Managing the Application Availability State\"></a>.1.3. Managing the Application Availability State</h3><ol>\n<li>获取应用当前可用性状态：注入 <code>ApplicationAvailability</code> 接口并调用其方法；</li>\n<li>监听应用可用性变化：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EventListener</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChange</span><span class=\"params\">(AvailabilityChangeEvent&lt;ReadinessState&gt; event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (event.getState()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ACCEPTING_TRAFFIC:</span><br><span class=\"line\">        <span class=\"comment\">// create file /tmp/healthy</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REFUSING_TRAFFIC:</span><br><span class=\"line\">        <span class=\"comment\">// remove file /tmp/healthy</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更新应用可用性状态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class=\"line\"><span class=\"comment\">//自动 constructor 注入 publisher</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LocalCacheVerifier</span><span class=\"params\">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventPublisher = eventPublisher;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkLocalCache</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (CacheCompletelyBrokenException ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发布一个可用性更新事件</span></span><br><span class=\"line\">        AvailabilityChangeEvent.publish(<span class=\"keyword\">this</span>.eventPublisher, ex, LivenessState.BROKEN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-Application-Events-and-Listeners\"><a href=\"#2-Application-Events-and-Listeners\" class=\"headerlink\" title=\".2. Application Events and Listeners\"></a>.2. Application Events and Listeners</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-availability\">应用事件与监听器</a></p>\n<p>除了常规的应用事件 <code>ContextRefreshedEvent</code>， 一个 Spring 应用还可以发送其他事件。其中一些事件在整个应用上下文 <code>ApplicationContext</code> 创建前，对于这种事件并不能注册其监听器为一个 <code>Bean</code> ，但可以通过 <code>SpringApplication.addListeners()</code> 或 <code>SpringApplicationBuilder.listeners()</code> 方法注册。如果需要不考虑上下文是否创建自动注册监听器，可以在工程中 <code>META-INF/spring.factories</code> 引入监听器，使用 key <code>org.springframework.context.ApplicationListener=com.myproject.MyListener</code> 。</p>\n<p>应用开始启动后，事件发布顺序如下：</p>\n<ol>\n<li><code>ApplicationStartingEvent</code> 在应用刚开始启动，除 listeners initializers 已注册外，所有的其他处理工作都还未开启时。</li>\n<li><code>ApplicationEnvironmentPreparedEvent</code> 事件发布时机：<code>Environment</code> 在上下文中已清晰但上下文还未创建时</li>\n<li><code>ApplicationContextInitializedEvent</code> 在 <code>ApplicationContext</code> 已准备且 ApplicationInitializers 已被调用但 bean definitions 还未加载时</li>\n<li><code>ApplicationPreparedEvent</code> refreshed 开始之前 bean definitions 加载之后</li>\n<li><code>ApplicationStartedEvent</code>context refreshed 之后，application runners 与 command-line runners 调用之前</li>\n<li><code>AvailabilityChangeEvent</code> 在 <code>LivenessState.CORRECT</code> 可用性表明应用程序已具活性后</li>\n<li><code>ApplicationReadyEvent</code> 在所有的 application/command-line runner 被调用之后</li>\n<li><code>AvailabilityChangeEvent</code> 应用已为服务请求准备就绪 <code>ReadinessState.ACCEPTING_TRAFFIC</code> 之后</li>\n<li><code>ApplicationFailedEvent</code> 启动异常之后</li>\n</ol>\n<p>以上 9 个事件是与 <code>SpringApplication</code> 绑定的事件，除此外，在 <code>ApplicationPreparedEvent</code> 与 <code>ApplicationStartedEvent</code> 之间还有两个事件：</p>\n<ol>\n<li><code>WebServerInitializedEvent</code> <code>WebServer</code> 准备就绪后。而 <code>ServletWebServerInitializedEvent</code> 与 <code>ReactiveWebServerInitializedEvent</code> 分别在 servlet 与 reactive variants 就绪后。</li>\n<li><code>ContextRefreshedEvent</code> <code>ApplicationContext</code> 刷新后 when an ApplicationContext is refreshed.</li>\n</ol>\n<p>Spring Boot 就是使用以上各个事件来处理各类任务。</p>\n<p><em>根据以上顺序，倒推 Spring 应用启动的处理有：</em></p>\n<ol>\n<li>注册 listeners 与 initializers</li>\n<li>创建环境配置 <code>Environment</code></li>\n<li>创建上下文 ApplicationContext ，调用 ApplicationInitializers</li>\n<li>加载 bean definitions</li>\n<li>如果是 web 工程应用，加载相关 WebServer: ServletWebServer/ReactiveWebServer</li>\n<li>刷新 ApplicationContext</li>\n<li>改变应用可用性为活性 <code>LivenessState.CORRECT</code></li>\n<li>调用 application runner command-line runner</li>\n<li>改变应用服务请求就绪状态为就绪 <code>ReadinessState.ACCEPTING_TRAFFIC</code></li>\n</ol>\n<p>Spring Framework 的事件发布机制在子 context 发布事件后，父 context 同样会收到相应的事件发布，所以如果应用使用了 SpringApplication 层级，一个监听器会收到相同类型的 application event。为了区别来自哪里，可以将 Context 注入对比。如果 listener 是个 bean 直接使用 @AutoWired 注入，如果 listener 不是 bean 需要实现 ApplicationContextAware 接口注入。</p>\n<h2 id=\"3-Web-Environment\"><a href=\"#3-Web-Environment\" class=\"headerlink\" title=\".3. Web Environment\"></a>.3. Web Environment</h2><p>SpringApplication 根据代码行为来创建正确的 <code>ApplicationContext</code> ，决定 <code>WebApplicationType</code> 的算法是：</p>\n<ol>\n<li>如果存在 Spring MVC ，使用 <code>AnnotationConfigServletWebApplicationContext</code></li>\n<li>如果不使用 Spring MVC 使用 Spring WebFlux，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>\n<li>否则，使用 <code>AnnotationConfigApplicationContext</code></li>\n</ol>\n<p>算法决定了，如果一个应用使用了 Spring MVC 也使用了 Spring WebFlux ，将按 Spring MVC 处理。可使用 <code>setWebApplicationType(WebApplicationType)</code> 方法直接覆盖算法决定。如果要完全控制 <code>ApplicationContext</code> 使用方法 <code>setApplicationContestClass(...)</code>。在使用 JUnit 测试时，不需要 web 层，可调方法 <code>sebWebApplicationType(WebApplicationType.NONE)</code></p>\n<h2 id=\"4-Accessing-Application-Arguments\"><a href=\"#4-Accessing-Application-Arguments\" class=\"headerlink\" title=\".4. Accessing Application Arguments\"></a>.4. Accessing Application Arguments</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment\">访问应用参数</a></p>\n<p>在 Spring Boot 中，当需要访问应用参数时，注入一个 <code>ApplicationArguments</code> bean，即可直接访问 <code>String[]</code> 参数或编译成 option 与 not-option 形式的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoWired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyBean</span><span class=\"params\">(ApplicationArguments args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> debug = args.containsOption(<span class=\"string\">&quot;debug&quot;</span>);</span><br><span class=\"line\">    List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class=\"line\">    <span class=\"comment\">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring Boot 也注册了一个与 Environment 关联的 <code>CommandLinePropertySource</code>，这就意味着可以在程序中使用 <code>@Value</code> 注解直接注入各个命令行参数。</p>\n<h2 id=\"5-Using-the-ApplicationRunner-and-CommandLineRunner\"><a href=\"#5-Using-the-ApplicationRunner-and-CommandLineRunner\" class=\"headerlink\" title=\".5. Using the ApplicationRunner and CommandLineRunner\"></a>.5. Using the ApplicationRunner and CommandLineRunner</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-web-environment\">使用应用、命令行Runner</a></p>\n<p>如果需要在 SpringApplication 启动后执行某些代码，可以实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口，这两个接口都提供一个 <code>run(ApplicationArguments)</code> 方法定义，其实现都是在 <code>SpringApplication.run(...)</code> 方法完成之前调用。如果有多个 Runner 需要执行，可以在 Runner 上添加 <code>Order</code> 接口或 <code>@Order</code> 注解用以指定顺序。</p>\n<h2 id=\"6-初始化流程\"><a href=\"#6-初始化流程\" class=\"headerlink\" title=\".6. 初始化流程\"></a>.6. 初始化流程</h2><blockquote>\n<p>spring boot 在初始化中把大量工作做了。</p>\n</blockquote>\n<ol>\n<li>加载 environment 数据</li>\n<li>创建 context</li>\n<li>context refresh<ol>\n<li>其中对入口类进行数据扫描，工作在 <code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code>，大量调用 ConfigurationClassParser 进行数据解析。</li>\n<li>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass 该解析器方法处理所有的 configuration 配置类数据，包括各注解 @Component @ComponentScan @PropertiesSource @Import @ImportSource @Bean 内嵌类、父类、接口默认方法 数据</li>\n<li><code>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</code> 调用 beanFactoryPostProcessor ，其就包括了将所有的 component 中的 beanDefinition 注册到容器 BeanDefinitionRegistry 中，也包括调用所有的 BeanPostProcessor .</li>\n<li>注册 BeanFactoryProcessor 时从 BeanDefinitionRegistry 获取其 BeanDefinition 进行初始化 bean 。</li>\n<li>org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass 使用 CGLIB 动态代理生成 bean 子类</li>\n</ol>\n</li>\n</ol>"},{"title":"Spring Validating, Data Binding and Type Conversion","date":"2020-04-15T04:14:38.000Z","description":"spring 中的数据验证、绑定与类型转换","_content":"\n[spring reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\nSpring 中的 数据验证、数据绑定、类型转换。<!--more-->\n\n## .1. Validation on Spring's Validator Interface\n\n- 实现接口 Validator ，定义验证各个 POJO 的代码。\n- 结合 `ValidationUtils 使用\n\n### .1.1. Configuring a Bean Validation Provider\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation-beanvalidation-overview)\n\n- `LocalValidatorFactoryBean` 继承了 ValidatorFactory 和 Validator 两个接口，将其注册为一个 Bean。\n- 在需要使用验证的 Bean 中注入 Validator 即可。\n- 使用 `@Constraint` 自定义约束，再使用 `ConstraintValidator` 实现约束行为。\n- Spring 驱动方法验证\n    - 整合方法验证直接将 `MethodValidationPostProcessor` 注册到容器中\n\n        ```java\n        @Bean\n        public MethodValidationPostProcessor validationPostProcessor() {\n            return new MethodValidationPostProcessor;\n        }\n        ```\n\n    - 目标类必须使用 Spring 的 `@Validated` 注解，同时目标类依赖 AOP 代理，否则不能正常工作。\n\n### .1.2. Resolving Codes to Error Messages\n\n- 如果需要使用 `MessageSource` 输出错误信息，可以使用在拒绝字段时提供的 error code。\n- `MessageCodesResolver` 决定 `Error` 注册哪个 error code 。\n- 默认解析器 `DefaultMessageCodesResolver` 不仅注册 reject 时提供的 message 与 code，也包括传递的字段名。\n\n## .2. Bean Manipulation and the `BeanWrapper`\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n- Spring 定义一个 [bean](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html) 的原则：一个类有默认的构造器，对于其属性要有其 setter 与 getter 。\n- beans package 中重要的接口 `BeanWrapper` 提供了访问设置 bean 各种属性的功能。\n\n    ```java\n    BeanWrapper company = new BeanWrapperImpl(new Company());\n    // setting the company name..\n    company.setPropertyValue(\"name\", \"Some Company Inc.\");\n    // ... can also be done like this:\n    PropertyValue value = new PropertyValue(\"name\", \"Some Company Inc.\");\n    company.setPropertyValue(value);\n\n    // ok, let's create the director and tie it to the company:\n    BeanWrapper jim = new BeanWrapperImpl(new Employee());\n    jim.setPropertyValue(\"name\", \"Jim Stravinsky\");\n    company.setPropertyValue(\"managingDirector\", jim.getWrappedInstance());\n\n    // retrieving the salary of the managingDirector through the company\n    Float salary = (Float) company.getPropertyValue(\"managingDirector.salary\");\n    ```\n\n### .2.1. Built-in `PropertyEditor` Implements\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n- Spring 使用 `PropertyEditor` 的概念来完成 `Object` 与 `String` 之间的转换。\n- 常用使用场景：\n    - 给 bean 设置 properties。在 xml 给 bean 配置了 class property ，使用 `ClassEditor` 将 String 转成 Class 对象。\n    - 在 Spring MVC 中使用 `PropertyEditor` 解析 HTTP 请求参数（可手动绑定 `CommandController` 所有子类）。\n\n#### .2.1.1. Spring 内置的 `PropertyEditor` 实现\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n其中有默认注册为 `BeanWrapperImpl` ，Spring 将自动使用这些组件实现 String 与 各个 type 的转换。\n\n#### .2.1.2. 注册自定义 `PropertyEditor`\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n两种注册方式：\n\n1. 当有获取到 BeanFactory reference 时，使用 ConfigurableBeanFactory 其 `registerCustomEditor()` 方法将自定义的 PropertyEditor 注册进来（不推荐）。\n2. 使用名为 `CustomEditorConfigurer` 的 bean factory post-processor，可使用注册 bean 方式注册，可设置其内置属性。\n\n- 实现一个 PropertyEditor\n\n    ```java\n    public class ExoticTypeEditor extends PropertyEditorSupport {\n\n        public void setAsText(String text) {\n            setValue(new ExoticType(text.toUpperCase()));\n        }\n    }\n    ```\n\n- 将 editor 注册到配置器中\n\n```xml\n<bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n    <property name=\"customEditors\">\n        <map>\n            <entry key=\"example.ExoticType\" value=\"example.ExoticTypeEditor\"/>\n        </map>\n    </property>\n</bean>\n```\n\n##### .2.1.2.1. 使用 `PropertyEditorRegistrar`\n\n- 在不同场景需要使用同一系列的 editor 时更适合此注册器。\n- 与接口 `CustomEditorConfigurer` 连用，将 PropertyEditorRegistrar 实例注册到 CustomerEditorConfigurer 中，editor 可轻松地共享到 `DataBinder` 与 Spring MVC Controller。同时，这样操作在每次调用 PropertyEditor 时都创建一个新的实例，而避免了同步。\n\n## .3. Spring Type Conversion\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beans-conversion-customeditor-registration)\n\n### .3.1. Converter SPI\n\n- 函数式接口， `Converter<S, T>`\n\n### .3.2. ConverterFactory\n\n- 使用 `ConverterFactory<S, R>` 可以实现提供将一个类型转换成多个类型的 不同的转换器。\n\n### .3.3. GenericConverter\n\n相对于 Converter 提供了更复杂灵活的转换功能。针对转换多个目标 类型。\n\n### .3.4. ConditionalGenericConverter\n\n- 联合了 `GenericConverter` 和 `ConditionalConverter` 两个接口而成，可以指定目标字段进行转换。\n- 可以给 GenericConverter 加上条件，指定允许哪些转换，哪些不允许；\n\n### .3.5. Formatting\n\n### .3.6. The `ConversionService` API\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API)\n\n- 大部分 `ConversionService` 实现了 `ConverterRegistry` ，这就提供了注册 Converter 的 SPI。内部实现将 conversion 工作委托给注册的 converter 。\n- `GenericConversionService` 覆盖了大部分 converter 使用场景\n- `ConversionServiceFactory` 提供工厂创建常用 `ConversionService` 。\n\n### .3.7. 配置 `ConversionService`\n\n- 使用默认的 `ConversionServiceFactoryBean` 为容器默认转换器服务，其提供了基础数据转换器（详见 `{@link DefaultConversionService # addDefaultConverters()}`）。\n- 添加自定义转换器\n\n```xml\n<bean id=\"conversionService\"\n        class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n    <property name=\"converters\">\n        <set>\n            <bean class=\"example.MyCustomConverter\"/>\n        </set>\n    </property>\n</bean>\n```\n\n- 使用默认转换复合类型数据（集合转集合）[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API)\n\n```java\nDefaultConversionService cs = new DefaultConversionService();\n\nList<Integer> input = ...\ncs.convert(input,\n    TypeDescriptor.forObject(input), // List<Integer> type descriptor\n    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));\n```\n\n- 使用 `DefaultConversionService` 默认添加各个转换器到 Spring 容器中\n- 添加自定义 Converter 到其中，使用时直接调用 convert 方法，其在添加时是将各个 converter 放入一个指定 map 中，在使用时再 get 到相应的目标 converter 再再使用（这里可以看出来，再复杂的系统设计，最后都回归到了数据结构中）。\n\n_规律：一个工具有多个功能时就可以集成到一个 service 组件中：Converter -> ConverterService。再将一个组件注册到 IoC 容器中，在容器中任何位置自动装配上此组件即可使用。_\n\n## .4. Spring Field Formatting\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#format)\n\nformatting 是 converting 的一个子集。在客户端环境（web 应用或桌面应用），需要将 `String` 与各个类型互转，同时也需要将 String 本地化。这个格式化的过程在 core.convert.Converter SPI 并没有直接解决。Spring 3 中引入 Formatting SPI 提供了可选的 `PropertyEditor`实现来完成格式化。\n\n- `Formatter` 接口实现了 Printer 与 Parser 两个接口。\n\n### .4.1. 注解驱动 Formatting\n\n- `AnnotationFormatterFactory<? extend Annotation>` 实现此接口，使用注解指定类中字段格式化。常用注解所在包： `org.springframework.format.annotation`\n\n### .4.2. 拓展 Formatting 注册\n\n1. 使用 FormatterRegistry SPI，其中可以提供多种类型的 formatter 注册包括注解指定字段、直接指定字段类型，最终 formatter 根据其 parser 与 printer 转换成两个 converter 注册到 conversionService 中\n\n## .5. Spring MVC 中配置序列化与反序列化的 Converter\n\n使用 JSR310 的序列化工具。\n\n### .5.1. 序列化时间类型数据\n\n默认情况下其添加的 jdk8 与 LocalDateTimeSerialize 等序列化工具使用的 formatter 常并不是我们想的结果，这时需要配置自己想要的 formatter。\n\n- jdk time 包 DateTimeFormatter 有具体的构造方法。可直接使用其 Builder 类 ： `DateTimeFormatterBuilder` 。\n    - `ResolveStyle` 指定 DateTime 解析模式：STRICT 严格按照日期来，超出则无效；SMART 智能模式，比如天超过当月最大天就到最大的；LENENT 宽容模式，超出边界也将被转换，比如：月份 15\n    - 指定 pattern ，在 builder 中 addPattern(String pattern) ，方法注释有对详细注释，其中有调用达到指定 pattern 字符等效方法说明。\n    - builder.configure() 中最后将所有的 serializer 与 deserializer 都添加进 new SimpleModule 中，再将 simpleModule 注册到 objectMapper 中（所有的配置数据都会注册入 objectMapper），最后 build 方法即将此 objectMapper 返回供 `AbstractJackson2HttpMessageConverter` 构造（for Spring MVC）使用。\n","source":"_posts/Spring/Validation_databinding_typeConversion.md","raw":"---\ntitle: Spring Validating, Data Binding and Type Conversion\ndate: 2020-04-15 12:14:38\ntags: [validating,data binding,type conversion,Java,Spring]\ncategories: [Spring]\ndescription: spring 中的数据验证、绑定与类型转换\n---\n\n[spring reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\nSpring 中的 数据验证、数据绑定、类型转换。<!--more-->\n\n## .1. Validation on Spring's Validator Interface\n\n- 实现接口 Validator ，定义验证各个 POJO 的代码。\n- 结合 `ValidationUtils 使用\n\n### .1.1. Configuring a Bean Validation Provider\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation-beanvalidation-overview)\n\n- `LocalValidatorFactoryBean` 继承了 ValidatorFactory 和 Validator 两个接口，将其注册为一个 Bean。\n- 在需要使用验证的 Bean 中注入 Validator 即可。\n- 使用 `@Constraint` 自定义约束，再使用 `ConstraintValidator` 实现约束行为。\n- Spring 驱动方法验证\n    - 整合方法验证直接将 `MethodValidationPostProcessor` 注册到容器中\n\n        ```java\n        @Bean\n        public MethodValidationPostProcessor validationPostProcessor() {\n            return new MethodValidationPostProcessor;\n        }\n        ```\n\n    - 目标类必须使用 Spring 的 `@Validated` 注解，同时目标类依赖 AOP 代理，否则不能正常工作。\n\n### .1.2. Resolving Codes to Error Messages\n\n- 如果需要使用 `MessageSource` 输出错误信息，可以使用在拒绝字段时提供的 error code。\n- `MessageCodesResolver` 决定 `Error` 注册哪个 error code 。\n- 默认解析器 `DefaultMessageCodesResolver` 不仅注册 reject 时提供的 message 与 code，也包括传递的字段名。\n\n## .2. Bean Manipulation and the `BeanWrapper`\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n- Spring 定义一个 [bean](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html) 的原则：一个类有默认的构造器，对于其属性要有其 setter 与 getter 。\n- beans package 中重要的接口 `BeanWrapper` 提供了访问设置 bean 各种属性的功能。\n\n    ```java\n    BeanWrapper company = new BeanWrapperImpl(new Company());\n    // setting the company name..\n    company.setPropertyValue(\"name\", \"Some Company Inc.\");\n    // ... can also be done like this:\n    PropertyValue value = new PropertyValue(\"name\", \"Some Company Inc.\");\n    company.setPropertyValue(value);\n\n    // ok, let's create the director and tie it to the company:\n    BeanWrapper jim = new BeanWrapperImpl(new Employee());\n    jim.setPropertyValue(\"name\", \"Jim Stravinsky\");\n    company.setPropertyValue(\"managingDirector\", jim.getWrappedInstance());\n\n    // retrieving the salary of the managingDirector through the company\n    Float salary = (Float) company.getPropertyValue(\"managingDirector.salary\");\n    ```\n\n### .2.1. Built-in `PropertyEditor` Implements\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n- Spring 使用 `PropertyEditor` 的概念来完成 `Object` 与 `String` 之间的转换。\n- 常用使用场景：\n    - 给 bean 设置 properties。在 xml 给 bean 配置了 class property ，使用 `ClassEditor` 将 String 转成 Class 对象。\n    - 在 Spring MVC 中使用 `PropertyEditor` 解析 HTTP 请求参数（可手动绑定 `CommandController` 所有子类）。\n\n#### .2.1.1. Spring 内置的 `PropertyEditor` 实现\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n其中有默认注册为 `BeanWrapperImpl` ，Spring 将自动使用这些组件实现 String 与 各个 type 的转换。\n\n#### .2.1.2. 注册自定义 `PropertyEditor`\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation)\n\n两种注册方式：\n\n1. 当有获取到 BeanFactory reference 时，使用 ConfigurableBeanFactory 其 `registerCustomEditor()` 方法将自定义的 PropertyEditor 注册进来（不推荐）。\n2. 使用名为 `CustomEditorConfigurer` 的 bean factory post-processor，可使用注册 bean 方式注册，可设置其内置属性。\n\n- 实现一个 PropertyEditor\n\n    ```java\n    public class ExoticTypeEditor extends PropertyEditorSupport {\n\n        public void setAsText(String text) {\n            setValue(new ExoticType(text.toUpperCase()));\n        }\n    }\n    ```\n\n- 将 editor 注册到配置器中\n\n```xml\n<bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n    <property name=\"customEditors\">\n        <map>\n            <entry key=\"example.ExoticType\" value=\"example.ExoticTypeEditor\"/>\n        </map>\n    </property>\n</bean>\n```\n\n##### .2.1.2.1. 使用 `PropertyEditorRegistrar`\n\n- 在不同场景需要使用同一系列的 editor 时更适合此注册器。\n- 与接口 `CustomEditorConfigurer` 连用，将 PropertyEditorRegistrar 实例注册到 CustomerEditorConfigurer 中，editor 可轻松地共享到 `DataBinder` 与 Spring MVC Controller。同时，这样操作在每次调用 PropertyEditor 时都创建一个新的实例，而避免了同步。\n\n## .3. Spring Type Conversion\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beans-conversion-customeditor-registration)\n\n### .3.1. Converter SPI\n\n- 函数式接口， `Converter<S, T>`\n\n### .3.2. ConverterFactory\n\n- 使用 `ConverterFactory<S, R>` 可以实现提供将一个类型转换成多个类型的 不同的转换器。\n\n### .3.3. GenericConverter\n\n相对于 Converter 提供了更复杂灵活的转换功能。针对转换多个目标 类型。\n\n### .3.4. ConditionalGenericConverter\n\n- 联合了 `GenericConverter` 和 `ConditionalConverter` 两个接口而成，可以指定目标字段进行转换。\n- 可以给 GenericConverter 加上条件，指定允许哪些转换，哪些不允许；\n\n### .3.5. Formatting\n\n### .3.6. The `ConversionService` API\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API)\n\n- 大部分 `ConversionService` 实现了 `ConverterRegistry` ，这就提供了注册 Converter 的 SPI。内部实现将 conversion 工作委托给注册的 converter 。\n- `GenericConversionService` 覆盖了大部分 converter 使用场景\n- `ConversionServiceFactory` 提供工厂创建常用 `ConversionService` 。\n\n### .3.7. 配置 `ConversionService`\n\n- 使用默认的 `ConversionServiceFactoryBean` 为容器默认转换器服务，其提供了基础数据转换器（详见 `{@link DefaultConversionService # addDefaultConverters()}`）。\n- 添加自定义转换器\n\n```xml\n<bean id=\"conversionService\"\n        class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n    <property name=\"converters\">\n        <set>\n            <bean class=\"example.MyCustomConverter\"/>\n        </set>\n    </property>\n</bean>\n```\n\n- 使用默认转换复合类型数据（集合转集合）[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API)\n\n```java\nDefaultConversionService cs = new DefaultConversionService();\n\nList<Integer> input = ...\ncs.convert(input,\n    TypeDescriptor.forObject(input), // List<Integer> type descriptor\n    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));\n```\n\n- 使用 `DefaultConversionService` 默认添加各个转换器到 Spring 容器中\n- 添加自定义 Converter 到其中，使用时直接调用 convert 方法，其在添加时是将各个 converter 放入一个指定 map 中，在使用时再 get 到相应的目标 converter 再再使用（这里可以看出来，再复杂的系统设计，最后都回归到了数据结构中）。\n\n_规律：一个工具有多个功能时就可以集成到一个 service 组件中：Converter -> ConverterService。再将一个组件注册到 IoC 容器中，在容器中任何位置自动装配上此组件即可使用。_\n\n## .4. Spring Field Formatting\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#format)\n\nformatting 是 converting 的一个子集。在客户端环境（web 应用或桌面应用），需要将 `String` 与各个类型互转，同时也需要将 String 本地化。这个格式化的过程在 core.convert.Converter SPI 并没有直接解决。Spring 3 中引入 Formatting SPI 提供了可选的 `PropertyEditor`实现来完成格式化。\n\n- `Formatter` 接口实现了 Printer 与 Parser 两个接口。\n\n### .4.1. 注解驱动 Formatting\n\n- `AnnotationFormatterFactory<? extend Annotation>` 实现此接口，使用注解指定类中字段格式化。常用注解所在包： `org.springframework.format.annotation`\n\n### .4.2. 拓展 Formatting 注册\n\n1. 使用 FormatterRegistry SPI，其中可以提供多种类型的 formatter 注册包括注解指定字段、直接指定字段类型，最终 formatter 根据其 parser 与 printer 转换成两个 converter 注册到 conversionService 中\n\n## .5. Spring MVC 中配置序列化与反序列化的 Converter\n\n使用 JSR310 的序列化工具。\n\n### .5.1. 序列化时间类型数据\n\n默认情况下其添加的 jdk8 与 LocalDateTimeSerialize 等序列化工具使用的 formatter 常并不是我们想的结果，这时需要配置自己想要的 formatter。\n\n- jdk time 包 DateTimeFormatter 有具体的构造方法。可直接使用其 Builder 类 ： `DateTimeFormatterBuilder` 。\n    - `ResolveStyle` 指定 DateTime 解析模式：STRICT 严格按照日期来，超出则无效；SMART 智能模式，比如天超过当月最大天就到最大的；LENENT 宽容模式，超出边界也将被转换，比如：月份 15\n    - 指定 pattern ，在 builder 中 addPattern(String pattern) ，方法注释有对详细注释，其中有调用达到指定 pattern 字符等效方法说明。\n    - builder.configure() 中最后将所有的 serializer 与 deserializer 都添加进 new SimpleModule 中，再将 simpleModule 注册到 objectMapper 中（所有的配置数据都会注册入 objectMapper），最后 build 方法即将此 objectMapper 返回供 `AbstractJackson2HttpMessageConverter` 构造（for Spring MVC）使用。\n","slug":"Spring/Validation_databinding_typeConversion","published":1,"updated":"2021-02-24T15:22:22.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckljnokrs002h2bhb52vv2k73","content":"<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">spring reference</a></p>\n<p>Spring 中的 数据验证、数据绑定、类型转换。<span id=\"more\"></span></p>\n<h2 id=\"1-Validation-on-Spring’s-Validator-Interface\"><a href=\"#1-Validation-on-Spring’s-Validator-Interface\" class=\"headerlink\" title=\".1. Validation on Spring’s Validator Interface\"></a>.1. Validation on Spring’s Validator Interface</h2><ul>\n<li>实现接口 Validator ，定义验证各个 POJO 的代码。</li>\n<li>结合 `ValidationUtils 使用</li>\n</ul>\n<h3 id=\"1-1-Configuring-a-Bean-Validation-Provider\"><a href=\"#1-1-Configuring-a-Bean-Validation-Provider\" class=\"headerlink\" title=\".1.1. Configuring a Bean Validation Provider\"></a>.1.1. Configuring a Bean Validation Provider</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation-beanvalidation-overview\">reference</a></p>\n<ul>\n<li><p><code>LocalValidatorFactoryBean</code> 继承了 ValidatorFactory 和 Validator 两个接口，将其注册为一个 Bean。</p>\n</li>\n<li><p>在需要使用验证的 Bean 中注入 Validator 即可。</p>\n</li>\n<li><p>使用 <code>@Constraint</code> 自定义约束，再使用 <code>ConstraintValidator</code> 实现约束行为。</p>\n</li>\n<li><p>Spring 驱动方法验证</p>\n<ul>\n<li><p>整合方法验证直接将 <code>MethodValidationPostProcessor</code> 注册到容器中</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MethodValidationPostProcessor <span class=\"title\">validationPostProcessor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MethodValidationPostProcessor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>目标类必须使用 Spring 的 <code>@Validated</code> 注解，同时目标类依赖 AOP 代理，否则不能正常工作。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-Resolving-Codes-to-Error-Messages\"><a href=\"#1-2-Resolving-Codes-to-Error-Messages\" class=\"headerlink\" title=\".1.2. Resolving Codes to Error Messages\"></a>.1.2. Resolving Codes to Error Messages</h3><ul>\n<li>如果需要使用 <code>MessageSource</code> 输出错误信息，可以使用在拒绝字段时提供的 error code。</li>\n<li><code>MessageCodesResolver</code> 决定 <code>Error</code> 注册哪个 error code 。</li>\n<li>默认解析器 <code>DefaultMessageCodesResolver</code> 不仅注册 reject 时提供的 message 与 code，也包括传递的字段名。</li>\n</ul>\n<h2 id=\"2-Bean-Manipulation-and-the-BeanWrapper\"><a href=\"#2-Bean-Manipulation-and-the-BeanWrapper\" class=\"headerlink\" title=\".2. Bean Manipulation and the BeanWrapper\"></a>.2. Bean Manipulation and the <code>BeanWrapper</code></h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<ul>\n<li><p>Spring 定义一个 <a href=\"https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html\">bean</a> 的原则：一个类有默认的构造器，对于其属性要有其 setter 与 getter 。</p>\n</li>\n<li><p>beans package 中重要的接口 <code>BeanWrapper</code> 提供了访问设置 bean 各种属性的功能。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeanWrapper company = <span class=\"keyword\">new</span> BeanWrapperImpl(<span class=\"keyword\">new</span> Company());</span><br><span class=\"line\"><span class=\"comment\">// setting the company name..</span></span><br><span class=\"line\">company.setPropertyValue(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Some Company Inc.&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// ... can also be done like this:</span></span><br><span class=\"line\">PropertyValue value = <span class=\"keyword\">new</span> PropertyValue(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Some Company Inc.&quot;</span>);</span><br><span class=\"line\">company.setPropertyValue(value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ok, let&#x27;s create the director and tie it to the company:</span></span><br><span class=\"line\">BeanWrapper jim = <span class=\"keyword\">new</span> BeanWrapperImpl(<span class=\"keyword\">new</span> Employee());</span><br><span class=\"line\">jim.setPropertyValue(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Jim Stravinsky&quot;</span>);</span><br><span class=\"line\">company.setPropertyValue(<span class=\"string\">&quot;managingDirector&quot;</span>, jim.getWrappedInstance());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// retrieving the salary of the managingDirector through the company</span></span><br><span class=\"line\">Float salary = (Float) company.getPropertyValue(<span class=\"string\">&quot;managingDirector.salary&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"2-1-Built-in-PropertyEditor-Implements\"><a href=\"#2-1-Built-in-PropertyEditor-Implements\" class=\"headerlink\" title=\".2.1. Built-in PropertyEditor Implements\"></a>.2.1. Built-in <code>PropertyEditor</code> Implements</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<ul>\n<li>Spring 使用 <code>PropertyEditor</code> 的概念来完成 <code>Object</code> 与 <code>String</code> 之间的转换。</li>\n<li>常用使用场景：<ul>\n<li>给 bean 设置 properties。在 xml 给 bean 配置了 class property ，使用 <code>ClassEditor</code> 将 String 转成 Class 对象。</li>\n<li>在 Spring MVC 中使用 <code>PropertyEditor</code> 解析 HTTP 请求参数（可手动绑定 <code>CommandController</code> 所有子类）。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-1-Spring-内置的-PropertyEditor-实现\"><a href=\"#2-1-1-Spring-内置的-PropertyEditor-实现\" class=\"headerlink\" title=\".2.1.1. Spring 内置的 PropertyEditor 实现\"></a>.2.1.1. Spring 内置的 <code>PropertyEditor</code> 实现</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<p>其中有默认注册为 <code>BeanWrapperImpl</code> ，Spring 将自动使用这些组件实现 String 与 各个 type 的转换。</p>\n<h4 id=\"2-1-2-注册自定义-PropertyEditor\"><a href=\"#2-1-2-注册自定义-PropertyEditor\" class=\"headerlink\" title=\".2.1.2. 注册自定义 PropertyEditor\"></a>.2.1.2. 注册自定义 <code>PropertyEditor</code></h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<p>两种注册方式：</p>\n<ol>\n<li>当有获取到 BeanFactory reference 时，使用 ConfigurableBeanFactory 其 <code>registerCustomEditor()</code> 方法将自定义的 PropertyEditor 注册进来（不推荐）。</li>\n<li>使用名为 <code>CustomEditorConfigurer</code> 的 bean factory post-processor，可使用注册 bean 方式注册，可设置其内置属性。</li>\n</ol>\n<ul>\n<li><p>实现一个 PropertyEditor</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExoticTypeEditor</span> <span class=\"keyword\">extends</span> <span class=\"title\">PropertyEditorSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAsText</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">        setValue(<span class=\"keyword\">new</span> ExoticType(text.toUpperCase()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将 editor 注册到配置器中</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;customEditors&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;example.ExoticType&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;example.ExoticTypeEditor&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-1-2-1-使用-PropertyEditorRegistrar\"><a href=\"#2-1-2-1-使用-PropertyEditorRegistrar\" class=\"headerlink\" title=\".2.1.2.1. 使用 PropertyEditorRegistrar\"></a>.2.1.2.1. 使用 <code>PropertyEditorRegistrar</code></h5><ul>\n<li>在不同场景需要使用同一系列的 editor 时更适合此注册器。</li>\n<li>与接口 <code>CustomEditorConfigurer</code> 连用，将 PropertyEditorRegistrar 实例注册到 CustomerEditorConfigurer 中，editor 可轻松地共享到 <code>DataBinder</code> 与 Spring MVC Controller。同时，这样操作在每次调用 PropertyEditor 时都创建一个新的实例，而避免了同步。</li>\n</ul>\n<h2 id=\"3-Spring-Type-Conversion\"><a href=\"#3-Spring-Type-Conversion\" class=\"headerlink\" title=\".3. Spring Type Conversion\"></a>.3. Spring Type Conversion</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beans-conversion-customeditor-registration\">reference</a></p>\n<h3 id=\"3-1-Converter-SPI\"><a href=\"#3-1-Converter-SPI\" class=\"headerlink\" title=\".3.1. Converter SPI\"></a>.3.1. Converter SPI</h3><ul>\n<li>函数式接口， <code>Converter&lt;S, T&gt;</code></li>\n</ul>\n<h3 id=\"3-2-ConverterFactory\"><a href=\"#3-2-ConverterFactory\" class=\"headerlink\" title=\".3.2. ConverterFactory\"></a>.3.2. ConverterFactory</h3><ul>\n<li>使用 <code>ConverterFactory&lt;S, R&gt;</code> 可以实现提供将一个类型转换成多个类型的 不同的转换器。</li>\n</ul>\n<h3 id=\"3-3-GenericConverter\"><a href=\"#3-3-GenericConverter\" class=\"headerlink\" title=\".3.3. GenericConverter\"></a>.3.3. GenericConverter</h3><p>相对于 Converter 提供了更复杂灵活的转换功能。针对转换多个目标 类型。</p>\n<h3 id=\"3-4-ConditionalGenericConverter\"><a href=\"#3-4-ConditionalGenericConverter\" class=\"headerlink\" title=\".3.4. ConditionalGenericConverter\"></a>.3.4. ConditionalGenericConverter</h3><ul>\n<li>联合了 <code>GenericConverter</code> 和 <code>ConditionalConverter</code> 两个接口而成，可以指定目标字段进行转换。</li>\n<li>可以给 GenericConverter 加上条件，指定允许哪些转换，哪些不允许；</li>\n</ul>\n<h3 id=\"3-5-Formatting\"><a href=\"#3-5-Formatting\" class=\"headerlink\" title=\".3.5. Formatting\"></a>.3.5. Formatting</h3><h3 id=\"3-6-The-ConversionService-API\"><a href=\"#3-6-The-ConversionService-API\" class=\"headerlink\" title=\".3.6. The ConversionService API\"></a>.3.6. The <code>ConversionService</code> API</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API\">reference</a></p>\n<ul>\n<li>大部分 <code>ConversionService</code> 实现了 <code>ConverterRegistry</code> ，这就提供了注册 Converter 的 SPI。内部实现将 conversion 工作委托给注册的 converter 。</li>\n<li><code>GenericConversionService</code> 覆盖了大部分 converter 使用场景</li>\n<li><code>ConversionServiceFactory</code> 提供工厂创建常用 <code>ConversionService</code> 。</li>\n</ul>\n<h3 id=\"3-7-配置-ConversionService\"><a href=\"#3-7-配置-ConversionService\" class=\"headerlink\" title=\".3.7. 配置 ConversionService\"></a>.3.7. 配置 <code>ConversionService</code></h3><ul>\n<li>使用默认的 <code>ConversionServiceFactoryBean</code> 为容器默认转换器服务，其提供了基础数据转换器（详见 <code>&#123;@link DefaultConversionService # addDefaultConverters()&#125;</code>）。</li>\n<li>添加自定义转换器</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;conversionService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;converters&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;example.MyCustomConverter&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用默认转换复合类型数据（集合转集合）<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API\">reference</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultConversionService cs = <span class=\"keyword\">new</span> DefaultConversionService();</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Integer&gt; input = ...</span><br><span class=\"line\">cs.convert(input,</span><br><span class=\"line\">    TypeDescriptor.forObject(input), <span class=\"comment\">// List&lt;Integer&gt; type descriptor</span></span><br><span class=\"line\">    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>DefaultConversionService</code> 默认添加各个转换器到 Spring 容器中</li>\n<li>添加自定义 Converter 到其中，使用时直接调用 convert 方法，其在添加时是将各个 converter 放入一个指定 map 中，在使用时再 get 到相应的目标 converter 再再使用（这里可以看出来，再复杂的系统设计，最后都回归到了数据结构中）。</li>\n</ul>\n<p><em>规律：一个工具有多个功能时就可以集成到一个 service 组件中：Converter -&gt; ConverterService。再将一个组件注册到 IoC 容器中，在容器中任何位置自动装配上此组件即可使用。</em></p>\n<h2 id=\"4-Spring-Field-Formatting\"><a href=\"#4-Spring-Field-Formatting\" class=\"headerlink\" title=\".4. Spring Field Formatting\"></a>.4. Spring Field Formatting</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#format\">reference</a></p>\n<p>formatting 是 converting 的一个子集。在客户端环境（web 应用或桌面应用），需要将 <code>String</code> 与各个类型互转，同时也需要将 String 本地化。这个格式化的过程在 core.convert.Converter SPI 并没有直接解决。Spring 3 中引入 Formatting SPI 提供了可选的 <code>PropertyEditor</code>实现来完成格式化。</p>\n<ul>\n<li><code>Formatter</code> 接口实现了 Printer 与 Parser 两个接口。</li>\n</ul>\n<h3 id=\"4-1-注解驱动-Formatting\"><a href=\"#4-1-注解驱动-Formatting\" class=\"headerlink\" title=\".4.1. 注解驱动 Formatting\"></a>.4.1. 注解驱动 Formatting</h3><ul>\n<li><code>AnnotationFormatterFactory&lt;? extend Annotation&gt;</code> 实现此接口，使用注解指定类中字段格式化。常用注解所在包： <code>org.springframework.format.annotation</code></li>\n</ul>\n<h3 id=\"4-2-拓展-Formatting-注册\"><a href=\"#4-2-拓展-Formatting-注册\" class=\"headerlink\" title=\".4.2. 拓展 Formatting 注册\"></a>.4.2. 拓展 Formatting 注册</h3><ol>\n<li>使用 FormatterRegistry SPI，其中可以提供多种类型的 formatter 注册包括注解指定字段、直接指定字段类型，最终 formatter 根据其 parser 与 printer 转换成两个 converter 注册到 conversionService 中</li>\n</ol>\n<h2 id=\"5-Spring-MVC-中配置序列化与反序列化的-Converter\"><a href=\"#5-Spring-MVC-中配置序列化与反序列化的-Converter\" class=\"headerlink\" title=\".5. Spring MVC 中配置序列化与反序列化的 Converter\"></a>.5. Spring MVC 中配置序列化与反序列化的 Converter</h2><p>使用 JSR310 的序列化工具。</p>\n<h3 id=\"5-1-序列化时间类型数据\"><a href=\"#5-1-序列化时间类型数据\" class=\"headerlink\" title=\".5.1. 序列化时间类型数据\"></a>.5.1. 序列化时间类型数据</h3><p>默认情况下其添加的 jdk8 与 LocalDateTimeSerialize 等序列化工具使用的 formatter 常并不是我们想的结果，这时需要配置自己想要的 formatter。</p>\n<ul>\n<li>jdk time 包 DateTimeFormatter 有具体的构造方法。可直接使用其 Builder 类 ： <code>DateTimeFormatterBuilder</code> 。<ul>\n<li><code>ResolveStyle</code> 指定 DateTime 解析模式：STRICT 严格按照日期来，超出则无效；SMART 智能模式，比如天超过当月最大天就到最大的；LENENT 宽容模式，超出边界也将被转换，比如：月份 15</li>\n<li>指定 pattern ，在 builder 中 addPattern(String pattern) ，方法注释有对详细注释，其中有调用达到指定 pattern 字符等效方法说明。</li>\n<li>builder.configure() 中最后将所有的 serializer 与 deserializer 都添加进 new SimpleModule 中，再将 simpleModule 注册到 objectMapper 中（所有的配置数据都会注册入 objectMapper），最后 build 方法即将此 objectMapper 返回供 <code>AbstractJackson2HttpMessageConverter</code> 构造（for Spring MVC）使用。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">spring reference</a></p>\n<p>Spring 中的 数据验证、数据绑定、类型转换。","more":"</p>\n<h2 id=\"1-Validation-on-Spring’s-Validator-Interface\"><a href=\"#1-Validation-on-Spring’s-Validator-Interface\" class=\"headerlink\" title=\".1. Validation on Spring’s Validator Interface\"></a>.1. Validation on Spring’s Validator Interface</h2><ul>\n<li>实现接口 Validator ，定义验证各个 POJO 的代码。</li>\n<li>结合 `ValidationUtils 使用</li>\n</ul>\n<h3 id=\"1-1-Configuring-a-Bean-Validation-Provider\"><a href=\"#1-1-Configuring-a-Bean-Validation-Provider\" class=\"headerlink\" title=\".1.1. Configuring a Bean Validation Provider\"></a>.1.1. Configuring a Bean Validation Provider</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation-beanvalidation-overview\">reference</a></p>\n<ul>\n<li><p><code>LocalValidatorFactoryBean</code> 继承了 ValidatorFactory 和 Validator 两个接口，将其注册为一个 Bean。</p>\n</li>\n<li><p>在需要使用验证的 Bean 中注入 Validator 即可。</p>\n</li>\n<li><p>使用 <code>@Constraint</code> 自定义约束，再使用 <code>ConstraintValidator</code> 实现约束行为。</p>\n</li>\n<li><p>Spring 驱动方法验证</p>\n<ul>\n<li><p>整合方法验证直接将 <code>MethodValidationPostProcessor</code> 注册到容器中</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MethodValidationPostProcessor <span class=\"title\">validationPostProcessor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MethodValidationPostProcessor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>目标类必须使用 Spring 的 <code>@Validated</code> 注解，同时目标类依赖 AOP 代理，否则不能正常工作。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-Resolving-Codes-to-Error-Messages\"><a href=\"#1-2-Resolving-Codes-to-Error-Messages\" class=\"headerlink\" title=\".1.2. Resolving Codes to Error Messages\"></a>.1.2. Resolving Codes to Error Messages</h3><ul>\n<li>如果需要使用 <code>MessageSource</code> 输出错误信息，可以使用在拒绝字段时提供的 error code。</li>\n<li><code>MessageCodesResolver</code> 决定 <code>Error</code> 注册哪个 error code 。</li>\n<li>默认解析器 <code>DefaultMessageCodesResolver</code> 不仅注册 reject 时提供的 message 与 code，也包括传递的字段名。</li>\n</ul>\n<h2 id=\"2-Bean-Manipulation-and-the-BeanWrapper\"><a href=\"#2-Bean-Manipulation-and-the-BeanWrapper\" class=\"headerlink\" title=\".2. Bean Manipulation and the BeanWrapper\"></a>.2. Bean Manipulation and the <code>BeanWrapper</code></h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<ul>\n<li><p>Spring 定义一个 <a href=\"https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html\">bean</a> 的原则：一个类有默认的构造器，对于其属性要有其 setter 与 getter 。</p>\n</li>\n<li><p>beans package 中重要的接口 <code>BeanWrapper</code> 提供了访问设置 bean 各种属性的功能。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeanWrapper company = <span class=\"keyword\">new</span> BeanWrapperImpl(<span class=\"keyword\">new</span> Company());</span><br><span class=\"line\"><span class=\"comment\">// setting the company name..</span></span><br><span class=\"line\">company.setPropertyValue(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Some Company Inc.&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// ... can also be done like this:</span></span><br><span class=\"line\">PropertyValue value = <span class=\"keyword\">new</span> PropertyValue(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Some Company Inc.&quot;</span>);</span><br><span class=\"line\">company.setPropertyValue(value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ok, let&#x27;s create the director and tie it to the company:</span></span><br><span class=\"line\">BeanWrapper jim = <span class=\"keyword\">new</span> BeanWrapperImpl(<span class=\"keyword\">new</span> Employee());</span><br><span class=\"line\">jim.setPropertyValue(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Jim Stravinsky&quot;</span>);</span><br><span class=\"line\">company.setPropertyValue(<span class=\"string\">&quot;managingDirector&quot;</span>, jim.getWrappedInstance());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// retrieving the salary of the managingDirector through the company</span></span><br><span class=\"line\">Float salary = (Float) company.getPropertyValue(<span class=\"string\">&quot;managingDirector.salary&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"2-1-Built-in-PropertyEditor-Implements\"><a href=\"#2-1-Built-in-PropertyEditor-Implements\" class=\"headerlink\" title=\".2.1. Built-in PropertyEditor Implements\"></a>.2.1. Built-in <code>PropertyEditor</code> Implements</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<ul>\n<li>Spring 使用 <code>PropertyEditor</code> 的概念来完成 <code>Object</code> 与 <code>String</code> 之间的转换。</li>\n<li>常用使用场景：<ul>\n<li>给 bean 设置 properties。在 xml 给 bean 配置了 class property ，使用 <code>ClassEditor</code> 将 String 转成 Class 对象。</li>\n<li>在 Spring MVC 中使用 <code>PropertyEditor</code> 解析 HTTP 请求参数（可手动绑定 <code>CommandController</code> 所有子类）。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-1-Spring-内置的-PropertyEditor-实现\"><a href=\"#2-1-1-Spring-内置的-PropertyEditor-实现\" class=\"headerlink\" title=\".2.1.1. Spring 内置的 PropertyEditor 实现\"></a>.2.1.1. Spring 内置的 <code>PropertyEditor</code> 实现</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<p>其中有默认注册为 <code>BeanWrapperImpl</code> ，Spring 将自动使用这些组件实现 String 与 各个 type 的转换。</p>\n<h4 id=\"2-1-2-注册自定义-PropertyEditor\"><a href=\"#2-1-2-注册自定义-PropertyEditor\" class=\"headerlink\" title=\".2.1.2. 注册自定义 PropertyEditor\"></a>.2.1.2. 注册自定义 <code>PropertyEditor</code></h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation\">reference</a></p>\n<p>两种注册方式：</p>\n<ol>\n<li>当有获取到 BeanFactory reference 时，使用 ConfigurableBeanFactory 其 <code>registerCustomEditor()</code> 方法将自定义的 PropertyEditor 注册进来（不推荐）。</li>\n<li>使用名为 <code>CustomEditorConfigurer</code> 的 bean factory post-processor，可使用注册 bean 方式注册，可设置其内置属性。</li>\n</ol>\n<ul>\n<li><p>实现一个 PropertyEditor</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExoticTypeEditor</span> <span class=\"keyword\">extends</span> <span class=\"title\">PropertyEditorSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAsText</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">        setValue(<span class=\"keyword\">new</span> ExoticType(text.toUpperCase()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将 editor 注册到配置器中</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;customEditors&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;example.ExoticType&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;example.ExoticTypeEditor&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-1-2-1-使用-PropertyEditorRegistrar\"><a href=\"#2-1-2-1-使用-PropertyEditorRegistrar\" class=\"headerlink\" title=\".2.1.2.1. 使用 PropertyEditorRegistrar\"></a>.2.1.2.1. 使用 <code>PropertyEditorRegistrar</code></h5><ul>\n<li>在不同场景需要使用同一系列的 editor 时更适合此注册器。</li>\n<li>与接口 <code>CustomEditorConfigurer</code> 连用，将 PropertyEditorRegistrar 实例注册到 CustomerEditorConfigurer 中，editor 可轻松地共享到 <code>DataBinder</code> 与 Spring MVC Controller。同时，这样操作在每次调用 PropertyEditor 时都创建一个新的实例，而避免了同步。</li>\n</ul>\n<h2 id=\"3-Spring-Type-Conversion\"><a href=\"#3-Spring-Type-Conversion\" class=\"headerlink\" title=\".3. Spring Type Conversion\"></a>.3. Spring Type Conversion</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beans-conversion-customeditor-registration\">reference</a></p>\n<h3 id=\"3-1-Converter-SPI\"><a href=\"#3-1-Converter-SPI\" class=\"headerlink\" title=\".3.1. Converter SPI\"></a>.3.1. Converter SPI</h3><ul>\n<li>函数式接口， <code>Converter&lt;S, T&gt;</code></li>\n</ul>\n<h3 id=\"3-2-ConverterFactory\"><a href=\"#3-2-ConverterFactory\" class=\"headerlink\" title=\".3.2. ConverterFactory\"></a>.3.2. ConverterFactory</h3><ul>\n<li>使用 <code>ConverterFactory&lt;S, R&gt;</code> 可以实现提供将一个类型转换成多个类型的 不同的转换器。</li>\n</ul>\n<h3 id=\"3-3-GenericConverter\"><a href=\"#3-3-GenericConverter\" class=\"headerlink\" title=\".3.3. GenericConverter\"></a>.3.3. GenericConverter</h3><p>相对于 Converter 提供了更复杂灵活的转换功能。针对转换多个目标 类型。</p>\n<h3 id=\"3-4-ConditionalGenericConverter\"><a href=\"#3-4-ConditionalGenericConverter\" class=\"headerlink\" title=\".3.4. ConditionalGenericConverter\"></a>.3.4. ConditionalGenericConverter</h3><ul>\n<li>联合了 <code>GenericConverter</code> 和 <code>ConditionalConverter</code> 两个接口而成，可以指定目标字段进行转换。</li>\n<li>可以给 GenericConverter 加上条件，指定允许哪些转换，哪些不允许；</li>\n</ul>\n<h3 id=\"3-5-Formatting\"><a href=\"#3-5-Formatting\" class=\"headerlink\" title=\".3.5. Formatting\"></a>.3.5. Formatting</h3><h3 id=\"3-6-The-ConversionService-API\"><a href=\"#3-6-The-ConversionService-API\" class=\"headerlink\" title=\".3.6. The ConversionService API\"></a>.3.6. The <code>ConversionService</code> API</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API\">reference</a></p>\n<ul>\n<li>大部分 <code>ConversionService</code> 实现了 <code>ConverterRegistry</code> ，这就提供了注册 Converter 的 SPI。内部实现将 conversion 工作委托给注册的 converter 。</li>\n<li><code>GenericConversionService</code> 覆盖了大部分 converter 使用场景</li>\n<li><code>ConversionServiceFactory</code> 提供工厂创建常用 <code>ConversionService</code> 。</li>\n</ul>\n<h3 id=\"3-7-配置-ConversionService\"><a href=\"#3-7-配置-ConversionService\" class=\"headerlink\" title=\".3.7. 配置 ConversionService\"></a>.3.7. 配置 <code>ConversionService</code></h3><ul>\n<li>使用默认的 <code>ConversionServiceFactoryBean</code> 为容器默认转换器服务，其提供了基础数据转换器（详见 <code>&#123;@link DefaultConversionService # addDefaultConverters()&#125;</code>）。</li>\n<li>添加自定义转换器</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;conversionService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;converters&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;example.MyCustomConverter&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用默认转换复合类型数据（集合转集合）<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API\">reference</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultConversionService cs = <span class=\"keyword\">new</span> DefaultConversionService();</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Integer&gt; input = ...</span><br><span class=\"line\">cs.convert(input,</span><br><span class=\"line\">    TypeDescriptor.forObject(input), <span class=\"comment\">// List&lt;Integer&gt; type descriptor</span></span><br><span class=\"line\">    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>DefaultConversionService</code> 默认添加各个转换器到 Spring 容器中</li>\n<li>添加自定义 Converter 到其中，使用时直接调用 convert 方法，其在添加时是将各个 converter 放入一个指定 map 中，在使用时再 get 到相应的目标 converter 再再使用（这里可以看出来，再复杂的系统设计，最后都回归到了数据结构中）。</li>\n</ul>\n<p><em>规律：一个工具有多个功能时就可以集成到一个 service 组件中：Converter -&gt; ConverterService。再将一个组件注册到 IoC 容器中，在容器中任何位置自动装配上此组件即可使用。</em></p>\n<h2 id=\"4-Spring-Field-Formatting\"><a href=\"#4-Spring-Field-Formatting\" class=\"headerlink\" title=\".4. Spring Field Formatting\"></a>.4. Spring Field Formatting</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#format\">reference</a></p>\n<p>formatting 是 converting 的一个子集。在客户端环境（web 应用或桌面应用），需要将 <code>String</code> 与各个类型互转，同时也需要将 String 本地化。这个格式化的过程在 core.convert.Converter SPI 并没有直接解决。Spring 3 中引入 Formatting SPI 提供了可选的 <code>PropertyEditor</code>实现来完成格式化。</p>\n<ul>\n<li><code>Formatter</code> 接口实现了 Printer 与 Parser 两个接口。</li>\n</ul>\n<h3 id=\"4-1-注解驱动-Formatting\"><a href=\"#4-1-注解驱动-Formatting\" class=\"headerlink\" title=\".4.1. 注解驱动 Formatting\"></a>.4.1. 注解驱动 Formatting</h3><ul>\n<li><code>AnnotationFormatterFactory&lt;? extend Annotation&gt;</code> 实现此接口，使用注解指定类中字段格式化。常用注解所在包： <code>org.springframework.format.annotation</code></li>\n</ul>\n<h3 id=\"4-2-拓展-Formatting-注册\"><a href=\"#4-2-拓展-Formatting-注册\" class=\"headerlink\" title=\".4.2. 拓展 Formatting 注册\"></a>.4.2. 拓展 Formatting 注册</h3><ol>\n<li>使用 FormatterRegistry SPI，其中可以提供多种类型的 formatter 注册包括注解指定字段、直接指定字段类型，最终 formatter 根据其 parser 与 printer 转换成两个 converter 注册到 conversionService 中</li>\n</ol>\n<h2 id=\"5-Spring-MVC-中配置序列化与反序列化的-Converter\"><a href=\"#5-Spring-MVC-中配置序列化与反序列化的-Converter\" class=\"headerlink\" title=\".5. Spring MVC 中配置序列化与反序列化的 Converter\"></a>.5. Spring MVC 中配置序列化与反序列化的 Converter</h2><p>使用 JSR310 的序列化工具。</p>\n<h3 id=\"5-1-序列化时间类型数据\"><a href=\"#5-1-序列化时间类型数据\" class=\"headerlink\" title=\".5.1. 序列化时间类型数据\"></a>.5.1. 序列化时间类型数据</h3><p>默认情况下其添加的 jdk8 与 LocalDateTimeSerialize 等序列化工具使用的 formatter 常并不是我们想的结果，这时需要配置自己想要的 formatter。</p>\n<ul>\n<li>jdk time 包 DateTimeFormatter 有具体的构造方法。可直接使用其 Builder 类 ： <code>DateTimeFormatterBuilder</code> 。<ul>\n<li><code>ResolveStyle</code> 指定 DateTime 解析模式：STRICT 严格按照日期来，超出则无效；SMART 智能模式，比如天超过当月最大天就到最大的；LENENT 宽容模式，超出边界也将被转换，比如：月份 15</li>\n<li>指定 pattern ，在 builder 中 addPattern(String pattern) ，方法注释有对详细注释，其中有调用达到指定 pattern 字符等效方法说明。</li>\n<li>builder.configure() 中最后将所有的 serializer 与 deserializer 都添加进 new SimpleModule 中，再将 simpleModule 注册到 objectMapper 中（所有的配置数据都会注册入 objectMapper），最后 build 方法即将此 objectMapper 返回供 <code>AbstractJackson2HttpMessageConverter</code> 构造（for Spring MVC）使用。</li>\n</ul>\n</li>\n</ul>"},{"layout":"post","title":"Resources in Spring","date":"2020-04-10T04:14:38.000Z","description":"spring boot","_content":"\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-scoop-cli-installation)\n\n安装 spring CLI(command line interface)，后再运行本地 groovy 文件。<!--more-->\n\n## .1. spring boot 的简化处理\n\n1. 将所有依赖都写入其基本配置中，最大简化其配置；\n2. 自动扫描，一个注解自动识别所有的需要扫描的包与 bean；\n3. `@RestController` 指定此类为一个特殊处理器， spring 会识到并用来处理网络请求；\n4. `@RequestMapping` 提供 “路由” 信息给 spring ，spring 也会对处理结果进行渲染返回给调用者；\n5. `@EnableAutoConfiguration` 有这个注解 spring boot 会主动根据 pom 文件引入的依赖为你配置，eg: pom 中配置了 `spring-boot-starter-web` , spring boot 会假设工程是一个 web 应用并为其添加相应的依赖。\n6. `@ComponentScan` 自动扫描包中的 spring 组件。\n7. `@Configuration` 相当于 spring bean 的容器，也可以外部的 bean 或配置组件导入。\n8. `@SpringBootApplication` 声明 spring boot 入口，拥有的功能相当于 `@EnableAutoConfiguration` `@Configuration` `@ComponentScan` 三者之和。同时， spring boot 的入口类最好放在包根路径下，因为组件扫描时时会隐式地将此注解所在类定义为 search package 。`@SpringBootApplication` 和 `@EnableAutoConfiguration` 永远只添加一个，一般建议选择任意一个添加到主 `@Configuration` 类上。\n9. 组件导入\n   1. 建议使用 `@Configuration` java 组件， `@Import` 可用来将其他组件导入，也可以使用 `@ComponentScan` 自动扫描所有的 spring 组件，包括 `@Configuration` 配置组件\n   2. 如果非要使用 xml 配置，使用 `@ImportResource`\n\n### .1.1. create an executable jar\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application-dependencies)\n\n[build spring boot on maven](https://docs.spring.io/spring-boot/docs/2.3.2.BUILD-SNAPSHOT/maven-plugin/reference/html/)\n\n对于一个工程来说依赖各个 jar 包，而 java 并没有提供一个标准的方式去加载内嵌的 jar ，因此不能发布一个独立的程序包。\n\n为此，很多开发者的解决方案是创建一个 'uber' jar，所谓 uber jar 是指将应用所有的依赖的 class 文件整合成一个单独的包。这样做的问题在于：1、 难以查看依赖库；2、不同 jar 包中要是存在同名的 class 就会出现问题。\n\nspring boot 使用了不同的方式达到直接使用内嵌包。\n\n1. 打包： `mvn package`\n2. 查看 jar 包内打包文件 `mvn tvf jar_file`\n3. pom 中 groupid `org.springframework.boot`\n4. 指定打包为可执行 jar 包的插件\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n## .2. how to series\n\n[spring boot HOWTO 系列](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-properties-and-configuration)\n\n[设置 spring 项目 profile](https://stackoverflow.com/questions/38520638/how-to-set-spring-profile-from-system-variable)\n\n### .2.1. spring 项目中使用 profile\n\n[spring 项目 profile](https://www.baeldung.com/spring-profiles)\n\n用以指定当前运行环境，可以 maven 打包时也可以设置针对环境打包。\n\n获取当前活跃的 profile ，参考 `6. Get Active Profiles`\n\n## .3. Structuring Code\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-structuring-your-code)\n\n### .3.1. Locating the Main Application Class\n\n- 在根目录添加 Application.class 主类放在根目录上，使用 `@SpringBootApplication` 注解在主类上。此注解也隐匿地定义了某些特定项目的基础查找包 `base search package` 。_如果在root package 定义多个 application.class 打包发布时会认定哪个为项目入口呢？_亲测结果：`spring-boot-maven-plugin:2.3.1.RELEASE:repackage failed: Unable to find a single main class from the following candidates` 打包插件将报出不能找到唯一的主类异常\n- 若不使用 `@SpringBootApplication` 注解，可以使用 `@EnableAutoConfiguration` `@ComponentScan` 两个注解实现相同功能\n\n### .3.2. Auto-configuration\n\n> 自动配置\n\n- 使用 `@EnableAutoConfiguration` 后，spring boot 会检测 classpath 所有的内容进行自动添加配置。\n- 可以在运行时加上 --debug 进入 debug 模式查看自动配置了哪些东西。\n- 应该逐渐用特定的配置代替自动配置。\n- 若 spring boot 自动配置了不需要的配置，可以在 `@SpringBootApplication` 或 `@EnableAutoConfiguration` 添加排除 exclude ，若排除的类不在 classpath 中可以指定其全限定名到 `excludename`。也可以添加配置 `spring.autoconfigure.exclude` 指定自动配置排除配置。\n\n### .3.3. Spring Beans and Dependency Injection\n\n- spring 中的 bean 注入：使用构造器注入 `private final Dependency d;` 使用 final 修辞字段让其不能被修改。\n\n### .3.4. Using the @SpringBootApplication Annotation\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-spring-beans-and-dependency-injection)\n\n@SpringBootApplication 注解有三个特性，分别对应三个注解：\n\n1. @EnableAutoConfiguration\n2. @ComponentScan\n3. @Configuration\n\n@SpringBootApplication 提供别名以实现定义以上前两个注解的功能。\n\n## .4. Developer Tools\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-devtools)\n\n添加 spring-boot-devtools 依赖，实现热启动。其实现原理是固有的jar包代码使用一个固定的 classloader，而开发变动的代码使用另一个classloader，当发生变动时，重启一个 classloader 加载新的编译的代码。所以热启动相对冷启动要快些，因为其不用加载旧的不变的依赖的jar包中的代码。\n\n- 使用 trigger-file 触发项目重启。`spring.devtools.restart.trigger-file=<.reloadtrigger>` 手动更新了 trigger 文件才会触发更新。trigger 文件可以自定义在 classpath 中任意地方，而配置文件指定配置文件不需要全限定名，更新代码后只需要修改保存一下trigger文件即可触发reload。\n- 如果使用了Ultimate Edition IDEA 可以点击 relauch 触发重启。\n- 生产模式下devtool 自动关闭，如果项目启动通过 java -jar 运行一个包或从一个特定的 classloader 中开始，devtools 将自动识别在生产模式中。如果应用在窗口中开启需要排除 devtools 或者直接添加系统参数 `-Dspring.devtools.restart.enabled=false`。\n\n## .5. Source Code\n\nSpring Boot 源码\n\n### .5.1. 单例 bean 注册器中 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry\n\n- dependentBeanMap 注释 `Map between dependent bean names: bean name to Set of dependent bean names.` 表示 bean 与依赖此 bean 的映射 map 。\n- dependenciesForBeanMap `Map between depending bean names: bean name to Set of bean names for the bean's dependencies.` 表示 bean 与 此 bean 依赖的 bean 的映射关系集合。\n    - 上述结论来自方法 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registerDependentBean 及其注释说明。同时可以从自动装配方法 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireByType line:1511 推导：解析本bean 自动装配的依赖 autowiredBeanNames 出后，在注册处调用方法 line:1516 参数是本 bean 依赖 autowiredBeanName 为第一个参数，而本 beanName 是第二个参数（这时的依赖关系是： 本bean 依赖 autowiredBean）。再看此 registerDependentBean 方法，其执行是将第一个参数 beanName（此时就是本 bean 的依赖bean） 放入了 dependenciesForBeanMap 而 本 beanName 作为 了第二个参数 放入了 dependentBeanMap 。\n- CGLIB 策略生成子类创建 bean: org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass\n","source":"_posts/Spring/spring boot.md","raw":"---\nlayout: post\ntitle: \"Resources in Spring\"\ndate: 2020-04-10 12:14:38\ntags: [framework,java,spring boot]\ncategories: [Mysql]\ndescription: spring boot\n---\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-scoop-cli-installation)\n\n安装 spring CLI(command line interface)，后再运行本地 groovy 文件。<!--more-->\n\n## .1. spring boot 的简化处理\n\n1. 将所有依赖都写入其基本配置中，最大简化其配置；\n2. 自动扫描，一个注解自动识别所有的需要扫描的包与 bean；\n3. `@RestController` 指定此类为一个特殊处理器， spring 会识到并用来处理网络请求；\n4. `@RequestMapping` 提供 “路由” 信息给 spring ，spring 也会对处理结果进行渲染返回给调用者；\n5. `@EnableAutoConfiguration` 有这个注解 spring boot 会主动根据 pom 文件引入的依赖为你配置，eg: pom 中配置了 `spring-boot-starter-web` , spring boot 会假设工程是一个 web 应用并为其添加相应的依赖。\n6. `@ComponentScan` 自动扫描包中的 spring 组件。\n7. `@Configuration` 相当于 spring bean 的容器，也可以外部的 bean 或配置组件导入。\n8. `@SpringBootApplication` 声明 spring boot 入口，拥有的功能相当于 `@EnableAutoConfiguration` `@Configuration` `@ComponentScan` 三者之和。同时， spring boot 的入口类最好放在包根路径下，因为组件扫描时时会隐式地将此注解所在类定义为 search package 。`@SpringBootApplication` 和 `@EnableAutoConfiguration` 永远只添加一个，一般建议选择任意一个添加到主 `@Configuration` 类上。\n9. 组件导入\n   1. 建议使用 `@Configuration` java 组件， `@Import` 可用来将其他组件导入，也可以使用 `@ComponentScan` 自动扫描所有的 spring 组件，包括 `@Configuration` 配置组件\n   2. 如果非要使用 xml 配置，使用 `@ImportResource`\n\n### .1.1. create an executable jar\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application-dependencies)\n\n[build spring boot on maven](https://docs.spring.io/spring-boot/docs/2.3.2.BUILD-SNAPSHOT/maven-plugin/reference/html/)\n\n对于一个工程来说依赖各个 jar 包，而 java 并没有提供一个标准的方式去加载内嵌的 jar ，因此不能发布一个独立的程序包。\n\n为此，很多开发者的解决方案是创建一个 'uber' jar，所谓 uber jar 是指将应用所有的依赖的 class 文件整合成一个单独的包。这样做的问题在于：1、 难以查看依赖库；2、不同 jar 包中要是存在同名的 class 就会出现问题。\n\nspring boot 使用了不同的方式达到直接使用内嵌包。\n\n1. 打包： `mvn package`\n2. 查看 jar 包内打包文件 `mvn tvf jar_file`\n3. pom 中 groupid `org.springframework.boot`\n4. 指定打包为可执行 jar 包的插件\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n## .2. how to series\n\n[spring boot HOWTO 系列](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-properties-and-configuration)\n\n[设置 spring 项目 profile](https://stackoverflow.com/questions/38520638/how-to-set-spring-profile-from-system-variable)\n\n### .2.1. spring 项目中使用 profile\n\n[spring 项目 profile](https://www.baeldung.com/spring-profiles)\n\n用以指定当前运行环境，可以 maven 打包时也可以设置针对环境打包。\n\n获取当前活跃的 profile ，参考 `6. Get Active Profiles`\n\n## .3. Structuring Code\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-structuring-your-code)\n\n### .3.1. Locating the Main Application Class\n\n- 在根目录添加 Application.class 主类放在根目录上，使用 `@SpringBootApplication` 注解在主类上。此注解也隐匿地定义了某些特定项目的基础查找包 `base search package` 。_如果在root package 定义多个 application.class 打包发布时会认定哪个为项目入口呢？_亲测结果：`spring-boot-maven-plugin:2.3.1.RELEASE:repackage failed: Unable to find a single main class from the following candidates` 打包插件将报出不能找到唯一的主类异常\n- 若不使用 `@SpringBootApplication` 注解，可以使用 `@EnableAutoConfiguration` `@ComponentScan` 两个注解实现相同功能\n\n### .3.2. Auto-configuration\n\n> 自动配置\n\n- 使用 `@EnableAutoConfiguration` 后，spring boot 会检测 classpath 所有的内容进行自动添加配置。\n- 可以在运行时加上 --debug 进入 debug 模式查看自动配置了哪些东西。\n- 应该逐渐用特定的配置代替自动配置。\n- 若 spring boot 自动配置了不需要的配置，可以在 `@SpringBootApplication` 或 `@EnableAutoConfiguration` 添加排除 exclude ，若排除的类不在 classpath 中可以指定其全限定名到 `excludename`。也可以添加配置 `spring.autoconfigure.exclude` 指定自动配置排除配置。\n\n### .3.3. Spring Beans and Dependency Injection\n\n- spring 中的 bean 注入：使用构造器注入 `private final Dependency d;` 使用 final 修辞字段让其不能被修改。\n\n### .3.4. Using the @SpringBootApplication Annotation\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-spring-beans-and-dependency-injection)\n\n@SpringBootApplication 注解有三个特性，分别对应三个注解：\n\n1. @EnableAutoConfiguration\n2. @ComponentScan\n3. @Configuration\n\n@SpringBootApplication 提供别名以实现定义以上前两个注解的功能。\n\n## .4. Developer Tools\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-devtools)\n\n添加 spring-boot-devtools 依赖，实现热启动。其实现原理是固有的jar包代码使用一个固定的 classloader，而开发变动的代码使用另一个classloader，当发生变动时，重启一个 classloader 加载新的编译的代码。所以热启动相对冷启动要快些，因为其不用加载旧的不变的依赖的jar包中的代码。\n\n- 使用 trigger-file 触发项目重启。`spring.devtools.restart.trigger-file=<.reloadtrigger>` 手动更新了 trigger 文件才会触发更新。trigger 文件可以自定义在 classpath 中任意地方，而配置文件指定配置文件不需要全限定名，更新代码后只需要修改保存一下trigger文件即可触发reload。\n- 如果使用了Ultimate Edition IDEA 可以点击 relauch 触发重启。\n- 生产模式下devtool 自动关闭，如果项目启动通过 java -jar 运行一个包或从一个特定的 classloader 中开始，devtools 将自动识别在生产模式中。如果应用在窗口中开启需要排除 devtools 或者直接添加系统参数 `-Dspring.devtools.restart.enabled=false`。\n\n## .5. Source Code\n\nSpring Boot 源码\n\n### .5.1. 单例 bean 注册器中 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry\n\n- dependentBeanMap 注释 `Map between dependent bean names: bean name to Set of dependent bean names.` 表示 bean 与依赖此 bean 的映射 map 。\n- dependenciesForBeanMap `Map between depending bean names: bean name to Set of bean names for the bean's dependencies.` 表示 bean 与 此 bean 依赖的 bean 的映射关系集合。\n    - 上述结论来自方法 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registerDependentBean 及其注释说明。同时可以从自动装配方法 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireByType line:1511 推导：解析本bean 自动装配的依赖 autowiredBeanNames 出后，在注册处调用方法 line:1516 参数是本 bean 依赖 autowiredBeanName 为第一个参数，而本 beanName 是第二个参数（这时的依赖关系是： 本bean 依赖 autowiredBean）。再看此 registerDependentBean 方法，其执行是将第一个参数 beanName（此时就是本 bean 的依赖bean） 放入了 dependenciesForBeanMap 而 本 beanName 作为 了第二个参数 放入了 dependentBeanMap 。\n- CGLIB 策略生成子类创建 bean: org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass\n","slug":"Spring/spring boot","published":1,"updated":"2021-02-24T15:22:22.976Z","comments":1,"photos":[],"link":"","_id":"ckljnokrt002j2bhb395uhn4s","content":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-scoop-cli-installation\">reference</a></p>\n<p>安装 spring CLI(command line interface)，后再运行本地 groovy 文件。<span id=\"more\"></span></p>\n<h2 id=\"1-spring-boot-的简化处理\"><a href=\"#1-spring-boot-的简化处理\" class=\"headerlink\" title=\".1. spring boot 的简化处理\"></a>.1. spring boot 的简化处理</h2><ol>\n<li>将所有依赖都写入其基本配置中，最大简化其配置；</li>\n<li>自动扫描，一个注解自动识别所有的需要扫描的包与 bean；</li>\n<li><code>@RestController</code> 指定此类为一个特殊处理器， spring 会识到并用来处理网络请求；</li>\n<li><code>@RequestMapping</code> 提供 “路由” 信息给 spring ，spring 也会对处理结果进行渲染返回给调用者；</li>\n<li><code>@EnableAutoConfiguration</code> 有这个注解 spring boot 会主动根据 pom 文件引入的依赖为你配置，eg: pom 中配置了 <code>spring-boot-starter-web</code> , spring boot 会假设工程是一个 web 应用并为其添加相应的依赖。</li>\n<li><code>@ComponentScan</code> 自动扫描包中的 spring 组件。</li>\n<li><code>@Configuration</code> 相当于 spring bean 的容器，也可以外部的 bean 或配置组件导入。</li>\n<li><code>@SpringBootApplication</code> 声明 spring boot 入口，拥有的功能相当于 <code>@EnableAutoConfiguration</code> <code>@Configuration</code> <code>@ComponentScan</code> 三者之和。同时， spring boot 的入口类最好放在包根路径下，因为组件扫描时时会隐式地将此注解所在类定义为 search package 。<code>@SpringBootApplication</code> 和 <code>@EnableAutoConfiguration</code> 永远只添加一个，一般建议选择任意一个添加到主 <code>@Configuration</code> 类上。</li>\n<li>组件导入<ol>\n<li>建议使用 <code>@Configuration</code> java 组件， <code>@Import</code> 可用来将其他组件导入，也可以使用 <code>@ComponentScan</code> 自动扫描所有的 spring 组件，包括 <code>@Configuration</code> 配置组件</li>\n<li>如果非要使用 xml 配置，使用 <code>@ImportResource</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"1-1-create-an-executable-jar\"><a href=\"#1-1-create-an-executable-jar\" class=\"headerlink\" title=\".1.1. create an executable jar\"></a>.1.1. create an executable jar</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application-dependencies\">reference</a></p>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/2.3.2.BUILD-SNAPSHOT/maven-plugin/reference/html/\">build spring boot on maven</a></p>\n<p>对于一个工程来说依赖各个 jar 包，而 java 并没有提供一个标准的方式去加载内嵌的 jar ，因此不能发布一个独立的程序包。</p>\n<p>为此，很多开发者的解决方案是创建一个 ‘uber’ jar，所谓 uber jar 是指将应用所有的依赖的 class 文件整合成一个单独的包。这样做的问题在于：1、 难以查看依赖库；2、不同 jar 包中要是存在同名的 class 就会出现问题。</p>\n<p>spring boot 使用了不同的方式达到直接使用内嵌包。</p>\n<ol>\n<li>打包： <code>mvn package</code></li>\n<li>查看 jar 包内打包文件 <code>mvn tvf jar_file</code></li>\n<li>pom 中 groupid <code>org.springframework.boot</code></li>\n<li>指定打包为可执行 jar 包的插件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-how-to-series\"><a href=\"#2-how-to-series\" class=\"headerlink\" title=\".2. how to series\"></a>.2. how to series</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-properties-and-configuration\">spring boot HOWTO 系列</a></p>\n<p><a href=\"https://stackoverflow.com/questions/38520638/how-to-set-spring-profile-from-system-variable\">设置 spring 项目 profile</a></p>\n<h3 id=\"2-1-spring-项目中使用-profile\"><a href=\"#2-1-spring-项目中使用-profile\" class=\"headerlink\" title=\".2.1. spring 项目中使用 profile\"></a>.2.1. spring 项目中使用 profile</h3><p><a href=\"https://www.baeldung.com/spring-profiles\">spring 项目 profile</a></p>\n<p>用以指定当前运行环境，可以 maven 打包时也可以设置针对环境打包。</p>\n<p>获取当前活跃的 profile ，参考 <code>6. Get Active Profiles</code></p>\n<h2 id=\"3-Structuring-Code\"><a href=\"#3-Structuring-Code\" class=\"headerlink\" title=\".3. Structuring Code\"></a>.3. Structuring Code</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-structuring-your-code\">reference</a></p>\n<h3 id=\"3-1-Locating-the-Main-Application-Class\"><a href=\"#3-1-Locating-the-Main-Application-Class\" class=\"headerlink\" title=\".3.1. Locating the Main Application Class\"></a>.3.1. Locating the Main Application Class</h3><ul>\n<li>在根目录添加 Application.class 主类放在根目录上，使用 <code>@SpringBootApplication</code> 注解在主类上。此注解也隐匿地定义了某些特定项目的基础查找包 <code>base search package</code> 。_如果在root package 定义多个 application.class 打包发布时会认定哪个为项目入口呢？_亲测结果：<code>spring-boot-maven-plugin:2.3.1.RELEASE:repackage failed: Unable to find a single main class from the following candidates</code> 打包插件将报出不能找到唯一的主类异常</li>\n<li>若不使用 <code>@SpringBootApplication</code> 注解，可以使用 <code>@EnableAutoConfiguration</code> <code>@ComponentScan</code> 两个注解实现相同功能</li>\n</ul>\n<h3 id=\"3-2-Auto-configuration\"><a href=\"#3-2-Auto-configuration\" class=\"headerlink\" title=\".3.2. Auto-configuration\"></a>.3.2. Auto-configuration</h3><blockquote>\n<p>自动配置</p>\n</blockquote>\n<ul>\n<li>使用 <code>@EnableAutoConfiguration</code> 后，spring boot 会检测 classpath 所有的内容进行自动添加配置。</li>\n<li>可以在运行时加上 –debug 进入 debug 模式查看自动配置了哪些东西。</li>\n<li>应该逐渐用特定的配置代替自动配置。</li>\n<li>若 spring boot 自动配置了不需要的配置，可以在 <code>@SpringBootApplication</code> 或 <code>@EnableAutoConfiguration</code> 添加排除 exclude ，若排除的类不在 classpath 中可以指定其全限定名到 <code>excludename</code>。也可以添加配置 <code>spring.autoconfigure.exclude</code> 指定自动配置排除配置。</li>\n</ul>\n<h3 id=\"3-3-Spring-Beans-and-Dependency-Injection\"><a href=\"#3-3-Spring-Beans-and-Dependency-Injection\" class=\"headerlink\" title=\".3.3. Spring Beans and Dependency Injection\"></a>.3.3. Spring Beans and Dependency Injection</h3><ul>\n<li>spring 中的 bean 注入：使用构造器注入 <code>private final Dependency d;</code> 使用 final 修辞字段让其不能被修改。</li>\n</ul>\n<h3 id=\"3-4-Using-the-SpringBootApplication-Annotation\"><a href=\"#3-4-Using-the-SpringBootApplication-Annotation\" class=\"headerlink\" title=\".3.4. Using the @SpringBootApplication Annotation\"></a>.3.4. Using the @SpringBootApplication Annotation</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-spring-beans-and-dependency-injection\">reference</a></p>\n<p>@SpringBootApplication 注解有三个特性，分别对应三个注解：</p>\n<ol>\n<li>@EnableAutoConfiguration</li>\n<li>@ComponentScan</li>\n<li>@Configuration</li>\n</ol>\n<p>@SpringBootApplication 提供别名以实现定义以上前两个注解的功能。</p>\n<h2 id=\"4-Developer-Tools\"><a href=\"#4-Developer-Tools\" class=\"headerlink\" title=\".4. Developer Tools\"></a>.4. Developer Tools</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-devtools\">reference</a></p>\n<p>添加 spring-boot-devtools 依赖，实现热启动。其实现原理是固有的jar包代码使用一个固定的 classloader，而开发变动的代码使用另一个classloader，当发生变动时，重启一个 classloader 加载新的编译的代码。所以热启动相对冷启动要快些，因为其不用加载旧的不变的依赖的jar包中的代码。</p>\n<ul>\n<li>使用 trigger-file 触发项目重启。<code>spring.devtools.restart.trigger-file=&lt;.reloadtrigger&gt;</code> 手动更新了 trigger 文件才会触发更新。trigger 文件可以自定义在 classpath 中任意地方，而配置文件指定配置文件不需要全限定名，更新代码后只需要修改保存一下trigger文件即可触发reload。</li>\n<li>如果使用了Ultimate Edition IDEA 可以点击 relauch 触发重启。</li>\n<li>生产模式下devtool 自动关闭，如果项目启动通过 java -jar 运行一个包或从一个特定的 classloader 中开始，devtools 将自动识别在生产模式中。如果应用在窗口中开启需要排除 devtools 或者直接添加系统参数 <code>-Dspring.devtools.restart.enabled=false</code>。</li>\n</ul>\n<h2 id=\"5-Source-Code\"><a href=\"#5-Source-Code\" class=\"headerlink\" title=\".5. Source Code\"></a>.5. Source Code</h2><p>Spring Boot 源码</p>\n<h3 id=\"5-1-单例-bean-注册器中-org-springframework-beans-factory-support-DefaultSingletonBeanRegistry\"><a href=\"#5-1-单例-bean-注册器中-org-springframework-beans-factory-support-DefaultSingletonBeanRegistry\" class=\"headerlink\" title=\".5.1. 单例 bean 注册器中 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry\"></a>.5.1. 单例 bean 注册器中 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</h3><ul>\n<li>dependentBeanMap 注释 <code>Map between dependent bean names: bean name to Set of dependent bean names.</code> 表示 bean 与依赖此 bean 的映射 map 。</li>\n<li>dependenciesForBeanMap <code>Map between depending bean names: bean name to Set of bean names for the bean&#39;s dependencies.</code> 表示 bean 与 此 bean 依赖的 bean 的映射关系集合。<ul>\n<li>上述结论来自方法 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registerDependentBean 及其注释说明。同时可以从自动装配方法 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireByType line:1511 推导：解析本bean 自动装配的依赖 autowiredBeanNames 出后，在注册处调用方法 line:1516 参数是本 bean 依赖 autowiredBeanName 为第一个参数，而本 beanName 是第二个参数（这时的依赖关系是： 本bean 依赖 autowiredBean）。再看此 registerDependentBean 方法，其执行是将第一个参数 beanName（此时就是本 bean 的依赖bean） 放入了 dependenciesForBeanMap 而 本 beanName 作为 了第二个参数 放入了 dependentBeanMap 。</li>\n</ul>\n</li>\n<li>CGLIB 策略生成子类创建 bean: org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-scoop-cli-installation\">reference</a></p>\n<p>安装 spring CLI(command line interface)，后再运行本地 groovy 文件。","more":"</p>\n<h2 id=\"1-spring-boot-的简化处理\"><a href=\"#1-spring-boot-的简化处理\" class=\"headerlink\" title=\".1. spring boot 的简化处理\"></a>.1. spring boot 的简化处理</h2><ol>\n<li>将所有依赖都写入其基本配置中，最大简化其配置；</li>\n<li>自动扫描，一个注解自动识别所有的需要扫描的包与 bean；</li>\n<li><code>@RestController</code> 指定此类为一个特殊处理器， spring 会识到并用来处理网络请求；</li>\n<li><code>@RequestMapping</code> 提供 “路由” 信息给 spring ，spring 也会对处理结果进行渲染返回给调用者；</li>\n<li><code>@EnableAutoConfiguration</code> 有这个注解 spring boot 会主动根据 pom 文件引入的依赖为你配置，eg: pom 中配置了 <code>spring-boot-starter-web</code> , spring boot 会假设工程是一个 web 应用并为其添加相应的依赖。</li>\n<li><code>@ComponentScan</code> 自动扫描包中的 spring 组件。</li>\n<li><code>@Configuration</code> 相当于 spring bean 的容器，也可以外部的 bean 或配置组件导入。</li>\n<li><code>@SpringBootApplication</code> 声明 spring boot 入口，拥有的功能相当于 <code>@EnableAutoConfiguration</code> <code>@Configuration</code> <code>@ComponentScan</code> 三者之和。同时， spring boot 的入口类最好放在包根路径下，因为组件扫描时时会隐式地将此注解所在类定义为 search package 。<code>@SpringBootApplication</code> 和 <code>@EnableAutoConfiguration</code> 永远只添加一个，一般建议选择任意一个添加到主 <code>@Configuration</code> 类上。</li>\n<li>组件导入<ol>\n<li>建议使用 <code>@Configuration</code> java 组件， <code>@Import</code> 可用来将其他组件导入，也可以使用 <code>@ComponentScan</code> 自动扫描所有的 spring 组件，包括 <code>@Configuration</code> 配置组件</li>\n<li>如果非要使用 xml 配置，使用 <code>@ImportResource</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"1-1-create-an-executable-jar\"><a href=\"#1-1-create-an-executable-jar\" class=\"headerlink\" title=\".1.1. create an executable jar\"></a>.1.1. create an executable jar</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application-dependencies\">reference</a></p>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/2.3.2.BUILD-SNAPSHOT/maven-plugin/reference/html/\">build spring boot on maven</a></p>\n<p>对于一个工程来说依赖各个 jar 包，而 java 并没有提供一个标准的方式去加载内嵌的 jar ，因此不能发布一个独立的程序包。</p>\n<p>为此，很多开发者的解决方案是创建一个 ‘uber’ jar，所谓 uber jar 是指将应用所有的依赖的 class 文件整合成一个单独的包。这样做的问题在于：1、 难以查看依赖库；2、不同 jar 包中要是存在同名的 class 就会出现问题。</p>\n<p>spring boot 使用了不同的方式达到直接使用内嵌包。</p>\n<ol>\n<li>打包： <code>mvn package</code></li>\n<li>查看 jar 包内打包文件 <code>mvn tvf jar_file</code></li>\n<li>pom 中 groupid <code>org.springframework.boot</code></li>\n<li>指定打包为可执行 jar 包的插件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-how-to-series\"><a href=\"#2-how-to-series\" class=\"headerlink\" title=\".2. how to series\"></a>.2. how to series</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-properties-and-configuration\">spring boot HOWTO 系列</a></p>\n<p><a href=\"https://stackoverflow.com/questions/38520638/how-to-set-spring-profile-from-system-variable\">设置 spring 项目 profile</a></p>\n<h3 id=\"2-1-spring-项目中使用-profile\"><a href=\"#2-1-spring-项目中使用-profile\" class=\"headerlink\" title=\".2.1. spring 项目中使用 profile\"></a>.2.1. spring 项目中使用 profile</h3><p><a href=\"https://www.baeldung.com/spring-profiles\">spring 项目 profile</a></p>\n<p>用以指定当前运行环境，可以 maven 打包时也可以设置针对环境打包。</p>\n<p>获取当前活跃的 profile ，参考 <code>6. Get Active Profiles</code></p>\n<h2 id=\"3-Structuring-Code\"><a href=\"#3-Structuring-Code\" class=\"headerlink\" title=\".3. Structuring Code\"></a>.3. Structuring Code</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-structuring-your-code\">reference</a></p>\n<h3 id=\"3-1-Locating-the-Main-Application-Class\"><a href=\"#3-1-Locating-the-Main-Application-Class\" class=\"headerlink\" title=\".3.1. Locating the Main Application Class\"></a>.3.1. Locating the Main Application Class</h3><ul>\n<li>在根目录添加 Application.class 主类放在根目录上，使用 <code>@SpringBootApplication</code> 注解在主类上。此注解也隐匿地定义了某些特定项目的基础查找包 <code>base search package</code> 。_如果在root package 定义多个 application.class 打包发布时会认定哪个为项目入口呢？_亲测结果：<code>spring-boot-maven-plugin:2.3.1.RELEASE:repackage failed: Unable to find a single main class from the following candidates</code> 打包插件将报出不能找到唯一的主类异常</li>\n<li>若不使用 <code>@SpringBootApplication</code> 注解，可以使用 <code>@EnableAutoConfiguration</code> <code>@ComponentScan</code> 两个注解实现相同功能</li>\n</ul>\n<h3 id=\"3-2-Auto-configuration\"><a href=\"#3-2-Auto-configuration\" class=\"headerlink\" title=\".3.2. Auto-configuration\"></a>.3.2. Auto-configuration</h3><blockquote>\n<p>自动配置</p>\n</blockquote>\n<ul>\n<li>使用 <code>@EnableAutoConfiguration</code> 后，spring boot 会检测 classpath 所有的内容进行自动添加配置。</li>\n<li>可以在运行时加上 –debug 进入 debug 模式查看自动配置了哪些东西。</li>\n<li>应该逐渐用特定的配置代替自动配置。</li>\n<li>若 spring boot 自动配置了不需要的配置，可以在 <code>@SpringBootApplication</code> 或 <code>@EnableAutoConfiguration</code> 添加排除 exclude ，若排除的类不在 classpath 中可以指定其全限定名到 <code>excludename</code>。也可以添加配置 <code>spring.autoconfigure.exclude</code> 指定自动配置排除配置。</li>\n</ul>\n<h3 id=\"3-3-Spring-Beans-and-Dependency-Injection\"><a href=\"#3-3-Spring-Beans-and-Dependency-Injection\" class=\"headerlink\" title=\".3.3. Spring Beans and Dependency Injection\"></a>.3.3. Spring Beans and Dependency Injection</h3><ul>\n<li>spring 中的 bean 注入：使用构造器注入 <code>private final Dependency d;</code> 使用 final 修辞字段让其不能被修改。</li>\n</ul>\n<h3 id=\"3-4-Using-the-SpringBootApplication-Annotation\"><a href=\"#3-4-Using-the-SpringBootApplication-Annotation\" class=\"headerlink\" title=\".3.4. Using the @SpringBootApplication Annotation\"></a>.3.4. Using the @SpringBootApplication Annotation</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-spring-beans-and-dependency-injection\">reference</a></p>\n<p>@SpringBootApplication 注解有三个特性，分别对应三个注解：</p>\n<ol>\n<li>@EnableAutoConfiguration</li>\n<li>@ComponentScan</li>\n<li>@Configuration</li>\n</ol>\n<p>@SpringBootApplication 提供别名以实现定义以上前两个注解的功能。</p>\n<h2 id=\"4-Developer-Tools\"><a href=\"#4-Developer-Tools\" class=\"headerlink\" title=\".4. Developer Tools\"></a>.4. Developer Tools</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-devtools\">reference</a></p>\n<p>添加 spring-boot-devtools 依赖，实现热启动。其实现原理是固有的jar包代码使用一个固定的 classloader，而开发变动的代码使用另一个classloader，当发生变动时，重启一个 classloader 加载新的编译的代码。所以热启动相对冷启动要快些，因为其不用加载旧的不变的依赖的jar包中的代码。</p>\n<ul>\n<li>使用 trigger-file 触发项目重启。<code>spring.devtools.restart.trigger-file=&lt;.reloadtrigger&gt;</code> 手动更新了 trigger 文件才会触发更新。trigger 文件可以自定义在 classpath 中任意地方，而配置文件指定配置文件不需要全限定名，更新代码后只需要修改保存一下trigger文件即可触发reload。</li>\n<li>如果使用了Ultimate Edition IDEA 可以点击 relauch 触发重启。</li>\n<li>生产模式下devtool 自动关闭，如果项目启动通过 java -jar 运行一个包或从一个特定的 classloader 中开始，devtools 将自动识别在生产模式中。如果应用在窗口中开启需要排除 devtools 或者直接添加系统参数 <code>-Dspring.devtools.restart.enabled=false</code>。</li>\n</ul>\n<h2 id=\"5-Source-Code\"><a href=\"#5-Source-Code\" class=\"headerlink\" title=\".5. Source Code\"></a>.5. Source Code</h2><p>Spring Boot 源码</p>\n<h3 id=\"5-1-单例-bean-注册器中-org-springframework-beans-factory-support-DefaultSingletonBeanRegistry\"><a href=\"#5-1-单例-bean-注册器中-org-springframework-beans-factory-support-DefaultSingletonBeanRegistry\" class=\"headerlink\" title=\".5.1. 单例 bean 注册器中 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry\"></a>.5.1. 单例 bean 注册器中 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</h3><ul>\n<li>dependentBeanMap 注释 <code>Map between dependent bean names: bean name to Set of dependent bean names.</code> 表示 bean 与依赖此 bean 的映射 map 。</li>\n<li>dependenciesForBeanMap <code>Map between depending bean names: bean name to Set of bean names for the bean&#39;s dependencies.</code> 表示 bean 与 此 bean 依赖的 bean 的映射关系集合。<ul>\n<li>上述结论来自方法 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registerDependentBean 及其注释说明。同时可以从自动装配方法 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireByType line:1511 推导：解析本bean 自动装配的依赖 autowiredBeanNames 出后，在注册处调用方法 line:1516 参数是本 bean 依赖 autowiredBeanName 为第一个参数，而本 beanName 是第二个参数（这时的依赖关系是： 本bean 依赖 autowiredBean）。再看此 registerDependentBean 方法，其执行是将第一个参数 beanName（此时就是本 bean 的依赖bean） 放入了 dependenciesForBeanMap 而 本 beanName 作为 了第二个参数 放入了 dependentBeanMap 。</li>\n</ul>\n</li>\n<li>CGLIB 策略生成子类创建 bean: org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#createEnhancedSubclass</li>\n</ul>"},{"layout":"post","title":"Linux","date":"2020-05-12T10:52:00.000Z","description":"linux","_content":"\n## .1. tomcat\n\n在 linux 上安装 Tomcat 并启动。(root 123456)<!--more-->\n\n1. 安装 tomcat 后，进入 bin 中启动 `./startup.sh`;\n2. 必须开启防火墙：\n   1. `vim /etc/sysconfig/iptables` 打开系统 ip 配置文件\n   2. 添加配置 `-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT`\n      1. (直接调用服务写配置：`/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT`)\n   3. 重启防火墙 `service iptables restart`\n      1. 加上路径的命令为： `/etc/rc.d/init.d/iptables save`\n3. 通过外部网络可访问 tomcat 了。\n\n## .2. mysql\n\n在 linux 安装 mysql 并运行。（本地虚拟机上：root 12345）\n\n问题：March 12 2020 在虚拟机上 linux 设置自动启动 mysql 后，在使用 `service mysql stop` 命令出现错误：“ERROR! MySQL server PID file could not be found”。最后使用 stackoverflow 上方法解决：[stackoverflow](https://stackoverflow.com/questions/41616251/error-mysql-server-pid-file-could-not-be-found-in-osx-sierra)\n\n1. `ps -ef | grep mysql --color` 查找出正在运行的 mysql 进程；\n2. `kill -9 PID` 杀掉进程；\n3. 再使用 `service mysql start` 启动 mysql ，后面再使用 `service mysql stop` 正常停止 mysql。\n\n## .3. redis\n\n在 linux 上安装 redis 使用\n\n1. 编译好 redis 后运行 redis  不能直接使用 `redis-server` ，需要使用 `./redis-server` 才能启动；\n2. 修改 redis 服务后台启动：\n   1. 将 redis.conf 文件 copy 到 bin 目录下，将其 `daemonize` 修改为 `yes`;\n   2. 启动 redis-server 时加上参数：`./redis-server redis.conf`；\n\n## .4. 磁盘管理命令\n\n- `ls [参数] [文件或目录]` list 查看目录下所有文件\n    - `-a` 或 `--all` 查看全部，包括隐藏的\n    - `-l` 简化版: `ll` 详细格式列表\n- `cd [目录]` change directory\n    - `~` 当前用户目录\n    - `/` 根目录\n    - `.` 当前目录\n    - `..` 上级目录\n    - `-` 上次所在目录\n- `pwd` print working directory 打印当前所在目录\n- `mkdir` make directory\n- `rmdir` remove directory 移除空目录\n- scp secure copy 可以从远程服务器拷贝，同时加密\n\n## .5. 文件管理\n\n- `cat [OPTION]... [FILE]...` concatenate 将文件输出级联到另一个文件或终端\n    - `cat > {file}` 指定到同一个文件\n- `lsb_release [OPTION]` 查看系统发布版本\n- `more {file}`  分页显示文件内容\n    - enter 向下显示一行（默认1行，可定义）\n    - 空格/ctrl+F 显示下一页\n    - `B`  back 返回上一屏\n    - `q` 退出 more\n- `less [参数] {file}`\n    - `-m` 显示 more 命令一样的 百分比\n    - `-N` 显示行号\n    - 后续命令\n        - 空格/page down 向下翻页\n        - page up/b(back) 向上翻页\n        - 上下方向键/y与enter键 向上下一行\n        - `?` `/` 向上/下搜索\n            - `n`/`N` 跳到下一个/上一个查找的结果\n        - `q` 退出\n        - 左右方向键 左右滚屏\n- `tail [parameter] [file]`\n    - `-n` 显示行数\n    - `-f` 动态跟踪文件，查看动态日志\n    - ctrl + c 退出\n- `find [path] [parameter]` 在目录中查找文件\n    - `-name`  指定字符串作为查找的样本\n\n## .6. 文档编辑\n\n- `|` 管道命令，一般与 grep 联用，在上一个结果中进行操作下一个命令\n- [`vim [file]` 或者 `vi [file]` 命令](https://vim.rtorr.com/) [cheat sheet](https://spin.atomicobject.com/2016/04/19/vim-commands-cheat-sheet/)\n    - 进入到文件 vi 编辑状态后，有三种状态：\n        - command mode 命令模式，此模式下按 `:` 进入底行模式， `i`/`a`/`o` 进入到插入模式\n            - `i` 在光标前插入 `shift + i` 在光标所在行前插入\n            - `a` 在光标后插入， `shift + a` 在光标所在行最后插入\n            - `o` 在光标所在行下一行插入新行， `shift + o` 在光标所在行前一行插入新行\n            - i - Insert at cursor (goes into insert mode)\n            - a - Write after cursor (goes into insert mode)\n            - A - Write at the end of line (goes into insert mode)\n            - ESC - Terminate insert mode\n            - u - Undo last change\n            - U - Undo all changes to the entire line\n            - o - Open a new line (goes into insert mode)\n            - dd - Delete line\n            - 3dd - Delete 3 lines.\n            - D - Delete contents of line after the cursor\n            - C - Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.\n            - dw - Delete word\n            - 4dw - Delete 4 words\n            - cw - Change word\n            - x - Delete character at the cursor\n            - r - Replace character\n            - R - Overwrite characters from cursor onward\n            - s - Substitute one character under cursor continue to insert\n            - S - Substitute entire line and begin to insert at the beginning of the line\n            - `~` Change case of individual character, 前面加上数字将实现指定数量个字符的大小写切换\n        - last line mode 底行模式， w write, q quit 退出到编辑模式, ! force\n        - insert mode 插入模式，esc 退出到底行模式\n    - copy & paste\n        - `yy` 单行复制 yank current line\n        - `y$` 复制光标到行尾 yank to end of the current line from cursor\n        - `yw` 复制从光标处到 token 尾 yank from cursor to end of the current word\n        - `yW` 从光标处复制到 word 尾\n        - `nyy` n 行复制\n        - `p`/`P` 在光标后/前粘贴\n        - `gg` 到文本第一行\n        - `shift + gg` 到文本最后一行\n    - delete\n        - `dd`删除光标所在行\n        - `ndd` 删除 n 行\n    - `u` undo\n    - ctrl + `r` redo\n    - Movement\n        - h j k l 左下上右四个方向移动 cursor 在前加上数字可实现多个字符的跳动\n        - b w B W 向 back forward 方向移动整个 token/word ，在其前数字指定移动数量\n        - ^ $ 移动光标到行首尾\n        - ctrl + u/d 向上下翻页up/down ，cursor 跟着一起翻页\n        - 整页翻页 ctrl-f ctrl-b\n            - f 就是forward b就是backward\n            - 翻半页 ctrl-d ctrl-u d=down u=up\n            - 滚一行ctrl-e ctrl-y\n            - zz 让光标所在的行居屏幕中央\n            - zt 让光标所在的行居屏幕最上一行 t=top\n            - zb 让光标所在的行居屏幕最下一行 b=bottom\n        - *<line-number>*G 跳到指定行\n        - H M L 跳到页面上中下 High Middle Low\n        - `*` `#` 下一个与当前 cursor 所在 token 相同的 token ，前面加上数字指定跳跃数量\n        - `n` `N` 重复上一次命令结果往上/下找\n        - `''` 两次 `'` ，跳回上一次输入此命令的行首。相当于对特殊行进行一次记录，但只能记录一个历史，感觉没啥用。\n- `grep [parameter] [regular expression] {file}` Global Regular expression print 过滤搜索特定字符。匹配到的结果是行，rgep 可以多个，file 也可多个，也可用 * 匹配当前路径所有文件\n    - `-i` 或 `-ignore-case` 忽略大小写\n    - `--color[=auto|=never|=always]` ：可以将找到的关键词部分加上颜色的显示\n    - `-A2` after 显示匹配行+其后2行\n    - `-B` before\n    - `-C` 前后都有\n    - c 统计行数\n    - r recursive 递归查找包括子路径文件\n    - n number of line 显示行号\n    - E extend 扩展 regexp\n- 命令行中使用命令\n    - `ctrl + e` 移动到行尾 end\n    - `ctrl + a` 移动到行 首\n    - `ctrl + w` 删除光标前一个 token\n    - `esc + d` 删除光标后一个 token\n    - `ESC + f` 向前移动一个 token\n    - `esc + b` 向后移动一个 token\n\n## .7. 系统命令\n\n- `ps [parameter]` process status 进程运行状态\n    - `-e` 与 `-A` 相同显示所有进程\n    - `-f` 显示UID, PPIP, C, STIME 栏位\n- `kill [parameter] [process]`\n    - `-9 pid` 强制终止\n- `lscpu` 查看 cpu 信息\n- `dpkg --print-architecture` [查看指令集](https://unix.stackexchange.com/questions/180726/easy-command-line-method-to-determine-specific-arm-architecture-string)\n- sudo superuser do\n    - sudo [command] 给普通用户命令加上超级用户权限\n- 没有安装 systemmd(systemctl) 命令，使用 service {servicename} {start|stop|restart} 代替\n- `uname` unix name 查看系统版本信息\n- `update-alternatives [options] command` 管理系统可选项命令,建立命令的符号链接\n    - 当安装多个命令版本时,使用此命令配置各命令的优先级或管理其默认项,在安装 jdk 时需要配合环境变量配置设置系统 java 命令.\n    - `update-alternatives --install link name path priority [--slave link name path] ...` 可以将命令(path)生成符号链接(name)添加到环境变量目录(link) eg: `update-alternatives --install /usr/bin/java java /usr/local/java/jdk-8/bin/java 1`\n    - `--config` 交互配置命令,如果需要在命令使用配置,使用 `--set`\n\n## .8. 环境变量设置\n\n> [reference](https://askubuntu.com/questions/58814/how-do-i-add-environment-variables)\n> [环境变量设置](https://help.ubuntu.com/community/EnvironmentVariables)\n\n- 设置当前 shell 变量 : `name=value` 此语法设置的变量只在当前 shell 中有效,同时 **不能被当前 shell 启动的进程所读取到**.\n- 设置当前 shell 变量并对当前 shell 环境启动的进程生效:`export [-fn] [name=[value] ...]` `export -p` 给 shell 设置变量.变量域只在当前 shell ,从当前 shell 启动的进程都能读到此变量,而其他 shell 打开的进程不能读取到.\n    - 将每个 name 变量自动导入到后续执行的命令的环境中, value 使用前需要对其赋值.\n    - 命令选项\n        - -f 引用到某个 shell function\n        - -n 从 name 中移除导出属性 *?*\n        - -p 显示所有被导入的变量与函数\n        - `--` 关闭选项处理 *?*\n- 永久地对所有 bush sessions 功能添加变量: 将变量设置行添加到 `$HOME/.bashrc` 或者 .profile .bash_login 中,三者更推荐 .profile ,其他两个都只是在 shell 执行中会有效,对桌面应用无效.\n- 系统范围内(所有用户进程)永久添加变量: 添加到 /etc/environment, `sudo -H gedit /etc/environment`. 格式: `VARNAME=\"value\"`.或者在 /etc/profile.d/ 中添加脚本,脚本中使用 export 添加环境变量.此目录中的脚本都会在所有用户所有 shell 执行前先执行.\n    - 需要重新登录当前用户才能对当前用户生效.\n- `source <filename> [arguments]` 在当前 shell 中读取并执行文件中的命令, $PATH 中的变量会被用来查询在文件中指定的目录.如果参数 arguments 提供了,会被用来当作 shell 执行的位置参数(参数顺序被指定可以在 shell 中的使用 $n 获取). source 命令快捷方式: `.` .\n\n## .9. firewall 防火墙\n\n[reference](https://blog.csdn.net/u011846257/article/details/54707864)\n\n添加 iptables 规则时需要将其添加成 REJECT 所有其他的端口之前，否则将无效。\n\n## .10. 备份压缩\n\n> [difference between .gz and .tar](https://www.quora.com/What-is-the-difference-between-tar-gz-zip-and-tar-gz-in-Linux#:~:text=gz%20is%20a%20single%20file,an%20arbitrary%20number%20of%20filed.)\n\n- `.gz` 文件是使用 gzip 压缩过的文件后缀，而 tar 只是用于将多个文件进行打包并不包含压缩。\n- `tar`\n    - `-c` create 创建归档\n    - `-x` extract 解档\n    - `-z` 使用 **gzip** 压缩\n    - `-v` verbose 显示压缩的文件\n    - `-f` file 是否使用档名\n\n## .11. 关机重启\n\n- `reboot` 重启 CentOS\n- `halt` 关机 CentOS\n- debian\n    - reboot\n    - shutdown\n\n## .12. 文件权限\n\n`chmod [parameter] <权限范围> <符号><权限代码>` change mode 更改权限\n\n- `-R` 或 `-recursive` 递归将文件夹中所有文件都更改\n- 权限范围\n    - `u` user\n    - `g` group\n    - `o` other\n    - `a` all\n- 权限符号\n    - `+` 添加\n    - `-` 取消\n- 权限代号\n    - `r` read 4\n    - `w` write 2\n    - `x` execute 1\n    - `-` none 0\n\n## .13. 网络配置\n\n查看 网络配置 文件位置: `/etc/sysconfig/networking-scripts/ifcfg-eth0`\n\n### .13.1. windows operation\n\nwindows 操作系统中相关命令行。\n\n- 刷新 dns 数据命令：\n\n```sh\nipconfig/flushdns\n```\n\n- 查看电脑网络端口使用情况，类似于在 linux 中使用 `ps` 命令\n    - `netstat -ano` 命令行命令可以看到各个进程 pid 与 address 占用情况\n    - `netstat -ano|findstr portNum` 查看指定端口占用情况，这儿查看的端口占用包括了本地地址的占用与外部地址的占用\n    - `tasklist|findstr 'pid'` 查看指定 pid 的进程使用\n    - `taskkill /pid pid /f` 杀死进程 pid 指 progress id 进程 id\n        - 前两个步骤任选一个与最后个连用就可查找出端口被哪个进程给占用。\n        - 也可以使用前两个步骤配合任务管理器查找，相对于命令行来说更直观。\n        - 在 windows 系统中可用，不知在 linux 中是否可用\n\n## .14. rpm\n\n> resources package manager 资源包管理器，其相应的包文件后缀为 `.rpm` 在 red hat/Fedora/SUSE 系列使用此包管理，而在 Debian/Ubuntu 系列使用 `dpkg` 命令，其包文件后缀为 `.deb` 。\n\ncommand lind : `rpm [parameter] [软件]\n\n使用 rpm 管理系统软件包，可以定制软件的更新、安装与卸载。[reference](https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/)\n\n1. 下载软件包的 rpm 文件，再使用 rpm 命令安装仓库\n2. 安装后，可以使用 yum-util 的 yum-config-manager 管理包，也可以直接进入 /etc/yum.repos.d/{software}.repo 文件查看管理软件包数据\n3. 使用 yum install {software} 安装软件，安装时会自动根据其 repo 仓库配置文件安装指定的软件版本\n\n- `-v` verbose 显示指令执行过程\n- `-h` 或 `--hash` 套件安装时显示列出指令\n- `-q` question 询问模式，遇到问题时指令会先询问用户\n- `-a` all 显示所有的套件\n- `-i` 或 `--install`<套件档> 安装指定的套件档\n- `-U` 或 `--upgrade <套件档>` 更新指定的套件档\n- `-e <套件档>` erase 删除指定的套件档\n- `--nodeps` no dependence 不验证套件间的关联性\n- 常用命令：\n    - `rpm -qa` 查看安装的软件\n    - `rpm -e --nodeps <软件名>` 删除软件\n    - `rpm -iph <package>` 安装\n    - `rpm -Uph <软件>` 更新软件\n\n## .15. 服务命令\n\n- `service <service name> restart` 重启服务\n- `service <service name> start` 启动服务\n- `service <service name> stop` 停止服务\n\n## .16. windows10 & Ubuntu\n\n> win10 + ubuntu 双系统安装与使用\n\n## .17. 安装问题\n\n- 目前在台式机双显卡上遇到最大的问题是使用nvidia独显并不能设置分辨率为1920x1080，相反使用核显反而能。但是如果连接核显VGA接口又不能正常启动系统，只能先连接独显DVI－I接口让系统启动，启动后再将连接线接到VGA接口。\n    - [显示器接口认识](https://www.zhihu.com/question/19571221)\n    - [修改分辨率](https://blog.csdn.net/shixin_0125/article/details/72793300)，在使用DVI-I接口时并不能设置成功，只能设置到未连接的VGA 或 HDMI 接口上。\n    - 使用 ｀xrandr｀ 命令查看系统正使用的接口与其分辨率\n- [双系统下时间相差 8 小时](https://www.jianshu.com/p/5c1db6364141)\n- ubuntu 默认使用其 snap 安装软件，其安装的 vscode 被阉割，不能在其中输入中文，需要自行安装完整版。[reference](https://blog.csdn.net/qq_35092399/article/details/105526908)\n- ubuntu 中安装软件包使用 dpkg 命令，一般流程：\n    - 使用 `wget` 下载 `＊.deb` 包，或直接在其官方网站上手动下载其提供的 linux 版本包；\n    - [安装](https://help.ubuntu.com/kubuntu/desktopguide/zh_CN/manual-install.html)。可直接在右击 .deb 文件选择 Kubuntu Package Menu -> install。也可以使用 dpkg 命令安装。卸载时使用 apt-get remove 包名。\n- [禁用启动时显卡加载参数](https://itectec.com/ubuntu/ubuntu-what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean/)\n    - `nomodeset` 添加此参数指令会让 kernel 不加载显卡驱动使用 BIOS 模式也并非一定要 X server 被加载。\n    - `quiet splash` 使用静默状态的启动，否则任何消息会打断 splash 桌面\n\n## .18. 使用\n\n- [在 Ubuntu 中使用 U 盘](https://blog.csdn.net/a999wt/article/details/8227154)\n    - 需要将 U 盘挂载（ `mount` 命令）到系统中，一般使用 /mnt 目录挂载\n    - 挂载后在 /mnt 目录中就可以看到 U 盘内容了。此处有个坑是如果挂载前已经进入 /mnt 目录，挂载后是看不到 U 盘内容的，需要重新进入目录才能看到。\n    - 操作完 U 盘内容后使得命令 `umount` 命令卸载 U 盘。\n        - 卸载 U 盘可能会出现 device is busy 的提示，等一会儿就自动卸载。\n","source":"_posts/Linux/linux.md","raw":"---\nlayout: \"post\"\ntitle: Linux\ndate: 2020-5-12 18:52:00\ncategories: [Linux]\ntags: [programming, linux, OS]\ndescription: linux\n---\n\n## .1. tomcat\n\n在 linux 上安装 Tomcat 并启动。(root 123456)<!--more-->\n\n1. 安装 tomcat 后，进入 bin 中启动 `./startup.sh`;\n2. 必须开启防火墙：\n   1. `vim /etc/sysconfig/iptables` 打开系统 ip 配置文件\n   2. 添加配置 `-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT`\n      1. (直接调用服务写配置：`/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT`)\n   3. 重启防火墙 `service iptables restart`\n      1. 加上路径的命令为： `/etc/rc.d/init.d/iptables save`\n3. 通过外部网络可访问 tomcat 了。\n\n## .2. mysql\n\n在 linux 安装 mysql 并运行。（本地虚拟机上：root 12345）\n\n问题：March 12 2020 在虚拟机上 linux 设置自动启动 mysql 后，在使用 `service mysql stop` 命令出现错误：“ERROR! MySQL server PID file could not be found”。最后使用 stackoverflow 上方法解决：[stackoverflow](https://stackoverflow.com/questions/41616251/error-mysql-server-pid-file-could-not-be-found-in-osx-sierra)\n\n1. `ps -ef | grep mysql --color` 查找出正在运行的 mysql 进程；\n2. `kill -9 PID` 杀掉进程；\n3. 再使用 `service mysql start` 启动 mysql ，后面再使用 `service mysql stop` 正常停止 mysql。\n\n## .3. redis\n\n在 linux 上安装 redis 使用\n\n1. 编译好 redis 后运行 redis  不能直接使用 `redis-server` ，需要使用 `./redis-server` 才能启动；\n2. 修改 redis 服务后台启动：\n   1. 将 redis.conf 文件 copy 到 bin 目录下，将其 `daemonize` 修改为 `yes`;\n   2. 启动 redis-server 时加上参数：`./redis-server redis.conf`；\n\n## .4. 磁盘管理命令\n\n- `ls [参数] [文件或目录]` list 查看目录下所有文件\n    - `-a` 或 `--all` 查看全部，包括隐藏的\n    - `-l` 简化版: `ll` 详细格式列表\n- `cd [目录]` change directory\n    - `~` 当前用户目录\n    - `/` 根目录\n    - `.` 当前目录\n    - `..` 上级目录\n    - `-` 上次所在目录\n- `pwd` print working directory 打印当前所在目录\n- `mkdir` make directory\n- `rmdir` remove directory 移除空目录\n- scp secure copy 可以从远程服务器拷贝，同时加密\n\n## .5. 文件管理\n\n- `cat [OPTION]... [FILE]...` concatenate 将文件输出级联到另一个文件或终端\n    - `cat > {file}` 指定到同一个文件\n- `lsb_release [OPTION]` 查看系统发布版本\n- `more {file}`  分页显示文件内容\n    - enter 向下显示一行（默认1行，可定义）\n    - 空格/ctrl+F 显示下一页\n    - `B`  back 返回上一屏\n    - `q` 退出 more\n- `less [参数] {file}`\n    - `-m` 显示 more 命令一样的 百分比\n    - `-N` 显示行号\n    - 后续命令\n        - 空格/page down 向下翻页\n        - page up/b(back) 向上翻页\n        - 上下方向键/y与enter键 向上下一行\n        - `?` `/` 向上/下搜索\n            - `n`/`N` 跳到下一个/上一个查找的结果\n        - `q` 退出\n        - 左右方向键 左右滚屏\n- `tail [parameter] [file]`\n    - `-n` 显示行数\n    - `-f` 动态跟踪文件，查看动态日志\n    - ctrl + c 退出\n- `find [path] [parameter]` 在目录中查找文件\n    - `-name`  指定字符串作为查找的样本\n\n## .6. 文档编辑\n\n- `|` 管道命令，一般与 grep 联用，在上一个结果中进行操作下一个命令\n- [`vim [file]` 或者 `vi [file]` 命令](https://vim.rtorr.com/) [cheat sheet](https://spin.atomicobject.com/2016/04/19/vim-commands-cheat-sheet/)\n    - 进入到文件 vi 编辑状态后，有三种状态：\n        - command mode 命令模式，此模式下按 `:` 进入底行模式， `i`/`a`/`o` 进入到插入模式\n            - `i` 在光标前插入 `shift + i` 在光标所在行前插入\n            - `a` 在光标后插入， `shift + a` 在光标所在行最后插入\n            - `o` 在光标所在行下一行插入新行， `shift + o` 在光标所在行前一行插入新行\n            - i - Insert at cursor (goes into insert mode)\n            - a - Write after cursor (goes into insert mode)\n            - A - Write at the end of line (goes into insert mode)\n            - ESC - Terminate insert mode\n            - u - Undo last change\n            - U - Undo all changes to the entire line\n            - o - Open a new line (goes into insert mode)\n            - dd - Delete line\n            - 3dd - Delete 3 lines.\n            - D - Delete contents of line after the cursor\n            - C - Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.\n            - dw - Delete word\n            - 4dw - Delete 4 words\n            - cw - Change word\n            - x - Delete character at the cursor\n            - r - Replace character\n            - R - Overwrite characters from cursor onward\n            - s - Substitute one character under cursor continue to insert\n            - S - Substitute entire line and begin to insert at the beginning of the line\n            - `~` Change case of individual character, 前面加上数字将实现指定数量个字符的大小写切换\n        - last line mode 底行模式， w write, q quit 退出到编辑模式, ! force\n        - insert mode 插入模式，esc 退出到底行模式\n    - copy & paste\n        - `yy` 单行复制 yank current line\n        - `y$` 复制光标到行尾 yank to end of the current line from cursor\n        - `yw` 复制从光标处到 token 尾 yank from cursor to end of the current word\n        - `yW` 从光标处复制到 word 尾\n        - `nyy` n 行复制\n        - `p`/`P` 在光标后/前粘贴\n        - `gg` 到文本第一行\n        - `shift + gg` 到文本最后一行\n    - delete\n        - `dd`删除光标所在行\n        - `ndd` 删除 n 行\n    - `u` undo\n    - ctrl + `r` redo\n    - Movement\n        - h j k l 左下上右四个方向移动 cursor 在前加上数字可实现多个字符的跳动\n        - b w B W 向 back forward 方向移动整个 token/word ，在其前数字指定移动数量\n        - ^ $ 移动光标到行首尾\n        - ctrl + u/d 向上下翻页up/down ，cursor 跟着一起翻页\n        - 整页翻页 ctrl-f ctrl-b\n            - f 就是forward b就是backward\n            - 翻半页 ctrl-d ctrl-u d=down u=up\n            - 滚一行ctrl-e ctrl-y\n            - zz 让光标所在的行居屏幕中央\n            - zt 让光标所在的行居屏幕最上一行 t=top\n            - zb 让光标所在的行居屏幕最下一行 b=bottom\n        - *<line-number>*G 跳到指定行\n        - H M L 跳到页面上中下 High Middle Low\n        - `*` `#` 下一个与当前 cursor 所在 token 相同的 token ，前面加上数字指定跳跃数量\n        - `n` `N` 重复上一次命令结果往上/下找\n        - `''` 两次 `'` ，跳回上一次输入此命令的行首。相当于对特殊行进行一次记录，但只能记录一个历史，感觉没啥用。\n- `grep [parameter] [regular expression] {file}` Global Regular expression print 过滤搜索特定字符。匹配到的结果是行，rgep 可以多个，file 也可多个，也可用 * 匹配当前路径所有文件\n    - `-i` 或 `-ignore-case` 忽略大小写\n    - `--color[=auto|=never|=always]` ：可以将找到的关键词部分加上颜色的显示\n    - `-A2` after 显示匹配行+其后2行\n    - `-B` before\n    - `-C` 前后都有\n    - c 统计行数\n    - r recursive 递归查找包括子路径文件\n    - n number of line 显示行号\n    - E extend 扩展 regexp\n- 命令行中使用命令\n    - `ctrl + e` 移动到行尾 end\n    - `ctrl + a` 移动到行 首\n    - `ctrl + w` 删除光标前一个 token\n    - `esc + d` 删除光标后一个 token\n    - `ESC + f` 向前移动一个 token\n    - `esc + b` 向后移动一个 token\n\n## .7. 系统命令\n\n- `ps [parameter]` process status 进程运行状态\n    - `-e` 与 `-A` 相同显示所有进程\n    - `-f` 显示UID, PPIP, C, STIME 栏位\n- `kill [parameter] [process]`\n    - `-9 pid` 强制终止\n- `lscpu` 查看 cpu 信息\n- `dpkg --print-architecture` [查看指令集](https://unix.stackexchange.com/questions/180726/easy-command-line-method-to-determine-specific-arm-architecture-string)\n- sudo superuser do\n    - sudo [command] 给普通用户命令加上超级用户权限\n- 没有安装 systemmd(systemctl) 命令，使用 service {servicename} {start|stop|restart} 代替\n- `uname` unix name 查看系统版本信息\n- `update-alternatives [options] command` 管理系统可选项命令,建立命令的符号链接\n    - 当安装多个命令版本时,使用此命令配置各命令的优先级或管理其默认项,在安装 jdk 时需要配合环境变量配置设置系统 java 命令.\n    - `update-alternatives --install link name path priority [--slave link name path] ...` 可以将命令(path)生成符号链接(name)添加到环境变量目录(link) eg: `update-alternatives --install /usr/bin/java java /usr/local/java/jdk-8/bin/java 1`\n    - `--config` 交互配置命令,如果需要在命令使用配置,使用 `--set`\n\n## .8. 环境变量设置\n\n> [reference](https://askubuntu.com/questions/58814/how-do-i-add-environment-variables)\n> [环境变量设置](https://help.ubuntu.com/community/EnvironmentVariables)\n\n- 设置当前 shell 变量 : `name=value` 此语法设置的变量只在当前 shell 中有效,同时 **不能被当前 shell 启动的进程所读取到**.\n- 设置当前 shell 变量并对当前 shell 环境启动的进程生效:`export [-fn] [name=[value] ...]` `export -p` 给 shell 设置变量.变量域只在当前 shell ,从当前 shell 启动的进程都能读到此变量,而其他 shell 打开的进程不能读取到.\n    - 将每个 name 变量自动导入到后续执行的命令的环境中, value 使用前需要对其赋值.\n    - 命令选项\n        - -f 引用到某个 shell function\n        - -n 从 name 中移除导出属性 *?*\n        - -p 显示所有被导入的变量与函数\n        - `--` 关闭选项处理 *?*\n- 永久地对所有 bush sessions 功能添加变量: 将变量设置行添加到 `$HOME/.bashrc` 或者 .profile .bash_login 中,三者更推荐 .profile ,其他两个都只是在 shell 执行中会有效,对桌面应用无效.\n- 系统范围内(所有用户进程)永久添加变量: 添加到 /etc/environment, `sudo -H gedit /etc/environment`. 格式: `VARNAME=\"value\"`.或者在 /etc/profile.d/ 中添加脚本,脚本中使用 export 添加环境变量.此目录中的脚本都会在所有用户所有 shell 执行前先执行.\n    - 需要重新登录当前用户才能对当前用户生效.\n- `source <filename> [arguments]` 在当前 shell 中读取并执行文件中的命令, $PATH 中的变量会被用来查询在文件中指定的目录.如果参数 arguments 提供了,会被用来当作 shell 执行的位置参数(参数顺序被指定可以在 shell 中的使用 $n 获取). source 命令快捷方式: `.` .\n\n## .9. firewall 防火墙\n\n[reference](https://blog.csdn.net/u011846257/article/details/54707864)\n\n添加 iptables 规则时需要将其添加成 REJECT 所有其他的端口之前，否则将无效。\n\n## .10. 备份压缩\n\n> [difference between .gz and .tar](https://www.quora.com/What-is-the-difference-between-tar-gz-zip-and-tar-gz-in-Linux#:~:text=gz%20is%20a%20single%20file,an%20arbitrary%20number%20of%20filed.)\n\n- `.gz` 文件是使用 gzip 压缩过的文件后缀，而 tar 只是用于将多个文件进行打包并不包含压缩。\n- `tar`\n    - `-c` create 创建归档\n    - `-x` extract 解档\n    - `-z` 使用 **gzip** 压缩\n    - `-v` verbose 显示压缩的文件\n    - `-f` file 是否使用档名\n\n## .11. 关机重启\n\n- `reboot` 重启 CentOS\n- `halt` 关机 CentOS\n- debian\n    - reboot\n    - shutdown\n\n## .12. 文件权限\n\n`chmod [parameter] <权限范围> <符号><权限代码>` change mode 更改权限\n\n- `-R` 或 `-recursive` 递归将文件夹中所有文件都更改\n- 权限范围\n    - `u` user\n    - `g` group\n    - `o` other\n    - `a` all\n- 权限符号\n    - `+` 添加\n    - `-` 取消\n- 权限代号\n    - `r` read 4\n    - `w` write 2\n    - `x` execute 1\n    - `-` none 0\n\n## .13. 网络配置\n\n查看 网络配置 文件位置: `/etc/sysconfig/networking-scripts/ifcfg-eth0`\n\n### .13.1. windows operation\n\nwindows 操作系统中相关命令行。\n\n- 刷新 dns 数据命令：\n\n```sh\nipconfig/flushdns\n```\n\n- 查看电脑网络端口使用情况，类似于在 linux 中使用 `ps` 命令\n    - `netstat -ano` 命令行命令可以看到各个进程 pid 与 address 占用情况\n    - `netstat -ano|findstr portNum` 查看指定端口占用情况，这儿查看的端口占用包括了本地地址的占用与外部地址的占用\n    - `tasklist|findstr 'pid'` 查看指定 pid 的进程使用\n    - `taskkill /pid pid /f` 杀死进程 pid 指 progress id 进程 id\n        - 前两个步骤任选一个与最后个连用就可查找出端口被哪个进程给占用。\n        - 也可以使用前两个步骤配合任务管理器查找，相对于命令行来说更直观。\n        - 在 windows 系统中可用，不知在 linux 中是否可用\n\n## .14. rpm\n\n> resources package manager 资源包管理器，其相应的包文件后缀为 `.rpm` 在 red hat/Fedora/SUSE 系列使用此包管理，而在 Debian/Ubuntu 系列使用 `dpkg` 命令，其包文件后缀为 `.deb` 。\n\ncommand lind : `rpm [parameter] [软件]\n\n使用 rpm 管理系统软件包，可以定制软件的更新、安装与卸载。[reference](https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/)\n\n1. 下载软件包的 rpm 文件，再使用 rpm 命令安装仓库\n2. 安装后，可以使用 yum-util 的 yum-config-manager 管理包，也可以直接进入 /etc/yum.repos.d/{software}.repo 文件查看管理软件包数据\n3. 使用 yum install {software} 安装软件，安装时会自动根据其 repo 仓库配置文件安装指定的软件版本\n\n- `-v` verbose 显示指令执行过程\n- `-h` 或 `--hash` 套件安装时显示列出指令\n- `-q` question 询问模式，遇到问题时指令会先询问用户\n- `-a` all 显示所有的套件\n- `-i` 或 `--install`<套件档> 安装指定的套件档\n- `-U` 或 `--upgrade <套件档>` 更新指定的套件档\n- `-e <套件档>` erase 删除指定的套件档\n- `--nodeps` no dependence 不验证套件间的关联性\n- 常用命令：\n    - `rpm -qa` 查看安装的软件\n    - `rpm -e --nodeps <软件名>` 删除软件\n    - `rpm -iph <package>` 安装\n    - `rpm -Uph <软件>` 更新软件\n\n## .15. 服务命令\n\n- `service <service name> restart` 重启服务\n- `service <service name> start` 启动服务\n- `service <service name> stop` 停止服务\n\n## .16. windows10 & Ubuntu\n\n> win10 + ubuntu 双系统安装与使用\n\n## .17. 安装问题\n\n- 目前在台式机双显卡上遇到最大的问题是使用nvidia独显并不能设置分辨率为1920x1080，相反使用核显反而能。但是如果连接核显VGA接口又不能正常启动系统，只能先连接独显DVI－I接口让系统启动，启动后再将连接线接到VGA接口。\n    - [显示器接口认识](https://www.zhihu.com/question/19571221)\n    - [修改分辨率](https://blog.csdn.net/shixin_0125/article/details/72793300)，在使用DVI-I接口时并不能设置成功，只能设置到未连接的VGA 或 HDMI 接口上。\n    - 使用 ｀xrandr｀ 命令查看系统正使用的接口与其分辨率\n- [双系统下时间相差 8 小时](https://www.jianshu.com/p/5c1db6364141)\n- ubuntu 默认使用其 snap 安装软件，其安装的 vscode 被阉割，不能在其中输入中文，需要自行安装完整版。[reference](https://blog.csdn.net/qq_35092399/article/details/105526908)\n- ubuntu 中安装软件包使用 dpkg 命令，一般流程：\n    - 使用 `wget` 下载 `＊.deb` 包，或直接在其官方网站上手动下载其提供的 linux 版本包；\n    - [安装](https://help.ubuntu.com/kubuntu/desktopguide/zh_CN/manual-install.html)。可直接在右击 .deb 文件选择 Kubuntu Package Menu -> install。也可以使用 dpkg 命令安装。卸载时使用 apt-get remove 包名。\n- [禁用启动时显卡加载参数](https://itectec.com/ubuntu/ubuntu-what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean/)\n    - `nomodeset` 添加此参数指令会让 kernel 不加载显卡驱动使用 BIOS 模式也并非一定要 X server 被加载。\n    - `quiet splash` 使用静默状态的启动，否则任何消息会打断 splash 桌面\n\n## .18. 使用\n\n- [在 Ubuntu 中使用 U 盘](https://blog.csdn.net/a999wt/article/details/8227154)\n    - 需要将 U 盘挂载（ `mount` 命令）到系统中，一般使用 /mnt 目录挂载\n    - 挂载后在 /mnt 目录中就可以看到 U 盘内容了。此处有个坑是如果挂载前已经进入 /mnt 目录，挂载后是看不到 U 盘内容的，需要重新进入目录才能看到。\n    - 操作完 U 盘内容后使得命令 `umount` 命令卸载 U 盘。\n        - 卸载 U 盘可能会出现 device is busy 的提示，等一会儿就自动卸载。\n","slug":"Linux/linux","published":1,"updated":"2021-02-24T15:22:22.712Z","comments":1,"photos":[],"link":"","_id":"ckljnokt0006n2bhbdsl5g6je","content":"<h2 id=\"1-tomcat\"><a href=\"#1-tomcat\" class=\"headerlink\" title=\".1. tomcat\"></a>.1. tomcat</h2><p>在 linux 上安装 Tomcat 并启动。(root 123456)<span id=\"more\"></span></p>\n<ol>\n<li>安装 tomcat 后，进入 bin 中启动 <code>./startup.sh</code>;</li>\n<li>必须开启防火墙：<ol>\n<li><code>vim /etc/sysconfig/iptables</code> 打开系统 ip 配置文件</li>\n<li>添加配置 <code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</code><ol>\n<li>(直接调用服务写配置：<code>/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT</code>)</li>\n</ol>\n</li>\n<li>重启防火墙 <code>service iptables restart</code><ol>\n<li>加上路径的命令为： <code>/etc/rc.d/init.d/iptables save</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>通过外部网络可访问 tomcat 了。</li>\n</ol>\n<h2 id=\"2-mysql\"><a href=\"#2-mysql\" class=\"headerlink\" title=\".2. mysql\"></a>.2. mysql</h2><p>在 linux 安装 mysql 并运行。（本地虚拟机上：root 12345）</p>\n<p>问题：March 12 2020 在虚拟机上 linux 设置自动启动 mysql 后，在使用 <code>service mysql stop</code> 命令出现错误：“ERROR! MySQL server PID file could not be found”。最后使用 stackoverflow 上方法解决：<a href=\"https://stackoverflow.com/questions/41616251/error-mysql-server-pid-file-could-not-be-found-in-osx-sierra\">stackoverflow</a></p>\n<ol>\n<li><code>ps -ef | grep mysql --color</code> 查找出正在运行的 mysql 进程；</li>\n<li><code>kill -9 PID</code> 杀掉进程；</li>\n<li>再使用 <code>service mysql start</code> 启动 mysql ，后面再使用 <code>service mysql stop</code> 正常停止 mysql。</li>\n</ol>\n<h2 id=\"3-redis\"><a href=\"#3-redis\" class=\"headerlink\" title=\".3. redis\"></a>.3. redis</h2><p>在 linux 上安装 redis 使用</p>\n<ol>\n<li>编译好 redis 后运行 redis  不能直接使用 <code>redis-server</code> ，需要使用 <code>./redis-server</code> 才能启动；</li>\n<li>修改 redis 服务后台启动：<ol>\n<li>将 redis.conf 文件 copy 到 bin 目录下，将其 <code>daemonize</code> 修改为 <code>yes</code>;</li>\n<li>启动 redis-server 时加上参数：<code>./redis-server redis.conf</code>；</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"4-磁盘管理命令\"><a href=\"#4-磁盘管理命令\" class=\"headerlink\" title=\".4. 磁盘管理命令\"></a>.4. 磁盘管理命令</h2><ul>\n<li><code>ls [参数] [文件或目录]</code> list 查看目录下所有文件<ul>\n<li><code>-a</code> 或 <code>--all</code> 查看全部，包括隐藏的</li>\n<li><code>-l</code> 简化版: <code>ll</code> 详细格式列表</li>\n</ul>\n</li>\n<li><code>cd [目录]</code> change directory<ul>\n<li><code>~</code> 当前用户目录</li>\n<li><code>/</code> 根目录</li>\n<li><code>.</code> 当前目录</li>\n<li><code>..</code> 上级目录</li>\n<li><code>-</code> 上次所在目录</li>\n</ul>\n</li>\n<li><code>pwd</code> print working directory 打印当前所在目录</li>\n<li><code>mkdir</code> make directory</li>\n<li><code>rmdir</code> remove directory 移除空目录</li>\n<li>scp secure copy 可以从远程服务器拷贝，同时加密</li>\n</ul>\n<h2 id=\"5-文件管理\"><a href=\"#5-文件管理\" class=\"headerlink\" title=\".5. 文件管理\"></a>.5. 文件管理</h2><ul>\n<li><code>cat [OPTION]... [FILE]...</code> concatenate 将文件输出级联到另一个文件或终端<ul>\n<li><code>cat &gt; &#123;file&#125;</code> 指定到同一个文件</li>\n</ul>\n</li>\n<li><code>lsb_release [OPTION]</code> 查看系统发布版本</li>\n<li><code>more &#123;file&#125;</code>  分页显示文件内容<ul>\n<li>enter 向下显示一行（默认1行，可定义）</li>\n<li>空格/ctrl+F 显示下一页</li>\n<li><code>B</code>  back 返回上一屏</li>\n<li><code>q</code> 退出 more</li>\n</ul>\n</li>\n<li><code>less [参数] &#123;file&#125;</code><ul>\n<li><code>-m</code> 显示 more 命令一样的 百分比</li>\n<li><code>-N</code> 显示行号</li>\n<li>后续命令<ul>\n<li>空格/page down 向下翻页</li>\n<li>page up/b(back) 向上翻页</li>\n<li>上下方向键/y与enter键 向上下一行</li>\n<li><code>?</code> <code>/</code> 向上/下搜索<ul>\n<li><code>n</code>/<code>N</code> 跳到下一个/上一个查找的结果</li>\n</ul>\n</li>\n<li><code>q</code> 退出</li>\n<li>左右方向键 左右滚屏</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>tail [parameter] [file]</code><ul>\n<li><code>-n</code> 显示行数</li>\n<li><code>-f</code> 动态跟踪文件，查看动态日志</li>\n<li>ctrl + c 退出</li>\n</ul>\n</li>\n<li><code>find [path] [parameter]</code> 在目录中查找文件<ul>\n<li><code>-name</code>  指定字符串作为查找的样本</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-文档编辑\"><a href=\"#6-文档编辑\" class=\"headerlink\" title=\".6. 文档编辑\"></a>.6. 文档编辑</h2><ul>\n<li><code>|</code> 管道命令，一般与 grep 联用，在上一个结果中进行操作下一个命令</li>\n<li><a href=\"https://vim.rtorr.com/\"><code>vim [file]</code> 或者 <code>vi [file]</code> 命令</a> <a href=\"https://spin.atomicobject.com/2016/04/19/vim-commands-cheat-sheet/\">cheat sheet</a><ul>\n<li>进入到文件 vi 编辑状态后，有三种状态：<ul>\n<li>command mode 命令模式，此模式下按 <code>:</code> 进入底行模式， <code>i</code>/<code>a</code>/<code>o</code> 进入到插入模式<ul>\n<li><code>i</code> 在光标前插入 <code>shift + i</code> 在光标所在行前插入</li>\n<li><code>a</code> 在光标后插入， <code>shift + a</code> 在光标所在行最后插入</li>\n<li><code>o</code> 在光标所在行下一行插入新行， <code>shift + o</code> 在光标所在行前一行插入新行</li>\n<li>i - Insert at cursor (goes into insert mode)</li>\n<li>a - Write after cursor (goes into insert mode)</li>\n<li>A - Write at the end of line (goes into insert mode)</li>\n<li>ESC - Terminate insert mode</li>\n<li>u - Undo last change</li>\n<li>U - Undo all changes to the entire line</li>\n<li>o - Open a new line (goes into insert mode)</li>\n<li>dd - Delete line</li>\n<li>3dd - Delete 3 lines.</li>\n<li>D - Delete contents of line after the cursor</li>\n<li>C - Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.</li>\n<li>dw - Delete word</li>\n<li>4dw - Delete 4 words</li>\n<li>cw - Change word</li>\n<li>x - Delete character at the cursor</li>\n<li>r - Replace character</li>\n<li>R - Overwrite characters from cursor onward</li>\n<li>s - Substitute one character under cursor continue to insert</li>\n<li>S - Substitute entire line and begin to insert at the beginning of the line</li>\n<li><code>~</code> Change case of individual character, 前面加上数字将实现指定数量个字符的大小写切换</li>\n</ul>\n</li>\n<li>last line mode 底行模式， w write, q quit 退出到编辑模式, ! force</li>\n<li>insert mode 插入模式，esc 退出到底行模式</li>\n</ul>\n</li>\n<li>copy &amp; paste<ul>\n<li><code>yy</code> 单行复制 yank current line</li>\n<li><code>y$</code> 复制光标到行尾 yank to end of the current line from cursor</li>\n<li><code>yw</code> 复制从光标处到 token 尾 yank from cursor to end of the current word</li>\n<li><code>yW</code> 从光标处复制到 word 尾</li>\n<li><code>nyy</code> n 行复制</li>\n<li><code>p</code>/<code>P</code> 在光标后/前粘贴</li>\n<li><code>gg</code> 到文本第一行</li>\n<li><code>shift + gg</code> 到文本最后一行</li>\n</ul>\n</li>\n<li>delete<ul>\n<li><code>dd</code>删除光标所在行</li>\n<li><code>ndd</code> 删除 n 行</li>\n</ul>\n</li>\n<li><code>u</code> undo</li>\n<li>ctrl + <code>r</code> redo</li>\n<li>Movement<ul>\n<li>h j k l 左下上右四个方向移动 cursor 在前加上数字可实现多个字符的跳动</li>\n<li>b w B W 向 back forward 方向移动整个 token/word ，在其前数字指定移动数量</li>\n<li>^ $ 移动光标到行首尾</li>\n<li>ctrl + u/d 向上下翻页up/down ，cursor 跟着一起翻页</li>\n<li>整页翻页 ctrl-f ctrl-b<ul>\n<li>f 就是forward b就是backward</li>\n<li>翻半页 ctrl-d ctrl-u d=down u=up</li>\n<li>滚一行ctrl-e ctrl-y</li>\n<li>zz 让光标所在的行居屏幕中央</li>\n<li>zt 让光标所在的行居屏幕最上一行 t=top</li>\n<li>zb 让光标所在的行居屏幕最下一行 b=bottom</li>\n</ul>\n</li>\n<li>*<line-number>*G 跳到指定行</li>\n<li>H M L 跳到页面上中下 High Middle Low</li>\n<li><code>*</code> <code>#</code> 下一个与当前 cursor 所在 token 相同的 token ，前面加上数字指定跳跃数量</li>\n<li><code>n</code> <code>N</code> 重复上一次命令结果往上/下找</li>\n<li><code>&#39;&#39;</code> 两次 <code>&#39;</code> ，跳回上一次输入此命令的行首。相当于对特殊行进行一次记录，但只能记录一个历史，感觉没啥用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>grep [parameter] [regular expression] &#123;file&#125;</code> Global Regular expression print 过滤搜索特定字符。匹配到的结果是行，rgep 可以多个，file 也可多个，也可用 * 匹配当前路径所有文件<ul>\n<li><code>-i</code> 或 <code>-ignore-case</code> 忽略大小写</li>\n<li><code>--color[=auto|=never|=always]</code> ：可以将找到的关键词部分加上颜色的显示</li>\n<li><code>-A2</code> after 显示匹配行+其后2行</li>\n<li><code>-B</code> before</li>\n<li><code>-C</code> 前后都有</li>\n<li>c 统计行数</li>\n<li>r recursive 递归查找包括子路径文件</li>\n<li>n number of line 显示行号</li>\n<li>E extend 扩展 regexp</li>\n</ul>\n</li>\n<li>命令行中使用命令<ul>\n<li><code>ctrl + e</code> 移动到行尾 end</li>\n<li><code>ctrl + a</code> 移动到行 首</li>\n<li><code>ctrl + w</code> 删除光标前一个 token</li>\n<li><code>esc + d</code> 删除光标后一个 token</li>\n<li><code>ESC + f</code> 向前移动一个 token</li>\n<li><code>esc + b</code> 向后移动一个 token</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-系统命令\"><a href=\"#7-系统命令\" class=\"headerlink\" title=\".7. 系统命令\"></a>.7. 系统命令</h2><ul>\n<li><code>ps [parameter]</code> process status 进程运行状态<ul>\n<li><code>-e</code> 与 <code>-A</code> 相同显示所有进程</li>\n<li><code>-f</code> 显示UID, PPIP, C, STIME 栏位</li>\n</ul>\n</li>\n<li><code>kill [parameter] [process]</code><ul>\n<li><code>-9 pid</code> 强制终止</li>\n</ul>\n</li>\n<li><code>lscpu</code> 查看 cpu 信息</li>\n<li><code>dpkg --print-architecture</code> <a href=\"https://unix.stackexchange.com/questions/180726/easy-command-line-method-to-determine-specific-arm-architecture-string\">查看指令集</a></li>\n<li>sudo superuser do<ul>\n<li>sudo [command] 给普通用户命令加上超级用户权限</li>\n</ul>\n</li>\n<li>没有安装 systemmd(systemctl) 命令，使用 service {servicename} {start|stop|restart} 代替</li>\n<li><code>uname</code> unix name 查看系统版本信息</li>\n<li><code>update-alternatives [options] command</code> 管理系统可选项命令,建立命令的符号链接<ul>\n<li>当安装多个命令版本时,使用此命令配置各命令的优先级或管理其默认项,在安装 jdk 时需要配合环境变量配置设置系统 java 命令.</li>\n<li><code>update-alternatives --install link name path priority [--slave link name path] ...</code> 可以将命令(path)生成符号链接(name)添加到环境变量目录(link) eg: <code>update-alternatives --install /usr/bin/java java /usr/local/java/jdk-8/bin/java 1</code></li>\n<li><code>--config</code> 交互配置命令,如果需要在命令使用配置,使用 <code>--set</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"8-环境变量设置\"><a href=\"#8-环境变量设置\" class=\"headerlink\" title=\".8. 环境变量设置\"></a>.8. 环境变量设置</h2><blockquote>\n<p><a href=\"https://askubuntu.com/questions/58814/how-do-i-add-environment-variables\">reference</a><br><a href=\"https://help.ubuntu.com/community/EnvironmentVariables\">环境变量设置</a></p>\n</blockquote>\n<ul>\n<li>设置当前 shell 变量 : <code>name=value</code> 此语法设置的变量只在当前 shell 中有效,同时 <strong>不能被当前 shell 启动的进程所读取到</strong>.</li>\n<li>设置当前 shell 变量并对当前 shell 环境启动的进程生效:<code>export [-fn] [name=[value] ...]</code> <code>export -p</code> 给 shell 设置变量.变量域只在当前 shell ,从当前 shell 启动的进程都能读到此变量,而其他 shell 打开的进程不能读取到.<ul>\n<li>将每个 name 变量自动导入到后续执行的命令的环境中, value 使用前需要对其赋值.</li>\n<li>命令选项<ul>\n<li>-f 引用到某个 shell function</li>\n<li>-n 从 name 中移除导出属性 <em>?</em></li>\n<li>-p 显示所有被导入的变量与函数</li>\n<li><code>--</code> 关闭选项处理 <em>?</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>永久地对所有 bush sessions 功能添加变量: 将变量设置行添加到 <code>$HOME/.bashrc</code> 或者 .profile .bash_login 中,三者更推荐 .profile ,其他两个都只是在 shell 执行中会有效,对桌面应用无效.</li>\n<li>系统范围内(所有用户进程)永久添加变量: 添加到 /etc/environment, <code>sudo -H gedit /etc/environment</code>. 格式: <code>VARNAME=&quot;value&quot;</code>.或者在 /etc/profile.d/ 中添加脚本,脚本中使用 export 添加环境变量.此目录中的脚本都会在所有用户所有 shell 执行前先执行.<ul>\n<li>需要重新登录当前用户才能对当前用户生效.</li>\n</ul>\n</li>\n<li><code>source &lt;filename&gt; [arguments]</code> 在当前 shell 中读取并执行文件中的命令, $PATH 中的变量会被用来查询在文件中指定的目录.如果参数 arguments 提供了,会被用来当作 shell 执行的位置参数(参数顺序被指定可以在 shell 中的使用 $n 获取). source 命令快捷方式: <code>.</code> .</li>\n</ul>\n<h2 id=\"9-firewall-防火墙\"><a href=\"#9-firewall-防火墙\" class=\"headerlink\" title=\".9. firewall 防火墙\"></a>.9. firewall 防火墙</h2><p><a href=\"https://blog.csdn.net/u011846257/article/details/54707864\">reference</a></p>\n<p>添加 iptables 规则时需要将其添加成 REJECT 所有其他的端口之前，否则将无效。</p>\n<h2 id=\"10-备份压缩\"><a href=\"#10-备份压缩\" class=\"headerlink\" title=\".10. 备份压缩\"></a>.10. 备份压缩</h2><blockquote>\n<p><a href=\"https://www.quora.com/What-is-the-difference-between-tar-gz-zip-and-tar-gz-in-Linux#:~:text=gz%20is%20a%20single%20file,an%20arbitrary%20number%20of%20filed.\">difference between .gz and .tar</a></p>\n</blockquote>\n<ul>\n<li><code>.gz</code> 文件是使用 gzip 压缩过的文件后缀，而 tar 只是用于将多个文件进行打包并不包含压缩。</li>\n<li><code>tar</code><ul>\n<li><code>-c</code> create 创建归档</li>\n<li><code>-x</code> extract 解档</li>\n<li><code>-z</code> 使用 <strong>gzip</strong> 压缩</li>\n<li><code>-v</code> verbose 显示压缩的文件</li>\n<li><code>-f</code> file 是否使用档名</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"11-关机重启\"><a href=\"#11-关机重启\" class=\"headerlink\" title=\".11. 关机重启\"></a>.11. 关机重启</h2><ul>\n<li><code>reboot</code> 重启 CentOS</li>\n<li><code>halt</code> 关机 CentOS</li>\n<li>debian<ul>\n<li>reboot</li>\n<li>shutdown</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"12-文件权限\"><a href=\"#12-文件权限\" class=\"headerlink\" title=\".12. 文件权限\"></a>.12. 文件权限</h2><p><code>chmod [parameter] &lt;权限范围&gt; &lt;符号&gt;&lt;权限代码&gt;</code> change mode 更改权限</p>\n<ul>\n<li><code>-R</code> 或 <code>-recursive</code> 递归将文件夹中所有文件都更改</li>\n<li>权限范围<ul>\n<li><code>u</code> user</li>\n<li><code>g</code> group</li>\n<li><code>o</code> other</li>\n<li><code>a</code> all</li>\n</ul>\n</li>\n<li>权限符号<ul>\n<li><code>+</code> 添加</li>\n<li><code>-</code> 取消</li>\n</ul>\n</li>\n<li>权限代号<ul>\n<li><code>r</code> read 4</li>\n<li><code>w</code> write 2</li>\n<li><code>x</code> execute 1</li>\n<li><code>-</code> none 0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"13-网络配置\"><a href=\"#13-网络配置\" class=\"headerlink\" title=\".13. 网络配置\"></a>.13. 网络配置</h2><p>查看 网络配置 文件位置: <code>/etc/sysconfig/networking-scripts/ifcfg-eth0</code></p>\n<h3 id=\"13-1-windows-operation\"><a href=\"#13-1-windows-operation\" class=\"headerlink\" title=\".13.1. windows operation\"></a>.13.1. windows operation</h3><p>windows 操作系统中相关命令行。</p>\n<ul>\n<li>刷新 dns 数据命令：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ipconfig/flushdns</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查看电脑网络端口使用情况，类似于在 linux 中使用 <code>ps</code> 命令<ul>\n<li><code>netstat -ano</code> 命令行命令可以看到各个进程 pid 与 address 占用情况</li>\n<li><code>netstat -ano|findstr portNum</code> 查看指定端口占用情况，这儿查看的端口占用包括了本地地址的占用与外部地址的占用</li>\n<li><code>tasklist|findstr &#39;pid&#39;</code> 查看指定 pid 的进程使用</li>\n<li><code>taskkill /pid pid /f</code> 杀死进程 pid 指 progress id 进程 id<ul>\n<li>前两个步骤任选一个与最后个连用就可查找出端口被哪个进程给占用。</li>\n<li>也可以使用前两个步骤配合任务管理器查找，相对于命令行来说更直观。</li>\n<li>在 windows 系统中可用，不知在 linux 中是否可用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"14-rpm\"><a href=\"#14-rpm\" class=\"headerlink\" title=\".14. rpm\"></a>.14. rpm</h2><blockquote>\n<p>resources package manager 资源包管理器，其相应的包文件后缀为 <code>.rpm</code> 在 red hat/Fedora/SUSE 系列使用此包管理，而在 Debian/Ubuntu 系列使用 <code>dpkg</code> 命令，其包文件后缀为 <code>.deb</code> 。</p>\n</blockquote>\n<p>command lind : `rpm [parameter] [软件]</p>\n<p>使用 rpm 管理系统软件包，可以定制软件的更新、安装与卸载。<a href=\"https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/\">reference</a></p>\n<ol>\n<li>下载软件包的 rpm 文件，再使用 rpm 命令安装仓库</li>\n<li>安装后，可以使用 yum-util 的 yum-config-manager 管理包，也可以直接进入 /etc/yum.repos.d/{software}.repo 文件查看管理软件包数据</li>\n<li>使用 yum install {software} 安装软件，安装时会自动根据其 repo 仓库配置文件安装指定的软件版本</li>\n</ol>\n<ul>\n<li><code>-v</code> verbose 显示指令执行过程</li>\n<li><code>-h</code> 或 <code>--hash</code> 套件安装时显示列出指令</li>\n<li><code>-q</code> question 询问模式，遇到问题时指令会先询问用户</li>\n<li><code>-a</code> all 显示所有的套件</li>\n<li><code>-i</code> 或 <code>--install</code>&lt;套件档&gt; 安装指定的套件档</li>\n<li><code>-U</code> 或 <code>--upgrade &lt;套件档&gt;</code> 更新指定的套件档</li>\n<li><code>-e &lt;套件档&gt;</code> erase 删除指定的套件档</li>\n<li><code>--nodeps</code> no dependence 不验证套件间的关联性</li>\n<li>常用命令：<ul>\n<li><code>rpm -qa</code> 查看安装的软件</li>\n<li><code>rpm -e --nodeps &lt;软件名&gt;</code> 删除软件</li>\n<li><code>rpm -iph &lt;package&gt;</code> 安装</li>\n<li><code>rpm -Uph &lt;软件&gt;</code> 更新软件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"15-服务命令\"><a href=\"#15-服务命令\" class=\"headerlink\" title=\".15. 服务命令\"></a>.15. 服务命令</h2><ul>\n<li><code>service &lt;service name&gt; restart</code> 重启服务</li>\n<li><code>service &lt;service name&gt; start</code> 启动服务</li>\n<li><code>service &lt;service name&gt; stop</code> 停止服务</li>\n</ul>\n<h2 id=\"16-windows10-amp-Ubuntu\"><a href=\"#16-windows10-amp-Ubuntu\" class=\"headerlink\" title=\".16. windows10 &amp; Ubuntu\"></a>.16. windows10 &amp; Ubuntu</h2><blockquote>\n<p>win10 + ubuntu 双系统安装与使用</p>\n</blockquote>\n<h2 id=\"17-安装问题\"><a href=\"#17-安装问题\" class=\"headerlink\" title=\".17. 安装问题\"></a>.17. 安装问题</h2><ul>\n<li>目前在台式机双显卡上遇到最大的问题是使用nvidia独显并不能设置分辨率为1920x1080，相反使用核显反而能。但是如果连接核显VGA接口又不能正常启动系统，只能先连接独显DVI－I接口让系统启动，启动后再将连接线接到VGA接口。<ul>\n<li><a href=\"https://www.zhihu.com/question/19571221\">显示器接口认识</a></li>\n<li><a href=\"https://blog.csdn.net/shixin_0125/article/details/72793300\">修改分辨率</a>，在使用DVI-I接口时并不能设置成功，只能设置到未连接的VGA 或 HDMI 接口上。</li>\n<li>使用 ｀xrandr｀ 命令查看系统正使用的接口与其分辨率</li>\n</ul>\n</li>\n<li><a href=\"https://www.jianshu.com/p/5c1db6364141\">双系统下时间相差 8 小时</a></li>\n<li>ubuntu 默认使用其 snap 安装软件，其安装的 vscode 被阉割，不能在其中输入中文，需要自行安装完整版。<a href=\"https://blog.csdn.net/qq_35092399/article/details/105526908\">reference</a></li>\n<li>ubuntu 中安装软件包使用 dpkg 命令，一般流程：<ul>\n<li>使用 <code>wget</code> 下载 <code>＊.deb</code> 包，或直接在其官方网站上手动下载其提供的 linux 版本包；</li>\n<li><a href=\"https://help.ubuntu.com/kubuntu/desktopguide/zh_CN/manual-install.html\">安装</a>。可直接在右击 .deb 文件选择 Kubuntu Package Menu -&gt; install。也可以使用 dpkg 命令安装。卸载时使用 apt-get remove 包名。</li>\n</ul>\n</li>\n<li><a href=\"https://itectec.com/ubuntu/ubuntu-what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean/\">禁用启动时显卡加载参数</a><ul>\n<li><code>nomodeset</code> 添加此参数指令会让 kernel 不加载显卡驱动使用 BIOS 模式也并非一定要 X server 被加载。</li>\n<li><code>quiet splash</code> 使用静默状态的启动，否则任何消息会打断 splash 桌面</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"18-使用\"><a href=\"#18-使用\" class=\"headerlink\" title=\".18. 使用\"></a>.18. 使用</h2><ul>\n<li><a href=\"https://blog.csdn.net/a999wt/article/details/8227154\">在 Ubuntu 中使用 U 盘</a><ul>\n<li>需要将 U 盘挂载（ <code>mount</code> 命令）到系统中，一般使用 /mnt 目录挂载</li>\n<li>挂载后在 /mnt 目录中就可以看到 U 盘内容了。此处有个坑是如果挂载前已经进入 /mnt 目录，挂载后是看不到 U 盘内容的，需要重新进入目录才能看到。</li>\n<li>操作完 U 盘内容后使得命令 <code>umount</code> 命令卸载 U 盘。<ul>\n<li>卸载 U 盘可能会出现 device is busy 的提示，等一会儿就自动卸载。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-tomcat\"><a href=\"#1-tomcat\" class=\"headerlink\" title=\".1. tomcat\"></a>.1. tomcat</h2><p>在 linux 上安装 Tomcat 并启动。(root 123456)","more":"</p>\n<ol>\n<li>安装 tomcat 后，进入 bin 中启动 <code>./startup.sh</code>;</li>\n<li>必须开启防火墙：<ol>\n<li><code>vim /etc/sysconfig/iptables</code> 打开系统 ip 配置文件</li>\n<li>添加配置 <code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</code><ol>\n<li>(直接调用服务写配置：<code>/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT</code>)</li>\n</ol>\n</li>\n<li>重启防火墙 <code>service iptables restart</code><ol>\n<li>加上路径的命令为： <code>/etc/rc.d/init.d/iptables save</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>通过外部网络可访问 tomcat 了。</li>\n</ol>\n<h2 id=\"2-mysql\"><a href=\"#2-mysql\" class=\"headerlink\" title=\".2. mysql\"></a>.2. mysql</h2><p>在 linux 安装 mysql 并运行。（本地虚拟机上：root 12345）</p>\n<p>问题：March 12 2020 在虚拟机上 linux 设置自动启动 mysql 后，在使用 <code>service mysql stop</code> 命令出现错误：“ERROR! MySQL server PID file could not be found”。最后使用 stackoverflow 上方法解决：<a href=\"https://stackoverflow.com/questions/41616251/error-mysql-server-pid-file-could-not-be-found-in-osx-sierra\">stackoverflow</a></p>\n<ol>\n<li><code>ps -ef | grep mysql --color</code> 查找出正在运行的 mysql 进程；</li>\n<li><code>kill -9 PID</code> 杀掉进程；</li>\n<li>再使用 <code>service mysql start</code> 启动 mysql ，后面再使用 <code>service mysql stop</code> 正常停止 mysql。</li>\n</ol>\n<h2 id=\"3-redis\"><a href=\"#3-redis\" class=\"headerlink\" title=\".3. redis\"></a>.3. redis</h2><p>在 linux 上安装 redis 使用</p>\n<ol>\n<li>编译好 redis 后运行 redis  不能直接使用 <code>redis-server</code> ，需要使用 <code>./redis-server</code> 才能启动；</li>\n<li>修改 redis 服务后台启动：<ol>\n<li>将 redis.conf 文件 copy 到 bin 目录下，将其 <code>daemonize</code> 修改为 <code>yes</code>;</li>\n<li>启动 redis-server 时加上参数：<code>./redis-server redis.conf</code>；</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"4-磁盘管理命令\"><a href=\"#4-磁盘管理命令\" class=\"headerlink\" title=\".4. 磁盘管理命令\"></a>.4. 磁盘管理命令</h2><ul>\n<li><code>ls [参数] [文件或目录]</code> list 查看目录下所有文件<ul>\n<li><code>-a</code> 或 <code>--all</code> 查看全部，包括隐藏的</li>\n<li><code>-l</code> 简化版: <code>ll</code> 详细格式列表</li>\n</ul>\n</li>\n<li><code>cd [目录]</code> change directory<ul>\n<li><code>~</code> 当前用户目录</li>\n<li><code>/</code> 根目录</li>\n<li><code>.</code> 当前目录</li>\n<li><code>..</code> 上级目录</li>\n<li><code>-</code> 上次所在目录</li>\n</ul>\n</li>\n<li><code>pwd</code> print working directory 打印当前所在目录</li>\n<li><code>mkdir</code> make directory</li>\n<li><code>rmdir</code> remove directory 移除空目录</li>\n<li>scp secure copy 可以从远程服务器拷贝，同时加密</li>\n</ul>\n<h2 id=\"5-文件管理\"><a href=\"#5-文件管理\" class=\"headerlink\" title=\".5. 文件管理\"></a>.5. 文件管理</h2><ul>\n<li><code>cat [OPTION]... [FILE]...</code> concatenate 将文件输出级联到另一个文件或终端<ul>\n<li><code>cat &gt; &#123;file&#125;</code> 指定到同一个文件</li>\n</ul>\n</li>\n<li><code>lsb_release [OPTION]</code> 查看系统发布版本</li>\n<li><code>more &#123;file&#125;</code>  分页显示文件内容<ul>\n<li>enter 向下显示一行（默认1行，可定义）</li>\n<li>空格/ctrl+F 显示下一页</li>\n<li><code>B</code>  back 返回上一屏</li>\n<li><code>q</code> 退出 more</li>\n</ul>\n</li>\n<li><code>less [参数] &#123;file&#125;</code><ul>\n<li><code>-m</code> 显示 more 命令一样的 百分比</li>\n<li><code>-N</code> 显示行号</li>\n<li>后续命令<ul>\n<li>空格/page down 向下翻页</li>\n<li>page up/b(back) 向上翻页</li>\n<li>上下方向键/y与enter键 向上下一行</li>\n<li><code>?</code> <code>/</code> 向上/下搜索<ul>\n<li><code>n</code>/<code>N</code> 跳到下一个/上一个查找的结果</li>\n</ul>\n</li>\n<li><code>q</code> 退出</li>\n<li>左右方向键 左右滚屏</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>tail [parameter] [file]</code><ul>\n<li><code>-n</code> 显示行数</li>\n<li><code>-f</code> 动态跟踪文件，查看动态日志</li>\n<li>ctrl + c 退出</li>\n</ul>\n</li>\n<li><code>find [path] [parameter]</code> 在目录中查找文件<ul>\n<li><code>-name</code>  指定字符串作为查找的样本</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-文档编辑\"><a href=\"#6-文档编辑\" class=\"headerlink\" title=\".6. 文档编辑\"></a>.6. 文档编辑</h2><ul>\n<li><code>|</code> 管道命令，一般与 grep 联用，在上一个结果中进行操作下一个命令</li>\n<li><a href=\"https://vim.rtorr.com/\"><code>vim [file]</code> 或者 <code>vi [file]</code> 命令</a> <a href=\"https://spin.atomicobject.com/2016/04/19/vim-commands-cheat-sheet/\">cheat sheet</a><ul>\n<li>进入到文件 vi 编辑状态后，有三种状态：<ul>\n<li>command mode 命令模式，此模式下按 <code>:</code> 进入底行模式， <code>i</code>/<code>a</code>/<code>o</code> 进入到插入模式<ul>\n<li><code>i</code> 在光标前插入 <code>shift + i</code> 在光标所在行前插入</li>\n<li><code>a</code> 在光标后插入， <code>shift + a</code> 在光标所在行最后插入</li>\n<li><code>o</code> 在光标所在行下一行插入新行， <code>shift + o</code> 在光标所在行前一行插入新行</li>\n<li>i - Insert at cursor (goes into insert mode)</li>\n<li>a - Write after cursor (goes into insert mode)</li>\n<li>A - Write at the end of line (goes into insert mode)</li>\n<li>ESC - Terminate insert mode</li>\n<li>u - Undo last change</li>\n<li>U - Undo all changes to the entire line</li>\n<li>o - Open a new line (goes into insert mode)</li>\n<li>dd - Delete line</li>\n<li>3dd - Delete 3 lines.</li>\n<li>D - Delete contents of line after the cursor</li>\n<li>C - Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.</li>\n<li>dw - Delete word</li>\n<li>4dw - Delete 4 words</li>\n<li>cw - Change word</li>\n<li>x - Delete character at the cursor</li>\n<li>r - Replace character</li>\n<li>R - Overwrite characters from cursor onward</li>\n<li>s - Substitute one character under cursor continue to insert</li>\n<li>S - Substitute entire line and begin to insert at the beginning of the line</li>\n<li><code>~</code> Change case of individual character, 前面加上数字将实现指定数量个字符的大小写切换</li>\n</ul>\n</li>\n<li>last line mode 底行模式， w write, q quit 退出到编辑模式, ! force</li>\n<li>insert mode 插入模式，esc 退出到底行模式</li>\n</ul>\n</li>\n<li>copy &amp; paste<ul>\n<li><code>yy</code> 单行复制 yank current line</li>\n<li><code>y$</code> 复制光标到行尾 yank to end of the current line from cursor</li>\n<li><code>yw</code> 复制从光标处到 token 尾 yank from cursor to end of the current word</li>\n<li><code>yW</code> 从光标处复制到 word 尾</li>\n<li><code>nyy</code> n 行复制</li>\n<li><code>p</code>/<code>P</code> 在光标后/前粘贴</li>\n<li><code>gg</code> 到文本第一行</li>\n<li><code>shift + gg</code> 到文本最后一行</li>\n</ul>\n</li>\n<li>delete<ul>\n<li><code>dd</code>删除光标所在行</li>\n<li><code>ndd</code> 删除 n 行</li>\n</ul>\n</li>\n<li><code>u</code> undo</li>\n<li>ctrl + <code>r</code> redo</li>\n<li>Movement<ul>\n<li>h j k l 左下上右四个方向移动 cursor 在前加上数字可实现多个字符的跳动</li>\n<li>b w B W 向 back forward 方向移动整个 token/word ，在其前数字指定移动数量</li>\n<li>^ $ 移动光标到行首尾</li>\n<li>ctrl + u/d 向上下翻页up/down ，cursor 跟着一起翻页</li>\n<li>整页翻页 ctrl-f ctrl-b<ul>\n<li>f 就是forward b就是backward</li>\n<li>翻半页 ctrl-d ctrl-u d=down u=up</li>\n<li>滚一行ctrl-e ctrl-y</li>\n<li>zz 让光标所在的行居屏幕中央</li>\n<li>zt 让光标所在的行居屏幕最上一行 t=top</li>\n<li>zb 让光标所在的行居屏幕最下一行 b=bottom</li>\n</ul>\n</li>\n<li>*<line-number>*G 跳到指定行</li>\n<li>H M L 跳到页面上中下 High Middle Low</li>\n<li><code>*</code> <code>#</code> 下一个与当前 cursor 所在 token 相同的 token ，前面加上数字指定跳跃数量</li>\n<li><code>n</code> <code>N</code> 重复上一次命令结果往上/下找</li>\n<li><code>&#39;&#39;</code> 两次 <code>&#39;</code> ，跳回上一次输入此命令的行首。相当于对特殊行进行一次记录，但只能记录一个历史，感觉没啥用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>grep [parameter] [regular expression] &#123;file&#125;</code> Global Regular expression print 过滤搜索特定字符。匹配到的结果是行，rgep 可以多个，file 也可多个，也可用 * 匹配当前路径所有文件<ul>\n<li><code>-i</code> 或 <code>-ignore-case</code> 忽略大小写</li>\n<li><code>--color[=auto|=never|=always]</code> ：可以将找到的关键词部分加上颜色的显示</li>\n<li><code>-A2</code> after 显示匹配行+其后2行</li>\n<li><code>-B</code> before</li>\n<li><code>-C</code> 前后都有</li>\n<li>c 统计行数</li>\n<li>r recursive 递归查找包括子路径文件</li>\n<li>n number of line 显示行号</li>\n<li>E extend 扩展 regexp</li>\n</ul>\n</li>\n<li>命令行中使用命令<ul>\n<li><code>ctrl + e</code> 移动到行尾 end</li>\n<li><code>ctrl + a</code> 移动到行 首</li>\n<li><code>ctrl + w</code> 删除光标前一个 token</li>\n<li><code>esc + d</code> 删除光标后一个 token</li>\n<li><code>ESC + f</code> 向前移动一个 token</li>\n<li><code>esc + b</code> 向后移动一个 token</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-系统命令\"><a href=\"#7-系统命令\" class=\"headerlink\" title=\".7. 系统命令\"></a>.7. 系统命令</h2><ul>\n<li><code>ps [parameter]</code> process status 进程运行状态<ul>\n<li><code>-e</code> 与 <code>-A</code> 相同显示所有进程</li>\n<li><code>-f</code> 显示UID, PPIP, C, STIME 栏位</li>\n</ul>\n</li>\n<li><code>kill [parameter] [process]</code><ul>\n<li><code>-9 pid</code> 强制终止</li>\n</ul>\n</li>\n<li><code>lscpu</code> 查看 cpu 信息</li>\n<li><code>dpkg --print-architecture</code> <a href=\"https://unix.stackexchange.com/questions/180726/easy-command-line-method-to-determine-specific-arm-architecture-string\">查看指令集</a></li>\n<li>sudo superuser do<ul>\n<li>sudo [command] 给普通用户命令加上超级用户权限</li>\n</ul>\n</li>\n<li>没有安装 systemmd(systemctl) 命令，使用 service {servicename} {start|stop|restart} 代替</li>\n<li><code>uname</code> unix name 查看系统版本信息</li>\n<li><code>update-alternatives [options] command</code> 管理系统可选项命令,建立命令的符号链接<ul>\n<li>当安装多个命令版本时,使用此命令配置各命令的优先级或管理其默认项,在安装 jdk 时需要配合环境变量配置设置系统 java 命令.</li>\n<li><code>update-alternatives --install link name path priority [--slave link name path] ...</code> 可以将命令(path)生成符号链接(name)添加到环境变量目录(link) eg: <code>update-alternatives --install /usr/bin/java java /usr/local/java/jdk-8/bin/java 1</code></li>\n<li><code>--config</code> 交互配置命令,如果需要在命令使用配置,使用 <code>--set</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"8-环境变量设置\"><a href=\"#8-环境变量设置\" class=\"headerlink\" title=\".8. 环境变量设置\"></a>.8. 环境变量设置</h2><blockquote>\n<p><a href=\"https://askubuntu.com/questions/58814/how-do-i-add-environment-variables\">reference</a><br><a href=\"https://help.ubuntu.com/community/EnvironmentVariables\">环境变量设置</a></p>\n</blockquote>\n<ul>\n<li>设置当前 shell 变量 : <code>name=value</code> 此语法设置的变量只在当前 shell 中有效,同时 <strong>不能被当前 shell 启动的进程所读取到</strong>.</li>\n<li>设置当前 shell 变量并对当前 shell 环境启动的进程生效:<code>export [-fn] [name=[value] ...]</code> <code>export -p</code> 给 shell 设置变量.变量域只在当前 shell ,从当前 shell 启动的进程都能读到此变量,而其他 shell 打开的进程不能读取到.<ul>\n<li>将每个 name 变量自动导入到后续执行的命令的环境中, value 使用前需要对其赋值.</li>\n<li>命令选项<ul>\n<li>-f 引用到某个 shell function</li>\n<li>-n 从 name 中移除导出属性 <em>?</em></li>\n<li>-p 显示所有被导入的变量与函数</li>\n<li><code>--</code> 关闭选项处理 <em>?</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>永久地对所有 bush sessions 功能添加变量: 将变量设置行添加到 <code>$HOME/.bashrc</code> 或者 .profile .bash_login 中,三者更推荐 .profile ,其他两个都只是在 shell 执行中会有效,对桌面应用无效.</li>\n<li>系统范围内(所有用户进程)永久添加变量: 添加到 /etc/environment, <code>sudo -H gedit /etc/environment</code>. 格式: <code>VARNAME=&quot;value&quot;</code>.或者在 /etc/profile.d/ 中添加脚本,脚本中使用 export 添加环境变量.此目录中的脚本都会在所有用户所有 shell 执行前先执行.<ul>\n<li>需要重新登录当前用户才能对当前用户生效.</li>\n</ul>\n</li>\n<li><code>source &lt;filename&gt; [arguments]</code> 在当前 shell 中读取并执行文件中的命令, $PATH 中的变量会被用来查询在文件中指定的目录.如果参数 arguments 提供了,会被用来当作 shell 执行的位置参数(参数顺序被指定可以在 shell 中的使用 $n 获取). source 命令快捷方式: <code>.</code> .</li>\n</ul>\n<h2 id=\"9-firewall-防火墙\"><a href=\"#9-firewall-防火墙\" class=\"headerlink\" title=\".9. firewall 防火墙\"></a>.9. firewall 防火墙</h2><p><a href=\"https://blog.csdn.net/u011846257/article/details/54707864\">reference</a></p>\n<p>添加 iptables 规则时需要将其添加成 REJECT 所有其他的端口之前，否则将无效。</p>\n<h2 id=\"10-备份压缩\"><a href=\"#10-备份压缩\" class=\"headerlink\" title=\".10. 备份压缩\"></a>.10. 备份压缩</h2><blockquote>\n<p><a href=\"https://www.quora.com/What-is-the-difference-between-tar-gz-zip-and-tar-gz-in-Linux#:~:text=gz%20is%20a%20single%20file,an%20arbitrary%20number%20of%20filed.\">difference between .gz and .tar</a></p>\n</blockquote>\n<ul>\n<li><code>.gz</code> 文件是使用 gzip 压缩过的文件后缀，而 tar 只是用于将多个文件进行打包并不包含压缩。</li>\n<li><code>tar</code><ul>\n<li><code>-c</code> create 创建归档</li>\n<li><code>-x</code> extract 解档</li>\n<li><code>-z</code> 使用 <strong>gzip</strong> 压缩</li>\n<li><code>-v</code> verbose 显示压缩的文件</li>\n<li><code>-f</code> file 是否使用档名</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"11-关机重启\"><a href=\"#11-关机重启\" class=\"headerlink\" title=\".11. 关机重启\"></a>.11. 关机重启</h2><ul>\n<li><code>reboot</code> 重启 CentOS</li>\n<li><code>halt</code> 关机 CentOS</li>\n<li>debian<ul>\n<li>reboot</li>\n<li>shutdown</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"12-文件权限\"><a href=\"#12-文件权限\" class=\"headerlink\" title=\".12. 文件权限\"></a>.12. 文件权限</h2><p><code>chmod [parameter] &lt;权限范围&gt; &lt;符号&gt;&lt;权限代码&gt;</code> change mode 更改权限</p>\n<ul>\n<li><code>-R</code> 或 <code>-recursive</code> 递归将文件夹中所有文件都更改</li>\n<li>权限范围<ul>\n<li><code>u</code> user</li>\n<li><code>g</code> group</li>\n<li><code>o</code> other</li>\n<li><code>a</code> all</li>\n</ul>\n</li>\n<li>权限符号<ul>\n<li><code>+</code> 添加</li>\n<li><code>-</code> 取消</li>\n</ul>\n</li>\n<li>权限代号<ul>\n<li><code>r</code> read 4</li>\n<li><code>w</code> write 2</li>\n<li><code>x</code> execute 1</li>\n<li><code>-</code> none 0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"13-网络配置\"><a href=\"#13-网络配置\" class=\"headerlink\" title=\".13. 网络配置\"></a>.13. 网络配置</h2><p>查看 网络配置 文件位置: <code>/etc/sysconfig/networking-scripts/ifcfg-eth0</code></p>\n<h3 id=\"13-1-windows-operation\"><a href=\"#13-1-windows-operation\" class=\"headerlink\" title=\".13.1. windows operation\"></a>.13.1. windows operation</h3><p>windows 操作系统中相关命令行。</p>\n<ul>\n<li>刷新 dns 数据命令：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ipconfig/flushdns</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查看电脑网络端口使用情况，类似于在 linux 中使用 <code>ps</code> 命令<ul>\n<li><code>netstat -ano</code> 命令行命令可以看到各个进程 pid 与 address 占用情况</li>\n<li><code>netstat -ano|findstr portNum</code> 查看指定端口占用情况，这儿查看的端口占用包括了本地地址的占用与外部地址的占用</li>\n<li><code>tasklist|findstr &#39;pid&#39;</code> 查看指定 pid 的进程使用</li>\n<li><code>taskkill /pid pid /f</code> 杀死进程 pid 指 progress id 进程 id<ul>\n<li>前两个步骤任选一个与最后个连用就可查找出端口被哪个进程给占用。</li>\n<li>也可以使用前两个步骤配合任务管理器查找，相对于命令行来说更直观。</li>\n<li>在 windows 系统中可用，不知在 linux 中是否可用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"14-rpm\"><a href=\"#14-rpm\" class=\"headerlink\" title=\".14. rpm\"></a>.14. rpm</h2><blockquote>\n<p>resources package manager 资源包管理器，其相应的包文件后缀为 <code>.rpm</code> 在 red hat/Fedora/SUSE 系列使用此包管理，而在 Debian/Ubuntu 系列使用 <code>dpkg</code> 命令，其包文件后缀为 <code>.deb</code> 。</p>\n</blockquote>\n<p>command lind : `rpm [parameter] [软件]</p>\n<p>使用 rpm 管理系统软件包，可以定制软件的更新、安装与卸载。<a href=\"https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/\">reference</a></p>\n<ol>\n<li>下载软件包的 rpm 文件，再使用 rpm 命令安装仓库</li>\n<li>安装后，可以使用 yum-util 的 yum-config-manager 管理包，也可以直接进入 /etc/yum.repos.d/{software}.repo 文件查看管理软件包数据</li>\n<li>使用 yum install {software} 安装软件，安装时会自动根据其 repo 仓库配置文件安装指定的软件版本</li>\n</ol>\n<ul>\n<li><code>-v</code> verbose 显示指令执行过程</li>\n<li><code>-h</code> 或 <code>--hash</code> 套件安装时显示列出指令</li>\n<li><code>-q</code> question 询问模式，遇到问题时指令会先询问用户</li>\n<li><code>-a</code> all 显示所有的套件</li>\n<li><code>-i</code> 或 <code>--install</code>&lt;套件档&gt; 安装指定的套件档</li>\n<li><code>-U</code> 或 <code>--upgrade &lt;套件档&gt;</code> 更新指定的套件档</li>\n<li><code>-e &lt;套件档&gt;</code> erase 删除指定的套件档</li>\n<li><code>--nodeps</code> no dependence 不验证套件间的关联性</li>\n<li>常用命令：<ul>\n<li><code>rpm -qa</code> 查看安装的软件</li>\n<li><code>rpm -e --nodeps &lt;软件名&gt;</code> 删除软件</li>\n<li><code>rpm -iph &lt;package&gt;</code> 安装</li>\n<li><code>rpm -Uph &lt;软件&gt;</code> 更新软件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"15-服务命令\"><a href=\"#15-服务命令\" class=\"headerlink\" title=\".15. 服务命令\"></a>.15. 服务命令</h2><ul>\n<li><code>service &lt;service name&gt; restart</code> 重启服务</li>\n<li><code>service &lt;service name&gt; start</code> 启动服务</li>\n<li><code>service &lt;service name&gt; stop</code> 停止服务</li>\n</ul>\n<h2 id=\"16-windows10-amp-Ubuntu\"><a href=\"#16-windows10-amp-Ubuntu\" class=\"headerlink\" title=\".16. windows10 &amp; Ubuntu\"></a>.16. windows10 &amp; Ubuntu</h2><blockquote>\n<p>win10 + ubuntu 双系统安装与使用</p>\n</blockquote>\n<h2 id=\"17-安装问题\"><a href=\"#17-安装问题\" class=\"headerlink\" title=\".17. 安装问题\"></a>.17. 安装问题</h2><ul>\n<li>目前在台式机双显卡上遇到最大的问题是使用nvidia独显并不能设置分辨率为1920x1080，相反使用核显反而能。但是如果连接核显VGA接口又不能正常启动系统，只能先连接独显DVI－I接口让系统启动，启动后再将连接线接到VGA接口。<ul>\n<li><a href=\"https://www.zhihu.com/question/19571221\">显示器接口认识</a></li>\n<li><a href=\"https://blog.csdn.net/shixin_0125/article/details/72793300\">修改分辨率</a>，在使用DVI-I接口时并不能设置成功，只能设置到未连接的VGA 或 HDMI 接口上。</li>\n<li>使用 ｀xrandr｀ 命令查看系统正使用的接口与其分辨率</li>\n</ul>\n</li>\n<li><a href=\"https://www.jianshu.com/p/5c1db6364141\">双系统下时间相差 8 小时</a></li>\n<li>ubuntu 默认使用其 snap 安装软件，其安装的 vscode 被阉割，不能在其中输入中文，需要自行安装完整版。<a href=\"https://blog.csdn.net/qq_35092399/article/details/105526908\">reference</a></li>\n<li>ubuntu 中安装软件包使用 dpkg 命令，一般流程：<ul>\n<li>使用 <code>wget</code> 下载 <code>＊.deb</code> 包，或直接在其官方网站上手动下载其提供的 linux 版本包；</li>\n<li><a href=\"https://help.ubuntu.com/kubuntu/desktopguide/zh_CN/manual-install.html\">安装</a>。可直接在右击 .deb 文件选择 Kubuntu Package Menu -&gt; install。也可以使用 dpkg 命令安装。卸载时使用 apt-get remove 包名。</li>\n</ul>\n</li>\n<li><a href=\"https://itectec.com/ubuntu/ubuntu-what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean/\">禁用启动时显卡加载参数</a><ul>\n<li><code>nomodeset</code> 添加此参数指令会让 kernel 不加载显卡驱动使用 BIOS 模式也并非一定要 X server 被加载。</li>\n<li><code>quiet splash</code> 使用静默状态的启动，否则任何消息会打断 splash 桌面</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"18-使用\"><a href=\"#18-使用\" class=\"headerlink\" title=\".18. 使用\"></a>.18. 使用</h2><ul>\n<li><a href=\"https://blog.csdn.net/a999wt/article/details/8227154\">在 Ubuntu 中使用 U 盘</a><ul>\n<li>需要将 U 盘挂载（ <code>mount</code> 命令）到系统中，一般使用 /mnt 目录挂载</li>\n<li>挂载后在 /mnt 目录中就可以看到 U 盘内容了。此处有个坑是如果挂载前已经进入 /mnt 目录，挂载后是看不到 U 盘内容的，需要重新进入目录才能看到。</li>\n<li>操作完 U 盘内容后使得命令 <code>umount</code> 命令卸载 U 盘。<ul>\n<li>卸载 U 盘可能会出现 device is busy 的提示，等一会儿就自动卸载。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"layout":"post","title":"Spring IoC","date":"2017-09-15T04:14:38.000Z","_content":"\n> Spring 说到底就是一个轻量级的容器，让它来负责各个实例的生产、管理、维护，而这些实例的参数与依赖关系都交由 spring 的配置文件来设置；<!--more-->\n\n<!--more-->\n\n## 1.1. 反向控制（Inverse of Control)\n\n> 概念：也可以叫依赖注入（Dependency Injection)，是 spring 的核心思想。通俗地理解就是将原本正向流程走的程序让其反向执行。\n> 之所以也叫依赖注入，是因为在实现反向控制的过程中是将原本要在后面实例化的属性提前注入到自己的实例中。这样 **把离散的组件在运行时组装到一块** ，实现程序流程在运行时组装，这样就可以很方便地添加功能，比如：拦截器；\n\n### 1.1.1. 举例\n\n- 当我们要通过 DAO 层的 dao 与 Service 层的 service 对象来实现分业务层的访问数据库操作：\n    - **正向思维**：是先实例化一个 Service 对象，再在这个 Service 对象中实例一个 Dao 对象来，在 Service 方法中执行这个 Dao 对象的方法来访问数据库。\n    - **反向控制**：Service 与 Dao 都抽象出各自的接口，而在 Service 实现类中约定一个 Dao 接口的属性，service 方法中再来调用这个 Dao 的方法；而在 Spring 中，这个属性的实现就叫注入，而这个注入是通过 spring 配置文件中的 bean 实现，在 Service 的 bean 中，有一个 `<property>` 的标签，这个标签中配置相关的 dao 的 bean 。\n        - _在这个例子中， Service 与 Dao 都是作为独立的组件出现，在编码阶段，既没有实例化对象出来也没有设置依赖关系，而把它交给Spring，**由 Spring 在运行阶段实例化并组装**。这种颠覆传统编码过程就叫反转控制。_\n\n----------\n**Note:**\n\n- 反向控制在 spring 配置中高频地被使用，在实现AOP面向切面编程中高频地使用到反向控制来将各个方法注入到其他的方法之前或之后；\n\n## 1.2. Container Configuration\n\nioc 容器配置。传统配置方法是使用 xml 配置文件实现。\n\n### 1.2.1. java based container configuration\n\n基于 java 代码配置 ioc 容器，也就是注解配置。\n\n- spring 注解配置的中心就是 `@Bean` 用于标记方法与 `@Configuration` 标记的类。\n- `@Bean` 用以标记方法实例化、配置并初始化一个 IoC 容器管理的 object ，类似 `<beans/>` 配置文件中的 `<bean>` 元素。\n- `@Bean` 可置于 `@Component` 标记的类中，成为 lite （轻量）Bean 模式，但一般与 `@Configuration` 配置类联用。\n    - full @Configuration 与 lite @Bean 模式[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java)\n        - lite @Bean 模式指 `@Bean` 不与 `@Configuration` 联用，可以是与 `@Component` 联用，也可以是与普通 java 类联用；\n        - full @Configuration 下 bean 间的依赖通过调用其他 bean 方法全都实现，而 lite 模式只能通过参数实现 bean 间依赖。因而， lite 模式 bean 方法只是一个提供 bean 引用的工厂方法，没有运行时语义。这给 lite 模式带来的正面意义是在运行时没有 CGLIB 子类产生，对于类设计而言也没有限制，配置类可为 final 。？？？\n        - 通常情况 `@Bean` 都与 `@Configuration` 类联用，因为 full 模式下，跨方法的引用都重定向到 **IoC 容器生命周期**管理。这就阻止了 @Bean 方法意外地被常规 java 调用而引起难以追踪的 bug 。\n\n#### 1.2.1.1. AnnotationConfigApplicationContext 初始化 IoC 容器\n\n使用 AnnotationConfigApplicationContext 初始化 IoC 容器。AnnotaionConfigApplicationContext 在 spring 3.0 中引进。\n\n- 通过 `@Configuration` 配置类注册初始化\n\n\t```java\n\tpublic static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        MyService myService = ctx.getBean(MyService.class);\n        myService.doStuff();\n\t}\n\t```\n\n    - AppConfig 是一个 bean 配置类，集合相应的 bean ，在一个类中。\n    - 可以使用无参构造一个 AnnotationConfigApplicationContext 实例，再调用其 `register(config.class)` 方法将配置类注册进去，达到同样的效果。\n- 通过各个 bean 的 class 注册\n\n\t```java\n\tpublic static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);\n        MyService myService = ctx.getBean(MyService.class);\n        myService.doStuff();\n\t}\n\t```\n\n#### 1.2.1.2. ComponentScan\n\n- 使用 `@ComponentScan(basePackage={\"com.xxx\"})` 注解在 Configuration 上将 component 扫描入 IoC Container。等同于 beans.xml 配置中的 `<context:component-scan base-package=\"com.xxx\" />`。\n- 在 AnnotationConfigurationApplicationContext 中可使用 `scan(String package)` 达到同样的效果。\n- `@Configuration` 被元注解 `@Component` 所注解，所以，只要被 scan 到，同样会被注册到 IoC 容器中。\n\n#### 1.2.1.3. AnnotationConfigWebApplicationContext\n\n- AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的变体，用于初始化 springmvc 容器。\n- 可用于注册 Spring Servlet listener `ContextLoaderListener`、spring MVC DispatcherServlet 等等。\n\n#### Fine-tuning Annotation-based Autowiring with Qualifiers\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation-primary)\n\n微调 bean 注入。使用注解 `@Qualifier` 在bean 定义与bean 注入处添加数据用以鉴别 bean 。\n\n- bean 定义处可以不使用 `@Qualifier` ，注入处会自动使用 beanName 。\n- `@AutoWired` 注入的策略是先使用 Type 匹配，匹配到多个时会使用 `@Qualifier` 指定的 value 匹配。\n- `@Resource` 注解注入匹配策略只使用其唯一名 unique name，type 定义与其无关。\n- 如果 bean 定义为一个集合，数组或 Map，使用 `@Resource` 可直接匹配其 beanName 得到此集合。\n- 通过 `@AutoWired` 注入时有多个 bean Type 匹配，此时可以添加 `@Qualifier` 数据获取。\n- `@AutoWired` 自注入（截止到 Spring 4.3），在这种场景自注入的 self-bean 优先级最低，不能为 Primary 。\n- 在同一个 Configuration 类 @Bean 方法中注入自身是解决自引用的问题更高效。\n\n## 1.3. Container Extension points\n\n容器扩展[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension)\n\n### 1.3.1. 自定义 BeanPostProcessor\n\n- 针对 bean 初始化后执行的回调配置，在每个 bean 初始化后执行其中的回调。\n- 可以配置多个，可指定其执行的顺序，通过 `Ordered` 接口或注解 `@Order`\n- BeanPostProcessor 只与自己所有的上下文环境相关，所在容器之间的处理器互不干扰。\n- 如果要操作容器中 BeanDefinition（bean 蓝图），要定义 BeanFactoryPostProcessor\n- 代理包装就是使用 BeanPostProcessor\n- ApplicationContext 自动检测 BeanPostProcessor 实现并注册到容器中，并在随后的 bean creation 中调用。\n- 指定 lazy-init 属性对这两类处理器无效，因为如果其中没有其他 bean 引用 processor 不会初始化。\n\nNote:\n\n**Programmatically registering BeanPostProcessor instances**\n\n- ApplicationContext 自动检测注册 BeanPostProcessor 外，还可以通过 ConfigurableBeanFactory.addBeanPostProcess() 手动注册。\n- 手动注册将忽略 processor 的 order 属性，直接使用手动注册的顺序作为 process() 的顺序。同时手动注册的优先于 ApplicationContext 自动检测注册的 processor。\n\n**BeanPostProcessor instances and AOP auto-proxying**\n\n- 容器对实现 BeanPostProcessor 的类专门处理。所有的 BeanPostProcessor 的实例与 bean 直接引用都在 ApplicationContext 启动时初始化，作为其启动阶段之一。\n- 所有的 BeanPostProcessor 实例都有序注册并都在后来相应的阶段处理容器中的 Bean。\n- 因为 Spring AOP 自动代理实现本身就是一个 BeanPostProcessor ，对于 BeanPostProcessor 实例，不管是其本身还是其直接依赖的 bean 都是自动代理的对象，所以不要对其编织切面。这于这类错误添加切面的 bean ，会出现日志信息：`Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`。\n- 当在 BeanPostProcessor 使用 `@AutoWired`（自动装配） 或 `@Resource`(此类装配策略可能会退化为自动装配)装配了其他 Bean 。Spring 会在类型匹配查找时访问到不需要的 Bean 。所以需要让这些 Bean 对自动代理或其他类型的 Bean Post-Processing 失效。比如：有一个被 @Resource 注解的依赖，字段或 setter 名不能与一个与 bean 声明的名匹配且没有名字属性被使用，Spring 将访问与其他 type 相匹配的 bean 。\n\n### 1.3.2. 自定义 BeanFactoryPostProcessor\n\n[BeanFactoryPostProcessor](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension)\n\n- 可直接访问 ApplicationContext.getBean() 获取 bean 到 processor 中，但这种方法不妥之处在于其获取的 bean 未破坏了容器生命周期管理，会产生潜在的副作用\n- BeanFactoryPostProcessor 同样其域范围是容器。\n- 作用是操作配置的元数据\n- ApplicationContext 自动检测并部署 BeanFactoryPostProcessor 的实现。\n- PropertySourcesPlaceholderConfigurer 可以为 bean 从外部文件读取数据配置 bean property，外部文件是 java 标准的 Properties 格式。\n\n  ```xml\n  <bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\">\n    <property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/>\n  </bean>\n  <bean id=\"dataSource\" destroy-method=\"close\"\n        class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/>\n    <property name=\"url\" value=\"${jdbc.url}\"/>\n    <property name=\"username\" value=\"${jdbc.username}\"/>\n    <property name=\"password\" value=\"${jdbc.password}\"/>\n  </bean>\n  ```\n\n  外部数据：\n\n  ```java\n  jdbc.driverClassName=org.hsqldb.jdbcDriver\n  jdbc.url=jdbc:hsqldb:hsql://production:9002\n  jdbc.username=sa\n  jdbc.password=root\n  ```\n\n- PropertyOverrideConfigurer 与 PropertySourcesPlaceholderConfigurer 类似，但可以给配置添加默认值\n- 在不同环境使用不同的配置情况下，使用自定义处理器有用，具体使用还不明白。\n\n### 1.3.3. 通过 FactoryBean 自定义初始化逻辑\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension)\n\n- IoC 容器初始化逻辑的插口，如果有冗杂的初始化代码需要写，写在实现此接口的 java bean 中，而不是使用 xml 配置。\n- 定义一个 bean 实现 FactoryBean 接口，此时 bean 是自己的工厂。\n- 从容器中获取 FactoryBean 实例时， 在 bean id 前加上 `&`：`getBean(\"&beanName\")` 即可。\n\n## 1.4. ApplicationContext 额外功能\n\nApplicationContext 可以理解为 Spring IoC 容器。ApplicationContext 额外的功能[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n### 1.4.1. 使用 MessageResource 做国际化\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n- ApplicationContext 默认实现都继承了 MessageResource 接口，只要注册了任何一个 MessageContext Bean 在容器中，即可使用其功能。\n- 默认的 MessageContext 实现 `org.springframework.context.support.ResourceBundleMessageSource` ，可定义相关 ResourceBundle 用于 message 定制。\n- `ReloadableResourceBundleMessageSource` 有更灵活的实现，允许从 Spring 资源中加载任何路径中的文件， `ResourceBundleMessageSource` 只能加载 classpath 中的资源文件。同时也支持热重载资源文件。\n\n### 1.4.2. 标准事件与自定义事件\n\nApplicationContext 中事件的处理通过 `ApplicationEvent` 类和 `ApplicationListener` 接口完成，当发布一个 event 实现了 `ApplicationListener` 的类将被通知到此事件。这是一个典型的观察者设计模式。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n从 Spring 4.2 开始，事件处理可使用注解配置。\n\n#### 1.4.2.1. 内置的事件\n\n1. ContextRefreshedEvent 在 ApplicationContext 初始化或刷新时触发，在 context 未 closed，可以多次调用 `refresh()` 刷新\n2. ContextStartedEvent 在 `ConfigurableApplicationContext` 接口中调用 `start()` 方法开启一个 `ApplicationContext` 时发布此事件。\n3. ContextStoppedEvent 在`ConfigurableApplicationContext` 接口中调用 `stop()` 方法停止一个 context 时发布。\n4. ContextClosedEvent 在 `ConfigurableApplicationContext` 接口中调用 `close()` 方法关闭一个应用时发布。\n5. RequestHandledEvent 在一个使用 Spring DispatcherServlet 的 web 应用中，一个请求完成后发布此事件。\n6. ServletRequestHandledEvent `RequestHandledEvent` 的子类，可以添加指定 Servlet 上下文信息。\n\n#### 1.4.2.2. 监听器实现\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n- ApplicationContext 将自动注册为一个 `ApplicationEventPulisher`，事件发布器。\n- 使用注解注册监听器 `@EventLisener` ，注解在方法之上不用再实现 `ApplicationLisener` 。\n- 指定监听事件对象类型 `@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})`\n\n### 1.4.3. Web 应用中实例化 ApplicationContext\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create)\n\n### 1.4.4. 发布一个 Spring ApplicationContext 为 Java EE RAR 文件\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create)\n\n## 1.5. Environment Abstraction\n\nSpring IoC 环境抽象。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment)\n\n### 1.5.1. 使用 @Profile 注解 bean\n\n使用 `@Profile` 注解实现 bean 的不同环境是否激活。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment)\n\n- 如果 注解在配置类上，类中所有未单独使用 `@Profile` 注解的 bean 都会使用此注解。\n- value 可以使用 表达式，表达式共有三种布尔运算符：与 `&`, 或 `|` , 非 `!` 。表达式运算符可以连用，但超过两个，两两之间必须使用括号确定运行顺序： `@Profile(value=\"prd|(test&us-east)\")` 。在 xml 配置中只能使用 `!` ，使用 与 `&` 运算在 `<beans profile=\"production\"/>` 中再内嵌一个 `<beans profile=\"us-central\" />`\n- value 是数组，多个 value 之间可以使用 `,` 分隔开\n- 可以使用 `@Profile` 当元注解自定义 profile 功能注解。\n- 当使用 `@Profile` 注解在配置类的 bean defined method 方法上时，可以指定同一个 bean 在不同环境配置中为不同的实例。但在这种情况下，注意同一个方法的重载方法使用不同的 profile 只有第一个的生效。解决方案，使用不同的方法名避免 bean defined method 重载。\n\n### 1.5.2. 激活项目 Profile\n\n激活 spring profile 方式有很多。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment)\n\n1. 最直接简单方式：在 ApplicationContext 中获取 Environment 再调用其 `setProfiles()` 方法，之后还得 `refresh()` 一次刷新配置。\n2. 通过指定 `spring.profiles.active=\"dev\"` ，指定方式：\n   1. 添加 JVM 系统属性：`-D` 命令行；\n   2. 系统环境变量\n   3. servlet context 参数\n   4. JNDI 入口\n   5. 测试模块可使用注解 `@ActiveProifles`\n\n### 1.5.3. PropertySource Abstraction\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction)\n\n- Spring 的 `Environment` 抽象通过可配置的 Property Source （属性源）提供查询操作。\n- Spring 独立应用使用 `StandardEnvironment` 为默认的 Property Source 。 `StandardServletEnvironment` 还提供额外的Servlet config 和 servlet context 参数。\n- `StandardServletEnvironment` property source 从高到低优先级：\n    - ServletConfig parameters (if applicable — for example, in case of a DispatcherServlet context)\n    - ServletContext parameters (web.xml context-param entries)\n    - JNDI environment variables (java:comp/env/ entries)\n    - JVM system properties (-D command-line arguments)\n    - JVM system environment (operating system environment variables)\n- 整个查询机制是可配的，可自定义 property source 添加到 environment 中\n\n  ```java\n  ConfigurableApplicationContext ctx = new GenericApplicationContext();\n  MutablePropertySources sources = ctx.getEnvironment().getPropertySources();\n  sources.addFirst(new MyPropertySource());\n  ```\n\n### 1.5.4. 使用 @PropertySource\n\n使用此注解为 Configuration 添加外部配置文件。\n\n- `@PropertySource(\"classpath:/com/${my.placeholder:default/path}/app.properties\")` 其中可使用点位符添加已加入的配置作为路径\n- 可以添加多个 `@PropertySource` 或自定义同功能（使用此注解当元注解）的注解在同一个 configuration 上，但不推荐，因为直接的注解会覆盖数据注解。\n\n### 1.5.5. Placeholder Resolution in Statement\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction)\n\n使用已定义好的配置：\n\n```xml\n<beans>\n    <import resource=\"com/bank/service/${customer}-config.xml\"/>\n</beans>\n```\n\n## 1.6. BeanFactory\n\n[Spring IoC 容器基础](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beanfactory)\n\n- 整个框架组件都基于 BeanFactory 及 相关的接口（`BeanFactoryAware` `InitializingBean`  `DisposableBean`）整个而成。\n- BeanFactory 级别的 API （其默认实现： DefaultListableBeanFactory） 只是单纯的一个工厂，并没对应用相关的组件进行设定，配置格式与注解组件都未配置。\n- `ApplicationContext` 是 `BeanFactory` 增强，包含了BeanFactory 所有的功能，其实现（eg: GenericApplicationContext）会按惯例扫描各类 bean 。ApplicationContext 的各类变体都会扩展各类功能，如添加 BeanFactoryPostProcessor BeanPostProcessor。\n- `AnnotationConfigApplicationContext` 除了添加了 post-processor 等组件外，还通过注解添加其他组件，如：`@EnableTransactionManagement`。在 Spring 注解配置模式中，post-processor bean 的概念仅仅只是容器内部细节。\n","source":"_posts/Spring/Spring IOC.md","raw":"---\nlayout: post\ntitle: \"Spring IoC\"\ndate: 2017-09-15 12:14:38\ntags: [Spring, Java]\ncategories: [Spring]\n---\n\n> Spring 说到底就是一个轻量级的容器，让它来负责各个实例的生产、管理、维护，而这些实例的参数与依赖关系都交由 spring 的配置文件来设置；<!--more-->\n\n<!--more-->\n\n## 1.1. 反向控制（Inverse of Control)\n\n> 概念：也可以叫依赖注入（Dependency Injection)，是 spring 的核心思想。通俗地理解就是将原本正向流程走的程序让其反向执行。\n> 之所以也叫依赖注入，是因为在实现反向控制的过程中是将原本要在后面实例化的属性提前注入到自己的实例中。这样 **把离散的组件在运行时组装到一块** ，实现程序流程在运行时组装，这样就可以很方便地添加功能，比如：拦截器；\n\n### 1.1.1. 举例\n\n- 当我们要通过 DAO 层的 dao 与 Service 层的 service 对象来实现分业务层的访问数据库操作：\n    - **正向思维**：是先实例化一个 Service 对象，再在这个 Service 对象中实例一个 Dao 对象来，在 Service 方法中执行这个 Dao 对象的方法来访问数据库。\n    - **反向控制**：Service 与 Dao 都抽象出各自的接口，而在 Service 实现类中约定一个 Dao 接口的属性，service 方法中再来调用这个 Dao 的方法；而在 Spring 中，这个属性的实现就叫注入，而这个注入是通过 spring 配置文件中的 bean 实现，在 Service 的 bean 中，有一个 `<property>` 的标签，这个标签中配置相关的 dao 的 bean 。\n        - _在这个例子中， Service 与 Dao 都是作为独立的组件出现，在编码阶段，既没有实例化对象出来也没有设置依赖关系，而把它交给Spring，**由 Spring 在运行阶段实例化并组装**。这种颠覆传统编码过程就叫反转控制。_\n\n----------\n**Note:**\n\n- 反向控制在 spring 配置中高频地被使用，在实现AOP面向切面编程中高频地使用到反向控制来将各个方法注入到其他的方法之前或之后；\n\n## 1.2. Container Configuration\n\nioc 容器配置。传统配置方法是使用 xml 配置文件实现。\n\n### 1.2.1. java based container configuration\n\n基于 java 代码配置 ioc 容器，也就是注解配置。\n\n- spring 注解配置的中心就是 `@Bean` 用于标记方法与 `@Configuration` 标记的类。\n- `@Bean` 用以标记方法实例化、配置并初始化一个 IoC 容器管理的 object ，类似 `<beans/>` 配置文件中的 `<bean>` 元素。\n- `@Bean` 可置于 `@Component` 标记的类中，成为 lite （轻量）Bean 模式，但一般与 `@Configuration` 配置类联用。\n    - full @Configuration 与 lite @Bean 模式[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java)\n        - lite @Bean 模式指 `@Bean` 不与 `@Configuration` 联用，可以是与 `@Component` 联用，也可以是与普通 java 类联用；\n        - full @Configuration 下 bean 间的依赖通过调用其他 bean 方法全都实现，而 lite 模式只能通过参数实现 bean 间依赖。因而， lite 模式 bean 方法只是一个提供 bean 引用的工厂方法，没有运行时语义。这给 lite 模式带来的正面意义是在运行时没有 CGLIB 子类产生，对于类设计而言也没有限制，配置类可为 final 。？？？\n        - 通常情况 `@Bean` 都与 `@Configuration` 类联用，因为 full 模式下，跨方法的引用都重定向到 **IoC 容器生命周期**管理。这就阻止了 @Bean 方法意外地被常规 java 调用而引起难以追踪的 bug 。\n\n#### 1.2.1.1. AnnotationConfigApplicationContext 初始化 IoC 容器\n\n使用 AnnotationConfigApplicationContext 初始化 IoC 容器。AnnotaionConfigApplicationContext 在 spring 3.0 中引进。\n\n- 通过 `@Configuration` 配置类注册初始化\n\n\t```java\n\tpublic static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        MyService myService = ctx.getBean(MyService.class);\n        myService.doStuff();\n\t}\n\t```\n\n    - AppConfig 是一个 bean 配置类，集合相应的 bean ，在一个类中。\n    - 可以使用无参构造一个 AnnotationConfigApplicationContext 实例，再调用其 `register(config.class)` 方法将配置类注册进去，达到同样的效果。\n- 通过各个 bean 的 class 注册\n\n\t```java\n\tpublic static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);\n        MyService myService = ctx.getBean(MyService.class);\n        myService.doStuff();\n\t}\n\t```\n\n#### 1.2.1.2. ComponentScan\n\n- 使用 `@ComponentScan(basePackage={\"com.xxx\"})` 注解在 Configuration 上将 component 扫描入 IoC Container。等同于 beans.xml 配置中的 `<context:component-scan base-package=\"com.xxx\" />`。\n- 在 AnnotationConfigurationApplicationContext 中可使用 `scan(String package)` 达到同样的效果。\n- `@Configuration` 被元注解 `@Component` 所注解，所以，只要被 scan 到，同样会被注册到 IoC 容器中。\n\n#### 1.2.1.3. AnnotationConfigWebApplicationContext\n\n- AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的变体，用于初始化 springmvc 容器。\n- 可用于注册 Spring Servlet listener `ContextLoaderListener`、spring MVC DispatcherServlet 等等。\n\n#### Fine-tuning Annotation-based Autowiring with Qualifiers\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation-primary)\n\n微调 bean 注入。使用注解 `@Qualifier` 在bean 定义与bean 注入处添加数据用以鉴别 bean 。\n\n- bean 定义处可以不使用 `@Qualifier` ，注入处会自动使用 beanName 。\n- `@AutoWired` 注入的策略是先使用 Type 匹配，匹配到多个时会使用 `@Qualifier` 指定的 value 匹配。\n- `@Resource` 注解注入匹配策略只使用其唯一名 unique name，type 定义与其无关。\n- 如果 bean 定义为一个集合，数组或 Map，使用 `@Resource` 可直接匹配其 beanName 得到此集合。\n- 通过 `@AutoWired` 注入时有多个 bean Type 匹配，此时可以添加 `@Qualifier` 数据获取。\n- `@AutoWired` 自注入（截止到 Spring 4.3），在这种场景自注入的 self-bean 优先级最低，不能为 Primary 。\n- 在同一个 Configuration 类 @Bean 方法中注入自身是解决自引用的问题更高效。\n\n## 1.3. Container Extension points\n\n容器扩展[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension)\n\n### 1.3.1. 自定义 BeanPostProcessor\n\n- 针对 bean 初始化后执行的回调配置，在每个 bean 初始化后执行其中的回调。\n- 可以配置多个，可指定其执行的顺序，通过 `Ordered` 接口或注解 `@Order`\n- BeanPostProcessor 只与自己所有的上下文环境相关，所在容器之间的处理器互不干扰。\n- 如果要操作容器中 BeanDefinition（bean 蓝图），要定义 BeanFactoryPostProcessor\n- 代理包装就是使用 BeanPostProcessor\n- ApplicationContext 自动检测 BeanPostProcessor 实现并注册到容器中，并在随后的 bean creation 中调用。\n- 指定 lazy-init 属性对这两类处理器无效，因为如果其中没有其他 bean 引用 processor 不会初始化。\n\nNote:\n\n**Programmatically registering BeanPostProcessor instances**\n\n- ApplicationContext 自动检测注册 BeanPostProcessor 外，还可以通过 ConfigurableBeanFactory.addBeanPostProcess() 手动注册。\n- 手动注册将忽略 processor 的 order 属性，直接使用手动注册的顺序作为 process() 的顺序。同时手动注册的优先于 ApplicationContext 自动检测注册的 processor。\n\n**BeanPostProcessor instances and AOP auto-proxying**\n\n- 容器对实现 BeanPostProcessor 的类专门处理。所有的 BeanPostProcessor 的实例与 bean 直接引用都在 ApplicationContext 启动时初始化，作为其启动阶段之一。\n- 所有的 BeanPostProcessor 实例都有序注册并都在后来相应的阶段处理容器中的 Bean。\n- 因为 Spring AOP 自动代理实现本身就是一个 BeanPostProcessor ，对于 BeanPostProcessor 实例，不管是其本身还是其直接依赖的 bean 都是自动代理的对象，所以不要对其编织切面。这于这类错误添加切面的 bean ，会出现日志信息：`Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`。\n- 当在 BeanPostProcessor 使用 `@AutoWired`（自动装配） 或 `@Resource`(此类装配策略可能会退化为自动装配)装配了其他 Bean 。Spring 会在类型匹配查找时访问到不需要的 Bean 。所以需要让这些 Bean 对自动代理或其他类型的 Bean Post-Processing 失效。比如：有一个被 @Resource 注解的依赖，字段或 setter 名不能与一个与 bean 声明的名匹配且没有名字属性被使用，Spring 将访问与其他 type 相匹配的 bean 。\n\n### 1.3.2. 自定义 BeanFactoryPostProcessor\n\n[BeanFactoryPostProcessor](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension)\n\n- 可直接访问 ApplicationContext.getBean() 获取 bean 到 processor 中，但这种方法不妥之处在于其获取的 bean 未破坏了容器生命周期管理，会产生潜在的副作用\n- BeanFactoryPostProcessor 同样其域范围是容器。\n- 作用是操作配置的元数据\n- ApplicationContext 自动检测并部署 BeanFactoryPostProcessor 的实现。\n- PropertySourcesPlaceholderConfigurer 可以为 bean 从外部文件读取数据配置 bean property，外部文件是 java 标准的 Properties 格式。\n\n  ```xml\n  <bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\">\n    <property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/>\n  </bean>\n  <bean id=\"dataSource\" destroy-method=\"close\"\n        class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/>\n    <property name=\"url\" value=\"${jdbc.url}\"/>\n    <property name=\"username\" value=\"${jdbc.username}\"/>\n    <property name=\"password\" value=\"${jdbc.password}\"/>\n  </bean>\n  ```\n\n  外部数据：\n\n  ```java\n  jdbc.driverClassName=org.hsqldb.jdbcDriver\n  jdbc.url=jdbc:hsqldb:hsql://production:9002\n  jdbc.username=sa\n  jdbc.password=root\n  ```\n\n- PropertyOverrideConfigurer 与 PropertySourcesPlaceholderConfigurer 类似，但可以给配置添加默认值\n- 在不同环境使用不同的配置情况下，使用自定义处理器有用，具体使用还不明白。\n\n### 1.3.3. 通过 FactoryBean 自定义初始化逻辑\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension)\n\n- IoC 容器初始化逻辑的插口，如果有冗杂的初始化代码需要写，写在实现此接口的 java bean 中，而不是使用 xml 配置。\n- 定义一个 bean 实现 FactoryBean 接口，此时 bean 是自己的工厂。\n- 从容器中获取 FactoryBean 实例时， 在 bean id 前加上 `&`：`getBean(\"&beanName\")` 即可。\n\n## 1.4. ApplicationContext 额外功能\n\nApplicationContext 可以理解为 Spring IoC 容器。ApplicationContext 额外的功能[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n### 1.4.1. 使用 MessageResource 做国际化\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n- ApplicationContext 默认实现都继承了 MessageResource 接口，只要注册了任何一个 MessageContext Bean 在容器中，即可使用其功能。\n- 默认的 MessageContext 实现 `org.springframework.context.support.ResourceBundleMessageSource` ，可定义相关 ResourceBundle 用于 message 定制。\n- `ReloadableResourceBundleMessageSource` 有更灵活的实现，允许从 Spring 资源中加载任何路径中的文件， `ResourceBundleMessageSource` 只能加载 classpath 中的资源文件。同时也支持热重载资源文件。\n\n### 1.4.2. 标准事件与自定义事件\n\nApplicationContext 中事件的处理通过 `ApplicationEvent` 类和 `ApplicationListener` 接口完成，当发布一个 event 实现了 `ApplicationListener` 的类将被通知到此事件。这是一个典型的观察者设计模式。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n从 Spring 4.2 开始，事件处理可使用注解配置。\n\n#### 1.4.2.1. 内置的事件\n\n1. ContextRefreshedEvent 在 ApplicationContext 初始化或刷新时触发，在 context 未 closed，可以多次调用 `refresh()` 刷新\n2. ContextStartedEvent 在 `ConfigurableApplicationContext` 接口中调用 `start()` 方法开启一个 `ApplicationContext` 时发布此事件。\n3. ContextStoppedEvent 在`ConfigurableApplicationContext` 接口中调用 `stop()` 方法停止一个 context 时发布。\n4. ContextClosedEvent 在 `ConfigurableApplicationContext` 接口中调用 `close()` 方法关闭一个应用时发布。\n5. RequestHandledEvent 在一个使用 Spring DispatcherServlet 的 web 应用中，一个请求完成后发布此事件。\n6. ServletRequestHandledEvent `RequestHandledEvent` 的子类，可以添加指定 Servlet 上下文信息。\n\n#### 1.4.2.2. 监听器实现\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction)\n\n- ApplicationContext 将自动注册为一个 `ApplicationEventPulisher`，事件发布器。\n- 使用注解注册监听器 `@EventLisener` ，注解在方法之上不用再实现 `ApplicationLisener` 。\n- 指定监听事件对象类型 `@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})`\n\n### 1.4.3. Web 应用中实例化 ApplicationContext\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create)\n\n### 1.4.4. 发布一个 Spring ApplicationContext 为 Java EE RAR 文件\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create)\n\n## 1.5. Environment Abstraction\n\nSpring IoC 环境抽象。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment)\n\n### 1.5.1. 使用 @Profile 注解 bean\n\n使用 `@Profile` 注解实现 bean 的不同环境是否激活。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment)\n\n- 如果 注解在配置类上，类中所有未单独使用 `@Profile` 注解的 bean 都会使用此注解。\n- value 可以使用 表达式，表达式共有三种布尔运算符：与 `&`, 或 `|` , 非 `!` 。表达式运算符可以连用，但超过两个，两两之间必须使用括号确定运行顺序： `@Profile(value=\"prd|(test&us-east)\")` 。在 xml 配置中只能使用 `!` ，使用 与 `&` 运算在 `<beans profile=\"production\"/>` 中再内嵌一个 `<beans profile=\"us-central\" />`\n- value 是数组，多个 value 之间可以使用 `,` 分隔开\n- 可以使用 `@Profile` 当元注解自定义 profile 功能注解。\n- 当使用 `@Profile` 注解在配置类的 bean defined method 方法上时，可以指定同一个 bean 在不同环境配置中为不同的实例。但在这种情况下，注意同一个方法的重载方法使用不同的 profile 只有第一个的生效。解决方案，使用不同的方法名避免 bean defined method 重载。\n\n### 1.5.2. 激活项目 Profile\n\n激活 spring profile 方式有很多。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment)\n\n1. 最直接简单方式：在 ApplicationContext 中获取 Environment 再调用其 `setProfiles()` 方法，之后还得 `refresh()` 一次刷新配置。\n2. 通过指定 `spring.profiles.active=\"dev\"` ，指定方式：\n   1. 添加 JVM 系统属性：`-D` 命令行；\n   2. 系统环境变量\n   3. servlet context 参数\n   4. JNDI 入口\n   5. 测试模块可使用注解 `@ActiveProifles`\n\n### 1.5.3. PropertySource Abstraction\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction)\n\n- Spring 的 `Environment` 抽象通过可配置的 Property Source （属性源）提供查询操作。\n- Spring 独立应用使用 `StandardEnvironment` 为默认的 Property Source 。 `StandardServletEnvironment` 还提供额外的Servlet config 和 servlet context 参数。\n- `StandardServletEnvironment` property source 从高到低优先级：\n    - ServletConfig parameters (if applicable — for example, in case of a DispatcherServlet context)\n    - ServletContext parameters (web.xml context-param entries)\n    - JNDI environment variables (java:comp/env/ entries)\n    - JVM system properties (-D command-line arguments)\n    - JVM system environment (operating system environment variables)\n- 整个查询机制是可配的，可自定义 property source 添加到 environment 中\n\n  ```java\n  ConfigurableApplicationContext ctx = new GenericApplicationContext();\n  MutablePropertySources sources = ctx.getEnvironment().getPropertySources();\n  sources.addFirst(new MyPropertySource());\n  ```\n\n### 1.5.4. 使用 @PropertySource\n\n使用此注解为 Configuration 添加外部配置文件。\n\n- `@PropertySource(\"classpath:/com/${my.placeholder:default/path}/app.properties\")` 其中可使用点位符添加已加入的配置作为路径\n- 可以添加多个 `@PropertySource` 或自定义同功能（使用此注解当元注解）的注解在同一个 configuration 上，但不推荐，因为直接的注解会覆盖数据注解。\n\n### 1.5.5. Placeholder Resolution in Statement\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction)\n\n使用已定义好的配置：\n\n```xml\n<beans>\n    <import resource=\"com/bank/service/${customer}-config.xml\"/>\n</beans>\n```\n\n## 1.6. BeanFactory\n\n[Spring IoC 容器基础](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beanfactory)\n\n- 整个框架组件都基于 BeanFactory 及 相关的接口（`BeanFactoryAware` `InitializingBean`  `DisposableBean`）整个而成。\n- BeanFactory 级别的 API （其默认实现： DefaultListableBeanFactory） 只是单纯的一个工厂，并没对应用相关的组件进行设定，配置格式与注解组件都未配置。\n- `ApplicationContext` 是 `BeanFactory` 增强，包含了BeanFactory 所有的功能，其实现（eg: GenericApplicationContext）会按惯例扫描各类 bean 。ApplicationContext 的各类变体都会扩展各类功能，如添加 BeanFactoryPostProcessor BeanPostProcessor。\n- `AnnotationConfigApplicationContext` 除了添加了 post-processor 等组件外，还通过注解添加其他组件，如：`@EnableTransactionManagement`。在 Spring 注解配置模式中，post-processor bean 的概念仅仅只是容器内部细节。\n","slug":"Spring/Spring IOC","published":1,"updated":"2021-02-24T15:22:22.960Z","comments":1,"photos":[],"link":"","_id":"ckljnokt1006o2bhbgkkw4ht6","content":"<blockquote>\n<p>Spring 说到底就是一个轻量级的容器，让它来负责各个实例的生产、管理、维护，而这些实例的参数与依赖关系都交由 spring 的配置文件来设置；<span id=\"more\"></span></p>\n</blockquote>\n<!--more-->\n\n<h2 id=\"1-1-反向控制（Inverse-of-Control\"><a href=\"#1-1-反向控制（Inverse-of-Control\" class=\"headerlink\" title=\"1.1. 反向控制（Inverse of Control)\"></a>1.1. 反向控制（Inverse of Control)</h2><blockquote>\n<p>概念：也可以叫依赖注入（Dependency Injection)，是 spring 的核心思想。通俗地理解就是将原本正向流程走的程序让其反向执行。<br>之所以也叫依赖注入，是因为在实现反向控制的过程中是将原本要在后面实例化的属性提前注入到自己的实例中。这样 <strong>把离散的组件在运行时组装到一块</strong> ，实现程序流程在运行时组装，这样就可以很方便地添加功能，比如：拦截器；</p>\n</blockquote>\n<h3 id=\"1-1-1-举例\"><a href=\"#1-1-1-举例\" class=\"headerlink\" title=\"1.1.1. 举例\"></a>1.1.1. 举例</h3><ul>\n<li>当我们要通过 DAO 层的 dao 与 Service 层的 service 对象来实现分业务层的访问数据库操作：<ul>\n<li><strong>正向思维</strong>：是先实例化一个 Service 对象，再在这个 Service 对象中实例一个 Dao 对象来，在 Service 方法中执行这个 Dao 对象的方法来访问数据库。</li>\n<li><strong>反向控制</strong>：Service 与 Dao 都抽象出各自的接口，而在 Service 实现类中约定一个 Dao 接口的属性，service 方法中再来调用这个 Dao 的方法；而在 Spring 中，这个属性的实现就叫注入，而这个注入是通过 spring 配置文件中的 bean 实现，在 Service 的 bean 中，有一个 <code>&lt;property&gt;</code> 的标签，这个标签中配置相关的 dao 的 bean 。<ul>\n<li><em>在这个例子中， Service 与 Dao 都是作为独立的组件出现，在编码阶段，既没有实例化对象出来也没有设置依赖关系，而把它交给Spring，<strong>由 Spring 在运行阶段实例化并组装</strong>。这种颠覆传统编码过程就叫反转控制。</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Note:</strong></p>\n<ul>\n<li>反向控制在 spring 配置中高频地被使用，在实现AOP面向切面编程中高频地使用到反向控制来将各个方法注入到其他的方法之前或之后；</li>\n</ul>\n<h2 id=\"1-2-Container-Configuration\"><a href=\"#1-2-Container-Configuration\" class=\"headerlink\" title=\"1.2. Container Configuration\"></a>1.2. Container Configuration</h2><p>ioc 容器配置。传统配置方法是使用 xml 配置文件实现。</p>\n<h3 id=\"1-2-1-java-based-container-configuration\"><a href=\"#1-2-1-java-based-container-configuration\" class=\"headerlink\" title=\"1.2.1. java based container configuration\"></a>1.2.1. java based container configuration</h3><p>基于 java 代码配置 ioc 容器，也就是注解配置。</p>\n<ul>\n<li>spring 注解配置的中心就是 <code>@Bean</code> 用于标记方法与 <code>@Configuration</code> 标记的类。</li>\n<li><code>@Bean</code> 用以标记方法实例化、配置并初始化一个 IoC 容器管理的 object ，类似 <code>&lt;beans/&gt;</code> 配置文件中的 <code>&lt;bean&gt;</code> 元素。</li>\n<li><code>@Bean</code> 可置于 <code>@Component</code> 标记的类中，成为 lite （轻量）Bean 模式，但一般与 <code>@Configuration</code> 配置类联用。<ul>\n<li>full @Configuration 与 lite @Bean 模式<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java\">reference</a><ul>\n<li>lite @Bean 模式指 <code>@Bean</code> 不与 <code>@Configuration</code> 联用，可以是与 <code>@Component</code> 联用，也可以是与普通 java 类联用；</li>\n<li>full @Configuration 下 bean 间的依赖通过调用其他 bean 方法全都实现，而 lite 模式只能通过参数实现 bean 间依赖。因而， lite 模式 bean 方法只是一个提供 bean 引用的工厂方法，没有运行时语义。这给 lite 模式带来的正面意义是在运行时没有 CGLIB 子类产生，对于类设计而言也没有限制，配置类可为 final 。？？？</li>\n<li>通常情况 <code>@Bean</code> 都与 <code>@Configuration</code> 类联用，因为 full 模式下，跨方法的引用都重定向到 <strong>IoC 容器生命周期</strong>管理。这就阻止了 @Bean 方法意外地被常规 java 调用而引起难以追踪的 bug 。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-1-1-AnnotationConfigApplicationContext-初始化-IoC-容器\"><a href=\"#1-2-1-1-AnnotationConfigApplicationContext-初始化-IoC-容器\" class=\"headerlink\" title=\"1.2.1.1. AnnotationConfigApplicationContext 初始化 IoC 容器\"></a>1.2.1.1. AnnotationConfigApplicationContext 初始化 IoC 容器</h4><p>使用 AnnotationConfigApplicationContext 初始化 IoC 容器。AnnotaionConfigApplicationContext 在 spring 3.0 中引进。</p>\n<ul>\n<li><p>通过 <code>@Configuration</code> 配置类注册初始化</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       ApplicationContext ctx = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">       MyService myService = ctx.getBean(MyService.class);</span><br><span class=\"line\">       myService.doStuff();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>AppConfig 是一个 bean 配置类，集合相应的 bean ，在一个类中。</li>\n<li>可以使用无参构造一个 AnnotationConfigApplicationContext 实例，再调用其 <code>register(config.class)</code> 方法将配置类注册进去，达到同样的效果。</li>\n</ul>\n</li>\n<li><p>通过各个 bean 的 class 注册</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       ApplicationContext ctx = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class=\"line\">       MyService myService = ctx.getBean(MyService.class);</span><br><span class=\"line\">       myService.doStuff();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"1-2-1-2-ComponentScan\"><a href=\"#1-2-1-2-ComponentScan\" class=\"headerlink\" title=\"1.2.1.2. ComponentScan\"></a>1.2.1.2. ComponentScan</h4><ul>\n<li>使用 <code>@ComponentScan(basePackage=&#123;&quot;com.xxx&quot;&#125;)</code> 注解在 Configuration 上将 component 扫描入 IoC Container。等同于 beans.xml 配置中的 <code>&lt;context:component-scan base-package=&quot;com.xxx&quot; /&gt;</code>。</li>\n<li>在 AnnotationConfigurationApplicationContext 中可使用 <code>scan(String package)</code> 达到同样的效果。</li>\n<li><code>@Configuration</code> 被元注解 <code>@Component</code> 所注解，所以，只要被 scan 到，同样会被注册到 IoC 容器中。</li>\n</ul>\n<h4 id=\"1-2-1-3-AnnotationConfigWebApplicationContext\"><a href=\"#1-2-1-3-AnnotationConfigWebApplicationContext\" class=\"headerlink\" title=\"1.2.1.3. AnnotationConfigWebApplicationContext\"></a>1.2.1.3. AnnotationConfigWebApplicationContext</h4><ul>\n<li>AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的变体，用于初始化 springmvc 容器。</li>\n<li>可用于注册 Spring Servlet listener <code>ContextLoaderListener</code>、spring MVC DispatcherServlet 等等。</li>\n</ul>\n<h4 id=\"Fine-tuning-Annotation-based-Autowiring-with-Qualifiers\"><a href=\"#Fine-tuning-Annotation-based-Autowiring-with-Qualifiers\" class=\"headerlink\" title=\"Fine-tuning Annotation-based Autowiring with Qualifiers\"></a>Fine-tuning Annotation-based Autowiring with Qualifiers</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation-primary\">reference</a></p>\n<p>微调 bean 注入。使用注解 <code>@Qualifier</code> 在bean 定义与bean 注入处添加数据用以鉴别 bean 。</p>\n<ul>\n<li>bean 定义处可以不使用 <code>@Qualifier</code> ，注入处会自动使用 beanName 。</li>\n<li><code>@AutoWired</code> 注入的策略是先使用 Type 匹配，匹配到多个时会使用 <code>@Qualifier</code> 指定的 value 匹配。</li>\n<li><code>@Resource</code> 注解注入匹配策略只使用其唯一名 unique name，type 定义与其无关。</li>\n<li>如果 bean 定义为一个集合，数组或 Map，使用 <code>@Resource</code> 可直接匹配其 beanName 得到此集合。</li>\n<li>通过 <code>@AutoWired</code> 注入时有多个 bean Type 匹配，此时可以添加 <code>@Qualifier</code> 数据获取。</li>\n<li><code>@AutoWired</code> 自注入（截止到 Spring 4.3），在这种场景自注入的 self-bean 优先级最低，不能为 Primary 。</li>\n<li>在同一个 Configuration 类 @Bean 方法中注入自身是解决自引用的问题更高效。</li>\n</ul>\n<h2 id=\"1-3-Container-Extension-points\"><a href=\"#1-3-Container-Extension-points\" class=\"headerlink\" title=\"1.3. Container Extension points\"></a>1.3. Container Extension points</h2><p>容器扩展<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension\">reference</a></p>\n<h3 id=\"1-3-1-自定义-BeanPostProcessor\"><a href=\"#1-3-1-自定义-BeanPostProcessor\" class=\"headerlink\" title=\"1.3.1. 自定义 BeanPostProcessor\"></a>1.3.1. 自定义 BeanPostProcessor</h3><ul>\n<li>针对 bean 初始化后执行的回调配置，在每个 bean 初始化后执行其中的回调。</li>\n<li>可以配置多个，可指定其执行的顺序，通过 <code>Ordered</code> 接口或注解 <code>@Order</code></li>\n<li>BeanPostProcessor 只与自己所有的上下文环境相关，所在容器之间的处理器互不干扰。</li>\n<li>如果要操作容器中 BeanDefinition（bean 蓝图），要定义 BeanFactoryPostProcessor</li>\n<li>代理包装就是使用 BeanPostProcessor</li>\n<li>ApplicationContext 自动检测 BeanPostProcessor 实现并注册到容器中，并在随后的 bean creation 中调用。</li>\n<li>指定 lazy-init 属性对这两类处理器无效，因为如果其中没有其他 bean 引用 processor 不会初始化。</li>\n</ul>\n<p>Note:</p>\n<p><strong>Programmatically registering BeanPostProcessor instances</strong></p>\n<ul>\n<li>ApplicationContext 自动检测注册 BeanPostProcessor 外，还可以通过 ConfigurableBeanFactory.addBeanPostProcess() 手动注册。</li>\n<li>手动注册将忽略 processor 的 order 属性，直接使用手动注册的顺序作为 process() 的顺序。同时手动注册的优先于 ApplicationContext 自动检测注册的 processor。</li>\n</ul>\n<p><strong>BeanPostProcessor instances and AOP auto-proxying</strong></p>\n<ul>\n<li>容器对实现 BeanPostProcessor 的类专门处理。所有的 BeanPostProcessor 的实例与 bean 直接引用都在 ApplicationContext 启动时初始化，作为其启动阶段之一。</li>\n<li>所有的 BeanPostProcessor 实例都有序注册并都在后来相应的阶段处理容器中的 Bean。</li>\n<li>因为 Spring AOP 自动代理实现本身就是一个 BeanPostProcessor ，对于 BeanPostProcessor 实例，不管是其本身还是其直接依赖的 bean 都是自动代理的对象，所以不要对其编织切面。这于这类错误添加切面的 bean ，会出现日志信息：<code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code>。</li>\n<li>当在 BeanPostProcessor 使用 <code>@AutoWired</code>（自动装配） 或 <code>@Resource</code>(此类装配策略可能会退化为自动装配)装配了其他 Bean 。Spring 会在类型匹配查找时访问到不需要的 Bean 。所以需要让这些 Bean 对自动代理或其他类型的 Bean Post-Processing 失效。比如：有一个被 @Resource 注解的依赖，字段或 setter 名不能与一个与 bean 声明的名匹配且没有名字属性被使用，Spring 将访问与其他 type 相匹配的 bean 。</li>\n</ul>\n<h3 id=\"1-3-2-自定义-BeanFactoryPostProcessor\"><a href=\"#1-3-2-自定义-BeanFactoryPostProcessor\" class=\"headerlink\" title=\"1.3.2. 自定义 BeanFactoryPostProcessor\"></a>1.3.2. 自定义 BeanFactoryPostProcessor</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension\">BeanFactoryPostProcessor</a></p>\n<ul>\n<li><p>可直接访问 ApplicationContext.getBean() 获取 bean 到 processor 中，但这种方法不妥之处在于其获取的 bean 未破坏了容器生命周期管理，会产生潜在的副作用</p>\n</li>\n<li><p>BeanFactoryPostProcessor 同样其域范围是容器。</p>\n</li>\n<li><p>作用是操作配置的元数据</p>\n</li>\n<li><p>ApplicationContext 自动检测并部署 BeanFactoryPostProcessor 的实现。</p>\n</li>\n<li><p>PropertySourcesPlaceholderConfigurer 可以为 bean 从外部文件读取数据配置 bean property，外部文件是 java 标准的 Properties 格式。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;locations&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:com/something/jdbc.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;close&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>外部数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class=\"line\">jdbc.url=jdbc:hsqldb:hsql:<span class=\"comment\">//production:9002</span></span><br><span class=\"line\">jdbc.username=sa</span><br><span class=\"line\">jdbc.password=root</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>PropertyOverrideConfigurer 与 PropertySourcesPlaceholderConfigurer 类似，但可以给配置添加默认值</p>\n</li>\n<li><p>在不同环境使用不同的配置情况下，使用自定义处理器有用，具体使用还不明白。</p>\n</li>\n</ul>\n<h3 id=\"1-3-3-通过-FactoryBean-自定义初始化逻辑\"><a href=\"#1-3-3-通过-FactoryBean-自定义初始化逻辑\" class=\"headerlink\" title=\"1.3.3. 通过 FactoryBean 自定义初始化逻辑\"></a>1.3.3. 通过 FactoryBean 自定义初始化逻辑</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension\">reference</a></p>\n<ul>\n<li>IoC 容器初始化逻辑的插口，如果有冗杂的初始化代码需要写，写在实现此接口的 java bean 中，而不是使用 xml 配置。</li>\n<li>定义一个 bean 实现 FactoryBean 接口，此时 bean 是自己的工厂。</li>\n<li>从容器中获取 FactoryBean 实例时， 在 bean id 前加上 <code>&amp;</code>：<code>getBean(&quot;&amp;beanName&quot;)</code> 即可。</li>\n</ul>\n<h2 id=\"1-4-ApplicationContext-额外功能\"><a href=\"#1-4-ApplicationContext-额外功能\" class=\"headerlink\" title=\"1.4. ApplicationContext 额外功能\"></a>1.4. ApplicationContext 额外功能</h2><p>ApplicationContext 可以理解为 Spring IoC 容器。ApplicationContext 额外的功能<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<h3 id=\"1-4-1-使用-MessageResource-做国际化\"><a href=\"#1-4-1-使用-MessageResource-做国际化\" class=\"headerlink\" title=\"1.4.1. 使用 MessageResource 做国际化\"></a>1.4.1. 使用 MessageResource 做国际化</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<ul>\n<li>ApplicationContext 默认实现都继承了 MessageResource 接口，只要注册了任何一个 MessageContext Bean 在容器中，即可使用其功能。</li>\n<li>默认的 MessageContext 实现 <code>org.springframework.context.support.ResourceBundleMessageSource</code> ，可定义相关 ResourceBundle 用于 message 定制。</li>\n<li><code>ReloadableResourceBundleMessageSource</code> 有更灵活的实现，允许从 Spring 资源中加载任何路径中的文件， <code>ResourceBundleMessageSource</code> 只能加载 classpath 中的资源文件。同时也支持热重载资源文件。</li>\n</ul>\n<h3 id=\"1-4-2-标准事件与自定义事件\"><a href=\"#1-4-2-标准事件与自定义事件\" class=\"headerlink\" title=\"1.4.2. 标准事件与自定义事件\"></a>1.4.2. 标准事件与自定义事件</h3><p>ApplicationContext 中事件的处理通过 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口完成，当发布一个 event 实现了 <code>ApplicationListener</code> 的类将被通知到此事件。这是一个典型的观察者设计模式。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<p>从 Spring 4.2 开始，事件处理可使用注解配置。</p>\n<h4 id=\"1-4-2-1-内置的事件\"><a href=\"#1-4-2-1-内置的事件\" class=\"headerlink\" title=\"1.4.2.1. 内置的事件\"></a>1.4.2.1. 内置的事件</h4><ol>\n<li>ContextRefreshedEvent 在 ApplicationContext 初始化或刷新时触发，在 context 未 closed，可以多次调用 <code>refresh()</code> 刷新</li>\n<li>ContextStartedEvent 在 <code>ConfigurableApplicationContext</code> 接口中调用 <code>start()</code> 方法开启一个 <code>ApplicationContext</code> 时发布此事件。</li>\n<li>ContextStoppedEvent 在<code>ConfigurableApplicationContext</code> 接口中调用 <code>stop()</code> 方法停止一个 context 时发布。</li>\n<li>ContextClosedEvent 在 <code>ConfigurableApplicationContext</code> 接口中调用 <code>close()</code> 方法关闭一个应用时发布。</li>\n<li>RequestHandledEvent 在一个使用 Spring DispatcherServlet 的 web 应用中，一个请求完成后发布此事件。</li>\n<li>ServletRequestHandledEvent <code>RequestHandledEvent</code> 的子类，可以添加指定 Servlet 上下文信息。</li>\n</ol>\n<h4 id=\"1-4-2-2-监听器实现\"><a href=\"#1-4-2-2-监听器实现\" class=\"headerlink\" title=\"1.4.2.2. 监听器实现\"></a>1.4.2.2. 监听器实现</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<ul>\n<li>ApplicationContext 将自动注册为一个 <code>ApplicationEventPulisher</code>，事件发布器。</li>\n<li>使用注解注册监听器 <code>@EventLisener</code> ，注解在方法之上不用再实现 <code>ApplicationLisener</code> 。</li>\n<li>指定监听事件对象类型 <code>@EventListener(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)</code></li>\n</ul>\n<h3 id=\"1-4-3-Web-应用中实例化-ApplicationContext\"><a href=\"#1-4-3-Web-应用中实例化-ApplicationContext\" class=\"headerlink\" title=\"1.4.3. Web 应用中实例化 ApplicationContext\"></a>1.4.3. Web 应用中实例化 ApplicationContext</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create\">reference</a></p>\n<h3 id=\"1-4-4-发布一个-Spring-ApplicationContext-为-Java-EE-RAR-文件\"><a href=\"#1-4-4-发布一个-Spring-ApplicationContext-为-Java-EE-RAR-文件\" class=\"headerlink\" title=\"1.4.4. 发布一个 Spring ApplicationContext 为 Java EE RAR 文件\"></a>1.4.4. 发布一个 Spring ApplicationContext 为 Java EE RAR 文件</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create\">reference</a></p>\n<h2 id=\"1-5-Environment-Abstraction\"><a href=\"#1-5-Environment-Abstraction\" class=\"headerlink\" title=\"1.5. Environment Abstraction\"></a>1.5. Environment Abstraction</h2><p>Spring IoC 环境抽象。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment\">reference</a></p>\n<h3 id=\"1-5-1-使用-Profile-注解-bean\"><a href=\"#1-5-1-使用-Profile-注解-bean\" class=\"headerlink\" title=\"1.5.1. 使用 @Profile 注解 bean\"></a>1.5.1. 使用 @Profile 注解 bean</h3><p>使用 <code>@Profile</code> 注解实现 bean 的不同环境是否激活。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment\">reference</a></p>\n<ul>\n<li>如果 注解在配置类上，类中所有未单独使用 <code>@Profile</code> 注解的 bean 都会使用此注解。</li>\n<li>value 可以使用 表达式，表达式共有三种布尔运算符：与 <code>&amp;</code>, 或 <code>|</code> , 非 <code>!</code> 。表达式运算符可以连用，但超过两个，两两之间必须使用括号确定运行顺序： <code>@Profile(value=&quot;prd|(test&amp;us-east)&quot;)</code> 。在 xml 配置中只能使用 <code>!</code> ，使用 与 <code>&amp;</code> 运算在 <code>&lt;beans profile=&quot;production&quot;/&gt;</code> 中再内嵌一个 <code>&lt;beans profile=&quot;us-central&quot; /&gt;</code></li>\n<li>value 是数组，多个 value 之间可以使用 <code>,</code> 分隔开</li>\n<li>可以使用 <code>@Profile</code> 当元注解自定义 profile 功能注解。</li>\n<li>当使用 <code>@Profile</code> 注解在配置类的 bean defined method 方法上时，可以指定同一个 bean 在不同环境配置中为不同的实例。但在这种情况下，注意同一个方法的重载方法使用不同的 profile 只有第一个的生效。解决方案，使用不同的方法名避免 bean defined method 重载。</li>\n</ul>\n<h3 id=\"1-5-2-激活项目-Profile\"><a href=\"#1-5-2-激活项目-Profile\" class=\"headerlink\" title=\"1.5.2. 激活项目 Profile\"></a>1.5.2. 激活项目 Profile</h3><p>激活 spring profile 方式有很多。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment\">reference</a></p>\n<ol>\n<li>最直接简单方式：在 ApplicationContext 中获取 Environment 再调用其 <code>setProfiles()</code> 方法，之后还得 <code>refresh()</code> 一次刷新配置。</li>\n<li>通过指定 <code>spring.profiles.active=&quot;dev&quot;</code> ，指定方式：<ol>\n<li>添加 JVM 系统属性：<code>-D</code> 命令行；</li>\n<li>系统环境变量</li>\n<li>servlet context 参数</li>\n<li>JNDI 入口</li>\n<li>测试模块可使用注解 <code>@ActiveProifles</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"1-5-3-PropertySource-Abstraction\"><a href=\"#1-5-3-PropertySource-Abstraction\" class=\"headerlink\" title=\"1.5.3. PropertySource Abstraction\"></a>1.5.3. PropertySource Abstraction</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction\">reference</a></p>\n<ul>\n<li><p>Spring 的 <code>Environment</code> 抽象通过可配置的 Property Source （属性源）提供查询操作。</p>\n</li>\n<li><p>Spring 独立应用使用 <code>StandardEnvironment</code> 为默认的 Property Source 。 <code>StandardServletEnvironment</code> 还提供额外的Servlet config 和 servlet context 参数。</p>\n</li>\n<li><p><code>StandardServletEnvironment</code> property source 从高到低优先级：</p>\n<ul>\n<li>ServletConfig parameters (if applicable — for example, in case of a DispatcherServlet context)</li>\n<li>ServletContext parameters (web.xml context-param entries)</li>\n<li>JNDI environment variables (java:comp/env/ entries)</li>\n<li>JVM system properties (-D command-line arguments)</li>\n<li>JVM system environment (operating system environment variables)</li>\n</ul>\n</li>\n<li><p>整个查询机制是可配的，可自定义 property source 添加到 environment 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConfigurableApplicationContext ctx = <span class=\"keyword\">new</span> GenericApplicationContext();</span><br><span class=\"line\">MutablePropertySources sources = ctx.getEnvironment().getPropertySources();</span><br><span class=\"line\">sources.addFirst(<span class=\"keyword\">new</span> MyPropertySource());</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"1-5-4-使用-PropertySource\"><a href=\"#1-5-4-使用-PropertySource\" class=\"headerlink\" title=\"1.5.4. 使用 @PropertySource\"></a>1.5.4. 使用 @PropertySource</h3><p>使用此注解为 Configuration 添加外部配置文件。</p>\n<ul>\n<li><code>@PropertySource(&quot;classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties&quot;)</code> 其中可使用点位符添加已加入的配置作为路径</li>\n<li>可以添加多个 <code>@PropertySource</code> 或自定义同功能（使用此注解当元注解）的注解在同一个 configuration 上，但不推荐，因为直接的注解会覆盖数据注解。</li>\n</ul>\n<h3 id=\"1-5-5-Placeholder-Resolution-in-Statement\"><a href=\"#1-5-5-Placeholder-Resolution-in-Statement\" class=\"headerlink\" title=\"1.5.5. Placeholder Resolution in Statement\"></a>1.5.5. Placeholder Resolution in Statement</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction\">reference</a></p>\n<p>使用已定义好的配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">import</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;com/bank/service/$&#123;customer&#125;-config.xml&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-BeanFactory\"><a href=\"#1-6-BeanFactory\" class=\"headerlink\" title=\"1.6. BeanFactory\"></a>1.6. BeanFactory</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beanfactory\">Spring IoC 容器基础</a></p>\n<ul>\n<li>整个框架组件都基于 BeanFactory 及 相关的接口（<code>BeanFactoryAware</code> <code>InitializingBean</code>  <code>DisposableBean</code>）整个而成。</li>\n<li>BeanFactory 级别的 API （其默认实现： DefaultListableBeanFactory） 只是单纯的一个工厂，并没对应用相关的组件进行设定，配置格式与注解组件都未配置。</li>\n<li><code>ApplicationContext</code> 是 <code>BeanFactory</code> 增强，包含了BeanFactory 所有的功能，其实现（eg: GenericApplicationContext）会按惯例扫描各类 bean 。ApplicationContext 的各类变体都会扩展各类功能，如添加 BeanFactoryPostProcessor BeanPostProcessor。</li>\n<li><code>AnnotationConfigApplicationContext</code> 除了添加了 post-processor 等组件外，还通过注解添加其他组件，如：<code>@EnableTransactionManagement</code>。在 Spring 注解配置模式中，post-processor bean 的概念仅仅只是容器内部细节。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Spring 说到底就是一个轻量级的容器，让它来负责各个实例的生产、管理、维护，而这些实例的参数与依赖关系都交由 spring 的配置文件来设置；","more":"</p>\n</blockquote>\n<!--more-->\n\n<h2 id=\"1-1-反向控制（Inverse-of-Control\"><a href=\"#1-1-反向控制（Inverse-of-Control\" class=\"headerlink\" title=\"1.1. 反向控制（Inverse of Control)\"></a>1.1. 反向控制（Inverse of Control)</h2><blockquote>\n<p>概念：也可以叫依赖注入（Dependency Injection)，是 spring 的核心思想。通俗地理解就是将原本正向流程走的程序让其反向执行。<br>之所以也叫依赖注入，是因为在实现反向控制的过程中是将原本要在后面实例化的属性提前注入到自己的实例中。这样 <strong>把离散的组件在运行时组装到一块</strong> ，实现程序流程在运行时组装，这样就可以很方便地添加功能，比如：拦截器；</p>\n</blockquote>\n<h3 id=\"1-1-1-举例\"><a href=\"#1-1-1-举例\" class=\"headerlink\" title=\"1.1.1. 举例\"></a>1.1.1. 举例</h3><ul>\n<li>当我们要通过 DAO 层的 dao 与 Service 层的 service 对象来实现分业务层的访问数据库操作：<ul>\n<li><strong>正向思维</strong>：是先实例化一个 Service 对象，再在这个 Service 对象中实例一个 Dao 对象来，在 Service 方法中执行这个 Dao 对象的方法来访问数据库。</li>\n<li><strong>反向控制</strong>：Service 与 Dao 都抽象出各自的接口，而在 Service 实现类中约定一个 Dao 接口的属性，service 方法中再来调用这个 Dao 的方法；而在 Spring 中，这个属性的实现就叫注入，而这个注入是通过 spring 配置文件中的 bean 实现，在 Service 的 bean 中，有一个 <code>&lt;property&gt;</code> 的标签，这个标签中配置相关的 dao 的 bean 。<ul>\n<li><em>在这个例子中， Service 与 Dao 都是作为独立的组件出现，在编码阶段，既没有实例化对象出来也没有设置依赖关系，而把它交给Spring，<strong>由 Spring 在运行阶段实例化并组装</strong>。这种颠覆传统编码过程就叫反转控制。</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Note:</strong></p>\n<ul>\n<li>反向控制在 spring 配置中高频地被使用，在实现AOP面向切面编程中高频地使用到反向控制来将各个方法注入到其他的方法之前或之后；</li>\n</ul>\n<h2 id=\"1-2-Container-Configuration\"><a href=\"#1-2-Container-Configuration\" class=\"headerlink\" title=\"1.2. Container Configuration\"></a>1.2. Container Configuration</h2><p>ioc 容器配置。传统配置方法是使用 xml 配置文件实现。</p>\n<h3 id=\"1-2-1-java-based-container-configuration\"><a href=\"#1-2-1-java-based-container-configuration\" class=\"headerlink\" title=\"1.2.1. java based container configuration\"></a>1.2.1. java based container configuration</h3><p>基于 java 代码配置 ioc 容器，也就是注解配置。</p>\n<ul>\n<li>spring 注解配置的中心就是 <code>@Bean</code> 用于标记方法与 <code>@Configuration</code> 标记的类。</li>\n<li><code>@Bean</code> 用以标记方法实例化、配置并初始化一个 IoC 容器管理的 object ，类似 <code>&lt;beans/&gt;</code> 配置文件中的 <code>&lt;bean&gt;</code> 元素。</li>\n<li><code>@Bean</code> 可置于 <code>@Component</code> 标记的类中，成为 lite （轻量）Bean 模式，但一般与 <code>@Configuration</code> 配置类联用。<ul>\n<li>full @Configuration 与 lite @Bean 模式<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java\">reference</a><ul>\n<li>lite @Bean 模式指 <code>@Bean</code> 不与 <code>@Configuration</code> 联用，可以是与 <code>@Component</code> 联用，也可以是与普通 java 类联用；</li>\n<li>full @Configuration 下 bean 间的依赖通过调用其他 bean 方法全都实现，而 lite 模式只能通过参数实现 bean 间依赖。因而， lite 模式 bean 方法只是一个提供 bean 引用的工厂方法，没有运行时语义。这给 lite 模式带来的正面意义是在运行时没有 CGLIB 子类产生，对于类设计而言也没有限制，配置类可为 final 。？？？</li>\n<li>通常情况 <code>@Bean</code> 都与 <code>@Configuration</code> 类联用，因为 full 模式下，跨方法的引用都重定向到 <strong>IoC 容器生命周期</strong>管理。这就阻止了 @Bean 方法意外地被常规 java 调用而引起难以追踪的 bug 。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-1-1-AnnotationConfigApplicationContext-初始化-IoC-容器\"><a href=\"#1-2-1-1-AnnotationConfigApplicationContext-初始化-IoC-容器\" class=\"headerlink\" title=\"1.2.1.1. AnnotationConfigApplicationContext 初始化 IoC 容器\"></a>1.2.1.1. AnnotationConfigApplicationContext 初始化 IoC 容器</h4><p>使用 AnnotationConfigApplicationContext 初始化 IoC 容器。AnnotaionConfigApplicationContext 在 spring 3.0 中引进。</p>\n<ul>\n<li><p>通过 <code>@Configuration</code> 配置类注册初始化</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       ApplicationContext ctx = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">       MyService myService = ctx.getBean(MyService.class);</span><br><span class=\"line\">       myService.doStuff();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>AppConfig 是一个 bean 配置类，集合相应的 bean ，在一个类中。</li>\n<li>可以使用无参构造一个 AnnotationConfigApplicationContext 实例，再调用其 <code>register(config.class)</code> 方法将配置类注册进去，达到同样的效果。</li>\n</ul>\n</li>\n<li><p>通过各个 bean 的 class 注册</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       ApplicationContext ctx = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class=\"line\">       MyService myService = ctx.getBean(MyService.class);</span><br><span class=\"line\">       myService.doStuff();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"1-2-1-2-ComponentScan\"><a href=\"#1-2-1-2-ComponentScan\" class=\"headerlink\" title=\"1.2.1.2. ComponentScan\"></a>1.2.1.2. ComponentScan</h4><ul>\n<li>使用 <code>@ComponentScan(basePackage=&#123;&quot;com.xxx&quot;&#125;)</code> 注解在 Configuration 上将 component 扫描入 IoC Container。等同于 beans.xml 配置中的 <code>&lt;context:component-scan base-package=&quot;com.xxx&quot; /&gt;</code>。</li>\n<li>在 AnnotationConfigurationApplicationContext 中可使用 <code>scan(String package)</code> 达到同样的效果。</li>\n<li><code>@Configuration</code> 被元注解 <code>@Component</code> 所注解，所以，只要被 scan 到，同样会被注册到 IoC 容器中。</li>\n</ul>\n<h4 id=\"1-2-1-3-AnnotationConfigWebApplicationContext\"><a href=\"#1-2-1-3-AnnotationConfigWebApplicationContext\" class=\"headerlink\" title=\"1.2.1.3. AnnotationConfigWebApplicationContext\"></a>1.2.1.3. AnnotationConfigWebApplicationContext</h4><ul>\n<li>AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的变体，用于初始化 springmvc 容器。</li>\n<li>可用于注册 Spring Servlet listener <code>ContextLoaderListener</code>、spring MVC DispatcherServlet 等等。</li>\n</ul>\n<h4 id=\"Fine-tuning-Annotation-based-Autowiring-with-Qualifiers\"><a href=\"#Fine-tuning-Annotation-based-Autowiring-with-Qualifiers\" class=\"headerlink\" title=\"Fine-tuning Annotation-based Autowiring with Qualifiers\"></a>Fine-tuning Annotation-based Autowiring with Qualifiers</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation-primary\">reference</a></p>\n<p>微调 bean 注入。使用注解 <code>@Qualifier</code> 在bean 定义与bean 注入处添加数据用以鉴别 bean 。</p>\n<ul>\n<li>bean 定义处可以不使用 <code>@Qualifier</code> ，注入处会自动使用 beanName 。</li>\n<li><code>@AutoWired</code> 注入的策略是先使用 Type 匹配，匹配到多个时会使用 <code>@Qualifier</code> 指定的 value 匹配。</li>\n<li><code>@Resource</code> 注解注入匹配策略只使用其唯一名 unique name，type 定义与其无关。</li>\n<li>如果 bean 定义为一个集合，数组或 Map，使用 <code>@Resource</code> 可直接匹配其 beanName 得到此集合。</li>\n<li>通过 <code>@AutoWired</code> 注入时有多个 bean Type 匹配，此时可以添加 <code>@Qualifier</code> 数据获取。</li>\n<li><code>@AutoWired</code> 自注入（截止到 Spring 4.3），在这种场景自注入的 self-bean 优先级最低，不能为 Primary 。</li>\n<li>在同一个 Configuration 类 @Bean 方法中注入自身是解决自引用的问题更高效。</li>\n</ul>\n<h2 id=\"1-3-Container-Extension-points\"><a href=\"#1-3-Container-Extension-points\" class=\"headerlink\" title=\"1.3. Container Extension points\"></a>1.3. Container Extension points</h2><p>容器扩展<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension\">reference</a></p>\n<h3 id=\"1-3-1-自定义-BeanPostProcessor\"><a href=\"#1-3-1-自定义-BeanPostProcessor\" class=\"headerlink\" title=\"1.3.1. 自定义 BeanPostProcessor\"></a>1.3.1. 自定义 BeanPostProcessor</h3><ul>\n<li>针对 bean 初始化后执行的回调配置，在每个 bean 初始化后执行其中的回调。</li>\n<li>可以配置多个，可指定其执行的顺序，通过 <code>Ordered</code> 接口或注解 <code>@Order</code></li>\n<li>BeanPostProcessor 只与自己所有的上下文环境相关，所在容器之间的处理器互不干扰。</li>\n<li>如果要操作容器中 BeanDefinition（bean 蓝图），要定义 BeanFactoryPostProcessor</li>\n<li>代理包装就是使用 BeanPostProcessor</li>\n<li>ApplicationContext 自动检测 BeanPostProcessor 实现并注册到容器中，并在随后的 bean creation 中调用。</li>\n<li>指定 lazy-init 属性对这两类处理器无效，因为如果其中没有其他 bean 引用 processor 不会初始化。</li>\n</ul>\n<p>Note:</p>\n<p><strong>Programmatically registering BeanPostProcessor instances</strong></p>\n<ul>\n<li>ApplicationContext 自动检测注册 BeanPostProcessor 外，还可以通过 ConfigurableBeanFactory.addBeanPostProcess() 手动注册。</li>\n<li>手动注册将忽略 processor 的 order 属性，直接使用手动注册的顺序作为 process() 的顺序。同时手动注册的优先于 ApplicationContext 自动检测注册的 processor。</li>\n</ul>\n<p><strong>BeanPostProcessor instances and AOP auto-proxying</strong></p>\n<ul>\n<li>容器对实现 BeanPostProcessor 的类专门处理。所有的 BeanPostProcessor 的实例与 bean 直接引用都在 ApplicationContext 启动时初始化，作为其启动阶段之一。</li>\n<li>所有的 BeanPostProcessor 实例都有序注册并都在后来相应的阶段处理容器中的 Bean。</li>\n<li>因为 Spring AOP 自动代理实现本身就是一个 BeanPostProcessor ，对于 BeanPostProcessor 实例，不管是其本身还是其直接依赖的 bean 都是自动代理的对象，所以不要对其编织切面。这于这类错误添加切面的 bean ，会出现日志信息：<code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code>。</li>\n<li>当在 BeanPostProcessor 使用 <code>@AutoWired</code>（自动装配） 或 <code>@Resource</code>(此类装配策略可能会退化为自动装配)装配了其他 Bean 。Spring 会在类型匹配查找时访问到不需要的 Bean 。所以需要让这些 Bean 对自动代理或其他类型的 Bean Post-Processing 失效。比如：有一个被 @Resource 注解的依赖，字段或 setter 名不能与一个与 bean 声明的名匹配且没有名字属性被使用，Spring 将访问与其他 type 相匹配的 bean 。</li>\n</ul>\n<h3 id=\"1-3-2-自定义-BeanFactoryPostProcessor\"><a href=\"#1-3-2-自定义-BeanFactoryPostProcessor\" class=\"headerlink\" title=\"1.3.2. 自定义 BeanFactoryPostProcessor\"></a>1.3.2. 自定义 BeanFactoryPostProcessor</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension\">BeanFactoryPostProcessor</a></p>\n<ul>\n<li><p>可直接访问 ApplicationContext.getBean() 获取 bean 到 processor 中，但这种方法不妥之处在于其获取的 bean 未破坏了容器生命周期管理，会产生潜在的副作用</p>\n</li>\n<li><p>BeanFactoryPostProcessor 同样其域范围是容器。</p>\n</li>\n<li><p>作用是操作配置的元数据</p>\n</li>\n<li><p>ApplicationContext 自动检测并部署 BeanFactoryPostProcessor 的实现。</p>\n</li>\n<li><p>PropertySourcesPlaceholderConfigurer 可以为 bean 从外部文件读取数据配置 bean property，外部文件是 java 标准的 Properties 格式。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;locations&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:com/something/jdbc.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;close&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>外部数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class=\"line\">jdbc.url=jdbc:hsqldb:hsql:<span class=\"comment\">//production:9002</span></span><br><span class=\"line\">jdbc.username=sa</span><br><span class=\"line\">jdbc.password=root</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>PropertyOverrideConfigurer 与 PropertySourcesPlaceholderConfigurer 类似，但可以给配置添加默认值</p>\n</li>\n<li><p>在不同环境使用不同的配置情况下，使用自定义处理器有用，具体使用还不明白。</p>\n</li>\n</ul>\n<h3 id=\"1-3-3-通过-FactoryBean-自定义初始化逻辑\"><a href=\"#1-3-3-通过-FactoryBean-自定义初始化逻辑\" class=\"headerlink\" title=\"1.3.3. 通过 FactoryBean 自定义初始化逻辑\"></a>1.3.3. 通过 FactoryBean 自定义初始化逻辑</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension\">reference</a></p>\n<ul>\n<li>IoC 容器初始化逻辑的插口，如果有冗杂的初始化代码需要写，写在实现此接口的 java bean 中，而不是使用 xml 配置。</li>\n<li>定义一个 bean 实现 FactoryBean 接口，此时 bean 是自己的工厂。</li>\n<li>从容器中获取 FactoryBean 实例时， 在 bean id 前加上 <code>&amp;</code>：<code>getBean(&quot;&amp;beanName&quot;)</code> 即可。</li>\n</ul>\n<h2 id=\"1-4-ApplicationContext-额外功能\"><a href=\"#1-4-ApplicationContext-额外功能\" class=\"headerlink\" title=\"1.4. ApplicationContext 额外功能\"></a>1.4. ApplicationContext 额外功能</h2><p>ApplicationContext 可以理解为 Spring IoC 容器。ApplicationContext 额外的功能<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<h3 id=\"1-4-1-使用-MessageResource-做国际化\"><a href=\"#1-4-1-使用-MessageResource-做国际化\" class=\"headerlink\" title=\"1.4.1. 使用 MessageResource 做国际化\"></a>1.4.1. 使用 MessageResource 做国际化</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<ul>\n<li>ApplicationContext 默认实现都继承了 MessageResource 接口，只要注册了任何一个 MessageContext Bean 在容器中，即可使用其功能。</li>\n<li>默认的 MessageContext 实现 <code>org.springframework.context.support.ResourceBundleMessageSource</code> ，可定义相关 ResourceBundle 用于 message 定制。</li>\n<li><code>ReloadableResourceBundleMessageSource</code> 有更灵活的实现，允许从 Spring 资源中加载任何路径中的文件， <code>ResourceBundleMessageSource</code> 只能加载 classpath 中的资源文件。同时也支持热重载资源文件。</li>\n</ul>\n<h3 id=\"1-4-2-标准事件与自定义事件\"><a href=\"#1-4-2-标准事件与自定义事件\" class=\"headerlink\" title=\"1.4.2. 标准事件与自定义事件\"></a>1.4.2. 标准事件与自定义事件</h3><p>ApplicationContext 中事件的处理通过 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口完成，当发布一个 event 实现了 <code>ApplicationListener</code> 的类将被通知到此事件。这是一个典型的观察者设计模式。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<p>从 Spring 4.2 开始，事件处理可使用注解配置。</p>\n<h4 id=\"1-4-2-1-内置的事件\"><a href=\"#1-4-2-1-内置的事件\" class=\"headerlink\" title=\"1.4.2.1. 内置的事件\"></a>1.4.2.1. 内置的事件</h4><ol>\n<li>ContextRefreshedEvent 在 ApplicationContext 初始化或刷新时触发，在 context 未 closed，可以多次调用 <code>refresh()</code> 刷新</li>\n<li>ContextStartedEvent 在 <code>ConfigurableApplicationContext</code> 接口中调用 <code>start()</code> 方法开启一个 <code>ApplicationContext</code> 时发布此事件。</li>\n<li>ContextStoppedEvent 在<code>ConfigurableApplicationContext</code> 接口中调用 <code>stop()</code> 方法停止一个 context 时发布。</li>\n<li>ContextClosedEvent 在 <code>ConfigurableApplicationContext</code> 接口中调用 <code>close()</code> 方法关闭一个应用时发布。</li>\n<li>RequestHandledEvent 在一个使用 Spring DispatcherServlet 的 web 应用中，一个请求完成后发布此事件。</li>\n<li>ServletRequestHandledEvent <code>RequestHandledEvent</code> 的子类，可以添加指定 Servlet 上下文信息。</li>\n</ol>\n<h4 id=\"1-4-2-2-监听器实现\"><a href=\"#1-4-2-2-监听器实现\" class=\"headerlink\" title=\"1.4.2.2. 监听器实现\"></a>1.4.2.2. 监听器实现</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction\">reference</a></p>\n<ul>\n<li>ApplicationContext 将自动注册为一个 <code>ApplicationEventPulisher</code>，事件发布器。</li>\n<li>使用注解注册监听器 <code>@EventLisener</code> ，注解在方法之上不用再实现 <code>ApplicationLisener</code> 。</li>\n<li>指定监听事件对象类型 <code>@EventListener(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)</code></li>\n</ul>\n<h3 id=\"1-4-3-Web-应用中实例化-ApplicationContext\"><a href=\"#1-4-3-Web-应用中实例化-ApplicationContext\" class=\"headerlink\" title=\"1.4.3. Web 应用中实例化 ApplicationContext\"></a>1.4.3. Web 应用中实例化 ApplicationContext</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create\">reference</a></p>\n<h3 id=\"1-4-4-发布一个-Spring-ApplicationContext-为-Java-EE-RAR-文件\"><a href=\"#1-4-4-发布一个-Spring-ApplicationContext-为-Java-EE-RAR-文件\" class=\"headerlink\" title=\"1.4.4. 发布一个 Spring ApplicationContext 为 Java EE RAR 文件\"></a>1.4.4. 发布一个 Spring ApplicationContext 为 Java EE RAR 文件</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create\">reference</a></p>\n<h2 id=\"1-5-Environment-Abstraction\"><a href=\"#1-5-Environment-Abstraction\" class=\"headerlink\" title=\"1.5. Environment Abstraction\"></a>1.5. Environment Abstraction</h2><p>Spring IoC 环境抽象。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment\">reference</a></p>\n<h3 id=\"1-5-1-使用-Profile-注解-bean\"><a href=\"#1-5-1-使用-Profile-注解-bean\" class=\"headerlink\" title=\"1.5.1. 使用 @Profile 注解 bean\"></a>1.5.1. 使用 @Profile 注解 bean</h3><p>使用 <code>@Profile</code> 注解实现 bean 的不同环境是否激活。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment\">reference</a></p>\n<ul>\n<li>如果 注解在配置类上，类中所有未单独使用 <code>@Profile</code> 注解的 bean 都会使用此注解。</li>\n<li>value 可以使用 表达式，表达式共有三种布尔运算符：与 <code>&amp;</code>, 或 <code>|</code> , 非 <code>!</code> 。表达式运算符可以连用，但超过两个，两两之间必须使用括号确定运行顺序： <code>@Profile(value=&quot;prd|(test&amp;us-east)&quot;)</code> 。在 xml 配置中只能使用 <code>!</code> ，使用 与 <code>&amp;</code> 运算在 <code>&lt;beans profile=&quot;production&quot;/&gt;</code> 中再内嵌一个 <code>&lt;beans profile=&quot;us-central&quot; /&gt;</code></li>\n<li>value 是数组，多个 value 之间可以使用 <code>,</code> 分隔开</li>\n<li>可以使用 <code>@Profile</code> 当元注解自定义 profile 功能注解。</li>\n<li>当使用 <code>@Profile</code> 注解在配置类的 bean defined method 方法上时，可以指定同一个 bean 在不同环境配置中为不同的实例。但在这种情况下，注意同一个方法的重载方法使用不同的 profile 只有第一个的生效。解决方案，使用不同的方法名避免 bean defined method 重载。</li>\n</ul>\n<h3 id=\"1-5-2-激活项目-Profile\"><a href=\"#1-5-2-激活项目-Profile\" class=\"headerlink\" title=\"1.5.2. 激活项目 Profile\"></a>1.5.2. 激活项目 Profile</h3><p>激活 spring profile 方式有很多。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-environment\">reference</a></p>\n<ol>\n<li>最直接简单方式：在 ApplicationContext 中获取 Environment 再调用其 <code>setProfiles()</code> 方法，之后还得 <code>refresh()</code> 一次刷新配置。</li>\n<li>通过指定 <code>spring.profiles.active=&quot;dev&quot;</code> ，指定方式：<ol>\n<li>添加 JVM 系统属性：<code>-D</code> 命令行；</li>\n<li>系统环境变量</li>\n<li>servlet context 参数</li>\n<li>JNDI 入口</li>\n<li>测试模块可使用注解 <code>@ActiveProifles</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"1-5-3-PropertySource-Abstraction\"><a href=\"#1-5-3-PropertySource-Abstraction\" class=\"headerlink\" title=\"1.5.3. PropertySource Abstraction\"></a>1.5.3. PropertySource Abstraction</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction\">reference</a></p>\n<ul>\n<li><p>Spring 的 <code>Environment</code> 抽象通过可配置的 Property Source （属性源）提供查询操作。</p>\n</li>\n<li><p>Spring 独立应用使用 <code>StandardEnvironment</code> 为默认的 Property Source 。 <code>StandardServletEnvironment</code> 还提供额外的Servlet config 和 servlet context 参数。</p>\n</li>\n<li><p><code>StandardServletEnvironment</code> property source 从高到低优先级：</p>\n<ul>\n<li>ServletConfig parameters (if applicable — for example, in case of a DispatcherServlet context)</li>\n<li>ServletContext parameters (web.xml context-param entries)</li>\n<li>JNDI environment variables (java:comp/env/ entries)</li>\n<li>JVM system properties (-D command-line arguments)</li>\n<li>JVM system environment (operating system environment variables)</li>\n</ul>\n</li>\n<li><p>整个查询机制是可配的，可自定义 property source 添加到 environment 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConfigurableApplicationContext ctx = <span class=\"keyword\">new</span> GenericApplicationContext();</span><br><span class=\"line\">MutablePropertySources sources = ctx.getEnvironment().getPropertySources();</span><br><span class=\"line\">sources.addFirst(<span class=\"keyword\">new</span> MyPropertySource());</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"1-5-4-使用-PropertySource\"><a href=\"#1-5-4-使用-PropertySource\" class=\"headerlink\" title=\"1.5.4. 使用 @PropertySource\"></a>1.5.4. 使用 @PropertySource</h3><p>使用此注解为 Configuration 添加外部配置文件。</p>\n<ul>\n<li><code>@PropertySource(&quot;classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties&quot;)</code> 其中可使用点位符添加已加入的配置作为路径</li>\n<li>可以添加多个 <code>@PropertySource</code> 或自定义同功能（使用此注解当元注解）的注解在同一个 configuration 上，但不推荐，因为直接的注解会覆盖数据注解。</li>\n</ul>\n<h3 id=\"1-5-5-Placeholder-Resolution-in-Statement\"><a href=\"#1-5-5-Placeholder-Resolution-in-Statement\" class=\"headerlink\" title=\"1.5.5. Placeholder Resolution in Statement\"></a>1.5.5. Placeholder Resolution in Statement</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction\">reference</a></p>\n<p>使用已定义好的配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">import</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;com/bank/service/$&#123;customer&#125;-config.xml&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-BeanFactory\"><a href=\"#1-6-BeanFactory\" class=\"headerlink\" title=\"1.6. BeanFactory\"></a>1.6. BeanFactory</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beanfactory\">Spring IoC 容器基础</a></p>\n<ul>\n<li>整个框架组件都基于 BeanFactory 及 相关的接口（<code>BeanFactoryAware</code> <code>InitializingBean</code>  <code>DisposableBean</code>）整个而成。</li>\n<li>BeanFactory 级别的 API （其默认实现： DefaultListableBeanFactory） 只是单纯的一个工厂，并没对应用相关的组件进行设定，配置格式与注解组件都未配置。</li>\n<li><code>ApplicationContext</code> 是 <code>BeanFactory</code> 增强，包含了BeanFactory 所有的功能，其实现（eg: GenericApplicationContext）会按惯例扫描各类 bean 。ApplicationContext 的各类变体都会扩展各类功能，如添加 BeanFactoryPostProcessor BeanPostProcessor。</li>\n<li><code>AnnotationConfigApplicationContext</code> 除了添加了 post-processor 等组件外，还通过注解添加其他组件，如：<code>@EnableTransactionManagement</code>。在 Spring 注解配置模式中，post-processor bean 的概念仅仅只是容器内部细节。</li>\n</ul>"},{"title":"SpringBoot Externalized Configuration","date":"2020-07-19T15:48:38.000Z","description":"spring boot 外部配置的应用","_content":"\n[spring boot 外部配置](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config)\n\n> 外部配置\n\n一个应用，其通常添加外部配置的方式：properties file, yml files, environment variables, 命令行参数扩展配置。配置属性可以通过 `@Value` 直接被注入到 bean 中，通过 `Environment` 抽象直接访问，也可以通过 `@ConfigurationProperties` 绑定到结构对象上。<!--more-->\n\nSpring Boot 加载 `PropertySource` 有明确的顺序，以保证正确覆盖配置值。其**配置优先级**从高到低依次为：\n\n1. 当 devtool 在激活状态时， `$HOME/.config/spring-boot` 中的 devtool 全局配置\n2. `@TestPropertySource` 注解的 test 配置\n3. `@SpringBootTest` 注解与局部应用 test 注解上的 `Properties` 属性\n4. 命令行参数\n5. 内嵌于环境变量或系统属性的行内 JSON `SPRING_APPLICATION_JSON` 属性\n6. `ServletConfig` 初始化参数\n7. `ServletContext` 初始化参数\n8. `java:comp/env` JNDI 属性\n9. `System.getProperties()` Java 系统属性\n10. 操作系统环境变量 OS environment variables\n11. `random.*` 中的随机属性值 `RandomValuePropertySource`\n12. 包外的特定 profile 属性文件 `application-{profile}.properties` 与 YAML 变体\n13. 包内特定 profile 属性文件 `application-{profile}.properties` 或 YAML 变体\n14. 包外应用属性文件 `application.properties` 和 YAML 变体\n15. 包内应用配置文件  `application.properties` 和 YAML 变体\n16. `@PropertySource` 注解于 configuration 类上标注的属性文件。需要注意的是，这种配置在 application refreshed 前不会被加载到 `Environment` 中去，因此如果使用这种方式添加诸如 `logging.*` `spring.main.*` 配置是无效的，因为在 context refreshed 前，这些配置已经被读取了。\n17. 通过 `SpringApplication.setDefaultProperties()` 设置的默认属性。\n\nSpring Boot 在加载配置时支持通配路径，在外部指定不同路径下的同名配置文件时使用通配路径就会很方便。**通配路径必须包含且仅包含一个 `*` ，并且当以文件夹结尾时以 `/` 结尾，以文件为查找对象时以 `/<filename>` 结尾**。查找出的位置以文件路径的字母顺序排序。\n\n## .1. Configuring Random Values\n\n配置随机值随机注入一个 integer/long/uuid/string :\n\n```properties\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}\n```\n\n随机配置语法 `${random.int*}`是 `OPEN value (,max) CLOSE` `OPEN` 与 `CLOSE` 指代任意符号用以将最大值与最小值包起来，`value` 与 `max` 是 integer 。如果提供 `max`，`value` 就指最小值，`max` 指最大值（不包含）。\n\n## .2. Accessing Command Line Properties\n\n[访问命令行参数](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config)\n\n默认情况下命令行参数在 Spring 配置中有最高优先级别。在启动命令行中以 `--` 开始指定命令行参数。如果需要禁用命令行参数加入到系统 `Environment` 中，可以 `SpringApplication.setAddCommandLineProperties(false)`。\n\n## .3. Application Property Files\n\n[应用配置文件](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-application-property-files)\n\n`SpringApplication` 将不同位置的配置文件 `application.properties` 或 `.yaml` 数据加载到 `Environment` 中，不同位置加载优先级为：\n\n1. 当前路径子路径 `/config`\n2. 当前路径 The current directory\n3. classpath `/config` 包\n4. classpath 根\n\n高优先级配置会覆盖低优先级配置。\n\n如果需要修改配置文件，可以指定环境属性 `spring.config.name` 指定另一个配置文件，同时可指定 `spring.config.location` 多个配置文件路径（可为逗号 `,` 分隔的多个文件夹路径或文件路径，排列越靠后优先级越高）。这两个环境属性在很早期需要用以加载文件，所以必需以环境属性的方式（An OS Environment Variable, a system property, a command-line argument）指定。\n\n当 `spring.config.location` 指定文件夹路径时，需要以 `/` 结尾，在运行时将在其后追加 `spring.config.name` 中分离出的文件名与 profile-specific file name 。当 location 指定了全文件名时，直接使用此文件名，但不支持 profile-specific variant，并被 profile-specific 属性覆盖。\n\n`spring.config.additional-location` 用以指定额外的配置路径，其优先级大于默认的路径\n\n## .4. Profile-specific Properties\n\n通过 `spring.profiles.active` 变量激活当前应用的配置文件。profile 配置文件规约其名为 `application-{profile}.properties` ，当没有指定 profile 时， Environment 自动使用 `default` 作为 profile 环境配置，`application-default.properties` 中的属性将被加载。\n\n与标准的 `application.properties` 配置文件一样，profile 配置文件将从指定位置加载，同时不管所打包的 jar 包内还是包内，profile-specific file 配置覆盖 non-specific ones。If several profiles are specified, a last-wins strategy applies.如果指定多个，后者覆盖前者。\n\n如果在 `spring.config.location` 中指定了配置文件，那么此文件在 profile-specific variant 匹配中就不再考虑了。换句话说，如果需要使用 profile-specific 策略匹配配置文件，就不要在 `spring.config.location` 中添加相关的文件，最好其中只指定 directories 不指定文件。\n\n## .5. Placeholders in Properties\n\n在使用配置文件中 `application.properties` 配置的值时会通过存在的 `Environment` 过滤，所以，可以在配置中使用占位符 `${}` 引用先前定义好的配置（如：系统属性）。\n\n## .6. Type-safe Configuration Properties\n\n> [类型安全配置属性](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n### .6.1. JavaBean Properties Binding\n\n[JavaBean 属性绑定](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n- Spring Boot 映射配置到 javaBean 属性中并不是直接使用类的 Accessors(getter/setter)；\n- 如同 Spring MVC ，配置属性绑定通过标准的 Java Beans 属性描述符实现，所以在默认的空的构造器与 getter setter 通常是必须的；\n- 在以下情况下 setter 可以省略：\n    - 被初始化过的 Maps，只需要 getter 不需要 setter，因为他们可以通过 binder 改变。\n    - Collections Arrays 要么通过 `.yml` index 要么通过 `.properties` 的逗号分隔的单个值。在后者，setter 是必须的。如果初始化一个 collection ，保证其是可变的。\n    - 如果是内嵌的 POJO 属性，且已被初始化，setter 可以省略。如果需要让 binder 快速初始化 POJO ，这时 setter 是需要的。\n- 使用 Lombok 自动生成时，保证不要生成特定类型的构造器，因为容器可能需要用来初始化对象。\n- 只有标准 Java Bean 属性才能被绑定，**不支持绑定属性到静态字段上。**\n\n### .6.2. Constructor Binding\n\n[构造器绑定](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n- 在类上添加注解 `@ConstructorBinding`\n- 内嵌的属性 POJO 也会使用构造器绑定方式绑定配置属性。\n- 默认值可使用 `@DefaultValue(\"default\")` 注解添加在属性上，当 binder 找不到相关的配置就会强制将默认值添加到指定属性上\n- 默认情况下，如果没有为属性配置值，对象属性将为 null 。如果需要返回一个非 null POJO，可以指定一个空的 `@DefaultValue` 在其上。\n- 使用构造器绑定，**需要添加 `@EnableConfigurationProperties` 或配置属性扫描**。常规 Spring Bean 创建机制创建的 Bean （@Component @Bean @Import）上并不能通过此构建器绑定属性。\n- 如果绑定的 Class 有多个 Constructor ，可直接将 `@ConstructorBinding` 注解在需要的构造器上。\n\n### .6.3. Enable @ConfigurationProperties-annotated Types\n\n[注册配置 bean](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n- Spring Boot 提供了绑定配置到类的机制也提供注册其为 Bean 的机制。可以一个类一个类地配置也可像组件扫描一样配置属性扫描。\n- 如果需要部分扫描到配置属性，可以在 `@EnableConfigurationProperties` 指定 type.class ，任意 `@Configuration` 组件是添加此属性。\n- 添加 `@ConfigurationPropertiesScan` 注解在 Application 上会自动扫描包内所有的配置属性 Bean，注解上可添加包。\n- 当 Bean 注册到容器中后，这个 bean 有一个便名 `<prefix>-<fqn>` ，`<prefix>` 是在 `@ConfigurationProperties(prefix=\"\")` 上指定的前缀， `<fqn>` 指其全限定名。如果没有指定 prefix ，只有全限定名会为此 bean 所用。_这他妈有啥用？_\n\n### .6.4. Using @ConfigurationProperties-annotated Types\n\n[使用自动配置属性 Bean](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n在组件 Bean 直接无注解注入 `private final ConfiguredData configuredData;`\n\n### .6.5. Third-party Configuration\n\n> 第三方 Bean 属性注入\n\n- 直接在注入第三方 Bean 方法定义处加上 `@ConfigurationProperties` 注解，将自动将同名配置注入到 Bean 属性中。\n\n### .6.6. Relaxed Binding\n\n> 松绑定\n\nSpring Boot 松绑定 Environment 属性到 @ConfigurationProperties bean 中，所以不需要精确匹配 Environment 属性名与 bean 属性名。常见的例子是使用 dash-separated 或大小写环境属性 context-path 绑定到 contextPath，PORT绑定到 port。\n\n使用 `@ConfigurationProperties(prefix=\"project.data\")` 注解在有名为 `firstName` 属性的 bean 上（prefix 的值必须为 Kebab Case 写法），那么在配置文件中可以使用：\n\n1. `project.data.first-name`: Kebab Case （小写，单词分隔使用 `-`，看起来像羊肉串，所以叫 Kebab Case），推荐在 `.properties` 或 `.yml` 中使用\n2. `project.data.firstName` : standard camel case syntax 标准驼峰语法\n3. `project.data.first_name` : underscore notation，下划线符号，在 `.properties` `.yml` 中一种可选的写法\n4. `PROJECT_DATA_FIRSTNAME` : upper case format，推荐在系统环境变量中使用。\n\n#### .6.6.1. 从环境变量绑定数据 Binding from Environment Variables\n\n大多操作系统的环境变量都使用严格命名规则，如 Linux 系统 shell 变量只能使用字母数字下划线，Unix 系统 shell 变量只能使用大写。Spring Boot 为与这些系统兼容，规则如下：\n\n1. 用 `_` 代替 `.`\n2. 移除所有的 `-`\n3. 转换为大写形式\n\n比如：配置属性 `spring.main.log-startup-info` 将被系统环境变量 `SPRING_MAIN_LOGSTARTUPINFO` 的值所绑定。note:_下划线并不会被 dash 所替换_\n\n环境变量同样可以绑定到数组对象，数组的下标数字被下划线代替：`data[0].name` 被环境变量 DATA_0_NAME 值所赋。\n\n### .6.7. Merging Complex Types\n\n使用 `.yml` 与 `.properties` 外部配置文件添加属性给bean 时，会自动将各个同配置注入到列表属性中，也可以在其中指定不同的 profile 下不同的属性。\n\n### .6.8. Properties Conversion\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-relaxed-binding)\n\nSpring Boot 内置转换器可以将对多个类型数据进行转换，使用 `@**Unit` 注解指定单位\n\n1. Duration，ms `@DurationUnit` ns us ms s m h d\n2. Period ， days `@PeriodUnit` y m w(weeks is a shortcut means \"7 days\") d\n3. DataSize, byte `@DataSizeUnit` B KB MB GB TB\n\n可自定义 converter。\n\n### .6.9. @ConfigurationProperties Validation\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation)\n\n- 在注解 `@ConfigurationProperties` 的类上添加 `@Validated` ， 用以约束字段。也可以使用 JSR-303 `@Validation` （需要保证 JSR-303 在 classpath 之中）。在 @Configuration 组件 bean 定义处添加 `@Validated` 注解用以验证 bean 。\n- 验证内嵌的属性，其相应的字段需要添加 `@Valid` 注解\n- 自定义 Spring Validator 通过添加一个名为 `configurationPropertiesValidator` bean 定义静态方法实现，之所以要为 静态的 ，因为 configurationProperties validator 在应用生命周期很早阶段就需要实例化并使用，为避免与外部 `@Configuration` 类耦合而需要过早地将外部组件类实例化引起的错误，所以需要将此 validator bean 方法定义为静态的。\n\n### .6.10. @ConfigurationProperties vs. @Value\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation)\n\n- `@Value` 是容器核心特性，不提供类似类型安全的特性，支持部分 spring 松绑定，不支持 元数据，但比 `@ConfigurationProperties` 多支持 SpEL 表达式。\n- 如果同一个组件定义了多个配置属性，推荐使用 `@ConfigurationProperties` 在bean 类上，这样可以做结构化类型安全的bean 用以注入到 bean 中。\n- 如果需要使用 `@Value` ，推荐引用属性名通过其标准形式 Kebab-Case using only lowercase letters 。这样做可以让 Spring Boot 使用与 `@ConfigurationProperties` 松绑定相同的逻辑。如：使用 `@Value(\"{demo.first-name}\")` ，那么配置文件中的 `demo.firstName` 与 `demo.first-name`与系统环境变量 `DEMO_FIRSTNAME` 都会被当作有效配置（优先级此处不作讨论）。而如果使用 `@Value(\"{demo.firstName}\")` 只有配置文件中的 `demo.firstName` 会被识别到。\n\n## .7. Environment\n\n> spring 中的环境属性 org.springframework.core.env.Environment。\n\n此接口用于当前应用在运行时的环境，应用环境的两个关键模型是 `profiles` 与 `properties`。与 property 相关的访问方法定义于其父接口 `PropertyResolver` 。PropertyResolver 定义了很多可以直接将 String convert 2 T 的方法。\n\n要实现操作应用的 Environment ，能过 `ConfigurableEnvironment` 实现。//TODO\n\n`profile` 是特定命名的一组的 bean definition，只有在指定 profile 是激活状态才能将这组 bean 注册于容器。\n\nApplicationContext 中的 bean 都可以通过 EnvironmentAware 接口或注入 `@Inject Environment` 获取应用配置数据。 通常情况下，大多数应用级别的 bean 不需要直接与 Environment 交互获取配置数据，可以直接使用属性占位符配置器（PropertySourcesPlaceholderConfigurer） `${}` 获取属性配置值。PropertySourcesPlaceholderConfigurer 是 EnvironmentAware ，并从 Spring 3.1 开始只要配置 `<context:property-placeholder/>` ，就默认注册。\n\n### .7.1. AbstractEnvironment\n\n基本的环境变量，实现了接口 `ConfigurableEnvironment` 。其内部定义了基本的应用环境属性：忽略系统环境变量 `IGNORE_GETENV_PROPERTY_NAME` 默认为 false， 激活状态配置 `ACTIVE_PROFILES_PROPERTY_NAME` ，默认配置 `DEFAULT_PROFILES_PROPERTY_NAME` ，默认配置名 `RESERVED_DEFAULT_PROFILE_NAME` 。\n\n### .7.2. StandardEnvironment\n\n继承自 AbstractEnvironment ，在其基础上添加了系统变量 `SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME` 与环境变量 `SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME`。系统变量优先级更高，其初始化过程中先添加系统变量再添加环境变量在配置数据最末（环境变量可在同一个系统中跨服务共用，而系统变量是针对一个 JVM 而设置）。\n\n### .7.3. StandardServletEnvironment\n\nStandardServletEnvironment 基于 Servlet 的 web 应用 Environment 实现，继承自 StandardEnvironment 。每个基于 Servlet 的 web 应用 ApplicationContext 都会默认初始化一个实例。此环境会在 StandardEnvironment 的基础上依次（决定了配置变量的优先级从高到低）添加变量： servlet Config 属性 `SERVLET_CONTEXT_PROPERTY_SOURCE_NAME`，servlet context 属性 `SERVLET_CONFIG_PROPERTY_SOURCE_NAME` ，JNDI 属性 `JNDI_PROPERTY_SOURCE_NAME` 。\n\n## .8. PropertySourcePlaceHolderConfigurer\n\n使用此配置器解析 ApplicationContext 中的所有的 BeanDefinition 中的占位符（默认格式 `${value}`）。其实现了 `BeanFactoryPostProcessor` ，在 ApplicationContext 初始化阶段，会自动扫描所有的 BeanDefinition 并将所有使用占位符的地方都使用配置数据值进行替换。以此来实现占位符引入配置到 bean 中。\n\n### .8.1. @Value\n\n用于字段或方法参数上的注解，用以表明其默认值。典型应用于表达式驱动依赖注入，也支持处理器方法参数的动态方案，如 Spring MVC。\n\n`@Value` 注解的实际的处理是通过 `AutowiredAnnotationBeanPostProcessor` 实现，这就意味着不能使用此注解用于 BeanFactoryPostProcessor 与 BeanPostProcessor。\n\n#### .8.1.1. AutowiredAnnotationBeanPostProcessor\n\n一个 BeanPostProcessor 。//todo\n","source":"_posts/Spring/SpringBoot-ExternalizedConfiguration.md","raw":"---\ntitle: SpringBoot Externalized Configuration\ndate: 2020-07-19 23:48:38\ntags: [Java,SpringBoot,Configuration, Spring]\ncategories: [SpringBoot]\ndescription: spring boot 外部配置的应用\n---\n\n[spring boot 外部配置](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config)\n\n> 外部配置\n\n一个应用，其通常添加外部配置的方式：properties file, yml files, environment variables, 命令行参数扩展配置。配置属性可以通过 `@Value` 直接被注入到 bean 中，通过 `Environment` 抽象直接访问，也可以通过 `@ConfigurationProperties` 绑定到结构对象上。<!--more-->\n\nSpring Boot 加载 `PropertySource` 有明确的顺序，以保证正确覆盖配置值。其**配置优先级**从高到低依次为：\n\n1. 当 devtool 在激活状态时， `$HOME/.config/spring-boot` 中的 devtool 全局配置\n2. `@TestPropertySource` 注解的 test 配置\n3. `@SpringBootTest` 注解与局部应用 test 注解上的 `Properties` 属性\n4. 命令行参数\n5. 内嵌于环境变量或系统属性的行内 JSON `SPRING_APPLICATION_JSON` 属性\n6. `ServletConfig` 初始化参数\n7. `ServletContext` 初始化参数\n8. `java:comp/env` JNDI 属性\n9. `System.getProperties()` Java 系统属性\n10. 操作系统环境变量 OS environment variables\n11. `random.*` 中的随机属性值 `RandomValuePropertySource`\n12. 包外的特定 profile 属性文件 `application-{profile}.properties` 与 YAML 变体\n13. 包内特定 profile 属性文件 `application-{profile}.properties` 或 YAML 变体\n14. 包外应用属性文件 `application.properties` 和 YAML 变体\n15. 包内应用配置文件  `application.properties` 和 YAML 变体\n16. `@PropertySource` 注解于 configuration 类上标注的属性文件。需要注意的是，这种配置在 application refreshed 前不会被加载到 `Environment` 中去，因此如果使用这种方式添加诸如 `logging.*` `spring.main.*` 配置是无效的，因为在 context refreshed 前，这些配置已经被读取了。\n17. 通过 `SpringApplication.setDefaultProperties()` 设置的默认属性。\n\nSpring Boot 在加载配置时支持通配路径，在外部指定不同路径下的同名配置文件时使用通配路径就会很方便。**通配路径必须包含且仅包含一个 `*` ，并且当以文件夹结尾时以 `/` 结尾，以文件为查找对象时以 `/<filename>` 结尾**。查找出的位置以文件路径的字母顺序排序。\n\n## .1. Configuring Random Values\n\n配置随机值随机注入一个 integer/long/uuid/string :\n\n```properties\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}\n```\n\n随机配置语法 `${random.int*}`是 `OPEN value (,max) CLOSE` `OPEN` 与 `CLOSE` 指代任意符号用以将最大值与最小值包起来，`value` 与 `max` 是 integer 。如果提供 `max`，`value` 就指最小值，`max` 指最大值（不包含）。\n\n## .2. Accessing Command Line Properties\n\n[访问命令行参数](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config)\n\n默认情况下命令行参数在 Spring 配置中有最高优先级别。在启动命令行中以 `--` 开始指定命令行参数。如果需要禁用命令行参数加入到系统 `Environment` 中，可以 `SpringApplication.setAddCommandLineProperties(false)`。\n\n## .3. Application Property Files\n\n[应用配置文件](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-application-property-files)\n\n`SpringApplication` 将不同位置的配置文件 `application.properties` 或 `.yaml` 数据加载到 `Environment` 中，不同位置加载优先级为：\n\n1. 当前路径子路径 `/config`\n2. 当前路径 The current directory\n3. classpath `/config` 包\n4. classpath 根\n\n高优先级配置会覆盖低优先级配置。\n\n如果需要修改配置文件，可以指定环境属性 `spring.config.name` 指定另一个配置文件，同时可指定 `spring.config.location` 多个配置文件路径（可为逗号 `,` 分隔的多个文件夹路径或文件路径，排列越靠后优先级越高）。这两个环境属性在很早期需要用以加载文件，所以必需以环境属性的方式（An OS Environment Variable, a system property, a command-line argument）指定。\n\n当 `spring.config.location` 指定文件夹路径时，需要以 `/` 结尾，在运行时将在其后追加 `spring.config.name` 中分离出的文件名与 profile-specific file name 。当 location 指定了全文件名时，直接使用此文件名，但不支持 profile-specific variant，并被 profile-specific 属性覆盖。\n\n`spring.config.additional-location` 用以指定额外的配置路径，其优先级大于默认的路径\n\n## .4. Profile-specific Properties\n\n通过 `spring.profiles.active` 变量激活当前应用的配置文件。profile 配置文件规约其名为 `application-{profile}.properties` ，当没有指定 profile 时， Environment 自动使用 `default` 作为 profile 环境配置，`application-default.properties` 中的属性将被加载。\n\n与标准的 `application.properties` 配置文件一样，profile 配置文件将从指定位置加载，同时不管所打包的 jar 包内还是包内，profile-specific file 配置覆盖 non-specific ones。If several profiles are specified, a last-wins strategy applies.如果指定多个，后者覆盖前者。\n\n如果在 `spring.config.location` 中指定了配置文件，那么此文件在 profile-specific variant 匹配中就不再考虑了。换句话说，如果需要使用 profile-specific 策略匹配配置文件，就不要在 `spring.config.location` 中添加相关的文件，最好其中只指定 directories 不指定文件。\n\n## .5. Placeholders in Properties\n\n在使用配置文件中 `application.properties` 配置的值时会通过存在的 `Environment` 过滤，所以，可以在配置中使用占位符 `${}` 引用先前定义好的配置（如：系统属性）。\n\n## .6. Type-safe Configuration Properties\n\n> [类型安全配置属性](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n### .6.1. JavaBean Properties Binding\n\n[JavaBean 属性绑定](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n- Spring Boot 映射配置到 javaBean 属性中并不是直接使用类的 Accessors(getter/setter)；\n- 如同 Spring MVC ，配置属性绑定通过标准的 Java Beans 属性描述符实现，所以在默认的空的构造器与 getter setter 通常是必须的；\n- 在以下情况下 setter 可以省略：\n    - 被初始化过的 Maps，只需要 getter 不需要 setter，因为他们可以通过 binder 改变。\n    - Collections Arrays 要么通过 `.yml` index 要么通过 `.properties` 的逗号分隔的单个值。在后者，setter 是必须的。如果初始化一个 collection ，保证其是可变的。\n    - 如果是内嵌的 POJO 属性，且已被初始化，setter 可以省略。如果需要让 binder 快速初始化 POJO ，这时 setter 是需要的。\n- 使用 Lombok 自动生成时，保证不要生成特定类型的构造器，因为容器可能需要用来初始化对象。\n- 只有标准 Java Bean 属性才能被绑定，**不支持绑定属性到静态字段上。**\n\n### .6.2. Constructor Binding\n\n[构造器绑定](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n- 在类上添加注解 `@ConstructorBinding`\n- 内嵌的属性 POJO 也会使用构造器绑定方式绑定配置属性。\n- 默认值可使用 `@DefaultValue(\"default\")` 注解添加在属性上，当 binder 找不到相关的配置就会强制将默认值添加到指定属性上\n- 默认情况下，如果没有为属性配置值，对象属性将为 null 。如果需要返回一个非 null POJO，可以指定一个空的 `@DefaultValue` 在其上。\n- 使用构造器绑定，**需要添加 `@EnableConfigurationProperties` 或配置属性扫描**。常规 Spring Bean 创建机制创建的 Bean （@Component @Bean @Import）上并不能通过此构建器绑定属性。\n- 如果绑定的 Class 有多个 Constructor ，可直接将 `@ConstructorBinding` 注解在需要的构造器上。\n\n### .6.3. Enable @ConfigurationProperties-annotated Types\n\n[注册配置 bean](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n- Spring Boot 提供了绑定配置到类的机制也提供注册其为 Bean 的机制。可以一个类一个类地配置也可像组件扫描一样配置属性扫描。\n- 如果需要部分扫描到配置属性，可以在 `@EnableConfigurationProperties` 指定 type.class ，任意 `@Configuration` 组件是添加此属性。\n- 添加 `@ConfigurationPropertiesScan` 注解在 Application 上会自动扫描包内所有的配置属性 Bean，注解上可添加包。\n- 当 Bean 注册到容器中后，这个 bean 有一个便名 `<prefix>-<fqn>` ，`<prefix>` 是在 `@ConfigurationProperties(prefix=\"\")` 上指定的前缀， `<fqn>` 指其全限定名。如果没有指定 prefix ，只有全限定名会为此 bean 所用。_这他妈有啥用？_\n\n### .6.4. Using @ConfigurationProperties-annotated Types\n\n[使用自动配置属性 Bean](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding)\n\n在组件 Bean 直接无注解注入 `private final ConfiguredData configuredData;`\n\n### .6.5. Third-party Configuration\n\n> 第三方 Bean 属性注入\n\n- 直接在注入第三方 Bean 方法定义处加上 `@ConfigurationProperties` 注解，将自动将同名配置注入到 Bean 属性中。\n\n### .6.6. Relaxed Binding\n\n> 松绑定\n\nSpring Boot 松绑定 Environment 属性到 @ConfigurationProperties bean 中，所以不需要精确匹配 Environment 属性名与 bean 属性名。常见的例子是使用 dash-separated 或大小写环境属性 context-path 绑定到 contextPath，PORT绑定到 port。\n\n使用 `@ConfigurationProperties(prefix=\"project.data\")` 注解在有名为 `firstName` 属性的 bean 上（prefix 的值必须为 Kebab Case 写法），那么在配置文件中可以使用：\n\n1. `project.data.first-name`: Kebab Case （小写，单词分隔使用 `-`，看起来像羊肉串，所以叫 Kebab Case），推荐在 `.properties` 或 `.yml` 中使用\n2. `project.data.firstName` : standard camel case syntax 标准驼峰语法\n3. `project.data.first_name` : underscore notation，下划线符号，在 `.properties` `.yml` 中一种可选的写法\n4. `PROJECT_DATA_FIRSTNAME` : upper case format，推荐在系统环境变量中使用。\n\n#### .6.6.1. 从环境变量绑定数据 Binding from Environment Variables\n\n大多操作系统的环境变量都使用严格命名规则，如 Linux 系统 shell 变量只能使用字母数字下划线，Unix 系统 shell 变量只能使用大写。Spring Boot 为与这些系统兼容，规则如下：\n\n1. 用 `_` 代替 `.`\n2. 移除所有的 `-`\n3. 转换为大写形式\n\n比如：配置属性 `spring.main.log-startup-info` 将被系统环境变量 `SPRING_MAIN_LOGSTARTUPINFO` 的值所绑定。note:_下划线并不会被 dash 所替换_\n\n环境变量同样可以绑定到数组对象，数组的下标数字被下划线代替：`data[0].name` 被环境变量 DATA_0_NAME 值所赋。\n\n### .6.7. Merging Complex Types\n\n使用 `.yml` 与 `.properties` 外部配置文件添加属性给bean 时，会自动将各个同配置注入到列表属性中，也可以在其中指定不同的 profile 下不同的属性。\n\n### .6.8. Properties Conversion\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-relaxed-binding)\n\nSpring Boot 内置转换器可以将对多个类型数据进行转换，使用 `@**Unit` 注解指定单位\n\n1. Duration，ms `@DurationUnit` ns us ms s m h d\n2. Period ， days `@PeriodUnit` y m w(weeks is a shortcut means \"7 days\") d\n3. DataSize, byte `@DataSizeUnit` B KB MB GB TB\n\n可自定义 converter。\n\n### .6.9. @ConfigurationProperties Validation\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation)\n\n- 在注解 `@ConfigurationProperties` 的类上添加 `@Validated` ， 用以约束字段。也可以使用 JSR-303 `@Validation` （需要保证 JSR-303 在 classpath 之中）。在 @Configuration 组件 bean 定义处添加 `@Validated` 注解用以验证 bean 。\n- 验证内嵌的属性，其相应的字段需要添加 `@Valid` 注解\n- 自定义 Spring Validator 通过添加一个名为 `configurationPropertiesValidator` bean 定义静态方法实现，之所以要为 静态的 ，因为 configurationProperties validator 在应用生命周期很早阶段就需要实例化并使用，为避免与外部 `@Configuration` 类耦合而需要过早地将外部组件类实例化引起的错误，所以需要将此 validator bean 方法定义为静态的。\n\n### .6.10. @ConfigurationProperties vs. @Value\n\n[reference](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation)\n\n- `@Value` 是容器核心特性，不提供类似类型安全的特性，支持部分 spring 松绑定，不支持 元数据，但比 `@ConfigurationProperties` 多支持 SpEL 表达式。\n- 如果同一个组件定义了多个配置属性，推荐使用 `@ConfigurationProperties` 在bean 类上，这样可以做结构化类型安全的bean 用以注入到 bean 中。\n- 如果需要使用 `@Value` ，推荐引用属性名通过其标准形式 Kebab-Case using only lowercase letters 。这样做可以让 Spring Boot 使用与 `@ConfigurationProperties` 松绑定相同的逻辑。如：使用 `@Value(\"{demo.first-name}\")` ，那么配置文件中的 `demo.firstName` 与 `demo.first-name`与系统环境变量 `DEMO_FIRSTNAME` 都会被当作有效配置（优先级此处不作讨论）。而如果使用 `@Value(\"{demo.firstName}\")` 只有配置文件中的 `demo.firstName` 会被识别到。\n\n## .7. Environment\n\n> spring 中的环境属性 org.springframework.core.env.Environment。\n\n此接口用于当前应用在运行时的环境，应用环境的两个关键模型是 `profiles` 与 `properties`。与 property 相关的访问方法定义于其父接口 `PropertyResolver` 。PropertyResolver 定义了很多可以直接将 String convert 2 T 的方法。\n\n要实现操作应用的 Environment ，能过 `ConfigurableEnvironment` 实现。//TODO\n\n`profile` 是特定命名的一组的 bean definition，只有在指定 profile 是激活状态才能将这组 bean 注册于容器。\n\nApplicationContext 中的 bean 都可以通过 EnvironmentAware 接口或注入 `@Inject Environment` 获取应用配置数据。 通常情况下，大多数应用级别的 bean 不需要直接与 Environment 交互获取配置数据，可以直接使用属性占位符配置器（PropertySourcesPlaceholderConfigurer） `${}` 获取属性配置值。PropertySourcesPlaceholderConfigurer 是 EnvironmentAware ，并从 Spring 3.1 开始只要配置 `<context:property-placeholder/>` ，就默认注册。\n\n### .7.1. AbstractEnvironment\n\n基本的环境变量，实现了接口 `ConfigurableEnvironment` 。其内部定义了基本的应用环境属性：忽略系统环境变量 `IGNORE_GETENV_PROPERTY_NAME` 默认为 false， 激活状态配置 `ACTIVE_PROFILES_PROPERTY_NAME` ，默认配置 `DEFAULT_PROFILES_PROPERTY_NAME` ，默认配置名 `RESERVED_DEFAULT_PROFILE_NAME` 。\n\n### .7.2. StandardEnvironment\n\n继承自 AbstractEnvironment ，在其基础上添加了系统变量 `SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME` 与环境变量 `SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME`。系统变量优先级更高，其初始化过程中先添加系统变量再添加环境变量在配置数据最末（环境变量可在同一个系统中跨服务共用，而系统变量是针对一个 JVM 而设置）。\n\n### .7.3. StandardServletEnvironment\n\nStandardServletEnvironment 基于 Servlet 的 web 应用 Environment 实现，继承自 StandardEnvironment 。每个基于 Servlet 的 web 应用 ApplicationContext 都会默认初始化一个实例。此环境会在 StandardEnvironment 的基础上依次（决定了配置变量的优先级从高到低）添加变量： servlet Config 属性 `SERVLET_CONTEXT_PROPERTY_SOURCE_NAME`，servlet context 属性 `SERVLET_CONFIG_PROPERTY_SOURCE_NAME` ，JNDI 属性 `JNDI_PROPERTY_SOURCE_NAME` 。\n\n## .8. PropertySourcePlaceHolderConfigurer\n\n使用此配置器解析 ApplicationContext 中的所有的 BeanDefinition 中的占位符（默认格式 `${value}`）。其实现了 `BeanFactoryPostProcessor` ，在 ApplicationContext 初始化阶段，会自动扫描所有的 BeanDefinition 并将所有使用占位符的地方都使用配置数据值进行替换。以此来实现占位符引入配置到 bean 中。\n\n### .8.1. @Value\n\n用于字段或方法参数上的注解，用以表明其默认值。典型应用于表达式驱动依赖注入，也支持处理器方法参数的动态方案，如 Spring MVC。\n\n`@Value` 注解的实际的处理是通过 `AutowiredAnnotationBeanPostProcessor` 实现，这就意味着不能使用此注解用于 BeanFactoryPostProcessor 与 BeanPostProcessor。\n\n#### .8.1.1. AutowiredAnnotationBeanPostProcessor\n\n一个 BeanPostProcessor 。//todo\n","slug":"Spring/SpringBoot-ExternalizedConfiguration","published":1,"updated":"2021-02-24T15:22:22.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckljnokt2006q2bhb314xeove","content":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config\">spring boot 外部配置</a></p>\n<blockquote>\n<p>外部配置</p>\n</blockquote>\n<p>一个应用，其通常添加外部配置的方式：properties file, yml files, environment variables, 命令行参数扩展配置。配置属性可以通过 <code>@Value</code> 直接被注入到 bean 中，通过 <code>Environment</code> 抽象直接访问，也可以通过 <code>@ConfigurationProperties</code> 绑定到结构对象上。<span id=\"more\"></span></p>\n<p>Spring Boot 加载 <code>PropertySource</code> 有明确的顺序，以保证正确覆盖配置值。其<strong>配置优先级</strong>从高到低依次为：</p>\n<ol>\n<li>当 devtool 在激活状态时， <code>$HOME/.config/spring-boot</code> 中的 devtool 全局配置</li>\n<li><code>@TestPropertySource</code> 注解的 test 配置</li>\n<li><code>@SpringBootTest</code> 注解与局部应用 test 注解上的 <code>Properties</code> 属性</li>\n<li>命令行参数</li>\n<li>内嵌于环境变量或系统属性的行内 JSON <code>SPRING_APPLICATION_JSON</code> 属性</li>\n<li><code>ServletConfig</code> 初始化参数</li>\n<li><code>ServletContext</code> 初始化参数</li>\n<li><code>java:comp/env</code> JNDI 属性</li>\n<li><code>System.getProperties()</code> Java 系统属性</li>\n<li>操作系统环境变量 OS environment variables</li>\n<li><code>random.*</code> 中的随机属性值 <code>RandomValuePropertySource</code></li>\n<li>包外的特定 profile 属性文件 <code>application-&#123;profile&#125;.properties</code> 与 YAML 变体</li>\n<li>包内特定 profile 属性文件 <code>application-&#123;profile&#125;.properties</code> 或 YAML 变体</li>\n<li>包外应用属性文件 <code>application.properties</code> 和 YAML 变体</li>\n<li>包内应用配置文件  <code>application.properties</code> 和 YAML 变体</li>\n<li><code>@PropertySource</code> 注解于 configuration 类上标注的属性文件。需要注意的是，这种配置在 application refreshed 前不会被加载到 <code>Environment</code> 中去，因此如果使用这种方式添加诸如 <code>logging.*</code> <code>spring.main.*</code> 配置是无效的，因为在 context refreshed 前，这些配置已经被读取了。</li>\n<li>通过 <code>SpringApplication.setDefaultProperties()</code> 设置的默认属性。</li>\n</ol>\n<p>Spring Boot 在加载配置时支持通配路径，在外部指定不同路径下的同名配置文件时使用通配路径就会很方便。<strong>通配路径必须包含且仅包含一个 <code>*</code> ，并且当以文件夹结尾时以 <code>/</code> 结尾，以文件为查找对象时以 <code>/&lt;filename&gt;</code> 结尾</strong>。查找出的位置以文件路径的字母顺序排序。</p>\n<h2 id=\"1-Configuring-Random-Values\"><a href=\"#1-Configuring-Random-Values\" class=\"headerlink\" title=\".1. Configuring Random Values\"></a>.1. Configuring Random Values</h2><p>配置随机值随机注入一个 integer/long/uuid/string :</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">my.secret</span>=<span class=\"string\">$&#123;random.value&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.number</span>=<span class=\"string\">$&#123;random.int&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.bignumber</span>=<span class=\"string\">$&#123;random.long&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.uuid</span>=<span class=\"string\">$&#123;random.uuid&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.number.less.than.ten</span>=<span class=\"string\">$&#123;random.int(10)&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.number.in.range</span>=<span class=\"string\">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>随机配置语法 <code>$&#123;random.int*&#125;</code>是 <code>OPEN value (,max) CLOSE</code> <code>OPEN</code> 与 <code>CLOSE</code> 指代任意符号用以将最大值与最小值包起来，<code>value</code> 与 <code>max</code> 是 integer 。如果提供 <code>max</code>，<code>value</code> 就指最小值，<code>max</code> 指最大值（不包含）。</p>\n<h2 id=\"2-Accessing-Command-Line-Properties\"><a href=\"#2-Accessing-Command-Line-Properties\" class=\"headerlink\" title=\".2. Accessing Command Line Properties\"></a>.2. Accessing Command Line Properties</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config\">访问命令行参数</a></p>\n<p>默认情况下命令行参数在 Spring 配置中有最高优先级别。在启动命令行中以 <code>--</code> 开始指定命令行参数。如果需要禁用命令行参数加入到系统 <code>Environment</code> 中，可以 <code>SpringApplication.setAddCommandLineProperties(false)</code>。</p>\n<h2 id=\"3-Application-Property-Files\"><a href=\"#3-Application-Property-Files\" class=\"headerlink\" title=\".3. Application Property Files\"></a>.3. Application Property Files</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-application-property-files\">应用配置文件</a></p>\n<p><code>SpringApplication</code> 将不同位置的配置文件 <code>application.properties</code> 或 <code>.yaml</code> 数据加载到 <code>Environment</code> 中，不同位置加载优先级为：</p>\n<ol>\n<li>当前路径子路径 <code>/config</code></li>\n<li>当前路径 The current directory</li>\n<li>classpath <code>/config</code> 包</li>\n<li>classpath 根</li>\n</ol>\n<p>高优先级配置会覆盖低优先级配置。</p>\n<p>如果需要修改配置文件，可以指定环境属性 <code>spring.config.name</code> 指定另一个配置文件，同时可指定 <code>spring.config.location</code> 多个配置文件路径（可为逗号 <code>,</code> 分隔的多个文件夹路径或文件路径，排列越靠后优先级越高）。这两个环境属性在很早期需要用以加载文件，所以必需以环境属性的方式（An OS Environment Variable, a system property, a command-line argument）指定。</p>\n<p>当 <code>spring.config.location</code> 指定文件夹路径时，需要以 <code>/</code> 结尾，在运行时将在其后追加 <code>spring.config.name</code> 中分离出的文件名与 profile-specific file name 。当 location 指定了全文件名时，直接使用此文件名，但不支持 profile-specific variant，并被 profile-specific 属性覆盖。</p>\n<p><code>spring.config.additional-location</code> 用以指定额外的配置路径，其优先级大于默认的路径</p>\n<h2 id=\"4-Profile-specific-Properties\"><a href=\"#4-Profile-specific-Properties\" class=\"headerlink\" title=\".4. Profile-specific Properties\"></a>.4. Profile-specific Properties</h2><p>通过 <code>spring.profiles.active</code> 变量激活当前应用的配置文件。profile 配置文件规约其名为 <code>application-&#123;profile&#125;.properties</code> ，当没有指定 profile 时， Environment 自动使用 <code>default</code> 作为 profile 环境配置，<code>application-default.properties</code> 中的属性将被加载。</p>\n<p>与标准的 <code>application.properties</code> 配置文件一样，profile 配置文件将从指定位置加载，同时不管所打包的 jar 包内还是包内，profile-specific file 配置覆盖 non-specific ones。If several profiles are specified, a last-wins strategy applies.如果指定多个，后者覆盖前者。</p>\n<p>如果在 <code>spring.config.location</code> 中指定了配置文件，那么此文件在 profile-specific variant 匹配中就不再考虑了。换句话说，如果需要使用 profile-specific 策略匹配配置文件，就不要在 <code>spring.config.location</code> 中添加相关的文件，最好其中只指定 directories 不指定文件。</p>\n<h2 id=\"5-Placeholders-in-Properties\"><a href=\"#5-Placeholders-in-Properties\" class=\"headerlink\" title=\".5. Placeholders in Properties\"></a>.5. Placeholders in Properties</h2><p>在使用配置文件中 <code>application.properties</code> 配置的值时会通过存在的 <code>Environment</code> 过滤，所以，可以在配置中使用占位符 <code>$&#123;&#125;</code> 引用先前定义好的配置（如：系统属性）。</p>\n<h2 id=\"6-Type-safe-Configuration-Properties\"><a href=\"#6-Type-safe-Configuration-Properties\" class=\"headerlink\" title=\".6. Type-safe Configuration Properties\"></a>.6. Type-safe Configuration Properties</h2><blockquote>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">类型安全配置属性</a></p>\n</blockquote>\n<h3 id=\"6-1-JavaBean-Properties-Binding\"><a href=\"#6-1-JavaBean-Properties-Binding\" class=\"headerlink\" title=\".6.1. JavaBean Properties Binding\"></a>.6.1. JavaBean Properties Binding</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">JavaBean 属性绑定</a></p>\n<ul>\n<li>Spring Boot 映射配置到 javaBean 属性中并不是直接使用类的 Accessors(getter/setter)；</li>\n<li>如同 Spring MVC ，配置属性绑定通过标准的 Java Beans 属性描述符实现，所以在默认的空的构造器与 getter setter 通常是必须的；</li>\n<li>在以下情况下 setter 可以省略：<ul>\n<li>被初始化过的 Maps，只需要 getter 不需要 setter，因为他们可以通过 binder 改变。</li>\n<li>Collections Arrays 要么通过 <code>.yml</code> index 要么通过 <code>.properties</code> 的逗号分隔的单个值。在后者，setter 是必须的。如果初始化一个 collection ，保证其是可变的。</li>\n<li>如果是内嵌的 POJO 属性，且已被初始化，setter 可以省略。如果需要让 binder 快速初始化 POJO ，这时 setter 是需要的。</li>\n</ul>\n</li>\n<li>使用 Lombok 自动生成时，保证不要生成特定类型的构造器，因为容器可能需要用来初始化对象。</li>\n<li>只有标准 Java Bean 属性才能被绑定，<strong>不支持绑定属性到静态字段上。</strong></li>\n</ul>\n<h3 id=\"6-2-Constructor-Binding\"><a href=\"#6-2-Constructor-Binding\" class=\"headerlink\" title=\".6.2. Constructor Binding\"></a>.6.2. Constructor Binding</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">构造器绑定</a></p>\n<ul>\n<li>在类上添加注解 <code>@ConstructorBinding</code></li>\n<li>内嵌的属性 POJO 也会使用构造器绑定方式绑定配置属性。</li>\n<li>默认值可使用 <code>@DefaultValue(&quot;default&quot;)</code> 注解添加在属性上，当 binder 找不到相关的配置就会强制将默认值添加到指定属性上</li>\n<li>默认情况下，如果没有为属性配置值，对象属性将为 null 。如果需要返回一个非 null POJO，可以指定一个空的 <code>@DefaultValue</code> 在其上。</li>\n<li>使用构造器绑定，<strong>需要添加 <code>@EnableConfigurationProperties</code> 或配置属性扫描</strong>。常规 Spring Bean 创建机制创建的 Bean （@Component @Bean @Import）上并不能通过此构建器绑定属性。</li>\n<li>如果绑定的 Class 有多个 Constructor ，可直接将 <code>@ConstructorBinding</code> 注解在需要的构造器上。</li>\n</ul>\n<h3 id=\"6-3-Enable-ConfigurationProperties-annotated-Types\"><a href=\"#6-3-Enable-ConfigurationProperties-annotated-Types\" class=\"headerlink\" title=\".6.3. Enable @ConfigurationProperties-annotated Types\"></a>.6.3. Enable @ConfigurationProperties-annotated Types</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">注册配置 bean</a></p>\n<ul>\n<li>Spring Boot 提供了绑定配置到类的机制也提供注册其为 Bean 的机制。可以一个类一个类地配置也可像组件扫描一样配置属性扫描。</li>\n<li>如果需要部分扫描到配置属性，可以在 <code>@EnableConfigurationProperties</code> 指定 type.class ，任意 <code>@Configuration</code> 组件是添加此属性。</li>\n<li>添加 <code>@ConfigurationPropertiesScan</code> 注解在 Application 上会自动扫描包内所有的配置属性 Bean，注解上可添加包。</li>\n<li>当 Bean 注册到容器中后，这个 bean 有一个便名 <code>&lt;prefix&gt;-&lt;fqn&gt;</code> ，<code>&lt;prefix&gt;</code> 是在 <code>@ConfigurationProperties(prefix=&quot;&quot;)</code> 上指定的前缀， <code>&lt;fqn&gt;</code> 指其全限定名。如果没有指定 prefix ，只有全限定名会为此 bean 所用。<em>这他妈有啥用？</em></li>\n</ul>\n<h3 id=\"6-4-Using-ConfigurationProperties-annotated-Types\"><a href=\"#6-4-Using-ConfigurationProperties-annotated-Types\" class=\"headerlink\" title=\".6.4. Using @ConfigurationProperties-annotated Types\"></a>.6.4. Using @ConfigurationProperties-annotated Types</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">使用自动配置属性 Bean</a></p>\n<p>在组件 Bean 直接无注解注入 <code>private final ConfiguredData configuredData;</code></p>\n<h3 id=\"6-5-Third-party-Configuration\"><a href=\"#6-5-Third-party-Configuration\" class=\"headerlink\" title=\".6.5. Third-party Configuration\"></a>.6.5. Third-party Configuration</h3><blockquote>\n<p>第三方 Bean 属性注入</p>\n</blockquote>\n<ul>\n<li>直接在注入第三方 Bean 方法定义处加上 <code>@ConfigurationProperties</code> 注解，将自动将同名配置注入到 Bean 属性中。</li>\n</ul>\n<h3 id=\"6-6-Relaxed-Binding\"><a href=\"#6-6-Relaxed-Binding\" class=\"headerlink\" title=\".6.6. Relaxed Binding\"></a>.6.6. Relaxed Binding</h3><blockquote>\n<p>松绑定</p>\n</blockquote>\n<p>Spring Boot 松绑定 Environment 属性到 @ConfigurationProperties bean 中，所以不需要精确匹配 Environment 属性名与 bean 属性名。常见的例子是使用 dash-separated 或大小写环境属性 context-path 绑定到 contextPath，PORT绑定到 port。</p>\n<p>使用 <code>@ConfigurationProperties(prefix=&quot;project.data&quot;)</code> 注解在有名为 <code>firstName</code> 属性的 bean 上（prefix 的值必须为 Kebab Case 写法），那么在配置文件中可以使用：</p>\n<ol>\n<li><code>project.data.first-name</code>: Kebab Case （小写，单词分隔使用 <code>-</code>，看起来像羊肉串，所以叫 Kebab Case），推荐在 <code>.properties</code> 或 <code>.yml</code> 中使用</li>\n<li><code>project.data.firstName</code> : standard camel case syntax 标准驼峰语法</li>\n<li><code>project.data.first_name</code> : underscore notation，下划线符号，在 <code>.properties</code> <code>.yml</code> 中一种可选的写法</li>\n<li><code>PROJECT_DATA_FIRSTNAME</code> : upper case format，推荐在系统环境变量中使用。</li>\n</ol>\n<h4 id=\"6-6-1-从环境变量绑定数据-Binding-from-Environment-Variables\"><a href=\"#6-6-1-从环境变量绑定数据-Binding-from-Environment-Variables\" class=\"headerlink\" title=\".6.6.1. 从环境变量绑定数据 Binding from Environment Variables\"></a>.6.6.1. 从环境变量绑定数据 Binding from Environment Variables</h4><p>大多操作系统的环境变量都使用严格命名规则，如 Linux 系统 shell 变量只能使用字母数字下划线，Unix 系统 shell 变量只能使用大写。Spring Boot 为与这些系统兼容，规则如下：</p>\n<ol>\n<li>用 <code>_</code> 代替 <code>.</code></li>\n<li>移除所有的 <code>-</code></li>\n<li>转换为大写形式</li>\n</ol>\n<p>比如：配置属性 <code>spring.main.log-startup-info</code> 将被系统环境变量 <code>SPRING_MAIN_LOGSTARTUPINFO</code> 的值所绑定。note:<em>下划线并不会被 dash 所替换</em></p>\n<p>环境变量同样可以绑定到数组对象，数组的下标数字被下划线代替：<code>data[0].name</code> 被环境变量 DATA_0_NAME 值所赋。</p>\n<h3 id=\"6-7-Merging-Complex-Types\"><a href=\"#6-7-Merging-Complex-Types\" class=\"headerlink\" title=\".6.7. Merging Complex Types\"></a>.6.7. Merging Complex Types</h3><p>使用 <code>.yml</code> 与 <code>.properties</code> 外部配置文件添加属性给bean 时，会自动将各个同配置注入到列表属性中，也可以在其中指定不同的 profile 下不同的属性。</p>\n<h3 id=\"6-8-Properties-Conversion\"><a href=\"#6-8-Properties-Conversion\" class=\"headerlink\" title=\".6.8. Properties Conversion\"></a>.6.8. Properties Conversion</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-relaxed-binding\">reference</a></p>\n<p>Spring Boot 内置转换器可以将对多个类型数据进行转换，使用 <code>@**Unit</code> 注解指定单位</p>\n<ol>\n<li>Duration，ms <code>@DurationUnit</code> ns us ms s m h d</li>\n<li>Period ， days <code>@PeriodUnit</code> y m w(weeks is a shortcut means “7 days”) d</li>\n<li>DataSize, byte <code>@DataSizeUnit</code> B KB MB GB TB</li>\n</ol>\n<p>可自定义 converter。</p>\n<h3 id=\"6-9-ConfigurationProperties-Validation\"><a href=\"#6-9-ConfigurationProperties-Validation\" class=\"headerlink\" title=\".6.9. @ConfigurationProperties Validation\"></a>.6.9. @ConfigurationProperties Validation</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation\">reference</a></p>\n<ul>\n<li>在注解 <code>@ConfigurationProperties</code> 的类上添加 <code>@Validated</code> ， 用以约束字段。也可以使用 JSR-303 <code>@Validation</code> （需要保证 JSR-303 在 classpath 之中）。在 @Configuration 组件 bean 定义处添加 <code>@Validated</code> 注解用以验证 bean 。</li>\n<li>验证内嵌的属性，其相应的字段需要添加 <code>@Valid</code> 注解</li>\n<li>自定义 Spring Validator 通过添加一个名为 <code>configurationPropertiesValidator</code> bean 定义静态方法实现，之所以要为 静态的 ，因为 configurationProperties validator 在应用生命周期很早阶段就需要实例化并使用，为避免与外部 <code>@Configuration</code> 类耦合而需要过早地将外部组件类实例化引起的错误，所以需要将此 validator bean 方法定义为静态的。</li>\n</ul>\n<h3 id=\"6-10-ConfigurationProperties-vs-Value\"><a href=\"#6-10-ConfigurationProperties-vs-Value\" class=\"headerlink\" title=\".6.10. @ConfigurationProperties vs. @Value\"></a>.6.10. @ConfigurationProperties vs. @Value</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation\">reference</a></p>\n<ul>\n<li><code>@Value</code> 是容器核心特性，不提供类似类型安全的特性，支持部分 spring 松绑定，不支持 元数据，但比 <code>@ConfigurationProperties</code> 多支持 SpEL 表达式。</li>\n<li>如果同一个组件定义了多个配置属性，推荐使用 <code>@ConfigurationProperties</code> 在bean 类上，这样可以做结构化类型安全的bean 用以注入到 bean 中。</li>\n<li>如果需要使用 <code>@Value</code> ，推荐引用属性名通过其标准形式 Kebab-Case using only lowercase letters 。这样做可以让 Spring Boot 使用与 <code>@ConfigurationProperties</code> 松绑定相同的逻辑。如：使用 <code>@Value(&quot;&#123;demo.first-name&#125;&quot;)</code> ，那么配置文件中的 <code>demo.firstName</code> 与 <code>demo.first-name</code>与系统环境变量 <code>DEMO_FIRSTNAME</code> 都会被当作有效配置（优先级此处不作讨论）。而如果使用 <code>@Value(&quot;&#123;demo.firstName&#125;&quot;)</code> 只有配置文件中的 <code>demo.firstName</code> 会被识别到。</li>\n</ul>\n<h2 id=\"7-Environment\"><a href=\"#7-Environment\" class=\"headerlink\" title=\".7. Environment\"></a>.7. Environment</h2><blockquote>\n<p>spring 中的环境属性 org.springframework.core.env.Environment。</p>\n</blockquote>\n<p>此接口用于当前应用在运行时的环境，应用环境的两个关键模型是 <code>profiles</code> 与 <code>properties</code>。与 property 相关的访问方法定义于其父接口 <code>PropertyResolver</code> 。PropertyResolver 定义了很多可以直接将 String convert 2 T 的方法。</p>\n<p>要实现操作应用的 Environment ，能过 <code>ConfigurableEnvironment</code> 实现。//TODO</p>\n<p><code>profile</code> 是特定命名的一组的 bean definition，只有在指定 profile 是激活状态才能将这组 bean 注册于容器。</p>\n<p>ApplicationContext 中的 bean 都可以通过 EnvironmentAware 接口或注入 <code>@Inject Environment</code> 获取应用配置数据。 通常情况下，大多数应用级别的 bean 不需要直接与 Environment 交互获取配置数据，可以直接使用属性占位符配置器（PropertySourcesPlaceholderConfigurer） <code>$&#123;&#125;</code> 获取属性配置值。PropertySourcesPlaceholderConfigurer 是 EnvironmentAware ，并从 Spring 3.1 开始只要配置 <code>&lt;context:property-placeholder/&gt;</code> ，就默认注册。</p>\n<h3 id=\"7-1-AbstractEnvironment\"><a href=\"#7-1-AbstractEnvironment\" class=\"headerlink\" title=\".7.1. AbstractEnvironment\"></a>.7.1. AbstractEnvironment</h3><p>基本的环境变量，实现了接口 <code>ConfigurableEnvironment</code> 。其内部定义了基本的应用环境属性：忽略系统环境变量 <code>IGNORE_GETENV_PROPERTY_NAME</code> 默认为 false， 激活状态配置 <code>ACTIVE_PROFILES_PROPERTY_NAME</code> ，默认配置 <code>DEFAULT_PROFILES_PROPERTY_NAME</code> ，默认配置名 <code>RESERVED_DEFAULT_PROFILE_NAME</code> 。</p>\n<h3 id=\"7-2-StandardEnvironment\"><a href=\"#7-2-StandardEnvironment\" class=\"headerlink\" title=\".7.2. StandardEnvironment\"></a>.7.2. StandardEnvironment</h3><p>继承自 AbstractEnvironment ，在其基础上添加了系统变量 <code>SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</code> 与环境变量 <code>SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</code>。系统变量优先级更高，其初始化过程中先添加系统变量再添加环境变量在配置数据最末（环境变量可在同一个系统中跨服务共用，而系统变量是针对一个 JVM 而设置）。</p>\n<h3 id=\"7-3-StandardServletEnvironment\"><a href=\"#7-3-StandardServletEnvironment\" class=\"headerlink\" title=\".7.3. StandardServletEnvironment\"></a>.7.3. StandardServletEnvironment</h3><p>StandardServletEnvironment 基于 Servlet 的 web 应用 Environment 实现，继承自 StandardEnvironment 。每个基于 Servlet 的 web 应用 ApplicationContext 都会默认初始化一个实例。此环境会在 StandardEnvironment 的基础上依次（决定了配置变量的优先级从高到低）添加变量： servlet Config 属性 <code>SERVLET_CONTEXT_PROPERTY_SOURCE_NAME</code>，servlet context 属性 <code>SERVLET_CONFIG_PROPERTY_SOURCE_NAME</code> ，JNDI 属性 <code>JNDI_PROPERTY_SOURCE_NAME</code> 。</p>\n<h2 id=\"8-PropertySourcePlaceHolderConfigurer\"><a href=\"#8-PropertySourcePlaceHolderConfigurer\" class=\"headerlink\" title=\".8. PropertySourcePlaceHolderConfigurer\"></a>.8. PropertySourcePlaceHolderConfigurer</h2><p>使用此配置器解析 ApplicationContext 中的所有的 BeanDefinition 中的占位符（默认格式 <code>$&#123;value&#125;</code>）。其实现了 <code>BeanFactoryPostProcessor</code> ，在 ApplicationContext 初始化阶段，会自动扫描所有的 BeanDefinition 并将所有使用占位符的地方都使用配置数据值进行替换。以此来实现占位符引入配置到 bean 中。</p>\n<h3 id=\"8-1-Value\"><a href=\"#8-1-Value\" class=\"headerlink\" title=\".8.1. @Value\"></a>.8.1. @Value</h3><p>用于字段或方法参数上的注解，用以表明其默认值。典型应用于表达式驱动依赖注入，也支持处理器方法参数的动态方案，如 Spring MVC。</p>\n<p><code>@Value</code> 注解的实际的处理是通过 <code>AutowiredAnnotationBeanPostProcessor</code> 实现，这就意味着不能使用此注解用于 BeanFactoryPostProcessor 与 BeanPostProcessor。</p>\n<h4 id=\"8-1-1-AutowiredAnnotationBeanPostProcessor\"><a href=\"#8-1-1-AutowiredAnnotationBeanPostProcessor\" class=\"headerlink\" title=\".8.1.1. AutowiredAnnotationBeanPostProcessor\"></a>.8.1.1. AutowiredAnnotationBeanPostProcessor</h4><p>一个 BeanPostProcessor 。//todo</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config\">spring boot 外部配置</a></p>\n<blockquote>\n<p>外部配置</p>\n</blockquote>\n<p>一个应用，其通常添加外部配置的方式：properties file, yml files, environment variables, 命令行参数扩展配置。配置属性可以通过 <code>@Value</code> 直接被注入到 bean 中，通过 <code>Environment</code> 抽象直接访问，也可以通过 <code>@ConfigurationProperties</code> 绑定到结构对象上。","more":"</p>\n<p>Spring Boot 加载 <code>PropertySource</code> 有明确的顺序，以保证正确覆盖配置值。其<strong>配置优先级</strong>从高到低依次为：</p>\n<ol>\n<li>当 devtool 在激活状态时， <code>$HOME/.config/spring-boot</code> 中的 devtool 全局配置</li>\n<li><code>@TestPropertySource</code> 注解的 test 配置</li>\n<li><code>@SpringBootTest</code> 注解与局部应用 test 注解上的 <code>Properties</code> 属性</li>\n<li>命令行参数</li>\n<li>内嵌于环境变量或系统属性的行内 JSON <code>SPRING_APPLICATION_JSON</code> 属性</li>\n<li><code>ServletConfig</code> 初始化参数</li>\n<li><code>ServletContext</code> 初始化参数</li>\n<li><code>java:comp/env</code> JNDI 属性</li>\n<li><code>System.getProperties()</code> Java 系统属性</li>\n<li>操作系统环境变量 OS environment variables</li>\n<li><code>random.*</code> 中的随机属性值 <code>RandomValuePropertySource</code></li>\n<li>包外的特定 profile 属性文件 <code>application-&#123;profile&#125;.properties</code> 与 YAML 变体</li>\n<li>包内特定 profile 属性文件 <code>application-&#123;profile&#125;.properties</code> 或 YAML 变体</li>\n<li>包外应用属性文件 <code>application.properties</code> 和 YAML 变体</li>\n<li>包内应用配置文件  <code>application.properties</code> 和 YAML 变体</li>\n<li><code>@PropertySource</code> 注解于 configuration 类上标注的属性文件。需要注意的是，这种配置在 application refreshed 前不会被加载到 <code>Environment</code> 中去，因此如果使用这种方式添加诸如 <code>logging.*</code> <code>spring.main.*</code> 配置是无效的，因为在 context refreshed 前，这些配置已经被读取了。</li>\n<li>通过 <code>SpringApplication.setDefaultProperties()</code> 设置的默认属性。</li>\n</ol>\n<p>Spring Boot 在加载配置时支持通配路径，在外部指定不同路径下的同名配置文件时使用通配路径就会很方便。<strong>通配路径必须包含且仅包含一个 <code>*</code> ，并且当以文件夹结尾时以 <code>/</code> 结尾，以文件为查找对象时以 <code>/&lt;filename&gt;</code> 结尾</strong>。查找出的位置以文件路径的字母顺序排序。</p>\n<h2 id=\"1-Configuring-Random-Values\"><a href=\"#1-Configuring-Random-Values\" class=\"headerlink\" title=\".1. Configuring Random Values\"></a>.1. Configuring Random Values</h2><p>配置随机值随机注入一个 integer/long/uuid/string :</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">my.secret</span>=<span class=\"string\">$&#123;random.value&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.number</span>=<span class=\"string\">$&#123;random.int&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.bignumber</span>=<span class=\"string\">$&#123;random.long&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.uuid</span>=<span class=\"string\">$&#123;random.uuid&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.number.less.than.ten</span>=<span class=\"string\">$&#123;random.int(10)&#125;</span></span><br><span class=\"line\"><span class=\"meta\">my.number.in.range</span>=<span class=\"string\">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>随机配置语法 <code>$&#123;random.int*&#125;</code>是 <code>OPEN value (,max) CLOSE</code> <code>OPEN</code> 与 <code>CLOSE</code> 指代任意符号用以将最大值与最小值包起来，<code>value</code> 与 <code>max</code> 是 integer 。如果提供 <code>max</code>，<code>value</code> 就指最小值，<code>max</code> 指最大值（不包含）。</p>\n<h2 id=\"2-Accessing-Command-Line-Properties\"><a href=\"#2-Accessing-Command-Line-Properties\" class=\"headerlink\" title=\".2. Accessing Command Line Properties\"></a>.2. Accessing Command Line Properties</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config\">访问命令行参数</a></p>\n<p>默认情况下命令行参数在 Spring 配置中有最高优先级别。在启动命令行中以 <code>--</code> 开始指定命令行参数。如果需要禁用命令行参数加入到系统 <code>Environment</code> 中，可以 <code>SpringApplication.setAddCommandLineProperties(false)</code>。</p>\n<h2 id=\"3-Application-Property-Files\"><a href=\"#3-Application-Property-Files\" class=\"headerlink\" title=\".3. Application Property Files\"></a>.3. Application Property Files</h2><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-application-property-files\">应用配置文件</a></p>\n<p><code>SpringApplication</code> 将不同位置的配置文件 <code>application.properties</code> 或 <code>.yaml</code> 数据加载到 <code>Environment</code> 中，不同位置加载优先级为：</p>\n<ol>\n<li>当前路径子路径 <code>/config</code></li>\n<li>当前路径 The current directory</li>\n<li>classpath <code>/config</code> 包</li>\n<li>classpath 根</li>\n</ol>\n<p>高优先级配置会覆盖低优先级配置。</p>\n<p>如果需要修改配置文件，可以指定环境属性 <code>spring.config.name</code> 指定另一个配置文件，同时可指定 <code>spring.config.location</code> 多个配置文件路径（可为逗号 <code>,</code> 分隔的多个文件夹路径或文件路径，排列越靠后优先级越高）。这两个环境属性在很早期需要用以加载文件，所以必需以环境属性的方式（An OS Environment Variable, a system property, a command-line argument）指定。</p>\n<p>当 <code>spring.config.location</code> 指定文件夹路径时，需要以 <code>/</code> 结尾，在运行时将在其后追加 <code>spring.config.name</code> 中分离出的文件名与 profile-specific file name 。当 location 指定了全文件名时，直接使用此文件名，但不支持 profile-specific variant，并被 profile-specific 属性覆盖。</p>\n<p><code>spring.config.additional-location</code> 用以指定额外的配置路径，其优先级大于默认的路径</p>\n<h2 id=\"4-Profile-specific-Properties\"><a href=\"#4-Profile-specific-Properties\" class=\"headerlink\" title=\".4. Profile-specific Properties\"></a>.4. Profile-specific Properties</h2><p>通过 <code>spring.profiles.active</code> 变量激活当前应用的配置文件。profile 配置文件规约其名为 <code>application-&#123;profile&#125;.properties</code> ，当没有指定 profile 时， Environment 自动使用 <code>default</code> 作为 profile 环境配置，<code>application-default.properties</code> 中的属性将被加载。</p>\n<p>与标准的 <code>application.properties</code> 配置文件一样，profile 配置文件将从指定位置加载，同时不管所打包的 jar 包内还是包内，profile-specific file 配置覆盖 non-specific ones。If several profiles are specified, a last-wins strategy applies.如果指定多个，后者覆盖前者。</p>\n<p>如果在 <code>spring.config.location</code> 中指定了配置文件，那么此文件在 profile-specific variant 匹配中就不再考虑了。换句话说，如果需要使用 profile-specific 策略匹配配置文件，就不要在 <code>spring.config.location</code> 中添加相关的文件，最好其中只指定 directories 不指定文件。</p>\n<h2 id=\"5-Placeholders-in-Properties\"><a href=\"#5-Placeholders-in-Properties\" class=\"headerlink\" title=\".5. Placeholders in Properties\"></a>.5. Placeholders in Properties</h2><p>在使用配置文件中 <code>application.properties</code> 配置的值时会通过存在的 <code>Environment</code> 过滤，所以，可以在配置中使用占位符 <code>$&#123;&#125;</code> 引用先前定义好的配置（如：系统属性）。</p>\n<h2 id=\"6-Type-safe-Configuration-Properties\"><a href=\"#6-Type-safe-Configuration-Properties\" class=\"headerlink\" title=\".6. Type-safe Configuration Properties\"></a>.6. Type-safe Configuration Properties</h2><blockquote>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">类型安全配置属性</a></p>\n</blockquote>\n<h3 id=\"6-1-JavaBean-Properties-Binding\"><a href=\"#6-1-JavaBean-Properties-Binding\" class=\"headerlink\" title=\".6.1. JavaBean Properties Binding\"></a>.6.1. JavaBean Properties Binding</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">JavaBean 属性绑定</a></p>\n<ul>\n<li>Spring Boot 映射配置到 javaBean 属性中并不是直接使用类的 Accessors(getter/setter)；</li>\n<li>如同 Spring MVC ，配置属性绑定通过标准的 Java Beans 属性描述符实现，所以在默认的空的构造器与 getter setter 通常是必须的；</li>\n<li>在以下情况下 setter 可以省略：<ul>\n<li>被初始化过的 Maps，只需要 getter 不需要 setter，因为他们可以通过 binder 改变。</li>\n<li>Collections Arrays 要么通过 <code>.yml</code> index 要么通过 <code>.properties</code> 的逗号分隔的单个值。在后者，setter 是必须的。如果初始化一个 collection ，保证其是可变的。</li>\n<li>如果是内嵌的 POJO 属性，且已被初始化，setter 可以省略。如果需要让 binder 快速初始化 POJO ，这时 setter 是需要的。</li>\n</ul>\n</li>\n<li>使用 Lombok 自动生成时，保证不要生成特定类型的构造器，因为容器可能需要用来初始化对象。</li>\n<li>只有标准 Java Bean 属性才能被绑定，<strong>不支持绑定属性到静态字段上。</strong></li>\n</ul>\n<h3 id=\"6-2-Constructor-Binding\"><a href=\"#6-2-Constructor-Binding\" class=\"headerlink\" title=\".6.2. Constructor Binding\"></a>.6.2. Constructor Binding</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">构造器绑定</a></p>\n<ul>\n<li>在类上添加注解 <code>@ConstructorBinding</code></li>\n<li>内嵌的属性 POJO 也会使用构造器绑定方式绑定配置属性。</li>\n<li>默认值可使用 <code>@DefaultValue(&quot;default&quot;)</code> 注解添加在属性上，当 binder 找不到相关的配置就会强制将默认值添加到指定属性上</li>\n<li>默认情况下，如果没有为属性配置值，对象属性将为 null 。如果需要返回一个非 null POJO，可以指定一个空的 <code>@DefaultValue</code> 在其上。</li>\n<li>使用构造器绑定，<strong>需要添加 <code>@EnableConfigurationProperties</code> 或配置属性扫描</strong>。常规 Spring Bean 创建机制创建的 Bean （@Component @Bean @Import）上并不能通过此构建器绑定属性。</li>\n<li>如果绑定的 Class 有多个 Constructor ，可直接将 <code>@ConstructorBinding</code> 注解在需要的构造器上。</li>\n</ul>\n<h3 id=\"6-3-Enable-ConfigurationProperties-annotated-Types\"><a href=\"#6-3-Enable-ConfigurationProperties-annotated-Types\" class=\"headerlink\" title=\".6.3. Enable @ConfigurationProperties-annotated Types\"></a>.6.3. Enable @ConfigurationProperties-annotated Types</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">注册配置 bean</a></p>\n<ul>\n<li>Spring Boot 提供了绑定配置到类的机制也提供注册其为 Bean 的机制。可以一个类一个类地配置也可像组件扫描一样配置属性扫描。</li>\n<li>如果需要部分扫描到配置属性，可以在 <code>@EnableConfigurationProperties</code> 指定 type.class ，任意 <code>@Configuration</code> 组件是添加此属性。</li>\n<li>添加 <code>@ConfigurationPropertiesScan</code> 注解在 Application 上会自动扫描包内所有的配置属性 Bean，注解上可添加包。</li>\n<li>当 Bean 注册到容器中后，这个 bean 有一个便名 <code>&lt;prefix&gt;-&lt;fqn&gt;</code> ，<code>&lt;prefix&gt;</code> 是在 <code>@ConfigurationProperties(prefix=&quot;&quot;)</code> 上指定的前缀， <code>&lt;fqn&gt;</code> 指其全限定名。如果没有指定 prefix ，只有全限定名会为此 bean 所用。<em>这他妈有啥用？</em></li>\n</ul>\n<h3 id=\"6-4-Using-ConfigurationProperties-annotated-Types\"><a href=\"#6-4-Using-ConfigurationProperties-annotated-Types\" class=\"headerlink\" title=\".6.4. Using @ConfigurationProperties-annotated Types\"></a>.6.4. Using @ConfigurationProperties-annotated Types</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-java-bean-binding\">使用自动配置属性 Bean</a></p>\n<p>在组件 Bean 直接无注解注入 <code>private final ConfiguredData configuredData;</code></p>\n<h3 id=\"6-5-Third-party-Configuration\"><a href=\"#6-5-Third-party-Configuration\" class=\"headerlink\" title=\".6.5. Third-party Configuration\"></a>.6.5. Third-party Configuration</h3><blockquote>\n<p>第三方 Bean 属性注入</p>\n</blockquote>\n<ul>\n<li>直接在注入第三方 Bean 方法定义处加上 <code>@ConfigurationProperties</code> 注解，将自动将同名配置注入到 Bean 属性中。</li>\n</ul>\n<h3 id=\"6-6-Relaxed-Binding\"><a href=\"#6-6-Relaxed-Binding\" class=\"headerlink\" title=\".6.6. Relaxed Binding\"></a>.6.6. Relaxed Binding</h3><blockquote>\n<p>松绑定</p>\n</blockquote>\n<p>Spring Boot 松绑定 Environment 属性到 @ConfigurationProperties bean 中，所以不需要精确匹配 Environment 属性名与 bean 属性名。常见的例子是使用 dash-separated 或大小写环境属性 context-path 绑定到 contextPath，PORT绑定到 port。</p>\n<p>使用 <code>@ConfigurationProperties(prefix=&quot;project.data&quot;)</code> 注解在有名为 <code>firstName</code> 属性的 bean 上（prefix 的值必须为 Kebab Case 写法），那么在配置文件中可以使用：</p>\n<ol>\n<li><code>project.data.first-name</code>: Kebab Case （小写，单词分隔使用 <code>-</code>，看起来像羊肉串，所以叫 Kebab Case），推荐在 <code>.properties</code> 或 <code>.yml</code> 中使用</li>\n<li><code>project.data.firstName</code> : standard camel case syntax 标准驼峰语法</li>\n<li><code>project.data.first_name</code> : underscore notation，下划线符号，在 <code>.properties</code> <code>.yml</code> 中一种可选的写法</li>\n<li><code>PROJECT_DATA_FIRSTNAME</code> : upper case format，推荐在系统环境变量中使用。</li>\n</ol>\n<h4 id=\"6-6-1-从环境变量绑定数据-Binding-from-Environment-Variables\"><a href=\"#6-6-1-从环境变量绑定数据-Binding-from-Environment-Variables\" class=\"headerlink\" title=\".6.6.1. 从环境变量绑定数据 Binding from Environment Variables\"></a>.6.6.1. 从环境变量绑定数据 Binding from Environment Variables</h4><p>大多操作系统的环境变量都使用严格命名规则，如 Linux 系统 shell 变量只能使用字母数字下划线，Unix 系统 shell 变量只能使用大写。Spring Boot 为与这些系统兼容，规则如下：</p>\n<ol>\n<li>用 <code>_</code> 代替 <code>.</code></li>\n<li>移除所有的 <code>-</code></li>\n<li>转换为大写形式</li>\n</ol>\n<p>比如：配置属性 <code>spring.main.log-startup-info</code> 将被系统环境变量 <code>SPRING_MAIN_LOGSTARTUPINFO</code> 的值所绑定。note:<em>下划线并不会被 dash 所替换</em></p>\n<p>环境变量同样可以绑定到数组对象，数组的下标数字被下划线代替：<code>data[0].name</code> 被环境变量 DATA_0_NAME 值所赋。</p>\n<h3 id=\"6-7-Merging-Complex-Types\"><a href=\"#6-7-Merging-Complex-Types\" class=\"headerlink\" title=\".6.7. Merging Complex Types\"></a>.6.7. Merging Complex Types</h3><p>使用 <code>.yml</code> 与 <code>.properties</code> 外部配置文件添加属性给bean 时，会自动将各个同配置注入到列表属性中，也可以在其中指定不同的 profile 下不同的属性。</p>\n<h3 id=\"6-8-Properties-Conversion\"><a href=\"#6-8-Properties-Conversion\" class=\"headerlink\" title=\".6.8. Properties Conversion\"></a>.6.8. Properties Conversion</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-relaxed-binding\">reference</a></p>\n<p>Spring Boot 内置转换器可以将对多个类型数据进行转换，使用 <code>@**Unit</code> 注解指定单位</p>\n<ol>\n<li>Duration，ms <code>@DurationUnit</code> ns us ms s m h d</li>\n<li>Period ， days <code>@PeriodUnit</code> y m w(weeks is a shortcut means “7 days”) d</li>\n<li>DataSize, byte <code>@DataSizeUnit</code> B KB MB GB TB</li>\n</ol>\n<p>可自定义 converter。</p>\n<h3 id=\"6-9-ConfigurationProperties-Validation\"><a href=\"#6-9-ConfigurationProperties-Validation\" class=\"headerlink\" title=\".6.9. @ConfigurationProperties Validation\"></a>.6.9. @ConfigurationProperties Validation</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation\">reference</a></p>\n<ul>\n<li>在注解 <code>@ConfigurationProperties</code> 的类上添加 <code>@Validated</code> ， 用以约束字段。也可以使用 JSR-303 <code>@Validation</code> （需要保证 JSR-303 在 classpath 之中）。在 @Configuration 组件 bean 定义处添加 <code>@Validated</code> 注解用以验证 bean 。</li>\n<li>验证内嵌的属性，其相应的字段需要添加 <code>@Valid</code> 注解</li>\n<li>自定义 Spring Validator 通过添加一个名为 <code>configurationPropertiesValidator</code> bean 定义静态方法实现，之所以要为 静态的 ，因为 configurationProperties validator 在应用生命周期很早阶段就需要实例化并使用，为避免与外部 <code>@Configuration</code> 类耦合而需要过早地将外部组件类实例化引起的错误，所以需要将此 validator bean 方法定义为静态的。</li>\n</ul>\n<h3 id=\"6-10-ConfigurationProperties-vs-Value\"><a href=\"#6-10-ConfigurationProperties-vs-Value\" class=\"headerlink\" title=\".6.10. @ConfigurationProperties vs. @Value\"></a>.6.10. @ConfigurationProperties vs. @Value</h3><p><a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config-validation\">reference</a></p>\n<ul>\n<li><code>@Value</code> 是容器核心特性，不提供类似类型安全的特性，支持部分 spring 松绑定，不支持 元数据，但比 <code>@ConfigurationProperties</code> 多支持 SpEL 表达式。</li>\n<li>如果同一个组件定义了多个配置属性，推荐使用 <code>@ConfigurationProperties</code> 在bean 类上，这样可以做结构化类型安全的bean 用以注入到 bean 中。</li>\n<li>如果需要使用 <code>@Value</code> ，推荐引用属性名通过其标准形式 Kebab-Case using only lowercase letters 。这样做可以让 Spring Boot 使用与 <code>@ConfigurationProperties</code> 松绑定相同的逻辑。如：使用 <code>@Value(&quot;&#123;demo.first-name&#125;&quot;)</code> ，那么配置文件中的 <code>demo.firstName</code> 与 <code>demo.first-name</code>与系统环境变量 <code>DEMO_FIRSTNAME</code> 都会被当作有效配置（优先级此处不作讨论）。而如果使用 <code>@Value(&quot;&#123;demo.firstName&#125;&quot;)</code> 只有配置文件中的 <code>demo.firstName</code> 会被识别到。</li>\n</ul>\n<h2 id=\"7-Environment\"><a href=\"#7-Environment\" class=\"headerlink\" title=\".7. Environment\"></a>.7. Environment</h2><blockquote>\n<p>spring 中的环境属性 org.springframework.core.env.Environment。</p>\n</blockquote>\n<p>此接口用于当前应用在运行时的环境，应用环境的两个关键模型是 <code>profiles</code> 与 <code>properties</code>。与 property 相关的访问方法定义于其父接口 <code>PropertyResolver</code> 。PropertyResolver 定义了很多可以直接将 String convert 2 T 的方法。</p>\n<p>要实现操作应用的 Environment ，能过 <code>ConfigurableEnvironment</code> 实现。//TODO</p>\n<p><code>profile</code> 是特定命名的一组的 bean definition，只有在指定 profile 是激活状态才能将这组 bean 注册于容器。</p>\n<p>ApplicationContext 中的 bean 都可以通过 EnvironmentAware 接口或注入 <code>@Inject Environment</code> 获取应用配置数据。 通常情况下，大多数应用级别的 bean 不需要直接与 Environment 交互获取配置数据，可以直接使用属性占位符配置器（PropertySourcesPlaceholderConfigurer） <code>$&#123;&#125;</code> 获取属性配置值。PropertySourcesPlaceholderConfigurer 是 EnvironmentAware ，并从 Spring 3.1 开始只要配置 <code>&lt;context:property-placeholder/&gt;</code> ，就默认注册。</p>\n<h3 id=\"7-1-AbstractEnvironment\"><a href=\"#7-1-AbstractEnvironment\" class=\"headerlink\" title=\".7.1. AbstractEnvironment\"></a>.7.1. AbstractEnvironment</h3><p>基本的环境变量，实现了接口 <code>ConfigurableEnvironment</code> 。其内部定义了基本的应用环境属性：忽略系统环境变量 <code>IGNORE_GETENV_PROPERTY_NAME</code> 默认为 false， 激活状态配置 <code>ACTIVE_PROFILES_PROPERTY_NAME</code> ，默认配置 <code>DEFAULT_PROFILES_PROPERTY_NAME</code> ，默认配置名 <code>RESERVED_DEFAULT_PROFILE_NAME</code> 。</p>\n<h3 id=\"7-2-StandardEnvironment\"><a href=\"#7-2-StandardEnvironment\" class=\"headerlink\" title=\".7.2. StandardEnvironment\"></a>.7.2. StandardEnvironment</h3><p>继承自 AbstractEnvironment ，在其基础上添加了系统变量 <code>SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</code> 与环境变量 <code>SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</code>。系统变量优先级更高，其初始化过程中先添加系统变量再添加环境变量在配置数据最末（环境变量可在同一个系统中跨服务共用，而系统变量是针对一个 JVM 而设置）。</p>\n<h3 id=\"7-3-StandardServletEnvironment\"><a href=\"#7-3-StandardServletEnvironment\" class=\"headerlink\" title=\".7.3. StandardServletEnvironment\"></a>.7.3. StandardServletEnvironment</h3><p>StandardServletEnvironment 基于 Servlet 的 web 应用 Environment 实现，继承自 StandardEnvironment 。每个基于 Servlet 的 web 应用 ApplicationContext 都会默认初始化一个实例。此环境会在 StandardEnvironment 的基础上依次（决定了配置变量的优先级从高到低）添加变量： servlet Config 属性 <code>SERVLET_CONTEXT_PROPERTY_SOURCE_NAME</code>，servlet context 属性 <code>SERVLET_CONFIG_PROPERTY_SOURCE_NAME</code> ，JNDI 属性 <code>JNDI_PROPERTY_SOURCE_NAME</code> 。</p>\n<h2 id=\"8-PropertySourcePlaceHolderConfigurer\"><a href=\"#8-PropertySourcePlaceHolderConfigurer\" class=\"headerlink\" title=\".8. PropertySourcePlaceHolderConfigurer\"></a>.8. PropertySourcePlaceHolderConfigurer</h2><p>使用此配置器解析 ApplicationContext 中的所有的 BeanDefinition 中的占位符（默认格式 <code>$&#123;value&#125;</code>）。其实现了 <code>BeanFactoryPostProcessor</code> ，在 ApplicationContext 初始化阶段，会自动扫描所有的 BeanDefinition 并将所有使用占位符的地方都使用配置数据值进行替换。以此来实现占位符引入配置到 bean 中。</p>\n<h3 id=\"8-1-Value\"><a href=\"#8-1-Value\" class=\"headerlink\" title=\".8.1. @Value\"></a>.8.1. @Value</h3><p>用于字段或方法参数上的注解，用以表明其默认值。典型应用于表达式驱动依赖注入，也支持处理器方法参数的动态方案，如 Spring MVC。</p>\n<p><code>@Value</code> 注解的实际的处理是通过 <code>AutowiredAnnotationBeanPostProcessor</code> 实现，这就意味着不能使用此注解用于 BeanFactoryPostProcessor 与 BeanPostProcessor。</p>\n<h4 id=\"8-1-1-AutowiredAnnotationBeanPostProcessor\"><a href=\"#8-1-1-AutowiredAnnotationBeanPostProcessor\" class=\"headerlink\" title=\".8.1.1. AutowiredAnnotationBeanPostProcessor\"></a>.8.1.1. AutowiredAnnotationBeanPostProcessor</h4><p>一个 BeanPostProcessor 。//todo</p>"},{"title":"Spring","layout":"post","date":"2017-08-15T04:14:38.000Z","description":"spring 框架的学习与理解","_content":"\n> spring 配置 beans 的底层原理就在于通过封装好的解析 xml 类，将 xml 文件中配置好的 bean 实例出一个对象来，再通过配置实现 bean 之间的相互引用，而实现将要用到的 bean （实用类）实例化并使用；<!--more-->\n\n- 通过 DI(dependency injection) 依赖注入，实现 IoC(Inverse of Control) 反转控制，将所有的 bean 注入 IoC 容器。\n- ioc 等于 di\n- IoC 的实现：将容器在装配 bean 时，先通过其构造器或工厂生产一个实例后，再根据其配置去构造 bean 的各个依赖。这与传统的实例生成方法相反，所以叫反转控制。\n- [启动步骤](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#application-startup-steps)\n\n## .1. ioc\n\n### .1.1. BeanFactory\n\n最基础的 ioc 容器 BeanFactory 源码：\n\nBean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:\n\n1. BeanNameAware's {@code setBeanName}\n2. BeanClassLoaderAware's {@code setBeanClassLoader}\n3. BeanFactoryAware's {@code setBeanFactory}\n4. EnvironmentAware's {@code setEnvironment}\n5. EmbeddedValueResolverAware's {@code setEmbeddedValueResolver}\n6. ResourceLoaderAware's {@code setResourceLoader}(only applicable when running in an application context)\n7. ApplicationEventPublisherAware's {@code setApplicationEventPublisher}(only applicable when running in an application context)\n8. MessageSourceAware's {@code setMessageSource}(only applicable when running in an application context)\n9. ApplicationContextAware's {@code setApplicationContext}(only applicable when running in an application context)\n10. ServletContextAware's {@code setServletContext}(only applicable when running in a web application context)\n11. {@code postProcessBeforeInitialization} methods of BeanPostProcessors\n12. InitializingBean's {@code afterPropertiesSet}\n13. a custom init-method definition {@code postProcessAfterInitialization} methods of BeanPostProcessors\n\nOn shutdown of a bean factory, the following lifecycle methods apply:\n\n1. {@code postProcessBeforeDestruction} methods of DestructionAwareBeanPostProcessors\n2. DisposableBean's {@code destroy}\n3. a custom destroy-method definition\n\n### .1.2. ApplicationContext\n\n## .2. Core 模块\n\n- bean 标签：\n    - id 属性指定这个实例的唯一标识；\n    - class 属性，用来指定这个实例的类定义；\n    - property 子元素，指定这个对象的属性，比如：user 对象中有属性 name ，那么这个这个 user 的 bean 对象就应该有一个子元素标签 property ，同时如果这个属性是另外一个本地的 bean ， name 属性指向这个属性：`<property name=\"advice\" id=\"beanId\">` 直接使用 id 属性来引用到其他的 bean 的 id 就行；\n\n## .3. AOP 模块\n\n> Aspect Oriented Programming , 面向切面编程\n\n- 切面 Aspect :可以理解为模块，比如，读写数据库、权限检查、异常情况记录；\n- Advice ，增强：拦截器实现增强接口 Advisor ，不同的拦截器实现不同的增强接口，比如：方法前拦截器\n\n    ```java\n    MethodBeforeInterceptor implements MethodBeforeAdvice{\n        //方法前拦截器\n        //调用对象的方法前将执行该方法。参数分别为被调用的方法、参数、对象\n        public void before(Method method, Object[] args, Object instance) throws Throwable{\n            System.out.println(\"即将要执行的方法：\" + method.getName());\n            //如果是 Service\n            if(instance instanceof WaiterServiceImpl)\n                String name = ((AopServiceImpl) instance).getName();\n                    if(name == null)//检查是否为空\n                        throw new NullPointerException(\"name 属性不能为 null\");\n            }\n            method.invoke(instance,args);\n        }\n    }\n    ```\n\n- 拦截器，interceptor，也是 pointcut 的核心:\n    - spring拦截器的配置实现，通过增加配置：\n\n        ```xml\n        <bean id=\"aopMethodBeforeInterceptor\" class=\"org.springframework.aop.supoort.NameMatchMethodPointcutAdvisor\">\n            <property name=\"advice\">\n                <bean class=\"com.snail.aopdemo.advice.MethodBeforeInterceptor\"/>\n            </property>\n            <property name=\"mappedName\" value=\"withAop\"></property>\n        </bean>\n        ```\n\n    - 从上面的代码可以看出：\n        - spring实现拦截器都是通过增强器Advisor，而这个增强器是一个代理，将参数（自定义的Advice）作为参数传入其中；\n        - 同时mappedName属性用来指定拦截的方法，这个方法并不是增加类中的方法，而是到时要执行到的所有的匹配方法名字段的方法；\n        - 同时：spring支持由正则表达式配置切入点：\n\n            ```xml\n            <property name=\"patterns\">      <!-- 正则表达式配置切入点-->\n                <list>\n                    <value>.*get.*</value> <!--包含get字段的方法就被拦截>\n                    <value>.*absquatulate</value>  <!--包含absquatutulat字段的方法被拦截>\n                </list>\n            </property>\n            ```\n\n## .4. ORM 模块\n\n> Object RelativeDatabase Mapping,对象关系型数据库映射\n\n- 简介：\n    - 此模块对 Hibernate/JDO/TopLink、iBatis 等 ORM 框架提供支持；\n    - Spring 提供在 DAO 层提供 HibernateDaoSupport 类与 JDBCTemplate 类；\n    - 在 Spring 里，Hibernate 与 SessionFactory 等只是 Spring 一个特殊的 Bean ，由 spring 负责实例化与销毁；所以也就不需要与 Hibernate 的 API 打交道，不需要开启关闭 Hibernate 的 Session/Transaction ， Spring 自动维护这些对象；\n\n### .4.1. 实体类\n\n这儿用User类举例：\n\n- 使用注解来让User中属性与数据库中表的列相关联；\n- Entity类的注解：\n    - @Entity，表明这个类为实体类；\n    - @Table（name=\"users\"),指明此实体类与数据库users表相关联；\n    - 属性的注解：\n        - @Id，主键注解，表明这属性为数据库表中的主键\n        - @GeneratedValue（strategy=GenerationType.IDENTITY),指明该主键生成策略为自增\n        - @Temporal（value = TemporalType.Date),表明列属性为Date\n- DAO层接口，不同的Entity对应不同的DAO接口：\n    - UserDao接口，就定义对User表的操作：\n\n        ```java\n        public interface UserDao{\n            public void saveUser(User user);\n            public List<User> findUsers();\n            public int getCount ();\n            public User findUserByName(String name);\n        }\n        ```\n\n    - UserDao接口的实现类，UserDaoImpl：\n        - 这个实现类要继承HibernateDaoSupport类，这就意味着从父类继承了Hibernate与HibernateTimplate对象，该对象就对实体对象进行各类操作；\n\n```java\npublic class UserDaoImpl extends HibernateDaoSupport implements UserDao{\n    //实现接口中的方法\n    public void saveUser(User user){\n        this.getHibernateTemplate().persist(user);//使用父类方法get到Template,并调用其persist方法将user存入\n    }\n    public int getCount(){   //查询记录条数\n        Number num = (Number)this.getSession(true).createQuery(\"select count (*) from User).uniqueResult();\n        return n.intValue();\n    }\n    public List<User> findUsers(){  //查询所有的user\n        return this.getHibernateTemplate().find(\"select * from User\");\n    }\n    public User findUserByName(String name){  //根据用户名查询用户\n        List<User> users = this.getHibernateTemplate().find{\"select * from User u where u.name=?\", name);  //使用Template\n        if(users.size() > 0)\n            return users.get(0);返回第一条\n        return null;\n    }\n}\n```\n\n    - **从上述代码例子中可以看出:**\n        - 查询(Read)、创建(Create)都由父类HibernateDaoSupport提供的getHibernateTemplate方法获取到实例并执行实例的方法来实现，其中查询使用实例方法find(String sql, Stirng 拼接String），而save则用持久化方法persist(Object user);\n        - 当要涉及到数据库计算时，则用getSession获取到与数据库的会话对象，让会话对象执行sql统计语句；\n        - 同时，所有sql语言的操作对象都指向实体类，而没有对数据库中的表进行组织sql语句；\n    - **个人理解：**spring通过封装Hibernate在框架中，让DAO接口的实现类继承HibernateDaoSupport尖，就将Hibernate对象创建出来，而直接操作这个对象的方法来获取session/Hibernate对象直接与数据库交互，而就节省了操作JDBC的代码；\n\n#### .4.1.1. 配置集成Hibernate\n\n- 在spring的bean.xml文件中配置集成hibernate到目前这一步只需要***配置三个bean***：\n    - 数据源datasource，这是一切的基础，所有的操作最终都会落到对数据库的操作上；\n\n```xml\n    <bean id=\"datasource\" class=\"org.apache.commonsdbcp.BasicDataSource\">\n        <property name=\"driverClassName\" class=\"org.gjt.mm.mysql.Driver\"></property>\n        <property name=\"url\" value=\"jdbc\\:mysql\\://localhost\\:3306/ssh\"></property>\n        <property name=\"username\" value=\"root\"></property>\n        <propery name=\"password\" value=\"\"></property>\n    </bean>\n```\n\n*- 数据源的配置就是用依赖包中的一个封装好的类（这儿就是BasicDataSource）的对象，并将这个对象的属性值配置好，这些属性就包括了数据库的驱动、连接的url、连接数据库的用户名、密码。可以想象的是，这个处理数据库的对象封装了所有的连接数据库的方法，使用密码与用户名，交给驱动对象，这个驱动对象就按照提供的url连接到主机上的数据库，并登录到数据库；*\n    - 有了数据源，就可以将关联连接库的数据源配置到sessionFactory中去：\n\n        ```xml\n            <bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate4.annotation.AnnotationSessionFactoryBean\" destroy-method=\"destroy\">\n                <property name=\"dataSource\">\n                    <ref bean=\"dataSource\"/>\n                <property/>\n                <property name=\"annotatedClasses\">\n                    <list>\n                        <value>com.woniuxy.orm.class_qulified_name</value>\n                    </list>\n                <property/>\n                <property name=\"hibernateProperties\">\n                    <pros>\n                        <pro key=\"hibernate.dialect\">\n                            org.hibernate.dialect.MySQLDialect\n                        </pro>\n                        <pro key=\"hibernate.show_sql\">true</pro>\n                        <pro key=\"hibernate.format_sql\">true</pro>\n                        <pro key=\"hibernate.hbm2ddl.auto\">create</pro>\n                    </pros>\n                </property>\n            </bean>\n        ```\n\n        - *配置会话工厂（因为我们的实体类使用的注解映射，所以就使用注解会话工厂AnnotationSessionFatoryBean)其中包括了：数据源、实体类还有hibernate,而hibernate的配置就包括了方言、输出sql语句、格式化sql语句、创建表结构*\n    - 有了会话工厂，距离操作数据库就只有让Dao配置为bean，而操作代码就getBean来获取到这个Dao的实例，让这个实例来操作数据库：\n            <bean id=\"userDao\" class=\"daoImpl_qualified_name\">\n                <property name=\"sessionfactory\" ref=\"sessionFactory\" />\n            </bean>\n        - *在Dao的bean中，将前面配置好的sessionFactory装配到其中*\n    - 以上情况是实体类User是使用注解来配置的，这种情况下，使用的sessionFactory是AnnotationSessionFactoryBean,但当实体类是使用xml文件来配置时，使用的配置bean应该是LocalSessionFactoryBean。同时，sessionFactory中配置实体的方式也变成：\n            <property name=\"mappingDirectoryLocations\">\n                <list>\n                    <value>classpath:entiteis_配置文件的路径</value>\n                </list>\n            </property>\n\n---\n\n### .4.2. Hibernate的事务管理\n\n- **分层的做法：应用层调用Service层，Service层对数据进行检查（是否重复之类），然后Service层（注入一个Dao属性）调用Dao层，Dao层调用Hibernate实现数据的操作。原则上不允许跨层访问，业务层次分明。**\n- 事务管理transaction，对应的层为Service层；\n\n### .4.3. spring的bean.xml配置文件的理解\n\n- 所有的操作都基于对数据库的crud，所以所有的配置都围绕着操作数据库；\n- 所以，第一个bean的是数据源：dataSource\n    - 其中的属性就包括：\n        - 连接数据库的驱动：driverClassName\n        - 数据库连接url:url\n        - 数据库连接用户名：username\n        - 数据库连接密码：password\n    - 通常情况下，我们把数据源信息都单独分离在jdbc.properties文件中，并在要用到的配置文件中将其配置为上下文`<context:property-placeholder> location=\"classpath:jdbc.properties/>`，之后就可以在数据源dataSource中配置其中的属性：`<property name=\"driverClass\" value=\"${driver}\"></property>`\n- 第二个配置的bean：sessionFactory\n    - 这儿就把上一次配置好的dataSource数据源装配到sessionFactory的属性中：\n\n```xml\n<!-- 配置本地会话工厂bean -->\n<bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n    <!-- 配置数据源 -->\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n    <!-- 指定hibernate配置文件-->\n    <property name=\"configLocations\" value=\"classpath:hibernate.cfg.xml\"/>\n    <!-- 指定hibernate映射文件-->\n    <property name=\"mappingDirectoryLocations\">\n        <list>\n            <value>classpath:mappings/*.xml</value>\n        </list>\n    </property>\n</bean>\n```\n\n- Note:*这儿配置spring的sessionFactory属性就会把 Hibernate sessionFactory属性覆盖；*\n- configLocations属性：*将指定路径的配置文件都加载进去，相应的LocalSessionFactoryBean中的的此属性的setter方法的参数为可变参数:*\n\n```java\npublic void setConfigLocations(Resource... configLocations) {\n    this.configLocations = configLocations;\n}\n```\n\n- 而在上述代码中，hibernate的配置文件也直接引入到sessionFatory中来，而在外部的hibernate配置文件：\n\n```xml\n<hibernate-configuration>\n    <session-factory>\n        <!-- 配置方言 -->\n        <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</property>\n        <!-- session上下文控制权:交给session来控制 -->\n        <property name=\"hibernate.current_session_context_class\">org.springframework.orm.hibernate5.SpringSessionContext</property>\n        <!-- 格式化sql语句 -->\n        <property name=\"format_sql\">true</property>\n        <!-- 显示sql语句 -->\n        <property name=\"show_sql\">true</property>\n        <!-- 表的生成策略 -->\n        <property name=\"hbm2ddl.auto\">update</property>\n    </session-factory>\n</hibernate-configuration>\n```\n\n- 其中配置了部分的Hibernate属性，同时也可以配置c3p0的属性在其中；\n- 第三个配置：事务管理器transactionManager\n    - 将前面配置好的sessionFactory装配到这个bean中，作为sessionFactory属性值；\n- 第四个配置：tx:advice，配置事务的传播特性，指定具备事务的方法名；\n\n```xml\n<!-- 事务配置增强 -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"txMng\">\n    <tx:attributes>\n        <tx:method name=\"save*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"update*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"delete*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"batch*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"get*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n        <tx:method name=\"load*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n        <tx:method name=\"find*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n        <!-- 统配 -->\n        <tx:method name=\"*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n    - 最后一行统配就指定了所有的方法都配置上事务，同时 isolation 指此事务的隔离级别，propagation 指事务的传播属性，read-only 指是否为只读；\n\n- 第五个配置aop:config，配置事务的切入点，以及被管理的对象\n\n```xml\n<aop:config>\n    <aop:pointcut id=\"interceptorPointCuts\" expression=\"execution(* com.woniuxy.sshdemo.service.impl.*(..))\"/>\n    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"interceptorPointCuts\"/>\n</aop:config>\n```\n\n    - 先将切面的切点配置进来，也就是各个service的执行对象。再将这此切点配置到advisor中\n\n- 其它的配置：\n    - dao的执行类，配置一个id加上sessionFactory;\n    - service的执行类,配置上dao这个属性的对象；\n- **使用注解来实现事务的配置**\n    - 这时bean.xml：\n        - 数据源不变\n        - sessionFactory不变；\n        - 事务管理器trasactionManager依然不变；\n        - 变的是：添加一个事务注解驱动`tx:annotation-driven trasaction-manager=\"transactionManager\"/>`，添加这个驱动配置后，对产生事务的类添加注解`@Transactional`，标记这个类为事务类，对其中的事务方法添加注解`@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)`注解（标明了这个方法的隔离水平与传播水平）。这样的注解就取代了上面例子中tx:advice与aop:config两个配置节点的功能；\n\n## .5. source codes\n\n源码\n\n- `@Configuration` 用以配置 spring 组件的注解，其文档有详细说明大部分的注解使用。\n- 使用 `@ContextConfiguration(locations={classpath*:xxx})` 时， `classpath*:` 表示可以从 jar 包里拿配置文件\n\n## .6. rap 在项目开发中的使用\n\n> date: \"2017-12-05 19:08\"\n\n使用 rap 来定义接口数据，这样方便前端开发人员与我们后端开发在各个接口请求上一致，更方便开发。\n\n### .6.1. 问题\n\n- mock 的使用中： `@mock=true` 在各个参数后面表示默认的数据格式样式吗？\n    - 时间类型/枚举类型等其他的数据选择什么类型？string？\n\n## .7. properties in springmvc\n\n> date: \"2018-12-03 15:05\" [参考文档](https://www.baeldung.com/properties-with-spring)\n\n- 在 xml 文件中引入 properties ： `<context:property-placeholder location=\"classpath:foo.properties\" />`\n- 在配置 bean java 文件中可以使用注解将其配置：\n\n```java\n  @Configuration\n  @PropertySource(\"classpath:foo.properties\")\n  public class PropertiesWithJavaConfig{\n    //...\n  }\n```\n\n    - 另外一个更有用的注解方法：\n\n```java\n@PropertySource({\n  \"classpath:persistence-${envTarget:mysql}.properties\"})\n```\n\n  **note**:\n    - [参考](http://www.cnblogs.com/jycboy/p/7349139.html)\n    - classpath 是指被编译过后的 src 中所有的文件（包括：java、xml、properties）都放在的 WEB-INFO/classes 的文件夹。\n    - `**/` 表示 任意目录。`**/mysql*.properties` 就表示任意目录下的以 `mysql` 开关的 properties 文件\n\n- 在 java 配置文件中插入一个 property 值使用标签 `@Value` ： `@Value(\"${jdbc.url:defaultUrl}\")` ， `:` 后面跟的是默认值。\n- 在 xml 配置文件中插入一个 property 值\n\n  ```xml\n  <bean id=\"dataSource\">\n    <property name=\"url\" value=\"${jdbc.url}\" />\n  </bean>\n","source":"_posts/Spring/spring.md","raw":"---\ntitle: Spring\nlayout: post\ndate: 2017-08-15 12:14:38\ntags: [java,spring]\ncategories: [Spring]\ndescription: spring 框架的学习与理解\n---\n\n> spring 配置 beans 的底层原理就在于通过封装好的解析 xml 类，将 xml 文件中配置好的 bean 实例出一个对象来，再通过配置实现 bean 之间的相互引用，而实现将要用到的 bean （实用类）实例化并使用；<!--more-->\n\n- 通过 DI(dependency injection) 依赖注入，实现 IoC(Inverse of Control) 反转控制，将所有的 bean 注入 IoC 容器。\n- ioc 等于 di\n- IoC 的实现：将容器在装配 bean 时，先通过其构造器或工厂生产一个实例后，再根据其配置去构造 bean 的各个依赖。这与传统的实例生成方法相反，所以叫反转控制。\n- [启动步骤](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#application-startup-steps)\n\n## .1. ioc\n\n### .1.1. BeanFactory\n\n最基础的 ioc 容器 BeanFactory 源码：\n\nBean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:\n\n1. BeanNameAware's {@code setBeanName}\n2. BeanClassLoaderAware's {@code setBeanClassLoader}\n3. BeanFactoryAware's {@code setBeanFactory}\n4. EnvironmentAware's {@code setEnvironment}\n5. EmbeddedValueResolverAware's {@code setEmbeddedValueResolver}\n6. ResourceLoaderAware's {@code setResourceLoader}(only applicable when running in an application context)\n7. ApplicationEventPublisherAware's {@code setApplicationEventPublisher}(only applicable when running in an application context)\n8. MessageSourceAware's {@code setMessageSource}(only applicable when running in an application context)\n9. ApplicationContextAware's {@code setApplicationContext}(only applicable when running in an application context)\n10. ServletContextAware's {@code setServletContext}(only applicable when running in a web application context)\n11. {@code postProcessBeforeInitialization} methods of BeanPostProcessors\n12. InitializingBean's {@code afterPropertiesSet}\n13. a custom init-method definition {@code postProcessAfterInitialization} methods of BeanPostProcessors\n\nOn shutdown of a bean factory, the following lifecycle methods apply:\n\n1. {@code postProcessBeforeDestruction} methods of DestructionAwareBeanPostProcessors\n2. DisposableBean's {@code destroy}\n3. a custom destroy-method definition\n\n### .1.2. ApplicationContext\n\n## .2. Core 模块\n\n- bean 标签：\n    - id 属性指定这个实例的唯一标识；\n    - class 属性，用来指定这个实例的类定义；\n    - property 子元素，指定这个对象的属性，比如：user 对象中有属性 name ，那么这个这个 user 的 bean 对象就应该有一个子元素标签 property ，同时如果这个属性是另外一个本地的 bean ， name 属性指向这个属性：`<property name=\"advice\" id=\"beanId\">` 直接使用 id 属性来引用到其他的 bean 的 id 就行；\n\n## .3. AOP 模块\n\n> Aspect Oriented Programming , 面向切面编程\n\n- 切面 Aspect :可以理解为模块，比如，读写数据库、权限检查、异常情况记录；\n- Advice ，增强：拦截器实现增强接口 Advisor ，不同的拦截器实现不同的增强接口，比如：方法前拦截器\n\n    ```java\n    MethodBeforeInterceptor implements MethodBeforeAdvice{\n        //方法前拦截器\n        //调用对象的方法前将执行该方法。参数分别为被调用的方法、参数、对象\n        public void before(Method method, Object[] args, Object instance) throws Throwable{\n            System.out.println(\"即将要执行的方法：\" + method.getName());\n            //如果是 Service\n            if(instance instanceof WaiterServiceImpl)\n                String name = ((AopServiceImpl) instance).getName();\n                    if(name == null)//检查是否为空\n                        throw new NullPointerException(\"name 属性不能为 null\");\n            }\n            method.invoke(instance,args);\n        }\n    }\n    ```\n\n- 拦截器，interceptor，也是 pointcut 的核心:\n    - spring拦截器的配置实现，通过增加配置：\n\n        ```xml\n        <bean id=\"aopMethodBeforeInterceptor\" class=\"org.springframework.aop.supoort.NameMatchMethodPointcutAdvisor\">\n            <property name=\"advice\">\n                <bean class=\"com.snail.aopdemo.advice.MethodBeforeInterceptor\"/>\n            </property>\n            <property name=\"mappedName\" value=\"withAop\"></property>\n        </bean>\n        ```\n\n    - 从上面的代码可以看出：\n        - spring实现拦截器都是通过增强器Advisor，而这个增强器是一个代理，将参数（自定义的Advice）作为参数传入其中；\n        - 同时mappedName属性用来指定拦截的方法，这个方法并不是增加类中的方法，而是到时要执行到的所有的匹配方法名字段的方法；\n        - 同时：spring支持由正则表达式配置切入点：\n\n            ```xml\n            <property name=\"patterns\">      <!-- 正则表达式配置切入点-->\n                <list>\n                    <value>.*get.*</value> <!--包含get字段的方法就被拦截>\n                    <value>.*absquatulate</value>  <!--包含absquatutulat字段的方法被拦截>\n                </list>\n            </property>\n            ```\n\n## .4. ORM 模块\n\n> Object RelativeDatabase Mapping,对象关系型数据库映射\n\n- 简介：\n    - 此模块对 Hibernate/JDO/TopLink、iBatis 等 ORM 框架提供支持；\n    - Spring 提供在 DAO 层提供 HibernateDaoSupport 类与 JDBCTemplate 类；\n    - 在 Spring 里，Hibernate 与 SessionFactory 等只是 Spring 一个特殊的 Bean ，由 spring 负责实例化与销毁；所以也就不需要与 Hibernate 的 API 打交道，不需要开启关闭 Hibernate 的 Session/Transaction ， Spring 自动维护这些对象；\n\n### .4.1. 实体类\n\n这儿用User类举例：\n\n- 使用注解来让User中属性与数据库中表的列相关联；\n- Entity类的注解：\n    - @Entity，表明这个类为实体类；\n    - @Table（name=\"users\"),指明此实体类与数据库users表相关联；\n    - 属性的注解：\n        - @Id，主键注解，表明这属性为数据库表中的主键\n        - @GeneratedValue（strategy=GenerationType.IDENTITY),指明该主键生成策略为自增\n        - @Temporal（value = TemporalType.Date),表明列属性为Date\n- DAO层接口，不同的Entity对应不同的DAO接口：\n    - UserDao接口，就定义对User表的操作：\n\n        ```java\n        public interface UserDao{\n            public void saveUser(User user);\n            public List<User> findUsers();\n            public int getCount ();\n            public User findUserByName(String name);\n        }\n        ```\n\n    - UserDao接口的实现类，UserDaoImpl：\n        - 这个实现类要继承HibernateDaoSupport类，这就意味着从父类继承了Hibernate与HibernateTimplate对象，该对象就对实体对象进行各类操作；\n\n```java\npublic class UserDaoImpl extends HibernateDaoSupport implements UserDao{\n    //实现接口中的方法\n    public void saveUser(User user){\n        this.getHibernateTemplate().persist(user);//使用父类方法get到Template,并调用其persist方法将user存入\n    }\n    public int getCount(){   //查询记录条数\n        Number num = (Number)this.getSession(true).createQuery(\"select count (*) from User).uniqueResult();\n        return n.intValue();\n    }\n    public List<User> findUsers(){  //查询所有的user\n        return this.getHibernateTemplate().find(\"select * from User\");\n    }\n    public User findUserByName(String name){  //根据用户名查询用户\n        List<User> users = this.getHibernateTemplate().find{\"select * from User u where u.name=?\", name);  //使用Template\n        if(users.size() > 0)\n            return users.get(0);返回第一条\n        return null;\n    }\n}\n```\n\n    - **从上述代码例子中可以看出:**\n        - 查询(Read)、创建(Create)都由父类HibernateDaoSupport提供的getHibernateTemplate方法获取到实例并执行实例的方法来实现，其中查询使用实例方法find(String sql, Stirng 拼接String），而save则用持久化方法persist(Object user);\n        - 当要涉及到数据库计算时，则用getSession获取到与数据库的会话对象，让会话对象执行sql统计语句；\n        - 同时，所有sql语言的操作对象都指向实体类，而没有对数据库中的表进行组织sql语句；\n    - **个人理解：**spring通过封装Hibernate在框架中，让DAO接口的实现类继承HibernateDaoSupport尖，就将Hibernate对象创建出来，而直接操作这个对象的方法来获取session/Hibernate对象直接与数据库交互，而就节省了操作JDBC的代码；\n\n#### .4.1.1. 配置集成Hibernate\n\n- 在spring的bean.xml文件中配置集成hibernate到目前这一步只需要***配置三个bean***：\n    - 数据源datasource，这是一切的基础，所有的操作最终都会落到对数据库的操作上；\n\n```xml\n    <bean id=\"datasource\" class=\"org.apache.commonsdbcp.BasicDataSource\">\n        <property name=\"driverClassName\" class=\"org.gjt.mm.mysql.Driver\"></property>\n        <property name=\"url\" value=\"jdbc\\:mysql\\://localhost\\:3306/ssh\"></property>\n        <property name=\"username\" value=\"root\"></property>\n        <propery name=\"password\" value=\"\"></property>\n    </bean>\n```\n\n*- 数据源的配置就是用依赖包中的一个封装好的类（这儿就是BasicDataSource）的对象，并将这个对象的属性值配置好，这些属性就包括了数据库的驱动、连接的url、连接数据库的用户名、密码。可以想象的是，这个处理数据库的对象封装了所有的连接数据库的方法，使用密码与用户名，交给驱动对象，这个驱动对象就按照提供的url连接到主机上的数据库，并登录到数据库；*\n    - 有了数据源，就可以将关联连接库的数据源配置到sessionFactory中去：\n\n        ```xml\n            <bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate4.annotation.AnnotationSessionFactoryBean\" destroy-method=\"destroy\">\n                <property name=\"dataSource\">\n                    <ref bean=\"dataSource\"/>\n                <property/>\n                <property name=\"annotatedClasses\">\n                    <list>\n                        <value>com.woniuxy.orm.class_qulified_name</value>\n                    </list>\n                <property/>\n                <property name=\"hibernateProperties\">\n                    <pros>\n                        <pro key=\"hibernate.dialect\">\n                            org.hibernate.dialect.MySQLDialect\n                        </pro>\n                        <pro key=\"hibernate.show_sql\">true</pro>\n                        <pro key=\"hibernate.format_sql\">true</pro>\n                        <pro key=\"hibernate.hbm2ddl.auto\">create</pro>\n                    </pros>\n                </property>\n            </bean>\n        ```\n\n        - *配置会话工厂（因为我们的实体类使用的注解映射，所以就使用注解会话工厂AnnotationSessionFatoryBean)其中包括了：数据源、实体类还有hibernate,而hibernate的配置就包括了方言、输出sql语句、格式化sql语句、创建表结构*\n    - 有了会话工厂，距离操作数据库就只有让Dao配置为bean，而操作代码就getBean来获取到这个Dao的实例，让这个实例来操作数据库：\n            <bean id=\"userDao\" class=\"daoImpl_qualified_name\">\n                <property name=\"sessionfactory\" ref=\"sessionFactory\" />\n            </bean>\n        - *在Dao的bean中，将前面配置好的sessionFactory装配到其中*\n    - 以上情况是实体类User是使用注解来配置的，这种情况下，使用的sessionFactory是AnnotationSessionFactoryBean,但当实体类是使用xml文件来配置时，使用的配置bean应该是LocalSessionFactoryBean。同时，sessionFactory中配置实体的方式也变成：\n            <property name=\"mappingDirectoryLocations\">\n                <list>\n                    <value>classpath:entiteis_配置文件的路径</value>\n                </list>\n            </property>\n\n---\n\n### .4.2. Hibernate的事务管理\n\n- **分层的做法：应用层调用Service层，Service层对数据进行检查（是否重复之类），然后Service层（注入一个Dao属性）调用Dao层，Dao层调用Hibernate实现数据的操作。原则上不允许跨层访问，业务层次分明。**\n- 事务管理transaction，对应的层为Service层；\n\n### .4.3. spring的bean.xml配置文件的理解\n\n- 所有的操作都基于对数据库的crud，所以所有的配置都围绕着操作数据库；\n- 所以，第一个bean的是数据源：dataSource\n    - 其中的属性就包括：\n        - 连接数据库的驱动：driverClassName\n        - 数据库连接url:url\n        - 数据库连接用户名：username\n        - 数据库连接密码：password\n    - 通常情况下，我们把数据源信息都单独分离在jdbc.properties文件中，并在要用到的配置文件中将其配置为上下文`<context:property-placeholder> location=\"classpath:jdbc.properties/>`，之后就可以在数据源dataSource中配置其中的属性：`<property name=\"driverClass\" value=\"${driver}\"></property>`\n- 第二个配置的bean：sessionFactory\n    - 这儿就把上一次配置好的dataSource数据源装配到sessionFactory的属性中：\n\n```xml\n<!-- 配置本地会话工厂bean -->\n<bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n    <!-- 配置数据源 -->\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n    <!-- 指定hibernate配置文件-->\n    <property name=\"configLocations\" value=\"classpath:hibernate.cfg.xml\"/>\n    <!-- 指定hibernate映射文件-->\n    <property name=\"mappingDirectoryLocations\">\n        <list>\n            <value>classpath:mappings/*.xml</value>\n        </list>\n    </property>\n</bean>\n```\n\n- Note:*这儿配置spring的sessionFactory属性就会把 Hibernate sessionFactory属性覆盖；*\n- configLocations属性：*将指定路径的配置文件都加载进去，相应的LocalSessionFactoryBean中的的此属性的setter方法的参数为可变参数:*\n\n```java\npublic void setConfigLocations(Resource... configLocations) {\n    this.configLocations = configLocations;\n}\n```\n\n- 而在上述代码中，hibernate的配置文件也直接引入到sessionFatory中来，而在外部的hibernate配置文件：\n\n```xml\n<hibernate-configuration>\n    <session-factory>\n        <!-- 配置方言 -->\n        <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</property>\n        <!-- session上下文控制权:交给session来控制 -->\n        <property name=\"hibernate.current_session_context_class\">org.springframework.orm.hibernate5.SpringSessionContext</property>\n        <!-- 格式化sql语句 -->\n        <property name=\"format_sql\">true</property>\n        <!-- 显示sql语句 -->\n        <property name=\"show_sql\">true</property>\n        <!-- 表的生成策略 -->\n        <property name=\"hbm2ddl.auto\">update</property>\n    </session-factory>\n</hibernate-configuration>\n```\n\n- 其中配置了部分的Hibernate属性，同时也可以配置c3p0的属性在其中；\n- 第三个配置：事务管理器transactionManager\n    - 将前面配置好的sessionFactory装配到这个bean中，作为sessionFactory属性值；\n- 第四个配置：tx:advice，配置事务的传播特性，指定具备事务的方法名；\n\n```xml\n<!-- 事务配置增强 -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"txMng\">\n    <tx:attributes>\n        <tx:method name=\"save*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"update*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"delete*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"batch*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"get*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n        <tx:method name=\"load*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n        <tx:method name=\"find*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n        <!-- 统配 -->\n        <tx:method name=\"*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n    - 最后一行统配就指定了所有的方法都配置上事务，同时 isolation 指此事务的隔离级别，propagation 指事务的传播属性，read-only 指是否为只读；\n\n- 第五个配置aop:config，配置事务的切入点，以及被管理的对象\n\n```xml\n<aop:config>\n    <aop:pointcut id=\"interceptorPointCuts\" expression=\"execution(* com.woniuxy.sshdemo.service.impl.*(..))\"/>\n    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"interceptorPointCuts\"/>\n</aop:config>\n```\n\n    - 先将切面的切点配置进来，也就是各个service的执行对象。再将这此切点配置到advisor中\n\n- 其它的配置：\n    - dao的执行类，配置一个id加上sessionFactory;\n    - service的执行类,配置上dao这个属性的对象；\n- **使用注解来实现事务的配置**\n    - 这时bean.xml：\n        - 数据源不变\n        - sessionFactory不变；\n        - 事务管理器trasactionManager依然不变；\n        - 变的是：添加一个事务注解驱动`tx:annotation-driven trasaction-manager=\"transactionManager\"/>`，添加这个驱动配置后，对产生事务的类添加注解`@Transactional`，标记这个类为事务类，对其中的事务方法添加注解`@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)`注解（标明了这个方法的隔离水平与传播水平）。这样的注解就取代了上面例子中tx:advice与aop:config两个配置节点的功能；\n\n## .5. source codes\n\n源码\n\n- `@Configuration` 用以配置 spring 组件的注解，其文档有详细说明大部分的注解使用。\n- 使用 `@ContextConfiguration(locations={classpath*:xxx})` 时， `classpath*:` 表示可以从 jar 包里拿配置文件\n\n## .6. rap 在项目开发中的使用\n\n> date: \"2017-12-05 19:08\"\n\n使用 rap 来定义接口数据，这样方便前端开发人员与我们后端开发在各个接口请求上一致，更方便开发。\n\n### .6.1. 问题\n\n- mock 的使用中： `@mock=true` 在各个参数后面表示默认的数据格式样式吗？\n    - 时间类型/枚举类型等其他的数据选择什么类型？string？\n\n## .7. properties in springmvc\n\n> date: \"2018-12-03 15:05\" [参考文档](https://www.baeldung.com/properties-with-spring)\n\n- 在 xml 文件中引入 properties ： `<context:property-placeholder location=\"classpath:foo.properties\" />`\n- 在配置 bean java 文件中可以使用注解将其配置：\n\n```java\n  @Configuration\n  @PropertySource(\"classpath:foo.properties\")\n  public class PropertiesWithJavaConfig{\n    //...\n  }\n```\n\n    - 另外一个更有用的注解方法：\n\n```java\n@PropertySource({\n  \"classpath:persistence-${envTarget:mysql}.properties\"})\n```\n\n  **note**:\n    - [参考](http://www.cnblogs.com/jycboy/p/7349139.html)\n    - classpath 是指被编译过后的 src 中所有的文件（包括：java、xml、properties）都放在的 WEB-INFO/classes 的文件夹。\n    - `**/` 表示 任意目录。`**/mysql*.properties` 就表示任意目录下的以 `mysql` 开关的 properties 文件\n\n- 在 java 配置文件中插入一个 property 值使用标签 `@Value` ： `@Value(\"${jdbc.url:defaultUrl}\")` ， `:` 后面跟的是默认值。\n- 在 xml 配置文件中插入一个 property 值\n\n  ```xml\n  <bean id=\"dataSource\">\n    <property name=\"url\" value=\"${jdbc.url}\" />\n  </bean>\n","slug":"Spring/spring","published":1,"updated":"2021-02-24T15:22:22.976Z","comments":1,"photos":[],"link":"","_id":"ckljnokt3006s2bhb4g2m8nhc","content":"<blockquote>\n<p>spring 配置 beans 的底层原理就在于通过封装好的解析 xml 类，将 xml 文件中配置好的 bean 实例出一个对象来，再通过配置实现 bean 之间的相互引用，而实现将要用到的 bean （实用类）实例化并使用；<span id=\"more\"></span></p>\n</blockquote>\n<ul>\n<li>通过 DI(dependency injection) 依赖注入，实现 IoC(Inverse of Control) 反转控制，将所有的 bean 注入 IoC 容器。</li>\n<li>ioc 等于 di</li>\n<li>IoC 的实现：将容器在装配 bean 时，先通过其构造器或工厂生产一个实例后，再根据其配置去构造 bean 的各个依赖。这与传统的实例生成方法相反，所以叫反转控制。</li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#application-startup-steps\">启动步骤</a></li>\n</ul>\n<h2 id=\"1-ioc\"><a href=\"#1-ioc\" class=\"headerlink\" title=\".1. ioc\"></a>.1. ioc</h2><h3 id=\"1-1-BeanFactory\"><a href=\"#1-1-BeanFactory\" class=\"headerlink\" title=\".1.1. BeanFactory\"></a>.1.1. BeanFactory</h3><p>最基础的 ioc 容器 BeanFactory 源码：</p>\n<p>Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:</p>\n<ol>\n<li>BeanNameAware’s {@code setBeanName}</li>\n<li>BeanClassLoaderAware’s {@code setBeanClassLoader}</li>\n<li>BeanFactoryAware’s {@code setBeanFactory}</li>\n<li>EnvironmentAware’s {@code setEnvironment}</li>\n<li>EmbeddedValueResolverAware’s {@code setEmbeddedValueResolver}</li>\n<li>ResourceLoaderAware’s {@code setResourceLoader}(only applicable when running in an application context)</li>\n<li>ApplicationEventPublisherAware’s {@code setApplicationEventPublisher}(only applicable when running in an application context)</li>\n<li>MessageSourceAware’s {@code setMessageSource}(only applicable when running in an application context)</li>\n<li>ApplicationContextAware’s {@code setApplicationContext}(only applicable when running in an application context)</li>\n<li>ServletContextAware’s {@code setServletContext}(only applicable when running in a web application context)</li>\n<li>{@code postProcessBeforeInitialization} methods of BeanPostProcessors</li>\n<li>InitializingBean’s {@code afterPropertiesSet}</li>\n<li>a custom init-method definition {@code postProcessAfterInitialization} methods of BeanPostProcessors</li>\n</ol>\n<p>On shutdown of a bean factory, the following lifecycle methods apply:</p>\n<ol>\n<li>{@code postProcessBeforeDestruction} methods of DestructionAwareBeanPostProcessors</li>\n<li>DisposableBean’s {@code destroy}</li>\n<li>a custom destroy-method definition</li>\n</ol>\n<h3 id=\"1-2-ApplicationContext\"><a href=\"#1-2-ApplicationContext\" class=\"headerlink\" title=\".1.2. ApplicationContext\"></a>.1.2. ApplicationContext</h3><h2 id=\"2-Core-模块\"><a href=\"#2-Core-模块\" class=\"headerlink\" title=\".2. Core 模块\"></a>.2. Core 模块</h2><ul>\n<li>bean 标签：<ul>\n<li>id 属性指定这个实例的唯一标识；</li>\n<li>class 属性，用来指定这个实例的类定义；</li>\n<li>property 子元素，指定这个对象的属性，比如：user 对象中有属性 name ，那么这个这个 user 的 bean 对象就应该有一个子元素标签 property ，同时如果这个属性是另外一个本地的 bean ， name 属性指向这个属性：<code>&lt;property name=&quot;advice&quot; id=&quot;beanId&quot;&gt;</code> 直接使用 id 属性来引用到其他的 bean 的 id 就行；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-AOP-模块\"><a href=\"#3-AOP-模块\" class=\"headerlink\" title=\".3. AOP 模块\"></a>.3. AOP 模块</h2><blockquote>\n<p>Aspect Oriented Programming , 面向切面编程</p>\n</blockquote>\n<ul>\n<li><p>切面 Aspect :可以理解为模块，比如，读写数据库、权限检查、异常情况记录；</p>\n</li>\n<li><p>Advice ，增强：拦截器实现增强接口 Advisor ，不同的拦截器实现不同的增强接口，比如：方法前拦截器</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MethodBeforeInterceptor implements MethodBeforeAdvice&#123;</span><br><span class=\"line\">    <span class=\"comment\">//方法前拦截器</span></span><br><span class=\"line\">    <span class=\"comment\">//调用对象的方法前将执行该方法。参数分别为被调用的方法、参数、对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">(Method method, Object[] args, Object instance)</span> <span class=\"keyword\">throws</span> Throwable</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;即将要执行的方法：&quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"comment\">//如果是 Service</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance <span class=\"keyword\">instanceof</span> WaiterServiceImpl)</span><br><span class=\"line\">            String name = ((AopServiceImpl) instance).getName();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(name == <span class=\"keyword\">null</span>)<span class=\"comment\">//检查是否为空</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;name 属性不能为 null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        method.invoke(instance,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>拦截器，interceptor，也是 pointcut 的核心:</p>\n<ul>\n<li><p>spring拦截器的配置实现，通过增加配置：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;aopMethodBeforeInterceptor&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.aop.supoort.NameMatchMethodPointcutAdvisor&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;advice&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.aopdemo.advice.MethodBeforeInterceptor&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mappedName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;withAop&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从上面的代码可以看出：</p>\n<ul>\n<li><p>spring实现拦截器都是通过增强器Advisor，而这个增强器是一个代理，将参数（自定义的Advice）作为参数传入其中；</p>\n</li>\n<li><p>同时mappedName属性用来指定拦截的方法，这个方法并不是增加类中的方法，而是到时要执行到的所有的匹配方法名字段的方法；</p>\n</li>\n<li><p>同时：spring支持由正则表达式配置切入点：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;patterns&quot;</span>&gt;</span>      <span class=\"comment\">&lt;!-- 正则表达式配置切入点--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>.*get.*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span> <span class=\"comment\">&lt;!--包含get字段的方法就被拦截&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;value&gt;.*absquatulate&lt;/value&gt;  &lt;!--包含absquatutulat字段的方法被拦截&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;/list&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-ORM-模块\"><a href=\"#4-ORM-模块\" class=\"headerlink\" title=\".4. ORM 模块\"></a>.4. ORM 模块</h2><blockquote>\n<p>Object RelativeDatabase Mapping,对象关系型数据库映射</p>\n</blockquote>\n<ul>\n<li>简介：<ul>\n<li>此模块对 Hibernate/JDO/TopLink、iBatis 等 ORM 框架提供支持；</li>\n<li>Spring 提供在 DAO 层提供 HibernateDaoSupport 类与 JDBCTemplate 类；</li>\n<li>在 Spring 里，Hibernate 与 SessionFactory 等只是 Spring 一个特殊的 Bean ，由 spring 负责实例化与销毁；所以也就不需要与 Hibernate 的 API 打交道，不需要开启关闭 Hibernate 的 Session/Transaction ， Spring 自动维护这些对象；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1-实体类\"><a href=\"#4-1-实体类\" class=\"headerlink\" title=\".4.1. 实体类\"></a>.4.1. 实体类</h3><p>这儿用User类举例：</p>\n<ul>\n<li><p>使用注解来让User中属性与数据库中表的列相关联；</p>\n</li>\n<li><p>Entity类的注解：</p>\n<ul>\n<li>@Entity，表明这个类为实体类；</li>\n<li>@Table（name=”users”),指明此实体类与数据库users表相关联；</li>\n<li>属性的注解：<ul>\n<li>@Id，主键注解，表明这属性为数据库表中的主键</li>\n<li>@GeneratedValue（strategy=GenerationType.IDENTITY),指明该主键生成策略为自增</li>\n<li>@Temporal（value = TemporalType.Date),表明列属性为Date</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DAO层接口，不同的Entity对应不同的DAO接口：</p>\n<ul>\n<li><p>UserDao接口，就定义对User表的操作：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveUser</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">findUsers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span> <span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">findUserByName</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>UserDao接口的实现类，UserDaoImpl：</p>\n<ul>\n<li>这个实现类要继承HibernateDaoSupport类，这就意味着从父类继承了Hibernate与HibernateTimplate对象，该对象就对实体对象进行各类操作；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实现接口中的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveUser</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.getHibernateTemplate().persist(user);<span class=\"comment\">//使用父类方法get到Template,并调用其persist方法将user存入</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span>&#123;   <span class=\"comment\">//查询记录条数</span></span><br><span class=\"line\">        Number num = (Number)<span class=\"keyword\">this</span>.getSession(<span class=\"keyword\">true</span>).createQuery(<span class=\"string\">&quot;select count (*) from User).uniqueResult();</span></span><br><span class=\"line\"><span class=\"string\">        return n.intValue();</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    public List&lt;User&gt; findUsers()&#123;  //查询所有的user</span></span><br><span class=\"line\"><span class=\"string\">        return this.getHibernateTemplate().find(&quot;</span>select * from User<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    public User findUserByName(String name)&#123;  //根据用户名查询用户</span></span><br><span class=\"line\"><span class=\"string\">        List&lt;User&gt; users = this.getHibernateTemplate().find&#123;&quot;</span>select * from User u where u.name=?<span class=\"string\">&quot;, name);  //使用Template</span></span><br><span class=\"line\"><span class=\"string\">        if(users.size() &gt; 0)</span></span><br><span class=\"line\"><span class=\"string\">            return users.get(0);返回第一条</span></span><br><span class=\"line\"><span class=\"string\">        return null;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>- **从上述代码例子中可以看出:**\n    - 查询(Read)、创建(Create)都由父类HibernateDaoSupport提供的getHibernateTemplate方法获取到实例并执行实例的方法来实现，其中查询使用实例方法find(String sql, Stirng 拼接String），而save则用持久化方法persist(Object user);\n    - 当要涉及到数据库计算时，则用getSession获取到与数据库的会话对象，让会话对象执行sql统计语句；\n    - 同时，所有sql语言的操作对象都指向实体类，而没有对数据库中的表进行组织sql语句；\n- **个人理解：**spring通过封装Hibernate在框架中，让DAO接口的实现类继承HibernateDaoSupport尖，就将Hibernate对象创建出来，而直接操作这个对象的方法来获取session/Hibernate对象直接与数据库交互，而就节省了操作JDBC的代码；\n</code></pre>\n<h4 id=\"4-1-1-配置集成Hibernate\"><a href=\"#4-1-1-配置集成Hibernate\" class=\"headerlink\" title=\".4.1.1. 配置集成Hibernate\"></a>.4.1.1. 配置集成Hibernate</h4><ul>\n<li>在spring的bean.xml文件中配置集成hibernate到目前这一步只需要**<em>配置三个bean**</em>：<ul>\n<li>数据源datasource，这是一切的基础，所有的操作最终都会落到对数据库的操作上；</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;datasource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.commonsdbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.gjt.mm.mysql.Driver&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc\\:mysql\\://localhost\\:3306/ssh&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">propery</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>- 数据源的配置就是用依赖包中的一个封装好的类（这儿就是BasicDataSource）的对象，并将这个对象的属性值配置好，这些属性就包括了数据库的驱动、连接的url、连接数据库的用户名、密码。可以想象的是，这个处理数据库的对象封装了所有的连接数据库的方法，使用密码与用户名，交给驱动对象，这个驱动对象就按照提供的url连接到主机上的数据库，并登录到数据库；</em><br>    - 有了数据源，就可以将关联连接库的数据源配置到sessionFactory中去：</p>\n<pre><code>    <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sessionFactory&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.orm.hibernate4.annotation.AnnotationSessionFactoryBean&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;destroy&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;annotatedClasses&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.woniuxy.orm.class_qulified_name<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">pros</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.dialect&quot;</span>&gt;</span></span><br><span class=\"line\">                org.hibernate.dialect.MySQLDialect</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>create<span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">pros</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n    - *配置会话工厂（因为我们的实体类使用的注解映射，所以就使用注解会话工厂AnnotationSessionFatoryBean)其中包括了：数据源、实体类还有hibernate,而hibernate的配置就包括了方言、输出sql语句、格式化sql语句、创建表结构*\n- 有了会话工厂，距离操作数据库就只有让Dao配置为bean，而操作代码就getBean来获取到这个Dao的实例，让这个实例来操作数据库：\n        &lt;bean id=&quot;userDao&quot; class=&quot;daoImpl_qualified_name&quot;&gt;\n            &lt;property name=&quot;sessionfactory&quot; ref=&quot;sessionFactory&quot; /&gt;\n        &lt;/bean&gt;\n    - *在Dao的bean中，将前面配置好的sessionFactory装配到其中*\n- 以上情况是实体类User是使用注解来配置的，这种情况下，使用的sessionFactory是AnnotationSessionFactoryBean,但当实体类是使用xml文件来配置时，使用的配置bean应该是LocalSessionFactoryBean。同时，sessionFactory中配置实体的方式也变成：\n        &lt;property name=&quot;mappingDirectoryLocations&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;classpath:entiteis_配置文件的路径&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n</code></pre>\n<hr>\n<h3 id=\"4-2-Hibernate的事务管理\"><a href=\"#4-2-Hibernate的事务管理\" class=\"headerlink\" title=\".4.2. Hibernate的事务管理\"></a>.4.2. Hibernate的事务管理</h3><ul>\n<li><strong>分层的做法：应用层调用Service层，Service层对数据进行检查（是否重复之类），然后Service层（注入一个Dao属性）调用Dao层，Dao层调用Hibernate实现数据的操作。原则上不允许跨层访问，业务层次分明。</strong></li>\n<li>事务管理transaction，对应的层为Service层；</li>\n</ul>\n<h3 id=\"4-3-spring的bean-xml配置文件的理解\"><a href=\"#4-3-spring的bean-xml配置文件的理解\" class=\"headerlink\" title=\".4.3. spring的bean.xml配置文件的理解\"></a>.4.3. spring的bean.xml配置文件的理解</h3><ul>\n<li>所有的操作都基于对数据库的crud，所以所有的配置都围绕着操作数据库；</li>\n<li>所以，第一个bean的是数据源：dataSource<ul>\n<li>其中的属性就包括：<ul>\n<li>连接数据库的驱动：driverClassName</li>\n<li>数据库连接url:url</li>\n<li>数据库连接用户名：username</li>\n<li>数据库连接密码：password</li>\n</ul>\n</li>\n<li>通常情况下，我们把数据源信息都单独分离在jdbc.properties文件中，并在要用到的配置文件中将其配置为上下文<code>&lt;context:property-placeholder&gt; location=&quot;classpath:jdbc.properties/&gt;</code>，之后就可以在数据源dataSource中配置其中的属性：<code>&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driver&#125;&quot;&gt;&lt;/property&gt;</code></li>\n</ul>\n</li>\n<li>第二个配置的bean：sessionFactory<ul>\n<li>这儿就把上一次配置好的dataSource数据源装配到sessionFactory的属性中：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置本地会话工厂bean --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sessionFactory&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置数据源 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定hibernate配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;configLocations&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:hibernate.cfg.xml&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定hibernate映射文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mappingDirectoryLocations&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:mappings/*.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Note:<em>这儿配置spring的sessionFactory属性就会把 Hibernate sessionFactory属性覆盖；</em></li>\n<li>configLocations属性：<em>将指定路径的配置文件都加载进去，相应的LocalSessionFactoryBean中的的此属性的setter方法的参数为可变参数:</em></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setConfigLocations</span><span class=\"params\">(Resource... configLocations)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.configLocations = configLocations;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在上述代码中，hibernate的配置文件也直接引入到sessionFatory中来，而在外部的hibernate配置文件：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 配置方言 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5InnoDBDialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- session上下文控制权:交给session来控制 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.current_session_context_class&quot;</span>&gt;</span>org.springframework.orm.hibernate5.SpringSessionContext<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 格式化sql语句 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;format_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 显示sql语句 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;show_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 表的生成策略 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hbm2ddl.auto&quot;</span>&gt;</span>update<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中配置了部分的Hibernate属性，同时也可以配置c3p0的属性在其中；</li>\n<li>第三个配置：事务管理器transactionManager<ul>\n<li>将前面配置好的sessionFactory装配到这个bean中，作为sessionFactory属性值；</li>\n</ul>\n</li>\n<li>第四个配置：tx:advice，配置事务的传播特性，指定具备事务的方法名；</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 事务配置增强 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;txMng&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;save*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;update*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;delete*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;batch*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;get*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;load*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;find*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 统配 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>- 最后一行统配就指定了所有的方法都配置上事务，同时 isolation 指此事务的隔离级别，propagation 指事务的传播属性，read-only 指是否为只读；\n</code></pre>\n<ul>\n<li>第五个配置aop:config，配置事务的切入点，以及被管理的对象</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;interceptorPointCuts&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;execution(* com.woniuxy.sshdemo.service.impl.*(..))&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">&quot;interceptorPointCuts&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>- 先将切面的切点配置进来，也就是各个service的执行对象。再将这此切点配置到advisor中\n</code></pre>\n<ul>\n<li>其它的配置：<ul>\n<li>dao的执行类，配置一个id加上sessionFactory;</li>\n<li>service的执行类,配置上dao这个属性的对象；</li>\n</ul>\n</li>\n<li><strong>使用注解来实现事务的配置</strong><ul>\n<li>这时bean.xml：<ul>\n<li>数据源不变</li>\n<li>sessionFactory不变；</li>\n<li>事务管理器trasactionManager依然不变；</li>\n<li>变的是：添加一个事务注解驱动<code>tx:annotation-driven trasaction-manager=&quot;transactionManager&quot;/&gt;</code>，添加这个驱动配置后，对产生事务的类添加注解<code>@Transactional</code>，标记这个类为事务类，对其中的事务方法添加注解<code>@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)</code>注解（标明了这个方法的隔离水平与传播水平）。这样的注解就取代了上面例子中tx:advice与aop:config两个配置节点的功能；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-source-codes\"><a href=\"#5-source-codes\" class=\"headerlink\" title=\".5. source codes\"></a>.5. source codes</h2><p>源码</p>\n<ul>\n<li><code>@Configuration</code> 用以配置 spring 组件的注解，其文档有详细说明大部分的注解使用。</li>\n<li>使用 <code>@ContextConfiguration(locations=&#123;classpath*:xxx&#125;)</code> 时， <code>classpath*:</code> 表示可以从 jar 包里拿配置文件</li>\n</ul>\n<h2 id=\"6-rap-在项目开发中的使用\"><a href=\"#6-rap-在项目开发中的使用\" class=\"headerlink\" title=\".6. rap 在项目开发中的使用\"></a>.6. rap 在项目开发中的使用</h2><blockquote>\n<p>date: “2017-12-05 19:08”</p>\n</blockquote>\n<p>使用 rap 来定义接口数据，这样方便前端开发人员与我们后端开发在各个接口请求上一致，更方便开发。</p>\n<h3 id=\"6-1-问题\"><a href=\"#6-1-问题\" class=\"headerlink\" title=\".6.1. 问题\"></a>.6.1. 问题</h3><ul>\n<li>mock 的使用中： <code>@mock=true</code> 在各个参数后面表示默认的数据格式样式吗？<ul>\n<li>时间类型/枚举类型等其他的数据选择什么类型？string？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-properties-in-springmvc\"><a href=\"#7-properties-in-springmvc\" class=\"headerlink\" title=\".7. properties in springmvc\"></a>.7. properties in springmvc</h2><blockquote>\n<p>date: “2018-12-03 15:05” <a href=\"https://www.baeldung.com/properties-with-spring\">参考文档</a></p>\n</blockquote>\n<ul>\n<li>在 xml 文件中引入 properties ： <code>&lt;context:property-placeholder location=&quot;classpath:foo.properties&quot; /&gt;</code></li>\n<li>在配置 bean java 文件中可以使用注解将其配置：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:foo.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertiesWithJavaConfig</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>- 另外一个更有用的注解方法：\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PropertySource(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">  &quot;classpath:persistence-$&#123;envTarget:mysql&#125;.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<p>  <strong>note</strong>:<br>    - <a href=\"http://www.cnblogs.com/jycboy/p/7349139.html\">参考</a><br>    - classpath 是指被编译过后的 src 中所有的文件（包括：java、xml、properties）都放在的 WEB-INFO/classes 的文件夹。<br>    - <code>**/</code> 表示 任意目录。<code>**/mysql*.properties</code> 就表示任意目录下的以 <code>mysql</code> 开关的 properties 文件</p>\n<ul>\n<li><p>在 java 配置文件中插入一个 property 值使用标签 <code>@Value</code> ： <code>@Value(&quot;$&#123;jdbc.url:defaultUrl&#125;&quot;)</code> ， <code>:</code> 后面跟的是默认值。</p>\n</li>\n<li><p>在 xml 配置文件中插入一个 property 值</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;dataSource&quot;&gt;\n  &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>spring 配置 beans 的底层原理就在于通过封装好的解析 xml 类，将 xml 文件中配置好的 bean 实例出一个对象来，再通过配置实现 bean 之间的相互引用，而实现将要用到的 bean （实用类）实例化并使用；","more":"</p>\n</blockquote>\n<ul>\n<li>通过 DI(dependency injection) 依赖注入，实现 IoC(Inverse of Control) 反转控制，将所有的 bean 注入 IoC 容器。</li>\n<li>ioc 等于 di</li>\n<li>IoC 的实现：将容器在装配 bean 时，先通过其构造器或工厂生产一个实例后，再根据其配置去构造 bean 的各个依赖。这与传统的实例生成方法相反，所以叫反转控制。</li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#application-startup-steps\">启动步骤</a></li>\n</ul>\n<h2 id=\"1-ioc\"><a href=\"#1-ioc\" class=\"headerlink\" title=\".1. ioc\"></a>.1. ioc</h2><h3 id=\"1-1-BeanFactory\"><a href=\"#1-1-BeanFactory\" class=\"headerlink\" title=\".1.1. BeanFactory\"></a>.1.1. BeanFactory</h3><p>最基础的 ioc 容器 BeanFactory 源码：</p>\n<p>Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:</p>\n<ol>\n<li>BeanNameAware’s {@code setBeanName}</li>\n<li>BeanClassLoaderAware’s {@code setBeanClassLoader}</li>\n<li>BeanFactoryAware’s {@code setBeanFactory}</li>\n<li>EnvironmentAware’s {@code setEnvironment}</li>\n<li>EmbeddedValueResolverAware’s {@code setEmbeddedValueResolver}</li>\n<li>ResourceLoaderAware’s {@code setResourceLoader}(only applicable when running in an application context)</li>\n<li>ApplicationEventPublisherAware’s {@code setApplicationEventPublisher}(only applicable when running in an application context)</li>\n<li>MessageSourceAware’s {@code setMessageSource}(only applicable when running in an application context)</li>\n<li>ApplicationContextAware’s {@code setApplicationContext}(only applicable when running in an application context)</li>\n<li>ServletContextAware’s {@code setServletContext}(only applicable when running in a web application context)</li>\n<li>{@code postProcessBeforeInitialization} methods of BeanPostProcessors</li>\n<li>InitializingBean’s {@code afterPropertiesSet}</li>\n<li>a custom init-method definition {@code postProcessAfterInitialization} methods of BeanPostProcessors</li>\n</ol>\n<p>On shutdown of a bean factory, the following lifecycle methods apply:</p>\n<ol>\n<li>{@code postProcessBeforeDestruction} methods of DestructionAwareBeanPostProcessors</li>\n<li>DisposableBean’s {@code destroy}</li>\n<li>a custom destroy-method definition</li>\n</ol>\n<h3 id=\"1-2-ApplicationContext\"><a href=\"#1-2-ApplicationContext\" class=\"headerlink\" title=\".1.2. ApplicationContext\"></a>.1.2. ApplicationContext</h3><h2 id=\"2-Core-模块\"><a href=\"#2-Core-模块\" class=\"headerlink\" title=\".2. Core 模块\"></a>.2. Core 模块</h2><ul>\n<li>bean 标签：<ul>\n<li>id 属性指定这个实例的唯一标识；</li>\n<li>class 属性，用来指定这个实例的类定义；</li>\n<li>property 子元素，指定这个对象的属性，比如：user 对象中有属性 name ，那么这个这个 user 的 bean 对象就应该有一个子元素标签 property ，同时如果这个属性是另外一个本地的 bean ， name 属性指向这个属性：<code>&lt;property name=&quot;advice&quot; id=&quot;beanId&quot;&gt;</code> 直接使用 id 属性来引用到其他的 bean 的 id 就行；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-AOP-模块\"><a href=\"#3-AOP-模块\" class=\"headerlink\" title=\".3. AOP 模块\"></a>.3. AOP 模块</h2><blockquote>\n<p>Aspect Oriented Programming , 面向切面编程</p>\n</blockquote>\n<ul>\n<li><p>切面 Aspect :可以理解为模块，比如，读写数据库、权限检查、异常情况记录；</p>\n</li>\n<li><p>Advice ，增强：拦截器实现增强接口 Advisor ，不同的拦截器实现不同的增强接口，比如：方法前拦截器</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MethodBeforeInterceptor implements MethodBeforeAdvice&#123;</span><br><span class=\"line\">    <span class=\"comment\">//方法前拦截器</span></span><br><span class=\"line\">    <span class=\"comment\">//调用对象的方法前将执行该方法。参数分别为被调用的方法、参数、对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">(Method method, Object[] args, Object instance)</span> <span class=\"keyword\">throws</span> Throwable</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;即将要执行的方法：&quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"comment\">//如果是 Service</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance <span class=\"keyword\">instanceof</span> WaiterServiceImpl)</span><br><span class=\"line\">            String name = ((AopServiceImpl) instance).getName();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(name == <span class=\"keyword\">null</span>)<span class=\"comment\">//检查是否为空</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;name 属性不能为 null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        method.invoke(instance,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>拦截器，interceptor，也是 pointcut 的核心:</p>\n<ul>\n<li><p>spring拦截器的配置实现，通过增加配置：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;aopMethodBeforeInterceptor&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.aop.supoort.NameMatchMethodPointcutAdvisor&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;advice&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.aopdemo.advice.MethodBeforeInterceptor&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mappedName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;withAop&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从上面的代码可以看出：</p>\n<ul>\n<li><p>spring实现拦截器都是通过增强器Advisor，而这个增强器是一个代理，将参数（自定义的Advice）作为参数传入其中；</p>\n</li>\n<li><p>同时mappedName属性用来指定拦截的方法，这个方法并不是增加类中的方法，而是到时要执行到的所有的匹配方法名字段的方法；</p>\n</li>\n<li><p>同时：spring支持由正则表达式配置切入点：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;patterns&quot;</span>&gt;</span>      <span class=\"comment\">&lt;!-- 正则表达式配置切入点--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>.*get.*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span> <span class=\"comment\">&lt;!--包含get字段的方法就被拦截&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;value&gt;.*absquatulate&lt;/value&gt;  &lt;!--包含absquatutulat字段的方法被拦截&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;/list&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-ORM-模块\"><a href=\"#4-ORM-模块\" class=\"headerlink\" title=\".4. ORM 模块\"></a>.4. ORM 模块</h2><blockquote>\n<p>Object RelativeDatabase Mapping,对象关系型数据库映射</p>\n</blockquote>\n<ul>\n<li>简介：<ul>\n<li>此模块对 Hibernate/JDO/TopLink、iBatis 等 ORM 框架提供支持；</li>\n<li>Spring 提供在 DAO 层提供 HibernateDaoSupport 类与 JDBCTemplate 类；</li>\n<li>在 Spring 里，Hibernate 与 SessionFactory 等只是 Spring 一个特殊的 Bean ，由 spring 负责实例化与销毁；所以也就不需要与 Hibernate 的 API 打交道，不需要开启关闭 Hibernate 的 Session/Transaction ， Spring 自动维护这些对象；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1-实体类\"><a href=\"#4-1-实体类\" class=\"headerlink\" title=\".4.1. 实体类\"></a>.4.1. 实体类</h3><p>这儿用User类举例：</p>\n<ul>\n<li><p>使用注解来让User中属性与数据库中表的列相关联；</p>\n</li>\n<li><p>Entity类的注解：</p>\n<ul>\n<li>@Entity，表明这个类为实体类；</li>\n<li>@Table（name=”users”),指明此实体类与数据库users表相关联；</li>\n<li>属性的注解：<ul>\n<li>@Id，主键注解，表明这属性为数据库表中的主键</li>\n<li>@GeneratedValue（strategy=GenerationType.IDENTITY),指明该主键生成策略为自增</li>\n<li>@Temporal（value = TemporalType.Date),表明列属性为Date</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DAO层接口，不同的Entity对应不同的DAO接口：</p>\n<ul>\n<li><p>UserDao接口，就定义对User表的操作：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveUser</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">findUsers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span> <span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">findUserByName</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>UserDao接口的实现类，UserDaoImpl：</p>\n<ul>\n<li>这个实现类要继承HibernateDaoSupport类，这就意味着从父类继承了Hibernate与HibernateTimplate对象，该对象就对实体对象进行各类操作；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实现接口中的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveUser</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.getHibernateTemplate().persist(user);<span class=\"comment\">//使用父类方法get到Template,并调用其persist方法将user存入</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span>&#123;   <span class=\"comment\">//查询记录条数</span></span><br><span class=\"line\">        Number num = (Number)<span class=\"keyword\">this</span>.getSession(<span class=\"keyword\">true</span>).createQuery(<span class=\"string\">&quot;select count (*) from User).uniqueResult();</span></span><br><span class=\"line\"><span class=\"string\">        return n.intValue();</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    public List&lt;User&gt; findUsers()&#123;  //查询所有的user</span></span><br><span class=\"line\"><span class=\"string\">        return this.getHibernateTemplate().find(&quot;</span>select * from User<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    public User findUserByName(String name)&#123;  //根据用户名查询用户</span></span><br><span class=\"line\"><span class=\"string\">        List&lt;User&gt; users = this.getHibernateTemplate().find&#123;&quot;</span>select * from User u where u.name=?<span class=\"string\">&quot;, name);  //使用Template</span></span><br><span class=\"line\"><span class=\"string\">        if(users.size() &gt; 0)</span></span><br><span class=\"line\"><span class=\"string\">            return users.get(0);返回第一条</span></span><br><span class=\"line\"><span class=\"string\">        return null;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>- **从上述代码例子中可以看出:**\n    - 查询(Read)、创建(Create)都由父类HibernateDaoSupport提供的getHibernateTemplate方法获取到实例并执行实例的方法来实现，其中查询使用实例方法find(String sql, Stirng 拼接String），而save则用持久化方法persist(Object user);\n    - 当要涉及到数据库计算时，则用getSession获取到与数据库的会话对象，让会话对象执行sql统计语句；\n    - 同时，所有sql语言的操作对象都指向实体类，而没有对数据库中的表进行组织sql语句；\n- **个人理解：**spring通过封装Hibernate在框架中，让DAO接口的实现类继承HibernateDaoSupport尖，就将Hibernate对象创建出来，而直接操作这个对象的方法来获取session/Hibernate对象直接与数据库交互，而就节省了操作JDBC的代码；\n</code></pre>\n<h4 id=\"4-1-1-配置集成Hibernate\"><a href=\"#4-1-1-配置集成Hibernate\" class=\"headerlink\" title=\".4.1.1. 配置集成Hibernate\"></a>.4.1.1. 配置集成Hibernate</h4><ul>\n<li>在spring的bean.xml文件中配置集成hibernate到目前这一步只需要**<em>配置三个bean**</em>：<ul>\n<li>数据源datasource，这是一切的基础，所有的操作最终都会落到对数据库的操作上；</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;datasource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.commonsdbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.gjt.mm.mysql.Driver&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc\\:mysql\\://localhost\\:3306/ssh&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">propery</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>- 数据源的配置就是用依赖包中的一个封装好的类（这儿就是BasicDataSource）的对象，并将这个对象的属性值配置好，这些属性就包括了数据库的驱动、连接的url、连接数据库的用户名、密码。可以想象的是，这个处理数据库的对象封装了所有的连接数据库的方法，使用密码与用户名，交给驱动对象，这个驱动对象就按照提供的url连接到主机上的数据库，并登录到数据库；</em><br>    - 有了数据源，就可以将关联连接库的数据源配置到sessionFactory中去：</p>\n<pre><code>    <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sessionFactory&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.orm.hibernate4.annotation.AnnotationSessionFactoryBean&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;destroy&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;annotatedClasses&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.woniuxy.orm.class_qulified_name<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">pros</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.dialect&quot;</span>&gt;</span></span><br><span class=\"line\">                org.hibernate.dialect.MySQLDialect</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pro</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>create<span class=\"tag\">&lt;/<span class=\"name\">pro</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">pros</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n    - *配置会话工厂（因为我们的实体类使用的注解映射，所以就使用注解会话工厂AnnotationSessionFatoryBean)其中包括了：数据源、实体类还有hibernate,而hibernate的配置就包括了方言、输出sql语句、格式化sql语句、创建表结构*\n- 有了会话工厂，距离操作数据库就只有让Dao配置为bean，而操作代码就getBean来获取到这个Dao的实例，让这个实例来操作数据库：\n        &lt;bean id=&quot;userDao&quot; class=&quot;daoImpl_qualified_name&quot;&gt;\n            &lt;property name=&quot;sessionfactory&quot; ref=&quot;sessionFactory&quot; /&gt;\n        &lt;/bean&gt;\n    - *在Dao的bean中，将前面配置好的sessionFactory装配到其中*\n- 以上情况是实体类User是使用注解来配置的，这种情况下，使用的sessionFactory是AnnotationSessionFactoryBean,但当实体类是使用xml文件来配置时，使用的配置bean应该是LocalSessionFactoryBean。同时，sessionFactory中配置实体的方式也变成：\n        &lt;property name=&quot;mappingDirectoryLocations&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;classpath:entiteis_配置文件的路径&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n</code></pre>\n<hr>\n<h3 id=\"4-2-Hibernate的事务管理\"><a href=\"#4-2-Hibernate的事务管理\" class=\"headerlink\" title=\".4.2. Hibernate的事务管理\"></a>.4.2. Hibernate的事务管理</h3><ul>\n<li><strong>分层的做法：应用层调用Service层，Service层对数据进行检查（是否重复之类），然后Service层（注入一个Dao属性）调用Dao层，Dao层调用Hibernate实现数据的操作。原则上不允许跨层访问，业务层次分明。</strong></li>\n<li>事务管理transaction，对应的层为Service层；</li>\n</ul>\n<h3 id=\"4-3-spring的bean-xml配置文件的理解\"><a href=\"#4-3-spring的bean-xml配置文件的理解\" class=\"headerlink\" title=\".4.3. spring的bean.xml配置文件的理解\"></a>.4.3. spring的bean.xml配置文件的理解</h3><ul>\n<li>所有的操作都基于对数据库的crud，所以所有的配置都围绕着操作数据库；</li>\n<li>所以，第一个bean的是数据源：dataSource<ul>\n<li>其中的属性就包括：<ul>\n<li>连接数据库的驱动：driverClassName</li>\n<li>数据库连接url:url</li>\n<li>数据库连接用户名：username</li>\n<li>数据库连接密码：password</li>\n</ul>\n</li>\n<li>通常情况下，我们把数据源信息都单独分离在jdbc.properties文件中，并在要用到的配置文件中将其配置为上下文<code>&lt;context:property-placeholder&gt; location=&quot;classpath:jdbc.properties/&gt;</code>，之后就可以在数据源dataSource中配置其中的属性：<code>&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driver&#125;&quot;&gt;&lt;/property&gt;</code></li>\n</ul>\n</li>\n<li>第二个配置的bean：sessionFactory<ul>\n<li>这儿就把上一次配置好的dataSource数据源装配到sessionFactory的属性中：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置本地会话工厂bean --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sessionFactory&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置数据源 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定hibernate配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;configLocations&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:hibernate.cfg.xml&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定hibernate映射文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mappingDirectoryLocations&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:mappings/*.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Note:<em>这儿配置spring的sessionFactory属性就会把 Hibernate sessionFactory属性覆盖；</em></li>\n<li>configLocations属性：<em>将指定路径的配置文件都加载进去，相应的LocalSessionFactoryBean中的的此属性的setter方法的参数为可变参数:</em></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setConfigLocations</span><span class=\"params\">(Resource... configLocations)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.configLocations = configLocations;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>而在上述代码中，hibernate的配置文件也直接引入到sessionFatory中来，而在外部的hibernate配置文件：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 配置方言 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5InnoDBDialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- session上下文控制权:交给session来控制 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.current_session_context_class&quot;</span>&gt;</span>org.springframework.orm.hibernate5.SpringSessionContext<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 格式化sql语句 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;format_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 显示sql语句 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;show_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 表的生成策略 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hbm2ddl.auto&quot;</span>&gt;</span>update<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中配置了部分的Hibernate属性，同时也可以配置c3p0的属性在其中；</li>\n<li>第三个配置：事务管理器transactionManager<ul>\n<li>将前面配置好的sessionFactory装配到这个bean中，作为sessionFactory属性值；</li>\n</ul>\n</li>\n<li>第四个配置：tx:advice，配置事务的传播特性，指定具备事务的方法名；</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 事务配置增强 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;txMng&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;save*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;update*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;delete*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;batch*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;get*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;load*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;find*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 统配 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;*&quot;</span> <span class=\"attr\">isolation</span>=<span class=\"string\">&quot;DEFAULT&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>- 最后一行统配就指定了所有的方法都配置上事务，同时 isolation 指此事务的隔离级别，propagation 指事务的传播属性，read-only 指是否为只读；\n</code></pre>\n<ul>\n<li>第五个配置aop:config，配置事务的切入点，以及被管理的对象</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;interceptorPointCuts&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;execution(* com.woniuxy.sshdemo.service.impl.*(..))&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">&quot;interceptorPointCuts&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>- 先将切面的切点配置进来，也就是各个service的执行对象。再将这此切点配置到advisor中\n</code></pre>\n<ul>\n<li>其它的配置：<ul>\n<li>dao的执行类，配置一个id加上sessionFactory;</li>\n<li>service的执行类,配置上dao这个属性的对象；</li>\n</ul>\n</li>\n<li><strong>使用注解来实现事务的配置</strong><ul>\n<li>这时bean.xml：<ul>\n<li>数据源不变</li>\n<li>sessionFactory不变；</li>\n<li>事务管理器trasactionManager依然不变；</li>\n<li>变的是：添加一个事务注解驱动<code>tx:annotation-driven trasaction-manager=&quot;transactionManager&quot;/&gt;</code>，添加这个驱动配置后，对产生事务的类添加注解<code>@Transactional</code>，标记这个类为事务类，对其中的事务方法添加注解<code>@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)</code>注解（标明了这个方法的隔离水平与传播水平）。这样的注解就取代了上面例子中tx:advice与aop:config两个配置节点的功能；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-source-codes\"><a href=\"#5-source-codes\" class=\"headerlink\" title=\".5. source codes\"></a>.5. source codes</h2><p>源码</p>\n<ul>\n<li><code>@Configuration</code> 用以配置 spring 组件的注解，其文档有详细说明大部分的注解使用。</li>\n<li>使用 <code>@ContextConfiguration(locations=&#123;classpath*:xxx&#125;)</code> 时， <code>classpath*:</code> 表示可以从 jar 包里拿配置文件</li>\n</ul>\n<h2 id=\"6-rap-在项目开发中的使用\"><a href=\"#6-rap-在项目开发中的使用\" class=\"headerlink\" title=\".6. rap 在项目开发中的使用\"></a>.6. rap 在项目开发中的使用</h2><blockquote>\n<p>date: “2017-12-05 19:08”</p>\n</blockquote>\n<p>使用 rap 来定义接口数据，这样方便前端开发人员与我们后端开发在各个接口请求上一致，更方便开发。</p>\n<h3 id=\"6-1-问题\"><a href=\"#6-1-问题\" class=\"headerlink\" title=\".6.1. 问题\"></a>.6.1. 问题</h3><ul>\n<li>mock 的使用中： <code>@mock=true</code> 在各个参数后面表示默认的数据格式样式吗？<ul>\n<li>时间类型/枚举类型等其他的数据选择什么类型？string？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-properties-in-springmvc\"><a href=\"#7-properties-in-springmvc\" class=\"headerlink\" title=\".7. properties in springmvc\"></a>.7. properties in springmvc</h2><blockquote>\n<p>date: “2018-12-03 15:05” <a href=\"https://www.baeldung.com/properties-with-spring\">参考文档</a></p>\n</blockquote>\n<ul>\n<li>在 xml 文件中引入 properties ： <code>&lt;context:property-placeholder location=&quot;classpath:foo.properties&quot; /&gt;</code></li>\n<li>在配置 bean java 文件中可以使用注解将其配置：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:foo.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertiesWithJavaConfig</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>- 另外一个更有用的注解方法：\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PropertySource(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">  &quot;classpath:persistence-$&#123;envTarget:mysql&#125;.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<p>  <strong>note</strong>:<br>    - <a href=\"http://www.cnblogs.com/jycboy/p/7349139.html\">参考</a><br>    - classpath 是指被编译过后的 src 中所有的文件（包括：java、xml、properties）都放在的 WEB-INFO/classes 的文件夹。<br>    - <code>**/</code> 表示 任意目录。<code>**/mysql*.properties</code> 就表示任意目录下的以 <code>mysql</code> 开关的 properties 文件</p>\n<ul>\n<li><p>在 java 配置文件中插入一个 property 值使用标签 <code>@Value</code> ： <code>@Value(&quot;$&#123;jdbc.url:defaultUrl&#125;&quot;)</code> ， <code>:</code> 后面跟的是默认值。</p>\n</li>\n<li><p>在 xml 配置文件中插入一个 property 值</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;dataSource&quot;&gt;\n  &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n</ul>"},{"title":"SpringMVC","layout":"post","date":"2017-08-20T05:29:17.000Z","_content":"\n> SpringMVC 同样是一种 MVC 架构，它与传统 MVC 框架的不同之处在于使用了中央调度器，用中央调度器 DispatcherServlet 来分发所有的请求与响应，中央调度器的存在就大大降低了其他组件之间的耦合度。这种分发请求与响应的实现得益于 spring 的装配。\n\n<!--more-->\n\n- **中央处理器的配置**：在web.xml中配置 springmvc 的 servlet\n\n```xml\n<servlet>\n  \t<servlet-name>springmvc</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  \t<init-param>\n  \t\t<param-name>contextConfigLocation</param-name>\n  \t\t<param-value>classpath:springmvc.xml</param-value>\n  \t</init-param>\n  \t<load-on-startup>0</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>springmvc</servlet-name>\n  \t<url-pattern>*.do</url-pattern>\n  </servlet-mapping>\n```\n\n- 中央处理器 DispatcherServlet 在web.xml中被配置成一个 servlet ,并通过初始化上下文配置参数 springmvc.xml 的路径与设置其启动时机与该servlet初始化时机；\n\t1. 其中 load-on-startup 这个属性来指定这个中央处理器被初始化的时机：\n\t\t1. 当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些；\n\t\t2. 当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序；\n\n## .1. 核心对象\n\n> 各个核心对象都有默认值，也就是说如果没有手动配置这些， springmvc 会按默认配置进行构建窗口。默认配置文件：spring-webmvc 包中 org.springframework.web.servlet 中的 DispatcherServlet.properties 。\n\n1. **中央分发控制器**（在springMVC框架中，它是核心的核心，所有的分发都由它处理，所以也叫 **中央处理器** ），处理请求并给出响应（下面的三个关键组件就是装配在 springmvc 中的，但中央处理器是装配在 web.xml 中作为一个 servlet 的）\n\n   ```xml\n\t<servlet>\n\t\t<servlet-name>springmvc</servlet-name>\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t\t<init-param>\n\t\t\t<param-name>contextConfigLocation</param-name>\n\t\t\t<param-value>classpath:springmvc.xml</param-value>\n\t\t</init-param>\n\t\t<load-on-startup>0</load-on-startup>\n\t</servlet>\n\t<servlet-mapping>\n\t\t<servlet-name>springmvc</servlet-name>\n\t\t<url-pattern>/</url-pattern>\n\t</servlet-mapping>\n  \t```\n\n\t1. [替代方案 WebApplicationInitializer](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html)\n\n2. **处理器映射器** HandlerMapping ：设置 handler 处理器与 url 资源的映射\n\t1. 使用 BeanNameUrlHandlerMapping 这个类时，就会将 handler 的 name 属性值作为 url 映射，访问这个处理器就填写其 name 属性值:`<bean id=\"login\" name=\"loginController.do\" class=\"com.kang.springdemo.controller.LoginController\"/>` 如上，就可能过name属性值，设置 `<a href=\"loginController.do>登录</a>`\n\t2. SimpleUrlHandlerMapping 这个类型的映射要求映射 url 与 controller 的配置 id 相对应，并在这个节点内将 controller 的 id 与相关的 key 对应起来；\n\n\t\t```xml\n\t\t<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n\t\t\t<property name=\"mappings\">\n\t\t\t\t<props>\n\t\t\t\t<!--配置指定的url与bean的id映射,可添加多个-->\n\t\t\t\t\t<prop key=\"/login.do\">login</prop>\n\t\t\t\t\t<prop key=\"/login2.do\">login2</prop>\n\t\t\t\t</props>\n\t\t\t</property>\n\t\t</bean>\n\t\t<bean id=\"login\" name=\"loginController.do\" class=\"com.kang.springdemo.controller.LoginController\"/>\n\t\t<bean id=\"login2\" name=\"loginController2.do\" class=\"com.kang.springdemo.controller.LoginController2\"/>\n  \t\t```\n\n\t3. 使用注解实现处理器与 url 的映射 `<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>`\n\t\t1. 这个配置节点就决定了处理器与其中的方法可以被注解 `@RequestMapping(\"url_name\")` 映射并指定 url\n3. **处理器适配器** HandlerAdapter，用于规定处理器的编写规则\n\t1. 使用接口来配置适配器：\n\t\t1. 当指定为 SimpleControllerHandlerAdapter 时，它就规定了要想成为处理器，就要实现 Controller 这个接口；\n\t\t2. HttpRequestHandlerAdapter 这个适配器要求所有的 Handler 都必须实现 HttpRequestAdapter 接口；\n\t2. 使用注解实现配置适配器（这个配置节点就决定了，有 `@Controller` 注解的类就是处理器）：\n\n  \t\t```xml\n\t\t\t<!-- 注解适配器 -->\n\t\t\t<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\n\n  \t\t```\n\n4. **视图解析器** 用来解析处理器处理后的逻辑视图，比如：加上前缀后缀，指定到特定的视图。\n\n\t```xml\n\t\t<!-- 配置视图解析器 -->\n\t\t<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t\t<!-- 前缀 -->\n\t\t\t<property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n\t\t\t<!-- 后缀 -->\n\t\t\t<property name=\"suffix\" value=\".jsp\"/>\n\t\t</bean>\n  \t```\n\n- 如果 springMVC 没有配置视图解析器，如果 接口返回的 字符串（如： \"hello\"）给的是相对路径（‘jsp’），那么 spring 会把当前路径给配上去（如果 当前的 controller 的 uri 是 “/v1/say” ，那么这时返回的视图 uri 就是 \"/v1/say/hello\"），这个时候返回的视图就会在 当前的 controller 中去找 hello 方法接口，产生问题。如果返回的字符串是绝对路径（如： \"/WEB-INF/jsp/hello.jsp\"），那么spring 就会在服务器的此绝对路径里去找这个 jsp 文件并返回给客户端。\n- **Small Notes:**\n\t1. 在 SpringMVC 中这四个核心的对象就已经可以将整个架构支撑起来了，整个**SpringMVC架构流程**：\n\t\t1. 中央分发器收到来自客户端的请求时，先将请求分发给处理器映射器，由控制器映射器决定了请求的**处理器**是谁（按面向对象编程思想，这儿一定是生成了映射的处理器对象，同时也**生成拦截器**之类的组件）；\n\t\t2. 同时分发器分发请求给处理器适配器，**适配器对相关的处理器进行适配扩展，并调用处理器对请求进行处理，** 处理结果就包括了逻辑视图与其他的响应结果（比如：存放在ModelAndView中），适配器再将这些处理结果返回给中央分发器；\n\t\t3. 中央分发器将结果分发给**视图解析器**，视图解析器对逻辑视图进行解析（比如：加上前缀后缀），视图解析器再解析之后的具体的view返回给中央分发器；\n\t\t4. 中央分发器收到view后对其进行**渲染**（将数据结果填充至视图中），再把最终结果响应出去；\n\n- 整个SpringMVC流程如上，我们常常使用时并不会完全按照上面四个核心对象进行配置，相对来说有更便利的方法来配置这四个核心对象:\n    - **组件扫描器：**自动扫描 `@Controller` 标记的控制器，这样省去将各个配置器配置在bean中：\n\t\t<!-- 扫描器组件，将指定包中的带有特定注解的类全都扫描进容器可用的controller中 -->\n\t\t<context:component-scan base-package=\"com.kang.springdemo.controller,\n\t\t                                      com.kang.springdemo.service\">\n\t\t\t<!-- 指定注解过滤器 -->\n\t\t\t<context:include-filter type=\"annotation\"\n\t\t\texpression=\"org.springframework.stereotype.Controller\"/>\n\t\t</context:component-scan>\n    - **注解映射器：**注解式映射器配置可以直接将使用过注解`@RequestMapping`的方法进行映射，而直接在处理器中寻到相关的处理方法； `<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>`\n    - **注解处理器适配器：**注解式处理器适配器，配置此甜酸器直接对标记`@RequestMapping`的方法进行适配： `<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>`\n    - **SpringMVC中的注解驱动配置：**注解驱动综合了前两个注解式的适配器与映射器，因此配置此驱动即可省略适配器与映射器的配置：`<mvc:annotation-driven/>`\n\n- **Tips:**\n    - *在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象；*\n\n### .1.1. springMVC 中的处理器\n\n在 DispatcherServlet 中， spring 规约的处理器 bean [reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet-special-bean-types)\n\n1. 通过上一步实现来自前端请求必须都通过 web.xml 文件中指定的 servlet 处理，也就是大部分请求都是交给了 springmvc，所有的 springmvc 的配置都在 springmvc.xml 文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。\n2. springmvc.xml 配置中就指定了适配器映射，使用 `@Controller` 注解就让该类成为处理器\n3. `@RequestMapping(\"url_name\")` 则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url;\n4. 注解使用时映射的方法中，可以与前端数据相通的**参数**有：\n\t1. 简单数据类型\n\t2. pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password\n\t3. session/request/response：用法与之前一致，可以用分发请求也可以重定向；\n\t4. Model/ModelAndView：\n\t5. 也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中；\n\t6. 注解`@RequestParam`的使用：\n\t\t1. 其中有参数：\n\t\t\t1. name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法；\n\t\t\t2. required：boolean 类型，当其值为 true 时，请求必须带有这个参数；\n\n5. 使用 controller 处理器时，各类方法 **返回数据类型**：\n\t1. ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图）\n\t2. String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串\"response:+方法映射\"；\n\t3. **void**:在controller形参上定义request与response来指定响应结果：\n\t\t1. \"forward:+方法映射\"，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到；\n\t\t2. 也可以直接使用`response`重定向到指定页面：`response.sendRedirect(String url);`\n\t\t3. 使用`response`指定响应结果：\n\t\t\t1. 响应jason数据：`response.setCharacterEncoding(\"utf-8\");`\n\t\t\t2. `response.getWriter().write(String \"jason格式的字符串\");`\n\n## .2. 使用代码代替 xml 配置文件\n\n参照 spring mvc doc： org.springframework.web.WebApplicationInitializer。\n\n### .2.1. LocalResolver 区域解析器\n\n在 springmvc 中配置这个解析器，用于国际化。其中解析器常用的有：\n\n- cookie ，根据 CookieLocaleResolver 来选择区域；\n    - 这个区域解析器所采用的Cookie可以通过cookieName和cookieMaxAge属性进行定制。cookieMaxAge属性表示这个Cookie应该持续多少秒，-1表示这个Cookie在浏览器关闭之后就失效。\n- SessionLocaleResolver\n    - 它通过检验用户会话中预置的属性来解析区域。如果该会话属性不存在，它会根据accept-language HTTP头部确定默认区域。\n\n### .2.2. 多部件解析器 MultipartResolver\n\n用于文件上传，需要引入包：commons-fileupload 与 commons-io\n\n### .2.3. json 数据交互\n\n> 在前后端分离的项目中，特别是存在为移动端提供的接口都应该使用 json 数据的格式对前端提供接口。\n\n渲染 view 是 mappingJackson2JsonView\n\n- 实际使用的是 `MappingJackson2HttpMessageConverter`\n- 添加在 DispatcherServlet 的适配器中的 messageConverters 中：\n\n  ```xml\n  <property name=\"messageConverters\">\n    <list>\n      <bean class=\"org.springframework.http.converter.xml.MappingJackson2HttpMessageConverter\" />\n    </list>\n  </property>\n  ```\n\n需要使用的依赖包：\n\n1. jackson-core\n2. jackson-annotations\n3. jackson-databind\n\n使用两个注解：\n\n- @RequestBody\n    - 用于将请求的字符串使用 converter 转换成 json/xml 等格式并绑定到 controller 参数上去\n- @ResponseBody\n    - 用于将 controller 返回的结果 使用 converter 转换成 json/xml 格式直接 response 给浏览器\n\n### .2.4. JsonConvert2HttpMessage\n\n在 spring mvc 中将请求与响应数据转换成 Http 所需要的对象需要使用到序列化与反序列化。其中使用时 mvc 中的配置 configureMessageConverters 方法。在使用时有一个问题，当使用 Jackson2ObjectMapperBuilder 来build 一个 JsonMapper 时，其本身会在 class path 中去寻找所需要的 Module ，并将项目中存在的  module 注册到 builder 中默认的 objectMapper 中。如果此时再手动在 builder 上注册  module 会出现重复的 module 如 JavaTimeModule objectMapper 默认 feature (MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS) 会忽略掉重复的 module 注册，因此手动在 builder 注册的重复 module 会失效，包括手动添加的 module 的各种属性。比如，指定 java8.javaTimeModule 中的 LocalDateTime 反序列化/序列化格式为 \"YYYY-MM-dd HH:mm:ss\"(其默认为 \"YYYY-MM-ddTHH:mm:ss\")，将会无效。\n\n- 解决办法：直接在 builder 中手动注册 LocalDateTime 序列化与反序列化器格式，而不在 builder 中注册相应的 module。这样处理的结果是，builder 默认会注册 JavaTimeModule 到其 ObjectMapper ，但也会注册一个 SimpleModule 到 ObjectMapper ，同时 simple 的权限更高，在序列化时会优先使用 simpleModule。\n\n### .2.5. xml 数据交互\n\n使用的渲染 view 是 mappingJackson2XmlView\n\n- 实际使用的是 `MappingJackson2XmlHttpMessageConverter`\n- 添加在 DispatcherServlet 的适配器中的 messageConverters 中：\n\n  ```xml\n  <property name=\"messageConverters\">\n    <list>\n      <bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\" />\n    </list>\n  </property>\n  ```\n\n需要的依赖包：\n\n1. jackson-annotations\n2. jackson-dataformat-xml\n\n使用：\n 同样使用两个标签 `@RequestBody` `@ResponseBody` 并联合使用 `@RequestMapping(produces={}, consumes={})` 来确定请求与返回数据的格式。\n\n### .2.6. 数据校验\n\nspringmvc 中可以直接使用 Hibernate 的一个校验框架：hibernate-validator。基于注解实现数据的校验。\n\n### .2.7. Restful 架构\n\n- 只是一种规范，终极的目标是资源 URI\n\n## .3. configuration based on java codes\n\n使用 java 代码配置 mvc [reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config)\n\n### .3.1. ant style\n\n关于 spring 中写 ant style 路径规则参照此类 doc: `org.springframework.util.AntPathMatcher`\n\n### .3.2. RequestMapping\n\n- 可使用正则表达式来匹配 url 参数\n- pattern 匹配比较，越具体的 url 越匹配。\n- Consumable/Producible Media Types 请求消费/生产数据类型匹配，`MediaType` 中有基本的类型。可使用 非 `!` 运行符\n- Parameters,headers\n    - 窄化请求路径：指定参数是否存在 `param` `!param`，指定具体参数类型： `param=myValue`\n    - headers 相同窄化：\n\n\t```java\n\t@GetMapping(path = \"/pets\", headers = \"myHeader=myValue\")\n\tpublic void findPet(@PathVariable String petId) {\n\t\t// ...\n\t}\n\t```\n\n- HTTP HEAD,OPTIONS 请求，自动转换请求到 GET 上，也可配置多个请求方式在同一个 URL 上\n- 所有 handler 请求响应的方法都会映射成一个 RequestMappingInfo ，其中包括了所有的 headers/consumes/produces, etc.，再将所有的方法注册到 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#registerMapping 中（容器 HashMap）。此 Mapping 实现 InitializeBean 会自动在 Spring 中实现并在其 afterPropertiesSet 方法中进行注册 handler method 方法。\n- @ResponseStatus 可以给特定方法 controller 指定其响应状态码\n- @ExceptionHandler 注解在 @ControllerAdvice 中异常处理，其 doc 说明了很多问题。\n\n#### .3.2.1. URI Pattern\n\nURI 路径样式与通配符\n\n- `?` 一个字符\n- `*` 匹配任意个字符在同一个 uri 片段中： `/resources/*/versions` 不匹配 `/resources/a/b/versions`\n- `**` 匹配任意个 uri 片段，但只能出现在 末尾： `/resource/**/version` 是非法的\n- `{name}` 匹配一个路径片段 （path segment）并将其捕获为名为 `name` 的变量\n- `{name:[a-z]+}` 匹配一个符合正则表达式 `[a-z]+` 的路径片段，并将其捕获为 `name` 变量\n- `{*path}` 匹配任意个路径片段并捕获其为 `path` 变量\n    - 使用捕获的变量使用 `@PathVariable` 注解在 handler 参数中即可。\n\n#### .3.2.2. 自定义注解\n\n_Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclass RequestMappingHandlerMapping and overriding the getCustomMethodCondition method, where you can check the custom attribute and return your own RequestCondition._\n\n#### .3.2.3. Explicit Registrations\n\n显式注册 RequestMapping\n\n除使用注解进行注册外，可以直接使用代码实现更灵活的 RequestMapping 注册。\n\n```java\n@AutoWired\npublic void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler)\n\t\tthrows NoSuchMethodException {\n\tRequestMappingInfo info = RequestMappingInfo\n\t\t\t.paths(\"/user/{id}\").methods(RequestMethod.GET).build();\n\tMethod method = UserHandler.class.getMethod(\"getUser\", Long.class);\n\tmapping.registerMapping(info, handler, method);\n}\n```\n\n将 handler 中的方法与 `/user/{id}` 映射关联上。\n\n## .4. Functional Endpoints\n\n函数式 mvc 编程，与 jdk8 很好地整合。可以直接使用流式编码将请求与响应数据装配好，诸如：header/body[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#webmvc-fn)\n\n## .5. Annotated Controllers\n\nSpring MVC 提供的注解式 Controller。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller)\n\n### .5.1. DataBidder\n\n使用 `@DataBidder` 给 Controller 添加数据绑定。\n\n### .5.2. Exceptions\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-exceptionhandlers)\n\nspring MVC 中的异常。\n\nSpring MVC中的异常处理器 HandlerExceptionResolver 的实现：\n\n1. SimpleMappingExceptionResolver 可指定异常类名与错误页面的映射，用于浏览器应用\n2. DefaultHandlerExceptionResolver 通过 Spring MVC 处理异常，并将异常与状态码映射。`ResponseEntityExceptionHandler` and REST API exceptions\n3. ResponseStatusExceptionResolver 通过注解 `@ResponseStatus` 处理异常。根据注解值映射其到相应 HTTP 状态码\n4. ExceptionHandlerExceptionResolver 通过调用 Controller 或 ControllerAdvice 中的 `@ExceptionHandler` 方法处理异常。\n\n#### .5.2.1. 异常处理器链 Chain of Exceptions\n\n1. 形成异常处理器链直接 declare 多个异常处理器 bean 即可，指定其 `order` 值，越高的 order 值，执行处理得越晚。\n2. 异常处理器返回数据规约：\n    1. 使用 ModelAndView 指定错误页面\n    2. 如果处理器已经将异常处理，返回一个空的 ModelAndView\n    3. 如果处理器未处理，后面的处理器继续，如果最后异常一直未被处理，抛给 Servlet 容器。\n        1. 当所有异常处理器未将异常处理，异常传递到 Servlet 容器或指定了一个错误状态码（4xx,5xx），servlet container 可以渲染一个默认的错误 HTML 页面，在 web.xml 中配置（servlet API 不提供 java 形式的方式创建 error page mapping，只能以此种形式创建\t）：\n\n\t\t ```xml\n\t\t <error-page>\n\t\t\t<location>/error</location>\n\n\t\t</error-page>\n\t\t```\n\n        2. servlet container 同时会作一个 ERROR 分发到配置的 URL ，于是就交给了 DispatcherServlet，如果有 Controller 对此 URL 处理，将映射到此 Controller 进行处理。剩下的就交给 Controller ，可能指定一个 model ，也可能响应一个 JSON。\n\n3. Spring MVC 自动注册内置的异常处理器处理的异常包括：Spring MVC 异常、`@ResponseStatus` 注解的异常、`@ExceptionHandler` 注解的方法处理。可自定义异常处理器列表替换内置的处理器。\n\n## .6. Asynchronous Requests\n\n> 异步请求\n\n### .6.1. Processing\n\n> 异步请求的处理\n\n1. ServletRequest 可以通过 `request.startAsync()` 切换入异步模式。异步模式开启，主要的效果是 Servlet 与 Filter 可退出，同时 response 保持打开至处理完成。\n2. `request.startAsync()` 方法返回 AsyncContext，可以使用此对象进行更细致地控制异步处理。\n3. 异步处理完成后，DispatcherServlet 将接收处理结果继续处理 response 。\n\n#### .6.1.1. Compared to WebFlux\n\n1. Spring WebFlux 不仅不需要构建在 Servlet API 之上，而且不需要异步 request ，因为其就是为异步请求而生。异步处理已设计在其框架之中，天生支持所有阶段的请求处理。\n\n### .6.2. Http Streaming\n\n> [流式响应 Http 请求](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming)\n\n#### .6.2.1. Objects\n\n1. 使用 ResponseBodyEmitter 让返回一个 value 可以生产对象流，每个对象都将被 HttpMessageConverter 序列化被写进 response 对象。\n2. 也可以将 ResponseBodyEmitter 写入一个 ResponseBody 中，实现自定义 header 与 status 。\n3. 当 Emitter 出现 I/O 异常，如：Client 离开。应用不需要清理连接，不需要调用 emitter.complete() / emitter.completeWithError()。Servlet Container 会自动初始化一个 AsyncListener 错误通知，Spring MVC 来完成 completeWithError 的调用。整个请求将执行一个最终的 Async 分发到应用，期间 Spring MVC 将使用配置异常处理器完成此次请求。\n\n#### .6.2.2. Raw Data\n\n> 有时需要直接返回不经过 message conversion 的生肉数据到响应输出流，比如：文件下载，这时可以使用 `StreamingResponseBody` 作为返回数据类型。\n\n### .6.3. Configuration\n\n> 异步请求的配置 [reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-configuration)\n\n异步请求属性必须在 servlet container 级别配置。\n\n1. 在servlet container 配置：1. Filter 和 Servlet 定义处需要将标识 asyncSupport 设置为 true。此外 Filter Mapping 需要定义为处理 DispatchType 为 `ASYNC`。\n   1. java 配置中，如果使用的是 `AbstractAnnotationConfigDispatcherServletInitializer` 初始化 Servlet Container ，以上配置是自动完成的。\n   2. web.xml 配置，you can add `<async-supported>true</async-supported>` to the DispatcherServlet and to Filter declarations and add `<dispatcher>ASYNC</dispatcher>` to filter mappings.\n2. Spring MVC 配置\n   1. Java 配置，在 WebMvcConfigurer 中使用 configureAsyncSupport 回调\n   2. XML namespace: Use the `<async-support>` element under `<mvc:annotation-driven>`\n   3. 此外还可以配置：\n      1. 异步请求的默认超时值，如果不配置将取决于 Servlet Container\n      2. AsyncTaskExecutor ，用以执行异步请求，响应类型 REACTIVE TYPE  streaming 流执行从 controller 方法返回的 callable 实例。默认此配置是 `SimpleAsyncTaskExecutor`。\n      3. `DeferredResultProcessingInterceptor` 实现与 `CallableProcessingInterceptor` 实现。\n      4. DeferredResult 与 ResponseBodyEmitter 可以单独设置其超时值，Callable 可以通过 `WebAsyncTask` 设置。\n","source":"_posts/Spring/springMVC.md","raw":"---\ntitle: SpringMVC\nlayout: post\ndate: 2017-08-20 13:29:17\ntags: [Java,Spring, SpringMVC]\ncategories: [Spring]\n---\n\n> SpringMVC 同样是一种 MVC 架构，它与传统 MVC 框架的不同之处在于使用了中央调度器，用中央调度器 DispatcherServlet 来分发所有的请求与响应，中央调度器的存在就大大降低了其他组件之间的耦合度。这种分发请求与响应的实现得益于 spring 的装配。\n\n<!--more-->\n\n- **中央处理器的配置**：在web.xml中配置 springmvc 的 servlet\n\n```xml\n<servlet>\n  \t<servlet-name>springmvc</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  \t<init-param>\n  \t\t<param-name>contextConfigLocation</param-name>\n  \t\t<param-value>classpath:springmvc.xml</param-value>\n  \t</init-param>\n  \t<load-on-startup>0</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>springmvc</servlet-name>\n  \t<url-pattern>*.do</url-pattern>\n  </servlet-mapping>\n```\n\n- 中央处理器 DispatcherServlet 在web.xml中被配置成一个 servlet ,并通过初始化上下文配置参数 springmvc.xml 的路径与设置其启动时机与该servlet初始化时机；\n\t1. 其中 load-on-startup 这个属性来指定这个中央处理器被初始化的时机：\n\t\t1. 当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些；\n\t\t2. 当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序；\n\n## .1. 核心对象\n\n> 各个核心对象都有默认值，也就是说如果没有手动配置这些， springmvc 会按默认配置进行构建窗口。默认配置文件：spring-webmvc 包中 org.springframework.web.servlet 中的 DispatcherServlet.properties 。\n\n1. **中央分发控制器**（在springMVC框架中，它是核心的核心，所有的分发都由它处理，所以也叫 **中央处理器** ），处理请求并给出响应（下面的三个关键组件就是装配在 springmvc 中的，但中央处理器是装配在 web.xml 中作为一个 servlet 的）\n\n   ```xml\n\t<servlet>\n\t\t<servlet-name>springmvc</servlet-name>\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t\t<init-param>\n\t\t\t<param-name>contextConfigLocation</param-name>\n\t\t\t<param-value>classpath:springmvc.xml</param-value>\n\t\t</init-param>\n\t\t<load-on-startup>0</load-on-startup>\n\t</servlet>\n\t<servlet-mapping>\n\t\t<servlet-name>springmvc</servlet-name>\n\t\t<url-pattern>/</url-pattern>\n\t</servlet-mapping>\n  \t```\n\n\t1. [替代方案 WebApplicationInitializer](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html)\n\n2. **处理器映射器** HandlerMapping ：设置 handler 处理器与 url 资源的映射\n\t1. 使用 BeanNameUrlHandlerMapping 这个类时，就会将 handler 的 name 属性值作为 url 映射，访问这个处理器就填写其 name 属性值:`<bean id=\"login\" name=\"loginController.do\" class=\"com.kang.springdemo.controller.LoginController\"/>` 如上，就可能过name属性值，设置 `<a href=\"loginController.do>登录</a>`\n\t2. SimpleUrlHandlerMapping 这个类型的映射要求映射 url 与 controller 的配置 id 相对应，并在这个节点内将 controller 的 id 与相关的 key 对应起来；\n\n\t\t```xml\n\t\t<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n\t\t\t<property name=\"mappings\">\n\t\t\t\t<props>\n\t\t\t\t<!--配置指定的url与bean的id映射,可添加多个-->\n\t\t\t\t\t<prop key=\"/login.do\">login</prop>\n\t\t\t\t\t<prop key=\"/login2.do\">login2</prop>\n\t\t\t\t</props>\n\t\t\t</property>\n\t\t</bean>\n\t\t<bean id=\"login\" name=\"loginController.do\" class=\"com.kang.springdemo.controller.LoginController\"/>\n\t\t<bean id=\"login2\" name=\"loginController2.do\" class=\"com.kang.springdemo.controller.LoginController2\"/>\n  \t\t```\n\n\t3. 使用注解实现处理器与 url 的映射 `<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>`\n\t\t1. 这个配置节点就决定了处理器与其中的方法可以被注解 `@RequestMapping(\"url_name\")` 映射并指定 url\n3. **处理器适配器** HandlerAdapter，用于规定处理器的编写规则\n\t1. 使用接口来配置适配器：\n\t\t1. 当指定为 SimpleControllerHandlerAdapter 时，它就规定了要想成为处理器，就要实现 Controller 这个接口；\n\t\t2. HttpRequestHandlerAdapter 这个适配器要求所有的 Handler 都必须实现 HttpRequestAdapter 接口；\n\t2. 使用注解实现配置适配器（这个配置节点就决定了，有 `@Controller` 注解的类就是处理器）：\n\n  \t\t```xml\n\t\t\t<!-- 注解适配器 -->\n\t\t\t<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\n\n  \t\t```\n\n4. **视图解析器** 用来解析处理器处理后的逻辑视图，比如：加上前缀后缀，指定到特定的视图。\n\n\t```xml\n\t\t<!-- 配置视图解析器 -->\n\t\t<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t\t<!-- 前缀 -->\n\t\t\t<property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n\t\t\t<!-- 后缀 -->\n\t\t\t<property name=\"suffix\" value=\".jsp\"/>\n\t\t</bean>\n  \t```\n\n- 如果 springMVC 没有配置视图解析器，如果 接口返回的 字符串（如： \"hello\"）给的是相对路径（‘jsp’），那么 spring 会把当前路径给配上去（如果 当前的 controller 的 uri 是 “/v1/say” ，那么这时返回的视图 uri 就是 \"/v1/say/hello\"），这个时候返回的视图就会在 当前的 controller 中去找 hello 方法接口，产生问题。如果返回的字符串是绝对路径（如： \"/WEB-INF/jsp/hello.jsp\"），那么spring 就会在服务器的此绝对路径里去找这个 jsp 文件并返回给客户端。\n- **Small Notes:**\n\t1. 在 SpringMVC 中这四个核心的对象就已经可以将整个架构支撑起来了，整个**SpringMVC架构流程**：\n\t\t1. 中央分发器收到来自客户端的请求时，先将请求分发给处理器映射器，由控制器映射器决定了请求的**处理器**是谁（按面向对象编程思想，这儿一定是生成了映射的处理器对象，同时也**生成拦截器**之类的组件）；\n\t\t2. 同时分发器分发请求给处理器适配器，**适配器对相关的处理器进行适配扩展，并调用处理器对请求进行处理，** 处理结果就包括了逻辑视图与其他的响应结果（比如：存放在ModelAndView中），适配器再将这些处理结果返回给中央分发器；\n\t\t3. 中央分发器将结果分发给**视图解析器**，视图解析器对逻辑视图进行解析（比如：加上前缀后缀），视图解析器再解析之后的具体的view返回给中央分发器；\n\t\t4. 中央分发器收到view后对其进行**渲染**（将数据结果填充至视图中），再把最终结果响应出去；\n\n- 整个SpringMVC流程如上，我们常常使用时并不会完全按照上面四个核心对象进行配置，相对来说有更便利的方法来配置这四个核心对象:\n    - **组件扫描器：**自动扫描 `@Controller` 标记的控制器，这样省去将各个配置器配置在bean中：\n\t\t<!-- 扫描器组件，将指定包中的带有特定注解的类全都扫描进容器可用的controller中 -->\n\t\t<context:component-scan base-package=\"com.kang.springdemo.controller,\n\t\t                                      com.kang.springdemo.service\">\n\t\t\t<!-- 指定注解过滤器 -->\n\t\t\t<context:include-filter type=\"annotation\"\n\t\t\texpression=\"org.springframework.stereotype.Controller\"/>\n\t\t</context:component-scan>\n    - **注解映射器：**注解式映射器配置可以直接将使用过注解`@RequestMapping`的方法进行映射，而直接在处理器中寻到相关的处理方法； `<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>`\n    - **注解处理器适配器：**注解式处理器适配器，配置此甜酸器直接对标记`@RequestMapping`的方法进行适配： `<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>`\n    - **SpringMVC中的注解驱动配置：**注解驱动综合了前两个注解式的适配器与映射器，因此配置此驱动即可省略适配器与映射器的配置：`<mvc:annotation-driven/>`\n\n- **Tips:**\n    - *在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象；*\n\n### .1.1. springMVC 中的处理器\n\n在 DispatcherServlet 中， spring 规约的处理器 bean [reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet-special-bean-types)\n\n1. 通过上一步实现来自前端请求必须都通过 web.xml 文件中指定的 servlet 处理，也就是大部分请求都是交给了 springmvc，所有的 springmvc 的配置都在 springmvc.xml 文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。\n2. springmvc.xml 配置中就指定了适配器映射，使用 `@Controller` 注解就让该类成为处理器\n3. `@RequestMapping(\"url_name\")` 则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url;\n4. 注解使用时映射的方法中，可以与前端数据相通的**参数**有：\n\t1. 简单数据类型\n\t2. pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password\n\t3. session/request/response：用法与之前一致，可以用分发请求也可以重定向；\n\t4. Model/ModelAndView：\n\t5. 也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中；\n\t6. 注解`@RequestParam`的使用：\n\t\t1. 其中有参数：\n\t\t\t1. name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法；\n\t\t\t2. required：boolean 类型，当其值为 true 时，请求必须带有这个参数；\n\n5. 使用 controller 处理器时，各类方法 **返回数据类型**：\n\t1. ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图）\n\t2. String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串\"response:+方法映射\"；\n\t3. **void**:在controller形参上定义request与response来指定响应结果：\n\t\t1. \"forward:+方法映射\"，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到；\n\t\t2. 也可以直接使用`response`重定向到指定页面：`response.sendRedirect(String url);`\n\t\t3. 使用`response`指定响应结果：\n\t\t\t1. 响应jason数据：`response.setCharacterEncoding(\"utf-8\");`\n\t\t\t2. `response.getWriter().write(String \"jason格式的字符串\");`\n\n## .2. 使用代码代替 xml 配置文件\n\n参照 spring mvc doc： org.springframework.web.WebApplicationInitializer。\n\n### .2.1. LocalResolver 区域解析器\n\n在 springmvc 中配置这个解析器，用于国际化。其中解析器常用的有：\n\n- cookie ，根据 CookieLocaleResolver 来选择区域；\n    - 这个区域解析器所采用的Cookie可以通过cookieName和cookieMaxAge属性进行定制。cookieMaxAge属性表示这个Cookie应该持续多少秒，-1表示这个Cookie在浏览器关闭之后就失效。\n- SessionLocaleResolver\n    - 它通过检验用户会话中预置的属性来解析区域。如果该会话属性不存在，它会根据accept-language HTTP头部确定默认区域。\n\n### .2.2. 多部件解析器 MultipartResolver\n\n用于文件上传，需要引入包：commons-fileupload 与 commons-io\n\n### .2.3. json 数据交互\n\n> 在前后端分离的项目中，特别是存在为移动端提供的接口都应该使用 json 数据的格式对前端提供接口。\n\n渲染 view 是 mappingJackson2JsonView\n\n- 实际使用的是 `MappingJackson2HttpMessageConverter`\n- 添加在 DispatcherServlet 的适配器中的 messageConverters 中：\n\n  ```xml\n  <property name=\"messageConverters\">\n    <list>\n      <bean class=\"org.springframework.http.converter.xml.MappingJackson2HttpMessageConverter\" />\n    </list>\n  </property>\n  ```\n\n需要使用的依赖包：\n\n1. jackson-core\n2. jackson-annotations\n3. jackson-databind\n\n使用两个注解：\n\n- @RequestBody\n    - 用于将请求的字符串使用 converter 转换成 json/xml 等格式并绑定到 controller 参数上去\n- @ResponseBody\n    - 用于将 controller 返回的结果 使用 converter 转换成 json/xml 格式直接 response 给浏览器\n\n### .2.4. JsonConvert2HttpMessage\n\n在 spring mvc 中将请求与响应数据转换成 Http 所需要的对象需要使用到序列化与反序列化。其中使用时 mvc 中的配置 configureMessageConverters 方法。在使用时有一个问题，当使用 Jackson2ObjectMapperBuilder 来build 一个 JsonMapper 时，其本身会在 class path 中去寻找所需要的 Module ，并将项目中存在的  module 注册到 builder 中默认的 objectMapper 中。如果此时再手动在 builder 上注册  module 会出现重复的 module 如 JavaTimeModule objectMapper 默认 feature (MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS) 会忽略掉重复的 module 注册，因此手动在 builder 注册的重复 module 会失效，包括手动添加的 module 的各种属性。比如，指定 java8.javaTimeModule 中的 LocalDateTime 反序列化/序列化格式为 \"YYYY-MM-dd HH:mm:ss\"(其默认为 \"YYYY-MM-ddTHH:mm:ss\")，将会无效。\n\n- 解决办法：直接在 builder 中手动注册 LocalDateTime 序列化与反序列化器格式，而不在 builder 中注册相应的 module。这样处理的结果是，builder 默认会注册 JavaTimeModule 到其 ObjectMapper ，但也会注册一个 SimpleModule 到 ObjectMapper ，同时 simple 的权限更高，在序列化时会优先使用 simpleModule。\n\n### .2.5. xml 数据交互\n\n使用的渲染 view 是 mappingJackson2XmlView\n\n- 实际使用的是 `MappingJackson2XmlHttpMessageConverter`\n- 添加在 DispatcherServlet 的适配器中的 messageConverters 中：\n\n  ```xml\n  <property name=\"messageConverters\">\n    <list>\n      <bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\" />\n    </list>\n  </property>\n  ```\n\n需要的依赖包：\n\n1. jackson-annotations\n2. jackson-dataformat-xml\n\n使用：\n 同样使用两个标签 `@RequestBody` `@ResponseBody` 并联合使用 `@RequestMapping(produces={}, consumes={})` 来确定请求与返回数据的格式。\n\n### .2.6. 数据校验\n\nspringmvc 中可以直接使用 Hibernate 的一个校验框架：hibernate-validator。基于注解实现数据的校验。\n\n### .2.7. Restful 架构\n\n- 只是一种规范，终极的目标是资源 URI\n\n## .3. configuration based on java codes\n\n使用 java 代码配置 mvc [reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config)\n\n### .3.1. ant style\n\n关于 spring 中写 ant style 路径规则参照此类 doc: `org.springframework.util.AntPathMatcher`\n\n### .3.2. RequestMapping\n\n- 可使用正则表达式来匹配 url 参数\n- pattern 匹配比较，越具体的 url 越匹配。\n- Consumable/Producible Media Types 请求消费/生产数据类型匹配，`MediaType` 中有基本的类型。可使用 非 `!` 运行符\n- Parameters,headers\n    - 窄化请求路径：指定参数是否存在 `param` `!param`，指定具体参数类型： `param=myValue`\n    - headers 相同窄化：\n\n\t```java\n\t@GetMapping(path = \"/pets\", headers = \"myHeader=myValue\")\n\tpublic void findPet(@PathVariable String petId) {\n\t\t// ...\n\t}\n\t```\n\n- HTTP HEAD,OPTIONS 请求，自动转换请求到 GET 上，也可配置多个请求方式在同一个 URL 上\n- 所有 handler 请求响应的方法都会映射成一个 RequestMappingInfo ，其中包括了所有的 headers/consumes/produces, etc.，再将所有的方法注册到 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#registerMapping 中（容器 HashMap）。此 Mapping 实现 InitializeBean 会自动在 Spring 中实现并在其 afterPropertiesSet 方法中进行注册 handler method 方法。\n- @ResponseStatus 可以给特定方法 controller 指定其响应状态码\n- @ExceptionHandler 注解在 @ControllerAdvice 中异常处理，其 doc 说明了很多问题。\n\n#### .3.2.1. URI Pattern\n\nURI 路径样式与通配符\n\n- `?` 一个字符\n- `*` 匹配任意个字符在同一个 uri 片段中： `/resources/*/versions` 不匹配 `/resources/a/b/versions`\n- `**` 匹配任意个 uri 片段，但只能出现在 末尾： `/resource/**/version` 是非法的\n- `{name}` 匹配一个路径片段 （path segment）并将其捕获为名为 `name` 的变量\n- `{name:[a-z]+}` 匹配一个符合正则表达式 `[a-z]+` 的路径片段，并将其捕获为 `name` 变量\n- `{*path}` 匹配任意个路径片段并捕获其为 `path` 变量\n    - 使用捕获的变量使用 `@PathVariable` 注解在 handler 参数中即可。\n\n#### .3.2.2. 自定义注解\n\n_Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclass RequestMappingHandlerMapping and overriding the getCustomMethodCondition method, where you can check the custom attribute and return your own RequestCondition._\n\n#### .3.2.3. Explicit Registrations\n\n显式注册 RequestMapping\n\n除使用注解进行注册外，可以直接使用代码实现更灵活的 RequestMapping 注册。\n\n```java\n@AutoWired\npublic void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler)\n\t\tthrows NoSuchMethodException {\n\tRequestMappingInfo info = RequestMappingInfo\n\t\t\t.paths(\"/user/{id}\").methods(RequestMethod.GET).build();\n\tMethod method = UserHandler.class.getMethod(\"getUser\", Long.class);\n\tmapping.registerMapping(info, handler, method);\n}\n```\n\n将 handler 中的方法与 `/user/{id}` 映射关联上。\n\n## .4. Functional Endpoints\n\n函数式 mvc 编程，与 jdk8 很好地整合。可以直接使用流式编码将请求与响应数据装配好，诸如：header/body[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#webmvc-fn)\n\n## .5. Annotated Controllers\n\nSpring MVC 提供的注解式 Controller。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller)\n\n### .5.1. DataBidder\n\n使用 `@DataBidder` 给 Controller 添加数据绑定。\n\n### .5.2. Exceptions\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-exceptionhandlers)\n\nspring MVC 中的异常。\n\nSpring MVC中的异常处理器 HandlerExceptionResolver 的实现：\n\n1. SimpleMappingExceptionResolver 可指定异常类名与错误页面的映射，用于浏览器应用\n2. DefaultHandlerExceptionResolver 通过 Spring MVC 处理异常，并将异常与状态码映射。`ResponseEntityExceptionHandler` and REST API exceptions\n3. ResponseStatusExceptionResolver 通过注解 `@ResponseStatus` 处理异常。根据注解值映射其到相应 HTTP 状态码\n4. ExceptionHandlerExceptionResolver 通过调用 Controller 或 ControllerAdvice 中的 `@ExceptionHandler` 方法处理异常。\n\n#### .5.2.1. 异常处理器链 Chain of Exceptions\n\n1. 形成异常处理器链直接 declare 多个异常处理器 bean 即可，指定其 `order` 值，越高的 order 值，执行处理得越晚。\n2. 异常处理器返回数据规约：\n    1. 使用 ModelAndView 指定错误页面\n    2. 如果处理器已经将异常处理，返回一个空的 ModelAndView\n    3. 如果处理器未处理，后面的处理器继续，如果最后异常一直未被处理，抛给 Servlet 容器。\n        1. 当所有异常处理器未将异常处理，异常传递到 Servlet 容器或指定了一个错误状态码（4xx,5xx），servlet container 可以渲染一个默认的错误 HTML 页面，在 web.xml 中配置（servlet API 不提供 java 形式的方式创建 error page mapping，只能以此种形式创建\t）：\n\n\t\t ```xml\n\t\t <error-page>\n\t\t\t<location>/error</location>\n\n\t\t</error-page>\n\t\t```\n\n        2. servlet container 同时会作一个 ERROR 分发到配置的 URL ，于是就交给了 DispatcherServlet，如果有 Controller 对此 URL 处理，将映射到此 Controller 进行处理。剩下的就交给 Controller ，可能指定一个 model ，也可能响应一个 JSON。\n\n3. Spring MVC 自动注册内置的异常处理器处理的异常包括：Spring MVC 异常、`@ResponseStatus` 注解的异常、`@ExceptionHandler` 注解的方法处理。可自定义异常处理器列表替换内置的处理器。\n\n## .6. Asynchronous Requests\n\n> 异步请求\n\n### .6.1. Processing\n\n> 异步请求的处理\n\n1. ServletRequest 可以通过 `request.startAsync()` 切换入异步模式。异步模式开启，主要的效果是 Servlet 与 Filter 可退出，同时 response 保持打开至处理完成。\n2. `request.startAsync()` 方法返回 AsyncContext，可以使用此对象进行更细致地控制异步处理。\n3. 异步处理完成后，DispatcherServlet 将接收处理结果继续处理 response 。\n\n#### .6.1.1. Compared to WebFlux\n\n1. Spring WebFlux 不仅不需要构建在 Servlet API 之上，而且不需要异步 request ，因为其就是为异步请求而生。异步处理已设计在其框架之中，天生支持所有阶段的请求处理。\n\n### .6.2. Http Streaming\n\n> [流式响应 Http 请求](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming)\n\n#### .6.2.1. Objects\n\n1. 使用 ResponseBodyEmitter 让返回一个 value 可以生产对象流，每个对象都将被 HttpMessageConverter 序列化被写进 response 对象。\n2. 也可以将 ResponseBodyEmitter 写入一个 ResponseBody 中，实现自定义 header 与 status 。\n3. 当 Emitter 出现 I/O 异常，如：Client 离开。应用不需要清理连接，不需要调用 emitter.complete() / emitter.completeWithError()。Servlet Container 会自动初始化一个 AsyncListener 错误通知，Spring MVC 来完成 completeWithError 的调用。整个请求将执行一个最终的 Async 分发到应用，期间 Spring MVC 将使用配置异常处理器完成此次请求。\n\n#### .6.2.2. Raw Data\n\n> 有时需要直接返回不经过 message conversion 的生肉数据到响应输出流，比如：文件下载，这时可以使用 `StreamingResponseBody` 作为返回数据类型。\n\n### .6.3. Configuration\n\n> 异步请求的配置 [reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-configuration)\n\n异步请求属性必须在 servlet container 级别配置。\n\n1. 在servlet container 配置：1. Filter 和 Servlet 定义处需要将标识 asyncSupport 设置为 true。此外 Filter Mapping 需要定义为处理 DispatchType 为 `ASYNC`。\n   1. java 配置中，如果使用的是 `AbstractAnnotationConfigDispatcherServletInitializer` 初始化 Servlet Container ，以上配置是自动完成的。\n   2. web.xml 配置，you can add `<async-supported>true</async-supported>` to the DispatcherServlet and to Filter declarations and add `<dispatcher>ASYNC</dispatcher>` to filter mappings.\n2. Spring MVC 配置\n   1. Java 配置，在 WebMvcConfigurer 中使用 configureAsyncSupport 回调\n   2. XML namespace: Use the `<async-support>` element under `<mvc:annotation-driven>`\n   3. 此外还可以配置：\n      1. 异步请求的默认超时值，如果不配置将取决于 Servlet Container\n      2. AsyncTaskExecutor ，用以执行异步请求，响应类型 REACTIVE TYPE  streaming 流执行从 controller 方法返回的 callable 实例。默认此配置是 `SimpleAsyncTaskExecutor`。\n      3. `DeferredResultProcessingInterceptor` 实现与 `CallableProcessingInterceptor` 实现。\n      4. DeferredResult 与 ResponseBodyEmitter 可以单独设置其超时值，Callable 可以通过 `WebAsyncTask` 设置。\n","slug":"Spring/springMVC","published":1,"updated":"2021-02-24T15:46:12.184Z","comments":1,"photos":[],"link":"","_id":"ckljnokt700792bhb32habdbg","content":"<blockquote>\n<p>SpringMVC 同样是一种 MVC 架构，它与传统 MVC 框架的不同之处在于使用了中央调度器，用中央调度器 DispatcherServlet 来分发所有的请求与响应，中央调度器的存在就大大降低了其他组件之间的耦合度。这种分发请求与响应的实现得益于 spring 的装配。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<ul>\n<li><strong>中央处理器的配置</strong>：在web.xml中配置 springmvc 的 servlet</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>中央处理器 DispatcherServlet 在web.xml中被配置成一个 servlet ,并通过初始化上下文配置参数 springmvc.xml 的路径与设置其启动时机与该servlet初始化时机；<ol>\n<li>其中 load-on-startup 这个属性来指定这个中央处理器被初始化的时机：<ol>\n<li>当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些；</li>\n<li>当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序；</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-核心对象\"><a href=\"#1-核心对象\" class=\"headerlink\" title=\".1. 核心对象\"></a>.1. 核心对象</h2><blockquote>\n<p>各个核心对象都有默认值，也就是说如果没有手动配置这些， springmvc 会按默认配置进行构建窗口。默认配置文件：spring-webmvc 包中 org.springframework.web.servlet 中的 DispatcherServlet.properties 。</p>\n</blockquote>\n<ol>\n<li><p><strong>中央分发控制器</strong>（在springMVC框架中，它是核心的核心，所有的分发都由它处理，所以也叫 <strong>中央处理器</strong> ），处理请求并给出响应（下面的三个关键组件就是装配在 springmvc 中的，但中央处理器是装配在 web.xml 中作为一个 servlet 的）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\">替代方案 WebApplicationInitializer</a></li>\n</ol>\n</li>\n<li><p><strong>处理器映射器</strong> HandlerMapping ：设置 handler 处理器与 url 资源的映射</p>\n<ol>\n<li><p>使用 BeanNameUrlHandlerMapping 这个类时，就会将 handler 的 name 属性值作为 url 映射，访问这个处理器就填写其 name 属性值:<code>&lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.kang.springdemo.controller.LoginController&quot;/&gt;</code> 如上，就可能过name属性值，设置 <code>&lt;a href=&quot;loginController.do&gt;登录&lt;/a&gt;</code></p>\n</li>\n<li><p>SimpleUrlHandlerMapping 这个类型的映射要求映射 url 与 controller 的配置 id 相对应，并在这个节点内将 controller 的 id 与相关的 key 对应起来；</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mappings&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--配置指定的url与bean的id映射,可添加多个--&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;/login.do&quot;</span>&gt;</span>login<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;/login2.do&quot;</span>&gt;</span>login2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;login&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;loginController.do&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.kang.springdemo.controller.LoginController&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;login2&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;loginController2.do&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.kang.springdemo.controller.LoginController2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用注解实现处理器与 url 的映射 <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></p>\n<ol>\n<li>这个配置节点就决定了处理器与其中的方法可以被注解 <code>@RequestMapping(&quot;url_name&quot;)</code> 映射并指定 url</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>处理器适配器</strong> HandlerAdapter，用于规定处理器的编写规则</p>\n<ol>\n<li><p>使用接口来配置适配器：</p>\n<ol>\n<li>当指定为 SimpleControllerHandlerAdapter 时，它就规定了要想成为处理器，就要实现 Controller 这个接口；</li>\n<li>HttpRequestHandlerAdapter 这个适配器要求所有的 Handler 都必须实现 HttpRequestAdapter 接口；</li>\n</ol>\n</li>\n<li><p>使用注解实现配置适配器（这个配置节点就决定了，有 <code>@Controller</code> 注解的类就是处理器）：</p>\n   <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 注解适配器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>视图解析器</strong> 用来解析处理器处理后的逻辑视图，比如：加上前缀后缀，指定到特定的视图。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 前缀 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;prefix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 后缀 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;suffix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>如果 springMVC 没有配置视图解析器，如果 接口返回的 字符串（如： “hello”）给的是相对路径（‘jsp’），那么 spring 会把当前路径给配上去（如果 当前的 controller 的 uri 是 “/v1/say” ，那么这时返回的视图 uri 就是 “/v1/say/hello”），这个时候返回的视图就会在 当前的 controller 中去找 hello 方法接口，产生问题。如果返回的字符串是绝对路径（如： “/WEB-INF/jsp/hello.jsp”），那么spring 就会在服务器的此绝对路径里去找这个 jsp 文件并返回给客户端。</p>\n</li>\n<li><p><strong>Small Notes:</strong></p>\n<ol>\n<li>在 SpringMVC 中这四个核心的对象就已经可以将整个架构支撑起来了，整个<strong>SpringMVC架构流程</strong>：<ol>\n<li>中央分发器收到来自客户端的请求时，先将请求分发给处理器映射器，由控制器映射器决定了请求的<strong>处理器</strong>是谁（按面向对象编程思想，这儿一定是生成了映射的处理器对象，同时也<strong>生成拦截器</strong>之类的组件）；</li>\n<li>同时分发器分发请求给处理器适配器，<strong>适配器对相关的处理器进行适配扩展，并调用处理器对请求进行处理，</strong> 处理结果就包括了逻辑视图与其他的响应结果（比如：存放在ModelAndView中），适配器再将这些处理结果返回给中央分发器；</li>\n<li>中央分发器将结果分发给<strong>视图解析器</strong>，视图解析器对逻辑视图进行解析（比如：加上前缀后缀），视图解析器再解析之后的具体的view返回给中央分发器；</li>\n<li>中央分发器收到view后对其进行<strong>渲染</strong>（将数据结果填充至视图中），再把最终结果响应出去；</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>整个SpringMVC流程如上，我们常常使用时并不会完全按照上面四个核心对象进行配置，相对来说有更便利的方法来配置这四个核心对象:</p>\n<ul>\n<li><strong>组件扫描器：</strong>自动扫描 <code>@Controller</code> 标记的控制器，这样省去将各个配置器配置在bean中：  <!-- 扫描器组件，将指定包中的带有特定注解的类全都扫描进容器可用的controller中 -->\n  &lt;context:component-scan base-package=”com.kang.springdemo.controller,<pre><code>                                    com.kang.springdemo.service&quot;&gt;\n  &lt;!-- 指定注解过滤器 --&gt;\n  &lt;context:include-filter type=&quot;annotation&quot;\n  expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\n</code></pre>\n  </context:component-scan></li>\n<li><strong>注解映射器：</strong>注解式映射器配置可以直接将使用过注解<code>@RequestMapping</code>的方法进行映射，而直接在处理器中寻到相关的处理方法； <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></li>\n<li><strong>注解处理器适配器：</strong>注解式处理器适配器，配置此甜酸器直接对标记<code>@RequestMapping</code>的方法进行适配： <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></li>\n<li><strong>SpringMVC中的注解驱动配置：</strong>注解驱动综合了前两个注解式的适配器与映射器，因此配置此驱动即可省略适配器与映射器的配置：<code>&lt;mvc:annotation-driven/&gt;</code></li>\n</ul>\n</li>\n<li><p><strong>Tips:</strong></p>\n<ul>\n<li><em>在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象；</em></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-1-springMVC-中的处理器\"><a href=\"#1-1-springMVC-中的处理器\" class=\"headerlink\" title=\".1.1. springMVC 中的处理器\"></a>.1.1. springMVC 中的处理器</h3><p>在 DispatcherServlet 中， spring 规约的处理器 bean <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet-special-bean-types\">reference</a></p>\n<ol>\n<li><p>通过上一步实现来自前端请求必须都通过 web.xml 文件中指定的 servlet 处理，也就是大部分请求都是交给了 springmvc，所有的 springmvc 的配置都在 springmvc.xml 文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。</p>\n</li>\n<li><p>springmvc.xml 配置中就指定了适配器映射，使用 <code>@Controller</code> 注解就让该类成为处理器</p>\n</li>\n<li><p><code>@RequestMapping(&quot;url_name&quot;)</code> 则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url;</p>\n</li>\n<li><p>注解使用时映射的方法中，可以与前端数据相通的<strong>参数</strong>有：</p>\n<ol>\n<li>简单数据类型</li>\n<li>pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password</li>\n<li>session/request/response：用法与之前一致，可以用分发请求也可以重定向；</li>\n<li>Model/ModelAndView：</li>\n<li>也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中；</li>\n<li>注解<code>@RequestParam</code>的使用：<ol>\n<li>其中有参数：<ol>\n<li>name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法；</li>\n<li>required：boolean 类型，当其值为 true 时，请求必须带有这个参数；</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>使用 controller 处理器时，各类方法 <strong>返回数据类型</strong>：</p>\n<ol>\n<li>ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图）</li>\n<li>String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串”response:+方法映射”；</li>\n<li><strong>void</strong>:在controller形参上定义request与response来指定响应结果：<ol>\n<li>“forward:+方法映射”，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到；</li>\n<li>也可以直接使用<code>response</code>重定向到指定页面：<code>response.sendRedirect(String url);</code></li>\n<li>使用<code>response</code>指定响应结果：<ol>\n<li>响应jason数据：<code>response.setCharacterEncoding(&quot;utf-8&quot;);</code></li>\n<li><code>response.getWriter().write(String &quot;jason格式的字符串&quot;);</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-使用代码代替-xml-配置文件\"><a href=\"#2-使用代码代替-xml-配置文件\" class=\"headerlink\" title=\".2. 使用代码代替 xml 配置文件\"></a>.2. 使用代码代替 xml 配置文件</h2><p>参照 spring mvc doc： org.springframework.web.WebApplicationInitializer。</p>\n<h3 id=\"2-1-LocalResolver-区域解析器\"><a href=\"#2-1-LocalResolver-区域解析器\" class=\"headerlink\" title=\".2.1. LocalResolver 区域解析器\"></a>.2.1. LocalResolver 区域解析器</h3><p>在 springmvc 中配置这个解析器，用于国际化。其中解析器常用的有：</p>\n<ul>\n<li>cookie ，根据 CookieLocaleResolver 来选择区域；<ul>\n<li>这个区域解析器所采用的Cookie可以通过cookieName和cookieMaxAge属性进行定制。cookieMaxAge属性表示这个Cookie应该持续多少秒，-1表示这个Cookie在浏览器关闭之后就失效。</li>\n</ul>\n</li>\n<li>SessionLocaleResolver<ul>\n<li>它通过检验用户会话中预置的属性来解析区域。如果该会话属性不存在，它会根据accept-language HTTP头部确定默认区域。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-多部件解析器-MultipartResolver\"><a href=\"#2-2-多部件解析器-MultipartResolver\" class=\"headerlink\" title=\".2.2. 多部件解析器 MultipartResolver\"></a>.2.2. 多部件解析器 MultipartResolver</h3><p>用于文件上传，需要引入包：commons-fileupload 与 commons-io</p>\n<h3 id=\"2-3-json-数据交互\"><a href=\"#2-3-json-数据交互\" class=\"headerlink\" title=\".2.3. json 数据交互\"></a>.2.3. json 数据交互</h3><blockquote>\n<p>在前后端分离的项目中，特别是存在为移动端提供的接口都应该使用 json 数据的格式对前端提供接口。</p>\n</blockquote>\n<p>渲染 view 是 mappingJackson2JsonView</p>\n<ul>\n<li><p>实际使用的是 <code>MappingJackson2HttpMessageConverter</code></p>\n</li>\n<li><p>添加在 DispatcherServlet 的适配器中的 messageConverters 中：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.http.converter.xml.MappingJackson2HttpMessageConverter&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>需要使用的依赖包：</p>\n<ol>\n<li>jackson-core</li>\n<li>jackson-annotations</li>\n<li>jackson-databind</li>\n</ol>\n<p>使用两个注解：</p>\n<ul>\n<li>@RequestBody<ul>\n<li>用于将请求的字符串使用 converter 转换成 json/xml 等格式并绑定到 controller 参数上去</li>\n</ul>\n</li>\n<li>@ResponseBody<ul>\n<li>用于将 controller 返回的结果 使用 converter 转换成 json/xml 格式直接 response 给浏览器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-4-JsonConvert2HttpMessage\"><a href=\"#2-4-JsonConvert2HttpMessage\" class=\"headerlink\" title=\".2.4. JsonConvert2HttpMessage\"></a>.2.4. JsonConvert2HttpMessage</h3><p>在 spring mvc 中将请求与响应数据转换成 Http 所需要的对象需要使用到序列化与反序列化。其中使用时 mvc 中的配置 configureMessageConverters 方法。在使用时有一个问题，当使用 Jackson2ObjectMapperBuilder 来build 一个 JsonMapper 时，其本身会在 class path 中去寻找所需要的 Module ，并将项目中存在的  module 注册到 builder 中默认的 objectMapper 中。如果此时再手动在 builder 上注册  module 会出现重复的 module 如 JavaTimeModule objectMapper 默认 feature (MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS) 会忽略掉重复的 module 注册，因此手动在 builder 注册的重复 module 会失效，包括手动添加的 module 的各种属性。比如，指定 java8.javaTimeModule 中的 LocalDateTime 反序列化/序列化格式为 “YYYY-MM-dd HH:mm:ss”(其默认为 “YYYY-MM-ddTHH:mm:ss”)，将会无效。</p>\n<ul>\n<li>解决办法：直接在 builder 中手动注册 LocalDateTime 序列化与反序列化器格式，而不在 builder 中注册相应的 module。这样处理的结果是，builder 默认会注册 JavaTimeModule 到其 ObjectMapper ，但也会注册一个 SimpleModule 到 ObjectMapper ，同时 simple 的权限更高，在序列化时会优先使用 simpleModule。</li>\n</ul>\n<h3 id=\"2-5-xml-数据交互\"><a href=\"#2-5-xml-数据交互\" class=\"headerlink\" title=\".2.5. xml 数据交互\"></a>.2.5. xml 数据交互</h3><p>使用的渲染 view 是 mappingJackson2XmlView</p>\n<ul>\n<li><p>实际使用的是 <code>MappingJackson2XmlHttpMessageConverter</code></p>\n</li>\n<li><p>添加在 DispatcherServlet 的适配器中的 messageConverters 中：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>需要的依赖包：</p>\n<ol>\n<li>jackson-annotations</li>\n<li>jackson-dataformat-xml</li>\n</ol>\n<p>使用：<br> 同样使用两个标签 <code>@RequestBody</code> <code>@ResponseBody</code> 并联合使用 <code>@RequestMapping(produces=&#123;&#125;, consumes=&#123;&#125;)</code> 来确定请求与返回数据的格式。</p>\n<h3 id=\"2-6-数据校验\"><a href=\"#2-6-数据校验\" class=\"headerlink\" title=\".2.6. 数据校验\"></a>.2.6. 数据校验</h3><p>springmvc 中可以直接使用 Hibernate 的一个校验框架：hibernate-validator。基于注解实现数据的校验。</p>\n<h3 id=\"2-7-Restful-架构\"><a href=\"#2-7-Restful-架构\" class=\"headerlink\" title=\".2.7. Restful 架构\"></a>.2.7. Restful 架构</h3><ul>\n<li>只是一种规范，终极的目标是资源 URI</li>\n</ul>\n<h2 id=\"3-configuration-based-on-java-codes\"><a href=\"#3-configuration-based-on-java-codes\" class=\"headerlink\" title=\".3. configuration based on java codes\"></a>.3. configuration based on java codes</h2><p>使用 java 代码配置 mvc <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config\">reference</a></p>\n<h3 id=\"3-1-ant-style\"><a href=\"#3-1-ant-style\" class=\"headerlink\" title=\".3.1. ant style\"></a>.3.1. ant style</h3><p>关于 spring 中写 ant style 路径规则参照此类 doc: <code>org.springframework.util.AntPathMatcher</code></p>\n<h3 id=\"3-2-RequestMapping\"><a href=\"#3-2-RequestMapping\" class=\"headerlink\" title=\".3.2. RequestMapping\"></a>.3.2. RequestMapping</h3><ul>\n<li><p>可使用正则表达式来匹配 url 参数</p>\n</li>\n<li><p>pattern 匹配比较，越具体的 url 越匹配。</p>\n</li>\n<li><p>Consumable/Producible Media Types 请求消费/生产数据类型匹配，<code>MediaType</code> 中有基本的类型。可使用 非 <code>!</code> 运行符</p>\n</li>\n<li><p>Parameters,headers</p>\n<ul>\n<li><p>窄化请求路径：指定参数是否存在 <code>param</code> <code>!param</code>，指定具体参数类型： <code>param=myValue</code></p>\n</li>\n<li><p>headers 相同窄化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">findPet</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String petId)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>HTTP HEAD,OPTIONS 请求，自动转换请求到 GET 上，也可配置多个请求方式在同一个 URL 上</p>\n</li>\n<li><p>所有 handler 请求响应的方法都会映射成一个 RequestMappingInfo ，其中包括了所有的 headers/consumes/produces, etc.，再将所有的方法注册到 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#registerMapping 中（容器 HashMap）。此 Mapping 实现 InitializeBean 会自动在 Spring 中实现并在其 afterPropertiesSet 方法中进行注册 handler method 方法。</p>\n</li>\n<li><p>@ResponseStatus 可以给特定方法 controller 指定其响应状态码</p>\n</li>\n<li><p>@ExceptionHandler 注解在 @ControllerAdvice 中异常处理，其 doc 说明了很多问题。</p>\n</li>\n</ul>\n<h4 id=\"3-2-1-URI-Pattern\"><a href=\"#3-2-1-URI-Pattern\" class=\"headerlink\" title=\".3.2.1. URI Pattern\"></a>.3.2.1. URI Pattern</h4><p>URI 路径样式与通配符</p>\n<ul>\n<li><code>?</code> 一个字符</li>\n<li><code>*</code> 匹配任意个字符在同一个 uri 片段中： <code>/resources/*/versions</code> 不匹配 <code>/resources/a/b/versions</code></li>\n<li><code>**</code> 匹配任意个 uri 片段，但只能出现在 末尾： <code>/resource/**/version</code> 是非法的</li>\n<li><code>&#123;name&#125;</code> 匹配一个路径片段 （path segment）并将其捕获为名为 <code>name</code> 的变量</li>\n<li><code>&#123;name:[a-z]+&#125;</code> 匹配一个符合正则表达式 <code>[a-z]+</code> 的路径片段，并将其捕获为 <code>name</code> 变量</li>\n<li><code>&#123;*path&#125;</code> 匹配任意个路径片段并捕获其为 <code>path</code> 变量<ul>\n<li>使用捕获的变量使用 <code>@PathVariable</code> 注解在 handler 参数中即可。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-2-自定义注解\"><a href=\"#3-2-2-自定义注解\" class=\"headerlink\" title=\".3.2.2. 自定义注解\"></a>.3.2.2. 自定义注解</h4><p><em>Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclass RequestMappingHandlerMapping and overriding the getCustomMethodCondition method, where you can check the custom attribute and return your own RequestCondition.</em></p>\n<h4 id=\"3-2-3-Explicit-Registrations\"><a href=\"#3-2-3-Explicit-Registrations\" class=\"headerlink\" title=\".3.2.3. Explicit Registrations\"></a>.3.2.3. Explicit Registrations</h4><p>显式注册 RequestMapping</p>\n<p>除使用注解进行注册外，可以直接使用代码实现更灵活的 RequestMapping 注册。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoWired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHandlerMapping</span><span class=\"params\">(RequestMappingHandlerMapping mapping, UserHandler handler)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t<span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">\tRequestMappingInfo info = RequestMappingInfo</span><br><span class=\"line\">\t\t\t.paths(<span class=\"string\">&quot;/user/&#123;id&#125;&quot;</span>).methods(RequestMethod.GET).build();</span><br><span class=\"line\">\tMethod method = UserHandler.class.getMethod(<span class=\"string\">&quot;getUser&quot;</span>, Long.class);</span><br><span class=\"line\">\tmapping.registerMapping(info, handler, method);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将 handler 中的方法与 <code>/user/&#123;id&#125;</code> 映射关联上。</p>\n<h2 id=\"4-Functional-Endpoints\"><a href=\"#4-Functional-Endpoints\" class=\"headerlink\" title=\".4. Functional Endpoints\"></a>.4. Functional Endpoints</h2><p>函数式 mvc 编程，与 jdk8 很好地整合。可以直接使用流式编码将请求与响应数据装配好，诸如：header/body<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#webmvc-fn\">reference</a></p>\n<h2 id=\"5-Annotated-Controllers\"><a href=\"#5-Annotated-Controllers\" class=\"headerlink\" title=\".5. Annotated Controllers\"></a>.5. Annotated Controllers</h2><p>Spring MVC 提供的注解式 Controller。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller\">reference</a></p>\n<h3 id=\"5-1-DataBidder\"><a href=\"#5-1-DataBidder\" class=\"headerlink\" title=\".5.1. DataBidder\"></a>.5.1. DataBidder</h3><p>使用 <code>@DataBidder</code> 给 Controller 添加数据绑定。</p>\n<h3 id=\"5-2-Exceptions\"><a href=\"#5-2-Exceptions\" class=\"headerlink\" title=\".5.2. Exceptions\"></a>.5.2. Exceptions</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-exceptionhandlers\">reference</a></p>\n<p>spring MVC 中的异常。</p>\n<p>Spring MVC中的异常处理器 HandlerExceptionResolver 的实现：</p>\n<ol>\n<li>SimpleMappingExceptionResolver 可指定异常类名与错误页面的映射，用于浏览器应用</li>\n<li>DefaultHandlerExceptionResolver 通过 Spring MVC 处理异常，并将异常与状态码映射。<code>ResponseEntityExceptionHandler</code> and REST API exceptions</li>\n<li>ResponseStatusExceptionResolver 通过注解 <code>@ResponseStatus</code> 处理异常。根据注解值映射其到相应 HTTP 状态码</li>\n<li>ExceptionHandlerExceptionResolver 通过调用 Controller 或 ControllerAdvice 中的 <code>@ExceptionHandler</code> 方法处理异常。</li>\n</ol>\n<h4 id=\"5-2-1-异常处理器链-Chain-of-Exceptions\"><a href=\"#5-2-1-异常处理器链-Chain-of-Exceptions\" class=\"headerlink\" title=\".5.2.1. 异常处理器链 Chain of Exceptions\"></a>.5.2.1. 异常处理器链 Chain of Exceptions</h4><ol>\n<li><p>形成异常处理器链直接 declare 多个异常处理器 bean 即可，指定其 <code>order</code> 值，越高的 order 值，执行处理得越晚。</p>\n</li>\n<li><p>异常处理器返回数据规约：</p>\n<ol>\n<li><p>使用 ModelAndView 指定错误页面</p>\n</li>\n<li><p>如果处理器已经将异常处理，返回一个空的 ModelAndView</p>\n</li>\n<li><p>如果处理器未处理，后面的处理器继续，如果最后异常一直未被处理，抛给 Servlet 容器。</p>\n<ol>\n<li><p>当所有异常处理器未将异常处理，异常传递到 Servlet 容器或指定了一个错误状态码（4xx,5xx），servlet container 可以渲染一个默认的错误 HTML 页面，在 web.xml 中配置（servlet API 不提供 java 形式的方式创建 error page mapping，只能以此种形式创建    ）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/error<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>servlet container 同时会作一个 ERROR 分发到配置的 URL ，于是就交给了 DispatcherServlet，如果有 Controller 对此 URL 处理，将映射到此 Controller 进行处理。剩下的就交给 Controller ，可能指定一个 model ，也可能响应一个 JSON。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Spring MVC 自动注册内置的异常处理器处理的异常包括：Spring MVC 异常、<code>@ResponseStatus</code> 注解的异常、<code>@ExceptionHandler</code> 注解的方法处理。可自定义异常处理器列表替换内置的处理器。</p>\n</li>\n</ol>\n<h2 id=\"6-Asynchronous-Requests\"><a href=\"#6-Asynchronous-Requests\" class=\"headerlink\" title=\".6. Asynchronous Requests\"></a>.6. Asynchronous Requests</h2><blockquote>\n<p>异步请求</p>\n</blockquote>\n<h3 id=\"6-1-Processing\"><a href=\"#6-1-Processing\" class=\"headerlink\" title=\".6.1. Processing\"></a>.6.1. Processing</h3><blockquote>\n<p>异步请求的处理</p>\n</blockquote>\n<ol>\n<li>ServletRequest 可以通过 <code>request.startAsync()</code> 切换入异步模式。异步模式开启，主要的效果是 Servlet 与 Filter 可退出，同时 response 保持打开至处理完成。</li>\n<li><code>request.startAsync()</code> 方法返回 AsyncContext，可以使用此对象进行更细致地控制异步处理。</li>\n<li>异步处理完成后，DispatcherServlet 将接收处理结果继续处理 response 。</li>\n</ol>\n<h4 id=\"6-1-1-Compared-to-WebFlux\"><a href=\"#6-1-1-Compared-to-WebFlux\" class=\"headerlink\" title=\".6.1.1. Compared to WebFlux\"></a>.6.1.1. Compared to WebFlux</h4><ol>\n<li>Spring WebFlux 不仅不需要构建在 Servlet API 之上，而且不需要异步 request ，因为其就是为异步请求而生。异步处理已设计在其框架之中，天生支持所有阶段的请求处理。</li>\n</ol>\n<h3 id=\"6-2-Http-Streaming\"><a href=\"#6-2-Http-Streaming\" class=\"headerlink\" title=\".6.2. Http Streaming\"></a>.6.2. Http Streaming</h3><blockquote>\n<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming\">流式响应 Http 请求</a></p>\n</blockquote>\n<h4 id=\"6-2-1-Objects\"><a href=\"#6-2-1-Objects\" class=\"headerlink\" title=\".6.2.1. Objects\"></a>.6.2.1. Objects</h4><ol>\n<li>使用 ResponseBodyEmitter 让返回一个 value 可以生产对象流，每个对象都将被 HttpMessageConverter 序列化被写进 response 对象。</li>\n<li>也可以将 ResponseBodyEmitter 写入一个 ResponseBody 中，实现自定义 header 与 status 。</li>\n<li>当 Emitter 出现 I/O 异常，如：Client 离开。应用不需要清理连接，不需要调用 emitter.complete() / emitter.completeWithError()。Servlet Container 会自动初始化一个 AsyncListener 错误通知，Spring MVC 来完成 completeWithError 的调用。整个请求将执行一个最终的 Async 分发到应用，期间 Spring MVC 将使用配置异常处理器完成此次请求。</li>\n</ol>\n<h4 id=\"6-2-2-Raw-Data\"><a href=\"#6-2-2-Raw-Data\" class=\"headerlink\" title=\".6.2.2. Raw Data\"></a>.6.2.2. Raw Data</h4><blockquote>\n<p>有时需要直接返回不经过 message conversion 的生肉数据到响应输出流，比如：文件下载，这时可以使用 <code>StreamingResponseBody</code> 作为返回数据类型。</p>\n</blockquote>\n<h3 id=\"6-3-Configuration\"><a href=\"#6-3-Configuration\" class=\"headerlink\" title=\".6.3. Configuration\"></a>.6.3. Configuration</h3><blockquote>\n<p>异步请求的配置 <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-configuration\">reference</a></p>\n</blockquote>\n<p>异步请求属性必须在 servlet container 级别配置。</p>\n<ol>\n<li>在servlet container 配置：1. Filter 和 Servlet 定义处需要将标识 asyncSupport 设置为 true。此外 Filter Mapping 需要定义为处理 DispatchType 为 <code>ASYNC</code>。<ol>\n<li>java 配置中，如果使用的是 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 初始化 Servlet Container ，以上配置是自动完成的。</li>\n<li>web.xml 配置，you can add <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code> to the DispatcherServlet and to Filter declarations and add <code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code> to filter mappings.</li>\n</ol>\n</li>\n<li>Spring MVC 配置<ol>\n<li>Java 配置，在 WebMvcConfigurer 中使用 configureAsyncSupport 回调</li>\n<li>XML namespace: Use the <code>&lt;async-support&gt;</code> element under <code>&lt;mvc:annotation-driven&gt;</code></li>\n<li>此外还可以配置：<ol>\n<li>异步请求的默认超时值，如果不配置将取决于 Servlet Container</li>\n<li>AsyncTaskExecutor ，用以执行异步请求，响应类型 REACTIVE TYPE  streaming 流执行从 controller 方法返回的 callable 实例。默认此配置是 <code>SimpleAsyncTaskExecutor</code>。</li>\n<li><code>DeferredResultProcessingInterceptor</code> 实现与 <code>CallableProcessingInterceptor</code> 实现。</li>\n<li>DeferredResult 与 ResponseBodyEmitter 可以单独设置其超时值，Callable 可以通过 <code>WebAsyncTask</code> 设置。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>SpringMVC 同样是一种 MVC 架构，它与传统 MVC 框架的不同之处在于使用了中央调度器，用中央调度器 DispatcherServlet 来分发所有的请求与响应，中央调度器的存在就大大降低了其他组件之间的耦合度。这种分发请求与响应的实现得益于 spring 的装配。</p>\n</blockquote>","more":"<ul>\n<li><strong>中央处理器的配置</strong>：在web.xml中配置 springmvc 的 servlet</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>中央处理器 DispatcherServlet 在web.xml中被配置成一个 servlet ,并通过初始化上下文配置参数 springmvc.xml 的路径与设置其启动时机与该servlet初始化时机；<ol>\n<li>其中 load-on-startup 这个属性来指定这个中央处理器被初始化的时机：<ol>\n<li>当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些；</li>\n<li>当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序；</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-核心对象\"><a href=\"#1-核心对象\" class=\"headerlink\" title=\".1. 核心对象\"></a>.1. 核心对象</h2><blockquote>\n<p>各个核心对象都有默认值，也就是说如果没有手动配置这些， springmvc 会按默认配置进行构建窗口。默认配置文件：spring-webmvc 包中 org.springframework.web.servlet 中的 DispatcherServlet.properties 。</p>\n</blockquote>\n<ol>\n<li><p><strong>中央分发控制器</strong>（在springMVC框架中，它是核心的核心，所有的分发都由它处理，所以也叫 <strong>中央处理器</strong> ），处理请求并给出响应（下面的三个关键组件就是装配在 springmvc 中的，但中央处理器是装配在 web.xml 中作为一个 servlet 的）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\">替代方案 WebApplicationInitializer</a></li>\n</ol>\n</li>\n<li><p><strong>处理器映射器</strong> HandlerMapping ：设置 handler 处理器与 url 资源的映射</p>\n<ol>\n<li><p>使用 BeanNameUrlHandlerMapping 这个类时，就会将 handler 的 name 属性值作为 url 映射，访问这个处理器就填写其 name 属性值:<code>&lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.kang.springdemo.controller.LoginController&quot;/&gt;</code> 如上，就可能过name属性值，设置 <code>&lt;a href=&quot;loginController.do&gt;登录&lt;/a&gt;</code></p>\n</li>\n<li><p>SimpleUrlHandlerMapping 这个类型的映射要求映射 url 与 controller 的配置 id 相对应，并在这个节点内将 controller 的 id 与相关的 key 对应起来；</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mappings&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--配置指定的url与bean的id映射,可添加多个--&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;/login.do&quot;</span>&gt;</span>login<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;/login2.do&quot;</span>&gt;</span>login2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;login&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;loginController.do&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.kang.springdemo.controller.LoginController&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;login2&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;loginController2.do&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.kang.springdemo.controller.LoginController2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用注解实现处理器与 url 的映射 <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></p>\n<ol>\n<li>这个配置节点就决定了处理器与其中的方法可以被注解 <code>@RequestMapping(&quot;url_name&quot;)</code> 映射并指定 url</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>处理器适配器</strong> HandlerAdapter，用于规定处理器的编写规则</p>\n<ol>\n<li><p>使用接口来配置适配器：</p>\n<ol>\n<li>当指定为 SimpleControllerHandlerAdapter 时，它就规定了要想成为处理器，就要实现 Controller 这个接口；</li>\n<li>HttpRequestHandlerAdapter 这个适配器要求所有的 Handler 都必须实现 HttpRequestAdapter 接口；</li>\n</ol>\n</li>\n<li><p>使用注解实现配置适配器（这个配置节点就决定了，有 <code>@Controller</code> 注解的类就是处理器）：</p>\n   <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 注解适配器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>视图解析器</strong> 用来解析处理器处理后的逻辑视图，比如：加上前缀后缀，指定到特定的视图。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 前缀 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;prefix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 后缀 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;suffix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>如果 springMVC 没有配置视图解析器，如果 接口返回的 字符串（如： “hello”）给的是相对路径（‘jsp’），那么 spring 会把当前路径给配上去（如果 当前的 controller 的 uri 是 “/v1/say” ，那么这时返回的视图 uri 就是 “/v1/say/hello”），这个时候返回的视图就会在 当前的 controller 中去找 hello 方法接口，产生问题。如果返回的字符串是绝对路径（如： “/WEB-INF/jsp/hello.jsp”），那么spring 就会在服务器的此绝对路径里去找这个 jsp 文件并返回给客户端。</p>\n</li>\n<li><p><strong>Small Notes:</strong></p>\n<ol>\n<li>在 SpringMVC 中这四个核心的对象就已经可以将整个架构支撑起来了，整个<strong>SpringMVC架构流程</strong>：<ol>\n<li>中央分发器收到来自客户端的请求时，先将请求分发给处理器映射器，由控制器映射器决定了请求的<strong>处理器</strong>是谁（按面向对象编程思想，这儿一定是生成了映射的处理器对象，同时也<strong>生成拦截器</strong>之类的组件）；</li>\n<li>同时分发器分发请求给处理器适配器，<strong>适配器对相关的处理器进行适配扩展，并调用处理器对请求进行处理，</strong> 处理结果就包括了逻辑视图与其他的响应结果（比如：存放在ModelAndView中），适配器再将这些处理结果返回给中央分发器；</li>\n<li>中央分发器将结果分发给<strong>视图解析器</strong>，视图解析器对逻辑视图进行解析（比如：加上前缀后缀），视图解析器再解析之后的具体的view返回给中央分发器；</li>\n<li>中央分发器收到view后对其进行<strong>渲染</strong>（将数据结果填充至视图中），再把最终结果响应出去；</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>整个SpringMVC流程如上，我们常常使用时并不会完全按照上面四个核心对象进行配置，相对来说有更便利的方法来配置这四个核心对象:</p>\n<ul>\n<li><strong>组件扫描器：</strong>自动扫描 <code>@Controller</code> 标记的控制器，这样省去将各个配置器配置在bean中：  <!-- 扫描器组件，将指定包中的带有特定注解的类全都扫描进容器可用的controller中 -->\n  &lt;context:component-scan base-package=”com.kang.springdemo.controller,<pre><code>                                    com.kang.springdemo.service&quot;&gt;\n  &lt;!-- 指定注解过滤器 --&gt;\n  &lt;context:include-filter type=&quot;annotation&quot;\n  expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\n</code></pre>\n  </context:component-scan></li>\n<li><strong>注解映射器：</strong>注解式映射器配置可以直接将使用过注解<code>@RequestMapping</code>的方法进行映射，而直接在处理器中寻到相关的处理方法； <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></li>\n<li><strong>注解处理器适配器：</strong>注解式处理器适配器，配置此甜酸器直接对标记<code>@RequestMapping</code>的方法进行适配： <code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></li>\n<li><strong>SpringMVC中的注解驱动配置：</strong>注解驱动综合了前两个注解式的适配器与映射器，因此配置此驱动即可省略适配器与映射器的配置：<code>&lt;mvc:annotation-driven/&gt;</code></li>\n</ul>\n</li>\n<li><p><strong>Tips:</strong></p>\n<ul>\n<li><em>在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象；</em></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-1-springMVC-中的处理器\"><a href=\"#1-1-springMVC-中的处理器\" class=\"headerlink\" title=\".1.1. springMVC 中的处理器\"></a>.1.1. springMVC 中的处理器</h3><p>在 DispatcherServlet 中， spring 规约的处理器 bean <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet-special-bean-types\">reference</a></p>\n<ol>\n<li><p>通过上一步实现来自前端请求必须都通过 web.xml 文件中指定的 servlet 处理，也就是大部分请求都是交给了 springmvc，所有的 springmvc 的配置都在 springmvc.xml 文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。</p>\n</li>\n<li><p>springmvc.xml 配置中就指定了适配器映射，使用 <code>@Controller</code> 注解就让该类成为处理器</p>\n</li>\n<li><p><code>@RequestMapping(&quot;url_name&quot;)</code> 则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url;</p>\n</li>\n<li><p>注解使用时映射的方法中，可以与前端数据相通的<strong>参数</strong>有：</p>\n<ol>\n<li>简单数据类型</li>\n<li>pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password</li>\n<li>session/request/response：用法与之前一致，可以用分发请求也可以重定向；</li>\n<li>Model/ModelAndView：</li>\n<li>也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中；</li>\n<li>注解<code>@RequestParam</code>的使用：<ol>\n<li>其中有参数：<ol>\n<li>name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法；</li>\n<li>required：boolean 类型，当其值为 true 时，请求必须带有这个参数；</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>使用 controller 处理器时，各类方法 <strong>返回数据类型</strong>：</p>\n<ol>\n<li>ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图）</li>\n<li>String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串”response:+方法映射”；</li>\n<li><strong>void</strong>:在controller形参上定义request与response来指定响应结果：<ol>\n<li>“forward:+方法映射”，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到；</li>\n<li>也可以直接使用<code>response</code>重定向到指定页面：<code>response.sendRedirect(String url);</code></li>\n<li>使用<code>response</code>指定响应结果：<ol>\n<li>响应jason数据：<code>response.setCharacterEncoding(&quot;utf-8&quot;);</code></li>\n<li><code>response.getWriter().write(String &quot;jason格式的字符串&quot;);</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-使用代码代替-xml-配置文件\"><a href=\"#2-使用代码代替-xml-配置文件\" class=\"headerlink\" title=\".2. 使用代码代替 xml 配置文件\"></a>.2. 使用代码代替 xml 配置文件</h2><p>参照 spring mvc doc： org.springframework.web.WebApplicationInitializer。</p>\n<h3 id=\"2-1-LocalResolver-区域解析器\"><a href=\"#2-1-LocalResolver-区域解析器\" class=\"headerlink\" title=\".2.1. LocalResolver 区域解析器\"></a>.2.1. LocalResolver 区域解析器</h3><p>在 springmvc 中配置这个解析器，用于国际化。其中解析器常用的有：</p>\n<ul>\n<li>cookie ，根据 CookieLocaleResolver 来选择区域；<ul>\n<li>这个区域解析器所采用的Cookie可以通过cookieName和cookieMaxAge属性进行定制。cookieMaxAge属性表示这个Cookie应该持续多少秒，-1表示这个Cookie在浏览器关闭之后就失效。</li>\n</ul>\n</li>\n<li>SessionLocaleResolver<ul>\n<li>它通过检验用户会话中预置的属性来解析区域。如果该会话属性不存在，它会根据accept-language HTTP头部确定默认区域。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-多部件解析器-MultipartResolver\"><a href=\"#2-2-多部件解析器-MultipartResolver\" class=\"headerlink\" title=\".2.2. 多部件解析器 MultipartResolver\"></a>.2.2. 多部件解析器 MultipartResolver</h3><p>用于文件上传，需要引入包：commons-fileupload 与 commons-io</p>\n<h3 id=\"2-3-json-数据交互\"><a href=\"#2-3-json-数据交互\" class=\"headerlink\" title=\".2.3. json 数据交互\"></a>.2.3. json 数据交互</h3><blockquote>\n<p>在前后端分离的项目中，特别是存在为移动端提供的接口都应该使用 json 数据的格式对前端提供接口。</p>\n</blockquote>\n<p>渲染 view 是 mappingJackson2JsonView</p>\n<ul>\n<li><p>实际使用的是 <code>MappingJackson2HttpMessageConverter</code></p>\n</li>\n<li><p>添加在 DispatcherServlet 的适配器中的 messageConverters 中：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.http.converter.xml.MappingJackson2HttpMessageConverter&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>需要使用的依赖包：</p>\n<ol>\n<li>jackson-core</li>\n<li>jackson-annotations</li>\n<li>jackson-databind</li>\n</ol>\n<p>使用两个注解：</p>\n<ul>\n<li>@RequestBody<ul>\n<li>用于将请求的字符串使用 converter 转换成 json/xml 等格式并绑定到 controller 参数上去</li>\n</ul>\n</li>\n<li>@ResponseBody<ul>\n<li>用于将 controller 返回的结果 使用 converter 转换成 json/xml 格式直接 response 给浏览器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-4-JsonConvert2HttpMessage\"><a href=\"#2-4-JsonConvert2HttpMessage\" class=\"headerlink\" title=\".2.4. JsonConvert2HttpMessage\"></a>.2.4. JsonConvert2HttpMessage</h3><p>在 spring mvc 中将请求与响应数据转换成 Http 所需要的对象需要使用到序列化与反序列化。其中使用时 mvc 中的配置 configureMessageConverters 方法。在使用时有一个问题，当使用 Jackson2ObjectMapperBuilder 来build 一个 JsonMapper 时，其本身会在 class path 中去寻找所需要的 Module ，并将项目中存在的  module 注册到 builder 中默认的 objectMapper 中。如果此时再手动在 builder 上注册  module 会出现重复的 module 如 JavaTimeModule objectMapper 默认 feature (MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS) 会忽略掉重复的 module 注册，因此手动在 builder 注册的重复 module 会失效，包括手动添加的 module 的各种属性。比如，指定 java8.javaTimeModule 中的 LocalDateTime 反序列化/序列化格式为 “YYYY-MM-dd HH:mm:ss”(其默认为 “YYYY-MM-ddTHH:mm:ss”)，将会无效。</p>\n<ul>\n<li>解决办法：直接在 builder 中手动注册 LocalDateTime 序列化与反序列化器格式，而不在 builder 中注册相应的 module。这样处理的结果是，builder 默认会注册 JavaTimeModule 到其 ObjectMapper ，但也会注册一个 SimpleModule 到 ObjectMapper ，同时 simple 的权限更高，在序列化时会优先使用 simpleModule。</li>\n</ul>\n<h3 id=\"2-5-xml-数据交互\"><a href=\"#2-5-xml-数据交互\" class=\"headerlink\" title=\".2.5. xml 数据交互\"></a>.2.5. xml 数据交互</h3><p>使用的渲染 view 是 mappingJackson2XmlView</p>\n<ul>\n<li><p>实际使用的是 <code>MappingJackson2XmlHttpMessageConverter</code></p>\n</li>\n<li><p>添加在 DispatcherServlet 的适配器中的 messageConverters 中：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>需要的依赖包：</p>\n<ol>\n<li>jackson-annotations</li>\n<li>jackson-dataformat-xml</li>\n</ol>\n<p>使用：<br> 同样使用两个标签 <code>@RequestBody</code> <code>@ResponseBody</code> 并联合使用 <code>@RequestMapping(produces=&#123;&#125;, consumes=&#123;&#125;)</code> 来确定请求与返回数据的格式。</p>\n<h3 id=\"2-6-数据校验\"><a href=\"#2-6-数据校验\" class=\"headerlink\" title=\".2.6. 数据校验\"></a>.2.6. 数据校验</h3><p>springmvc 中可以直接使用 Hibernate 的一个校验框架：hibernate-validator。基于注解实现数据的校验。</p>\n<h3 id=\"2-7-Restful-架构\"><a href=\"#2-7-Restful-架构\" class=\"headerlink\" title=\".2.7. Restful 架构\"></a>.2.7. Restful 架构</h3><ul>\n<li>只是一种规范，终极的目标是资源 URI</li>\n</ul>\n<h2 id=\"3-configuration-based-on-java-codes\"><a href=\"#3-configuration-based-on-java-codes\" class=\"headerlink\" title=\".3. configuration based on java codes\"></a>.3. configuration based on java codes</h2><p>使用 java 代码配置 mvc <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config\">reference</a></p>\n<h3 id=\"3-1-ant-style\"><a href=\"#3-1-ant-style\" class=\"headerlink\" title=\".3.1. ant style\"></a>.3.1. ant style</h3><p>关于 spring 中写 ant style 路径规则参照此类 doc: <code>org.springframework.util.AntPathMatcher</code></p>\n<h3 id=\"3-2-RequestMapping\"><a href=\"#3-2-RequestMapping\" class=\"headerlink\" title=\".3.2. RequestMapping\"></a>.3.2. RequestMapping</h3><ul>\n<li><p>可使用正则表达式来匹配 url 参数</p>\n</li>\n<li><p>pattern 匹配比较，越具体的 url 越匹配。</p>\n</li>\n<li><p>Consumable/Producible Media Types 请求消费/生产数据类型匹配，<code>MediaType</code> 中有基本的类型。可使用 非 <code>!</code> 运行符</p>\n</li>\n<li><p>Parameters,headers</p>\n<ul>\n<li><p>窄化请求路径：指定参数是否存在 <code>param</code> <code>!param</code>，指定具体参数类型： <code>param=myValue</code></p>\n</li>\n<li><p>headers 相同窄化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">findPet</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String petId)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>HTTP HEAD,OPTIONS 请求，自动转换请求到 GET 上，也可配置多个请求方式在同一个 URL 上</p>\n</li>\n<li><p>所有 handler 请求响应的方法都会映射成一个 RequestMappingInfo ，其中包括了所有的 headers/consumes/produces, etc.，再将所有的方法注册到 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#registerMapping 中（容器 HashMap）。此 Mapping 实现 InitializeBean 会自动在 Spring 中实现并在其 afterPropertiesSet 方法中进行注册 handler method 方法。</p>\n</li>\n<li><p>@ResponseStatus 可以给特定方法 controller 指定其响应状态码</p>\n</li>\n<li><p>@ExceptionHandler 注解在 @ControllerAdvice 中异常处理，其 doc 说明了很多问题。</p>\n</li>\n</ul>\n<h4 id=\"3-2-1-URI-Pattern\"><a href=\"#3-2-1-URI-Pattern\" class=\"headerlink\" title=\".3.2.1. URI Pattern\"></a>.3.2.1. URI Pattern</h4><p>URI 路径样式与通配符</p>\n<ul>\n<li><code>?</code> 一个字符</li>\n<li><code>*</code> 匹配任意个字符在同一个 uri 片段中： <code>/resources/*/versions</code> 不匹配 <code>/resources/a/b/versions</code></li>\n<li><code>**</code> 匹配任意个 uri 片段，但只能出现在 末尾： <code>/resource/**/version</code> 是非法的</li>\n<li><code>&#123;name&#125;</code> 匹配一个路径片段 （path segment）并将其捕获为名为 <code>name</code> 的变量</li>\n<li><code>&#123;name:[a-z]+&#125;</code> 匹配一个符合正则表达式 <code>[a-z]+</code> 的路径片段，并将其捕获为 <code>name</code> 变量</li>\n<li><code>&#123;*path&#125;</code> 匹配任意个路径片段并捕获其为 <code>path</code> 变量<ul>\n<li>使用捕获的变量使用 <code>@PathVariable</code> 注解在 handler 参数中即可。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-2-自定义注解\"><a href=\"#3-2-2-自定义注解\" class=\"headerlink\" title=\".3.2.2. 自定义注解\"></a>.3.2.2. 自定义注解</h4><p><em>Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclass RequestMappingHandlerMapping and overriding the getCustomMethodCondition method, where you can check the custom attribute and return your own RequestCondition.</em></p>\n<h4 id=\"3-2-3-Explicit-Registrations\"><a href=\"#3-2-3-Explicit-Registrations\" class=\"headerlink\" title=\".3.2.3. Explicit Registrations\"></a>.3.2.3. Explicit Registrations</h4><p>显式注册 RequestMapping</p>\n<p>除使用注解进行注册外，可以直接使用代码实现更灵活的 RequestMapping 注册。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoWired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHandlerMapping</span><span class=\"params\">(RequestMappingHandlerMapping mapping, UserHandler handler)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t<span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">\tRequestMappingInfo info = RequestMappingInfo</span><br><span class=\"line\">\t\t\t.paths(<span class=\"string\">&quot;/user/&#123;id&#125;&quot;</span>).methods(RequestMethod.GET).build();</span><br><span class=\"line\">\tMethod method = UserHandler.class.getMethod(<span class=\"string\">&quot;getUser&quot;</span>, Long.class);</span><br><span class=\"line\">\tmapping.registerMapping(info, handler, method);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将 handler 中的方法与 <code>/user/&#123;id&#125;</code> 映射关联上。</p>\n<h2 id=\"4-Functional-Endpoints\"><a href=\"#4-Functional-Endpoints\" class=\"headerlink\" title=\".4. Functional Endpoints\"></a>.4. Functional Endpoints</h2><p>函数式 mvc 编程，与 jdk8 很好地整合。可以直接使用流式编码将请求与响应数据装配好，诸如：header/body<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#webmvc-fn\">reference</a></p>\n<h2 id=\"5-Annotated-Controllers\"><a href=\"#5-Annotated-Controllers\" class=\"headerlink\" title=\".5. Annotated Controllers\"></a>.5. Annotated Controllers</h2><p>Spring MVC 提供的注解式 Controller。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller\">reference</a></p>\n<h3 id=\"5-1-DataBidder\"><a href=\"#5-1-DataBidder\" class=\"headerlink\" title=\".5.1. DataBidder\"></a>.5.1. DataBidder</h3><p>使用 <code>@DataBidder</code> 给 Controller 添加数据绑定。</p>\n<h3 id=\"5-2-Exceptions\"><a href=\"#5-2-Exceptions\" class=\"headerlink\" title=\".5.2. Exceptions\"></a>.5.2. Exceptions</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-exceptionhandlers\">reference</a></p>\n<p>spring MVC 中的异常。</p>\n<p>Spring MVC中的异常处理器 HandlerExceptionResolver 的实现：</p>\n<ol>\n<li>SimpleMappingExceptionResolver 可指定异常类名与错误页面的映射，用于浏览器应用</li>\n<li>DefaultHandlerExceptionResolver 通过 Spring MVC 处理异常，并将异常与状态码映射。<code>ResponseEntityExceptionHandler</code> and REST API exceptions</li>\n<li>ResponseStatusExceptionResolver 通过注解 <code>@ResponseStatus</code> 处理异常。根据注解值映射其到相应 HTTP 状态码</li>\n<li>ExceptionHandlerExceptionResolver 通过调用 Controller 或 ControllerAdvice 中的 <code>@ExceptionHandler</code> 方法处理异常。</li>\n</ol>\n<h4 id=\"5-2-1-异常处理器链-Chain-of-Exceptions\"><a href=\"#5-2-1-异常处理器链-Chain-of-Exceptions\" class=\"headerlink\" title=\".5.2.1. 异常处理器链 Chain of Exceptions\"></a>.5.2.1. 异常处理器链 Chain of Exceptions</h4><ol>\n<li><p>形成异常处理器链直接 declare 多个异常处理器 bean 即可，指定其 <code>order</code> 值，越高的 order 值，执行处理得越晚。</p>\n</li>\n<li><p>异常处理器返回数据规约：</p>\n<ol>\n<li><p>使用 ModelAndView 指定错误页面</p>\n</li>\n<li><p>如果处理器已经将异常处理，返回一个空的 ModelAndView</p>\n</li>\n<li><p>如果处理器未处理，后面的处理器继续，如果最后异常一直未被处理，抛给 Servlet 容器。</p>\n<ol>\n<li><p>当所有异常处理器未将异常处理，异常传递到 Servlet 容器或指定了一个错误状态码（4xx,5xx），servlet container 可以渲染一个默认的错误 HTML 页面，在 web.xml 中配置（servlet API 不提供 java 形式的方式创建 error page mapping，只能以此种形式创建    ）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/error<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>servlet container 同时会作一个 ERROR 分发到配置的 URL ，于是就交给了 DispatcherServlet，如果有 Controller 对此 URL 处理，将映射到此 Controller 进行处理。剩下的就交给 Controller ，可能指定一个 model ，也可能响应一个 JSON。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Spring MVC 自动注册内置的异常处理器处理的异常包括：Spring MVC 异常、<code>@ResponseStatus</code> 注解的异常、<code>@ExceptionHandler</code> 注解的方法处理。可自定义异常处理器列表替换内置的处理器。</p>\n</li>\n</ol>\n<h2 id=\"6-Asynchronous-Requests\"><a href=\"#6-Asynchronous-Requests\" class=\"headerlink\" title=\".6. Asynchronous Requests\"></a>.6. Asynchronous Requests</h2><blockquote>\n<p>异步请求</p>\n</blockquote>\n<h3 id=\"6-1-Processing\"><a href=\"#6-1-Processing\" class=\"headerlink\" title=\".6.1. Processing\"></a>.6.1. Processing</h3><blockquote>\n<p>异步请求的处理</p>\n</blockquote>\n<ol>\n<li>ServletRequest 可以通过 <code>request.startAsync()</code> 切换入异步模式。异步模式开启，主要的效果是 Servlet 与 Filter 可退出，同时 response 保持打开至处理完成。</li>\n<li><code>request.startAsync()</code> 方法返回 AsyncContext，可以使用此对象进行更细致地控制异步处理。</li>\n<li>异步处理完成后，DispatcherServlet 将接收处理结果继续处理 response 。</li>\n</ol>\n<h4 id=\"6-1-1-Compared-to-WebFlux\"><a href=\"#6-1-1-Compared-to-WebFlux\" class=\"headerlink\" title=\".6.1.1. Compared to WebFlux\"></a>.6.1.1. Compared to WebFlux</h4><ol>\n<li>Spring WebFlux 不仅不需要构建在 Servlet API 之上，而且不需要异步 request ，因为其就是为异步请求而生。异步处理已设计在其框架之中，天生支持所有阶段的请求处理。</li>\n</ol>\n<h3 id=\"6-2-Http-Streaming\"><a href=\"#6-2-Http-Streaming\" class=\"headerlink\" title=\".6.2. Http Streaming\"></a>.6.2. Http Streaming</h3><blockquote>\n<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming\">流式响应 Http 请求</a></p>\n</blockquote>\n<h4 id=\"6-2-1-Objects\"><a href=\"#6-2-1-Objects\" class=\"headerlink\" title=\".6.2.1. Objects\"></a>.6.2.1. Objects</h4><ol>\n<li>使用 ResponseBodyEmitter 让返回一个 value 可以生产对象流，每个对象都将被 HttpMessageConverter 序列化被写进 response 对象。</li>\n<li>也可以将 ResponseBodyEmitter 写入一个 ResponseBody 中，实现自定义 header 与 status 。</li>\n<li>当 Emitter 出现 I/O 异常，如：Client 离开。应用不需要清理连接，不需要调用 emitter.complete() / emitter.completeWithError()。Servlet Container 会自动初始化一个 AsyncListener 错误通知，Spring MVC 来完成 completeWithError 的调用。整个请求将执行一个最终的 Async 分发到应用，期间 Spring MVC 将使用配置异常处理器完成此次请求。</li>\n</ol>\n<h4 id=\"6-2-2-Raw-Data\"><a href=\"#6-2-2-Raw-Data\" class=\"headerlink\" title=\".6.2.2. Raw Data\"></a>.6.2.2. Raw Data</h4><blockquote>\n<p>有时需要直接返回不经过 message conversion 的生肉数据到响应输出流，比如：文件下载，这时可以使用 <code>StreamingResponseBody</code> 作为返回数据类型。</p>\n</blockquote>\n<h3 id=\"6-3-Configuration\"><a href=\"#6-3-Configuration\" class=\"headerlink\" title=\".6.3. Configuration\"></a>.6.3. Configuration</h3><blockquote>\n<p>异步请求的配置 <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-configuration\">reference</a></p>\n</blockquote>\n<p>异步请求属性必须在 servlet container 级别配置。</p>\n<ol>\n<li>在servlet container 配置：1. Filter 和 Servlet 定义处需要将标识 asyncSupport 设置为 true。此外 Filter Mapping 需要定义为处理 DispatchType 为 <code>ASYNC</code>。<ol>\n<li>java 配置中，如果使用的是 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 初始化 Servlet Container ，以上配置是自动完成的。</li>\n<li>web.xml 配置，you can add <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code> to the DispatcherServlet and to Filter declarations and add <code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code> to filter mappings.</li>\n</ol>\n</li>\n<li>Spring MVC 配置<ol>\n<li>Java 配置，在 WebMvcConfigurer 中使用 configureAsyncSupport 回调</li>\n<li>XML namespace: Use the <code>&lt;async-support&gt;</code> element under <code>&lt;mvc:annotation-driven&gt;</code></li>\n<li>此外还可以配置：<ol>\n<li>异步请求的默认超时值，如果不配置将取决于 Servlet Container</li>\n<li>AsyncTaskExecutor ，用以执行异步请求，响应类型 REACTIVE TYPE  streaming 流执行从 controller 方法返回的 callable 实例。默认此配置是 <code>SimpleAsyncTaskExecutor</code>。</li>\n<li><code>DeferredResultProcessingInterceptor</code> 实现与 <code>CallableProcessingInterceptor</code> 实现。</li>\n<li>DeferredResult 与 ResponseBodyEmitter 可以单独设置其超时值，Callable 可以通过 <code>WebAsyncTask</code> 设置。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>"},{"layout":"post","title":"Spring bean","date":"2017-08-22T18:04:38.000Z","_content":"\n> **前言：**\n> Spring 中的 bean 配置就是将各个类配置在 bean.xml 文件中，成为一个个的组件，方便实现各个组件之间的重新装配，这也是实现 spring 的依赖注入的方便法门；\n>\n> 因此就可以理解，一个个的 bean 就是一个个的类的实例，但在 spring 运行时，spring 容器装配各个组件时初始化这些类实例时，也就会涉及到类的构造函数，装配各个组件时会涉及到各种类型参数；\n>\n> Spring中的配置各个 bean 时有许多不曾注意到的小知识点，这儿一并给总结出来。\n<!--more-->\n\n## .1. 知识点\n\n1. Spring 容器初始化各个 bean 组件时，默认组件为 **单态模式**（singleton，也叫单例模式）也就是当这个类只有一个实例，如果要实现非单态（prototype，标准类型），则将这个 bean 的 `singleton` 属性设置为 `false` ；\n2. **构造函数** 的参数的配置，使用 `<constructor-arg>` 标签，多个参数就使用多个此标签，且要保证各个参数的顺序要与构造函数的参数顺序保持一致；\n3. bean 的属性的配置的前提是这个类中相关的属性要有 `setter` 方法；\n4. 在 bean 中配置属性使用 `<property>` 标签，给其赋值时可以后直接使用 `value` 属性也可以使用子元素 `<value>` 标签；\n5. **空字符** 的设置： `<value></value>` 设置的是空字符串 `\"\"` ，如果要设置为 `null` ，要使用 `<null/>` 或者干脆不设置;\n6. **匿名对象的配置** ，类似于 java 中的匿名对象，如果要在一个属性中配置一个未曾配置的对象（也就是这个对象只会被使用一次的情况下，如果专门给其装配一个 bean 组件会造成一定的内存浪费），则其配置时直接将该类的路径写在 `<property>` 标签中，而 **不在其中引入需要提前配置好的 bean 的 id**\n\n```xml\n<property name=\"dao\">\n    //使用匿名对象\n    <bean class=\"com.snail.springdemo.dao.impl.UserDaoImpl\"></bean>\n</property>\n```\n\n- ref 与 idref 之间的区别：\n    1. 两者都是用来设置 bean 的注入对象的；\n    2. 两者检查其引用对象bean是否存在：**ref** 只有在第一次调用时会检查，也就是在 **程序运行中才会抛出错误** ，而 **idref 在程序启动时就会抛出错误** ；\n    3. **idref只有bean、local属性，没有parent属性** ，而 ref 三个属性都有。（ local 表示就在当前配置文件中查找相关的 id，而 parent 表示在父配置文件中找。而 bean 则不会限制，可以在其本身找也可以在其父配置文件中找）；\n- depends-on，设置依赖对象：\n    1. 当我们设置的 bean 实例 a 之前要确保另外一个 bean 实例先实例化，这时就可以使用 `depends-on` 属性：\n\n    ```xml\n    <bean id=\"a\" class=\"com.snail.springdemo.A\" depends-on=\"b\"></bean>\n    <bean id=\"b\" class=\"com.snail.springdemo.B\"></bean>\n    ```\n\n- **初始化方法的执行：** 当我们想要一个 bean 在实例化过程中执行一些初始化方法，同时这些初始化执行过程不能放在构造函数中，这是就可以借助初始化方法的属性 `init-method` 在配置中来达到执行初始化的目标；\n\n```xml\n<bean id=\"test\" class=\"com.kk.springdemo.A\" init-method=\"initMethodName\"></bean>\n```\n\n## .2. spring bean 的自动装配\n\n> 上述情况每个 bean 的装配都由我们自己来在 xml 文件中通过 ref 属性来显式指定。但 spring 中有更为方便的方法：自动装配。\n\n- 在 `<beans>` 中，指定自动装配的属性 `default-autowire` ，对整个 beans 中的 bean 都生效。\n- `<bean>` 中，指定自动装配的属性 `autowire` ，此属性只对当前 bean 生效。\n\n`deault-autowire` 与 `autowire` 可以接受的值与其意义：\n\n- `no` 不使用自动装配。这个时候的 bean 的属性都得使用 ref 指定依赖。 **默认值** ，较大的部署环境中都这样，显式地指定出来方便后期检索。\n- `byName` 此种装配方法是 spring 会在 bean 库中去查找 bean 的 id 属性与当前需要装配的 setter 方法名（会将 setter 方法前面 `set` 去掉，并小写首字母）\n- `byType` 查找 setter 方法中形参的类型与 bean 库中的类型进行匹配。如果找到多个 bean 将会拋出异常，如果没找到不会发生动作\n- `constructor`  匹配 bean 的构造器与 setter 方法形参的构造器是否相同。同样如果找不到会拋出异常。\n- `autodetect` spring 根据 bean 的内部结构自行决定采用 byType 策略还是用 constructor 策略。\n\n_当一个 Bean 既使用自动装配依赖，又使用 ref 显式指定依赖时，则**显式指定的依赖覆盖自动装配依赖**；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大降低了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。_\n\n- 通过设置可以将 Bean 排除在自动装配之外\n\n```xml\n<!--通过设置可以将Bean排除在自动装配之外-->\n<bean id=\"\" autowire-candidate=\"false\"/>\n<!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外-->\n<beans default-autowire-candidates=\"*abc\"/>\n```\n\n_一个模块的 spring 配置文件根节点就是 `<beans>` ，也就是用这个节点来配置了一个 bean 池，再在这个里面配置了各个属性，也就是在这其中配置了各个 bean 与池的其他属性。_\n\n## .3. 创建 bean 的方式\n\n> 共 3 种\n\n创建 bean 的三种方式：\n\n1. 构造器创建 bean ，最常见的创建方式。 如果不采用构造注入， spring 会自动加载此 bean 的默认无参构造器，并将其属性全部初始化（基本类型设置为 0/false，引用类型设为 null）\n2. 静态工厂方法创建 bean 。使用静态工厂创建 bean 时必须指定 `<bean class=\"\">` 这儿的 class 属性就是用来指定静态工厂， factory-method 属性指定工厂的创建方法， 如果此方法需要参数，通过 constructor-arg 属性来指定。\n3. 实例工厂方法创建 bean 。顾名思义，此方法与 静态工厂方法 的不同之处在于使用工厂实例进行创建 bean 。所以这儿能过 factory-bean 来指定工厂实例，再通过 factory-method 指定创建 bean 的方法。如果需要参数通过 constructor-arg 指定参数值。\n\n## .4. Bean Scope\n\nBean scope : bean 领域，指 bean 的生存策略，共 6 种，其中 4 种只存在于 web 应用 context 中。\n\n1. singleton，spring bean 默认的单例，但 spring bean scope 单例与设计模式的单例不同。设计模式中单例是对一个特定 java 类来说的，每个 classloader 只生产一个实例。而 spring bean scope 是指一个 bean 在同一个 IoC 容器只生产一个实例。\n2. prototype, 模版模式，每次请求此 bean 被注入其他 bean 中或通过 `getBean()` 方式获取容器中 bean 时都会创建一个实例。按惯例， prototype scope 用于带状态的 bean ，而 singleton scope 用于无状态 bean 。\n    1. 对于 prototype scope 的 bean ， IoC 容器只负责其初始化、装配、交给需要此 bean 的客户端，并不负责其后的生命周期。所以对一个 prototype scope bean 就算配置了生命周期中 destruction 销毁的回调 IoC 也不会执行，而负责此任务的是 client。\n    2. client 可使用 bean post-processor 对 bean 进行资源管理。在某些方面来讲，IoC 容器对于 prototype scope bean 相当于一个 java new operator。在此之后的生命周期管理都交给了 client。\n3. 当一个 singleton scope beanA 中依赖注入了 prototype scope beanB ，同时，在 beanA 中需要 beanB 的多个不同的实例。IoC 容器在初始化 beanB 时只会在 beanA 中初始化一个 beanB 的实例，当 IoC 容器按顺序给 beanA 装配时只会装配同一个 beanB 实例到 beanA 中。[reference](https://spring.io/blog/2004/08/06/method-injection/)\n   1. 解决问题的方案一：放弃 IoC ，让 beanA 实现 `ApplicationContextAware` 接口让其对 IoC 容器敏感，每个需要 bean 的地方使用 `ApplicationContext.getBean(Bean.class)` 的方式获取，这样获取的 bean 就是一个新的实例。缺点：业务代码与 spring 框架耦合在一起。\n   2. 方案二：IoC 容器方法注入。\n\n    ```xml\n    <bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n        <lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n    </bean>\n    ```\n\n    或使用 annotation `@Lookup(value=\"\")`\n    3. 方法可以是抽象方法也可是具体方法，IoC 容器会通过 CGLIB 为方法所在的类生成子类覆盖方法，所以 `@Lookup` 只能在 IoC 容器能通过常规构造器初始化的 bean 中才能生效。也就是：Lookup 不能为工厂方法生产 bean 方法所替代，因为不能动态地为工厂方法所生产的 bean 提供子类。method 与 class 均不能为 final 修辞。\n    4. 在 spring 使用场景中需要注意：需要为 Lookup 方法提供具体实现，否则 component scanning 之类会过滤掉抽象 bean。同时， Lookup method 不能在 configuration class 中配置的 `@Bean` 方法上生效，需要使用 `@Inject` 之类的注解代替。\n\n### .4.1. Web application bean scope\n\n request/session/application/websocket scope 都用于 web application context，如果是一个普通的应用程序，使胳膊这几个 scope 会抛出 IllegalStateException。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-sing-prot-interaction)\n\n初始化一个 web application configuration:\n\n1. 如果使用 spring mvc scoped this beans，只需要注册一个 `DispatherServlet` 在 web 配置中即可。\n2. 在初始化一个 web configuration 时，当使用的 Servlet2.5 web 容器，且请求非 spring mvc （struts 、 jsf 之类），需要注册 `org.springframework.web.context.request.RequestContextListener` 到 web 配置中，如果使用 servlet3.0 使用 `WebApplicationInitializer` 接口将自动完成以上注册。\n3. 如果使用 listener 还有问题，可注册 `org.springframework.web.filter.RequestContextFilter` 到 web 中。\n4. 前面的 servlet/listener/filter 的目标只有一个：将 HTTP request 对象按名绑定到服务此请求的线程上。这就让请求域与会话域的 bean 在调用链更下游可用。\n\n四个 web bean scope\n\n1. request scope\n   1. 在 xml 配置中： `<bean id=\"loginAction\" class=\"com.something.LoginAction\" scope=\"request\"/>`\n   2. java configuration: `@RequestScope` 在请求类上注解\n   3. 效果：每次请求调用此 bean 将会产生一个新的 bean 实例来处理此次请求，请求与请求之间不互扰。当此次请求完成，bean 被废弃。\n2. session scope\n   1. xml 配置方式: `<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\"/>`\n   2. java 配置方式: `@SessionScope`\n   3. 效果：bean 实例的产生取决于一个 HTTP session 的生命周期，在同一个 HTTP 会话中，此 bean 实例都是有效的。只有当此次 HTTP 会话结束，bean 才会被废弃。所以在同一次会话中，不同的请求的状态变化将会相互影响。\n3. application scope\n   1. xml 配置方式：`<bean id=\"appPreferences\" class=\"com.something.AppPreferences\" scope=\"application\"/>`\n   2. java 配置方式： `@ApplicationScope`\n   3. 效果：整个 web 应用只生产一个 application scope 的 bean 。bean 域被划分到 ServletContext 级别，并且被存储为一个常规的 ServletContext 属性。类似于 spring 的 singleton scope，但有两点不同：\n      1. application scope  是每个 servlet 生产一个实例，而 spring 的 singleton scope 是每个 ApplicationContext 生产一个实例（一个应用中可能有多个 ApplicationContext）。\n      2. application scope bean 实际上是显露在外的，在 ServletContext 中属性可见。\n4. 依赖域的 bean[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-custom)\n   1. 当需要将一个短生命周期的 beanA(session scope) 注入一个相对长生命周期的 beanB(singleton scope) 中时，会出现 beanA 已经被丢弃而 beanB 依然去调用 beanA。\n   2. 添加 AOP 代理配置到 beanA ，代理会将短生命周期的 beanA 序列化存储起来，在 beanB 需要调用时实际上调用代理，代理去查找需要实际调用的实例，找不到则反序列化成为对象 beanA 再次调用此 beanA。\n   3. 如果代理的对象是 ptototype scope，则代理每次调用时将产生一个新的 beanA 实例供调用。\n   4. 代理 scope 并非唯一的在长域 bean 访问短域 bean 的方式，也可定义注入点（构造器、setter argument、autowired field）为 `ObjectFactory<MyBean>` ，通过调用其 `getObject()` 获取新的实例 bean。\n\n### .4.2. 协调作用域不同的 bean\n\n> 当 singleton bean 依赖于 prototype bean 时，会因为 spring 窗口初始化时会先预初始化 singleton bean ，如果  singleton bean 依赖于 prototype bean ，就不得不先将依赖的 prototype bean 初始化好，再注入到 singleton bean。这就带来一个不同步的问题（多个 singleton bean 依赖了同一个 prototype bean）。\n\n解决不同步的方法：\n\n1. 放弃依赖注入。每次需要 prototype bean 时都向窗口请求新的 bean 实例，这样每次都会产生新的 bean 实例（但是作为 prototype bean 的确是每次都产生新的实例，这里没有搞懂）。\n2. 利用方法注入。通常使用 `lookup` 方法注入，此方法会让 spring 容器重写容器中的 bean 的抽象或具体方法，返回查找容器中其他 bean 的结果，被查找的 bean 通常是一个 non-singleton bean 。 spring 通过使用 JDK 动态代理或者 cglib 库修改客户端代码实现上述动作。\n   1. 为了使用lookup方法注入，大致需要如下两步：\n        1. 将调用者Bean的实现类定义为抽象类，并定义一个抽象方法来获取被依赖的Bean。\n        2. 在 `<bean.../>` 元素中添加 `<lookup-method.../>` 子元素让 Spring 为调用者 Bean 的实现类实现指定的抽象方法。\n\n_Spring会采用运行时动态增强的方式来实现 `<lookup-method.../>`元素所指定的抽象方法，如果目标抽象类实现过接口，Spring 会采用 JDK 动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0 的 spring-core-xxx.jar 包中已经集成了 cglib 类库。_\n\n## .5. Dependencies\n\nspring IoC 容器中各个 bean 相互依赖。\n\n### .5.1. Dependency injection\n\n依赖注入\n\n依赖注入的方法主要有两种：构造器注入、工厂方法注入、setter 注入\n\n区别：constructor 与工厂方法注入在初始化就注入，而 setter 注入在初始化后注入依赖。\n\n#### .5.1.1. constructor injection\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection)\n\n1. 构造器注入与工厂方法注入类似，都在本 bean 初始化时将依赖注入。\n2. 当构造参数或工厂方法参数存在继承关系时，参数匹配会模糊不清。解决方案：\n   1. 添加参数 index （从 0 开始）；\n   2. 指定参数类型：\n\n   ```xml\n   <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n        <constructor-arg type=\"int\" value=\"7500000\"/>\n        <constructor-arg type=\"java.lang.String\" value=\"42\"/>\n    </bean>\n   ```\n\n   1. 指定参数名，同时需要在方法上添加 `@ConstructorProperties({\"years\", \"ultimateAnswer\"})`；\n\n#### .5.1.2. setter injection\n\n在 bean 实例化后调用，同一个 bean 的依赖注入两种方式都可使用。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection)\n\n#### .5.1.3. 依赖解析\n\n1. `ApplicationContext` 通过配置元数据创建并初始化，配置数据可以通过 xml/Java code/annotations 完成。\n2. 每个 bean 的依赖表现为 bean 的属性、构造器参数、工厂方法参数形式，当 bean 被创建时，这些依赖已准备好。\n3. 对于 bean 来说，每个依赖等同于被设置的值或 IoC 容器中其他 bean 引用。\n4. bean 的每个属性实际上是从指定的格式转换为其需要的类型。spring 可以将一个 String 类型的值转换为内置的类型（如：int boolean long）。\n5. 默认 spring IoC 容器在创建时会将 bean scope 域定为 singleton，且会预先初始化 bean ，否则只有在请求时才会被创建。\n6. bean 的创建可能会形成图形结构：bean 的依赖的创建及其依赖的依赖的创建。\n\n##### .5.1.3.1. 循环依赖\n\nbean 之间相互 constructor 依赖。beanA 依赖了 beanB ，同时 beanB 依赖了 beanA，且两者的依赖都是通过构造器依赖。当出现循环依赖时，IoC 在运行时会抛出 `BeanCurrentlyInCreationException`。\n\n解决方案：配置其中一个（或全部） bean 使用 setter 注入。虽然不推荐，但可以使用 setter 注入配置循环依赖。\n\n循环依赖与正常依赖不同之处：循环依赖其中一个 bean 强制在完全初始化前注入另一个 bean 。_IoC container 来做的？_\n\n##### .5.1.3.2. spring 依赖加载特性\n\n1. spring 在容器加载时会自动检测配置的潜在问题，诸如：引用缺失、循环依赖；\n2. spring 实际创建 bean 时会尽晚地设置属性和解析依赖（在未使用某个依赖前并不注入此依赖），这意味着在 spring container 正确加载后请求对象会出现创建对象或其依赖的异常，比如：bean throws a exception of  a missing of invalid property。为此，`ApplicationContext` 的实现默认预先初始化 singleton scope beans。用预先的时间与内存消耗来初始化 bean 在 `ApplicationContext` 创建时显露出配置的问题。\n\n### .5.2. Depends On\n\n使用 `depends-on` 属性决定本 bean 的初始化依赖于其他的 bean，Spring 会在本 bean 初始化前完成依赖的 bean 的初始化，同时在销毁依赖的 bean 前先销毁本 bean 。\n\n### .5.3. lazy-initialized beans\n\n指定懒加载 bean 。\n\n- 使用 `lazy-init=true` 指定 bean 懒加载。\n- 使用懒加载的 bean 即使是 singleton scope 也不会在 container 初始化时预先初始化此 bean，而是在第一次请求到此 bean 时才会初始化。\n- 当一个懒加载的 bean 是一个非懒加载 singleton scope bean 的依赖时，此 bean 一样会因为需要预先实例化其他 bean 而被实例化用以装配。\n- 设置容器全局懒加载 `<beans default-lazy-init=\"true\">`。\n\n### .5.4. AutoWiring Collaborators\n\n设置自动装配 bean 。\n\n- 在 `<bean/>` 配置中添加 `autowire` 属性使用自动装配。\n- 自动装配有 4 种模式：\n    - `no` ，默认模式，不使用自动装配，在大型系统中不推荐覆盖此配置。显式地指定各个 bean 更利于清晰控制系统。\n    - `byName` ，通过 bean property 名自动装配，spring 在容器中查找与 property（此 property 必须有其 setter） 名相同的 bean 用以装配。\n    - `byType`，通过 porperty 类型自动装配，spring 在容器中查找类型与其一致的 bean 进行装配，如果未找到，此 property 将不会被装配，如果找到多个将抛出异常。\n    - `constructor`，与 `byType` 类似，不过只应用于 constructor 参数。如果没有类型一致的 bean，将抛出异常。\n- `byType` 和 `constructor` 可以装配一个类型匹配的数组或集合。这种情况下，容器中所有类型匹配的 bean 都会被装配在其中，如果使用 map 来接收，其 key 就是 bean name 。\n\n#### .5.4.1. 使用自动装配的不足\n\n1. 显式地指定装配会自动装配，同时自动装配不能装配一个基本类型数据、String、Class 和这些类型的数组；\n2. 自动装配相对显式装配指代不够清晰；\n3. 当容器中有多个符合条件的 bean 而装配处只需要单个时，会抛出错误。\n\n解决方案：\n\n1. 放弃使用自动装配，使用显式装配；\n2. 将被装配 bean `autowire-candidate` 设为 `false`（此属性只对 `byType` 自动装配有效，如果装配处指定自动装配为 `byName` 一样可以自动装配到此 bean）；\n3. 在多个符合条件的 bean 中挑选一个作为主候选 bean ，指定其 `<bean/>` 中属性 `primary=true`；\n4. 使用更细粒度控制的注解配置。\n\n## .6. 自定义 bean 特性\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-nature)\n\n- 使用 `@PostConstruct` 与 `@PreDestroy` 代替实现 `InitializingBean` 与 `DisposableBean` 接口，代码与 spring 解耦；\n- 指定 `<bean/>` 属性 `destroy-method=inferred`，可使 spring 自动推断 bean 销毁前执行公共回调方法，如：`close()/shutdown()`。同理在 `<beans/>` 中设定属性 `default-destroy-method=inferred` 可指定所有的 bean 的销毁前回调方法；\n- 可在 `<beans/>` 中添加属性 `default-init-method=\"init\"` 指定默认的初始化回调方法名，让配置中所有的 bean 都保持一致调用名此回调；\n\n### .6.1. 指定回调方法\n\n在 spring 2.5 后，指定回调方法有 3 种\n\n1. 实现 `InitializingBean` `DisposableBean` 回调接口；\n2. 自定义的 `init()` `close()` 方法；\n3. 使用 `@PostConstruct` `@PreDestroy` 注解在方法上。\n\n当 bean 有多个生命周期回调且方法不一样时，回调都将被执行，其顺序是 : 3 -> 1 -> 2\n\n**Note:** 回调方法执行是在当前对象的依赖都准备好之后，但在代理、拦截器这些机制应用之前，所以 init() 前置回调如果需要访问代理、拦截器之类是做不到的。\n\n### .6.2. Shutting Down the Spring IoC Container Gracefully in Non-Web Applications\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-shutdown)\n\n在 web 工程中， ApplicationContext 的实现代码会在工程关闭时正确地关闭 Spring IoC 容器。而在一个非 web 工程中需要手动地将 Spring IoC 容器关闭注册到 JVM ，以保证在关闭时能释放 singleton 资源。\n\n```java\npublic final class Boot {\n\n    public static void main(final String[] args) throws Exception {\n        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n\n        // add a shutdown hook for the above context...\n        ctx.registerShutdownHook();\n\n        // app runs here...\n\n        // main method exits, hook is called prior to the app shutting down...\n    }\n}\n```\n\n### .6.3. ApplicationContextAware and BeanNameAware\n\n[reference](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-processor)\n\n#### .6.3.1. ApplicationContextAware\n\n实现 ApplicationContextAware 接口获取 ApplicationContext 。以获得操纵 ApplicationContext 的方法。但这样会让业务代码与 Spring 耦合。\n\n可以使用 Spring AutoWiring 特性，自动注入 ApplicationContext 。\n\n#### .6.3.2. BeanNameAware\n\n实现此接口的 bean 会提供一个定义 bean name 的方法，在 bean properties 设置之后且在其初始化回调（`InitializingBean` `afterPorpertiesSet` 或自定义初始化方法）执行之前会执行此方法。\n\n```java\npublic interface BeanNameAware {\n    void setBeanName(String name) throws BeansException;\n}\n```\n\nNote: BeanNameAware 回调执行是在 bean 基础属性配置好之后，在初始化回调 自定义 init 方法/afterPropertiesSet/InitializingBean 执行之前。\n\n## .7. Bean Definition Inheritance\n\n[reference](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions)\n\n> Bean Definition 继承\n\n- xml bean 配置中添加 abstract=true　属性就指定此 bean definition 为抽象，抽象的可以不指定 class\n- `parent=beanId` 指定当前 bean definition 继承目标 bean 。被继承的 bean 可以是抽象的。\n- 抽象的 bean definition 不能被初始化。ApplicationContext 默认会预初始化所有的 singleton，因此所有想被当作模版用 parent bean definition 在指定了class 后一定要指定其为 abstract=true，否则 application context 会对其进行初始化。\n\n## .8. spring bean 零配置支持\n\n> spring 零配置是指通过**注解**来实现 beans.xml 中配置 spring bean 容器的功能\n> 在 spring 配置文件中指定自动扫描的包： `<context:component-scan base-package=\"package.path.name\"/>`\n\n- 使用注解完成配置相对于 xml 配置更为精简，但也与源码耦合，修改配置需要重新编译。通常同一个项目中混合使用两种配置方式。\n- xml 配置中兼容注解配置，使用 `<context:annotation-config/>`\n    - 此配置隐匿地注册了很多 post-processor 包括： `AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, and the aforementioned RequiredAnnotationBeanPostProcessor`\n    - 此配置只查询同一级别的应用上下文的注解，所以如果只是在 DispatcherServlet 的 `WebApplicationContext` 配置，那么就只会扫描到 Controller 而不会扫描到 Service 的注解。\n\n### .8.1. 自动装配与精确装配 spring 4.0\n\n`@Autowired` 指定自动装配\n\n- 可以用来修辞 setter方法/普通方法/实例变量/构造器\n- 使用的是 byType 策略从 spring 容器中查找 bean ，如果容器中有多个同一类型的 bean 就会拋出异常。同时确保所需要的至少有一个是 declared by type ，否则抛出 \"no type match found\"\n- 为解决上述问题，spring 4.0 就增加了 `@Qualifier` 注解\n    - `@Qualifier` 用于精确装配 bean ，其方法是在其中指定 bean id 。因此如果要使用此注解来装配，就得将被装配的 bean id（也就是 beanName，通常的标注注解就这一个属性，默认为 \"\"） 标注出来。\n- 对于 xml 配置与 classpath 扫描，容器能知道具体的类型。但对于工厂方法的 `@Bean` 需要保证返回类型足够明确，特别是对于实现多个接口的 bean ，最好返回 bean 的最具体的类型（至少指定到需要的 bean 类型）。\n- 注解在 bean 集合上\n    - 如果是有序集合（数据、List），可以使用 `@Ordered` `@Priority` 注解标明其顺序，如果未标注，则其顺序为其在容器中注册的顺序。\n    - 如果是 Map ，其 key 是 bean name (String)。\n- `BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource` 这些 Spring 基础工具都是自动解析，直接使用 `@AutoWired` 即可。\n- 可用于 Constructor 上标明此构造器用于生产 bean 用于自动装配。\n\n#### .8.1.1. 自动装配微调\n\n1. 使用 `@Primary` 指定众多实现 bean 中一个为主 bean，当自动装配时优先使用此 bean；\n2. 使用 `@Qualifier` 指定修辞词，在 bean 定义上加入修辞词：`<qualifier value=\"main\"/>` ，使用处加上注解 `@Qualifier(\"main\")` 即指定相应的 bean 为需要的装配对象。\n   1. bean name 是一个默认的后备 qualifier value，所以不用内嵌一个 qualifier 定义 bean，直接使用其 name/id 即可。\n   2. `@AutoWired` 其根本上是类型匹配，附加了 Qualifier 语义匹配。所以不管是指定一个 Qualifier value 还是使用备选的 bean name qualifier，会窄化类型匹配的含义。一个好的 qualifier value 应该独立于其 bean id/name 定义其组件角色，诸如：`main` `EMEA` `persistent`。bean id 在匿名定义时会自动生成。\n   3. 如果通过 bean name 查找 qualifier value 可以不用在注入点添加 `@Qualifier` ，Spring 在没有其他解析指示器（qualifier/primary）处，类型匹配到多个依赖的情况下，会自动匹配注入点名与 bean name 相同的 bean。\n   4. 在使用自动装配加上 `@Qualifier` 注解或相关的 bean name 标记模式下，其查询机制是在 类型匹配的结果集上再进行 bean name 匹配。而 `@Resource` 注解是直接使用 bean id/name 匹配。\n3. 如果注入本身定义为集合、数组类型的 bean，直接使用 `@Resource` 匹配其 bean id/name 。\n4. 从 Spring 4.3 开始，bean 注入可以注入自身。自注入只是一个备选方案，常规的注入中其他的依赖的有更高的优先权。如果注入时有其他可选项，bean 本身不会被注入。可以使用 `@Resource` 来指定 bean id 来注入本身。实际编码中，如果出现需要在事务中同一个 bean 中调用其他方法，就得使用自注入实现 bean 代理（可选的方案还有将需要事务代理的方法抽取到另一个 bean 中）。\n5. `@Resource` 如果注解在方法上，方法只能有一个参数。\n6. 自定义 Qualifier ，自定义一个Qualifier 注解，其被 `@Qualifier` 注解，可为其加上属性，定义 bean 时，为其加上属性值，在注放处加上注解并指定其属性，自动装配时会主动匹配各属性一致的 bean。\n7. 可使用范型约束来达到 qualifier 的效果。在 `@AutoWired` 注入依赖时，如果依赖实现的是一个范型接口，注入点就使用此范型类型作为 type 即可以注入此实现。\n8. `@Qualifier` 定义 bean metadata 直接注解于 class 或 method 之上即可。\n\n### .8.2. @Resource 匹配\n\n> 位于 javax.anotation 包\n\n- 使用 `@Resource` 配置一个 bean 类的依赖，用于指定协作 bean 。这就与 `<property ...>` 中的 ref 属性有相同的效果。\n- 可以用于修改 setter 方法\n- 还可以直接修辞 实例变量。这样使用更为简单，spring 将会使用 javaEE 规范的 field 注入，setter 方法都不用写了。\n- @Resource 注解主要基于 bean name 匹配，同时 byType 类型匹配将作为一个备选策略，如果在容器中找不到指定的 bean name，将进行类型匹工配。\n- 注解在 field 上与字段名匹配，注解在 setter 方法上与类的 property 名匹配。\n- `BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource` 这些 Spring 基础工具都是自动解析，不用 bean define 直接使用 `@Resource` 可进入注入。\n\n### .8.3. @Value 注入配置数据\n\n`@Value` 注入外部属性。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation)\n\n1. 在配置上下文添加外部文件：`@PropertySource(\"classpath:application.properties\")`\n2. 需要注入外部属性数据的地方：`@Value(\"${upper_case}\")` 会注入外部文件的值。\n3. Spring 默认的解析器会解析此配置，如果未找到此属性名，那么会注入此注解的 value `${upper_case}`。\n4. 如果需要更严格地控制外部数据注入，需要静态注入一个 bean : `PropertySourcesPlaceholderConfigurer`\n\n    ```java\n    @Bean\n    public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {\n        return new PropertySourcesPlaceholderConfigurer();\n    }\n    ```\n\n    1. 使用此配置 bean 作为解析器，在 Spring 上下文初始化时就需要保证各个配置点位符能被正确解析（ key 必须存在），否则会抛出错误。\n    2. 此解析器可以添加配置 key 的前后缀。使用方法： `setPlaceholderPrefix()` `setPlaceholderSuffix`\n    3. 可添加默认值：`@Value(\"${upper_case:true}\")`\n5. 内置的解析器提供了简单地类型转换，数据类型可以直接转换成相应类型。\n   1. 可自定义数据转换器\n\n        ```java\n        @Bean\n        public ConversionService conversionService() {\n            DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();\n            conversionService.addConverter(new MyCustomConverter());\n            return conversionService;\n        }\n        ```\n\n6. Spring Boot 默认使用 `PropertySourcesPlaceholderConfigurer` ，其配置的外部文件为 `application.properties` `application.yml`\n\n### .8.4. 使用注解来定制 bean 方法成员的生命周期\n\n现个注解实现(javax.annotation 包)：\n\n- `@PostConstruct` 顾名思义，是在 bean 构造之后执行，修辞的是 bean 的初始化方法；\n- `@PreDestroy` 修辞 bean 销毁之前执行的方法\n\n## .9. Classpath Scanning and Managed Components\n\n配置元数据，Spring 容器会根据元配置数据生成 BeanDefinition，bean 的注入可以通过前面介绍的使用注解实现，但基本的 bean 定义还是使用的 xml 配置。Spring 3.0 开始引入 classpath scan，用以检测 Spring bean 组件。在扫描到的 classes 中，匹配到指定条件且有在容器中注册相应的 bean 定义。\n\n- `@Component` 标注为一个基本组件类，所有的 bean 组件注解都继此元注解，Spring 组件管理的标版。\n- `@Repository` 标注为持久层 DAO 组件类\n- `@Service` 标注为一个 service 层业务逻辑组件类\n- `@Controller` 标注为一个表现层控制器组件类\n\n### .9.1. 自动检测 class 并注册 Bean Definition\n\n- Spring 会自动检测各个标准版本 class 并注册相应的 BeanDefinition 实例（ApplicationContext 信息）。\n- 需要在配置 `Configuration` 类上添加 `@ComponentScan` 注解，其中 `basePackages` 属性可以是基础包名也可以是多个 bean class（用 `,` `;` 或空格 ` ` 分隔）。\n\n### .9.2. Class Scanning Filter\n\n在 Spring Class 扫描中添加过滤器。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-value-annotations)\n\n- Spring 默认的过滤效果是将 `@Component, @Repository, @Service, @Controller, @RestController, @Configuration` 6 个和自定义的注解 class 过滤出来。\n- 在 `@ComponentScan` 中指定属性 `useDefaultFilters=false` 将取消默认扫描的类\n- `includeFilters` 添加过滤器\n- `excludeFilters` 拦截过滤器\n  \n#### .9.2.1. Filter 类型\n\n1. annotation 默认，指定有某个注解的类为目标组件\n2. assignable 指定某个类或接口为目标组件\n3. aspectj AspectJ 类型表达式匹配目标组件\n4. regex 正则表达式匹配目标组件的 bean name\n5. custom 自定义实现 `org.springframework.core.type.TypeFilter` 过滤器\n\n## .10. spring 容器中的 bean 实现不同方法\n\n[参考](https://www.cnblogs.com/duanxz/p/7493276.html)\n\n可以通过 java 配置类来实现 spring beans 的配置：\n\n- @Configuration 等价于 `<Beans></Beans>`\n- @Bean 等价于 `<Bean></Bean>`\n- @ComponentScan 等价于 `<context:component-scan base-package=\"com.dxz.demo\"/>`\n\n[获取 xml applicationContext 方法参考](https://www.cnblogs.com/yjbjingcha/p/6752265.html)\n\n### .10.1. @Bean Annotation\n\n使用 `@Bean` 注册一个实例到 IoC 容器中。\n\n- 当要配置一个需要构造函数构造的 bean 时，需要指定其构造函数的参数。[指定构造器参数 bean](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection)\n- `@Bean` 是一个方法级别的注解，使用在方法之上，方法返回类型即 bean 实例类型。\n- 推荐方法返回具体实例类型而不是接口类型。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation)\n- 对一个 bean 指定生命周期回调\n    - 在 `@Bean` 中指定 `initMethod` `destroyMethod` 两个 bean 方法名，用以决定 bean 在初始化后现销毁前的回调。\n    - `destroyMethod` 默认为 `deferred` 推断模式，在容器销毁前自行推断其销毁方法，如果想在容器销毁时保留 bean ，可以指定 `destroyMethod=\"\"`。\n\n## .11. Naming Bean\n\nbean 的命名[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics)\n\n- 按惯例， bean 命名使用小驼峰。\n- 命名规范保持一致，有助于读与理解。同时，有助于 AOP 通过名字查找 bean 进入增强。\n- 对于 component scan ，Spring 为未命名的 componet 命名。取类的 simple name 小驼峰化为其名。特例：对于类名字母数量不只1个且前两个字符都是大写字母的情况， spring 会保留其原名。\n- 指定多个名：可使用逗号 `,`，分号 `;`，空格 `` 加以分隔。\n\n### .11.1. Aliasing Bean\n\n给 bean 起别名。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics)\n\n`@Bean`\n当一个应用中存在多个子系统，系统之间需要使用同一个 bean\n","source":"_posts/Spring/Spring_Bean.md","raw":"---\nlayout: post\ntitle: Spring bean\ndate: 2017-08-23 02:04:38\ntags: [Spring, Java]\ncategories: [Spring]\n---\n\n> **前言：**\n> Spring 中的 bean 配置就是将各个类配置在 bean.xml 文件中，成为一个个的组件，方便实现各个组件之间的重新装配，这也是实现 spring 的依赖注入的方便法门；\n>\n> 因此就可以理解，一个个的 bean 就是一个个的类的实例，但在 spring 运行时，spring 容器装配各个组件时初始化这些类实例时，也就会涉及到类的构造函数，装配各个组件时会涉及到各种类型参数；\n>\n> Spring中的配置各个 bean 时有许多不曾注意到的小知识点，这儿一并给总结出来。\n<!--more-->\n\n## .1. 知识点\n\n1. Spring 容器初始化各个 bean 组件时，默认组件为 **单态模式**（singleton，也叫单例模式）也就是当这个类只有一个实例，如果要实现非单态（prototype，标准类型），则将这个 bean 的 `singleton` 属性设置为 `false` ；\n2. **构造函数** 的参数的配置，使用 `<constructor-arg>` 标签，多个参数就使用多个此标签，且要保证各个参数的顺序要与构造函数的参数顺序保持一致；\n3. bean 的属性的配置的前提是这个类中相关的属性要有 `setter` 方法；\n4. 在 bean 中配置属性使用 `<property>` 标签，给其赋值时可以后直接使用 `value` 属性也可以使用子元素 `<value>` 标签；\n5. **空字符** 的设置： `<value></value>` 设置的是空字符串 `\"\"` ，如果要设置为 `null` ，要使用 `<null/>` 或者干脆不设置;\n6. **匿名对象的配置** ，类似于 java 中的匿名对象，如果要在一个属性中配置一个未曾配置的对象（也就是这个对象只会被使用一次的情况下，如果专门给其装配一个 bean 组件会造成一定的内存浪费），则其配置时直接将该类的路径写在 `<property>` 标签中，而 **不在其中引入需要提前配置好的 bean 的 id**\n\n```xml\n<property name=\"dao\">\n    //使用匿名对象\n    <bean class=\"com.snail.springdemo.dao.impl.UserDaoImpl\"></bean>\n</property>\n```\n\n- ref 与 idref 之间的区别：\n    1. 两者都是用来设置 bean 的注入对象的；\n    2. 两者检查其引用对象bean是否存在：**ref** 只有在第一次调用时会检查，也就是在 **程序运行中才会抛出错误** ，而 **idref 在程序启动时就会抛出错误** ；\n    3. **idref只有bean、local属性，没有parent属性** ，而 ref 三个属性都有。（ local 表示就在当前配置文件中查找相关的 id，而 parent 表示在父配置文件中找。而 bean 则不会限制，可以在其本身找也可以在其父配置文件中找）；\n- depends-on，设置依赖对象：\n    1. 当我们设置的 bean 实例 a 之前要确保另外一个 bean 实例先实例化，这时就可以使用 `depends-on` 属性：\n\n    ```xml\n    <bean id=\"a\" class=\"com.snail.springdemo.A\" depends-on=\"b\"></bean>\n    <bean id=\"b\" class=\"com.snail.springdemo.B\"></bean>\n    ```\n\n- **初始化方法的执行：** 当我们想要一个 bean 在实例化过程中执行一些初始化方法，同时这些初始化执行过程不能放在构造函数中，这是就可以借助初始化方法的属性 `init-method` 在配置中来达到执行初始化的目标；\n\n```xml\n<bean id=\"test\" class=\"com.kk.springdemo.A\" init-method=\"initMethodName\"></bean>\n```\n\n## .2. spring bean 的自动装配\n\n> 上述情况每个 bean 的装配都由我们自己来在 xml 文件中通过 ref 属性来显式指定。但 spring 中有更为方便的方法：自动装配。\n\n- 在 `<beans>` 中，指定自动装配的属性 `default-autowire` ，对整个 beans 中的 bean 都生效。\n- `<bean>` 中，指定自动装配的属性 `autowire` ，此属性只对当前 bean 生效。\n\n`deault-autowire` 与 `autowire` 可以接受的值与其意义：\n\n- `no` 不使用自动装配。这个时候的 bean 的属性都得使用 ref 指定依赖。 **默认值** ，较大的部署环境中都这样，显式地指定出来方便后期检索。\n- `byName` 此种装配方法是 spring 会在 bean 库中去查找 bean 的 id 属性与当前需要装配的 setter 方法名（会将 setter 方法前面 `set` 去掉，并小写首字母）\n- `byType` 查找 setter 方法中形参的类型与 bean 库中的类型进行匹配。如果找到多个 bean 将会拋出异常，如果没找到不会发生动作\n- `constructor`  匹配 bean 的构造器与 setter 方法形参的构造器是否相同。同样如果找不到会拋出异常。\n- `autodetect` spring 根据 bean 的内部结构自行决定采用 byType 策略还是用 constructor 策略。\n\n_当一个 Bean 既使用自动装配依赖，又使用 ref 显式指定依赖时，则**显式指定的依赖覆盖自动装配依赖**；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大降低了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。_\n\n- 通过设置可以将 Bean 排除在自动装配之外\n\n```xml\n<!--通过设置可以将Bean排除在自动装配之外-->\n<bean id=\"\" autowire-candidate=\"false\"/>\n<!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外-->\n<beans default-autowire-candidates=\"*abc\"/>\n```\n\n_一个模块的 spring 配置文件根节点就是 `<beans>` ，也就是用这个节点来配置了一个 bean 池，再在这个里面配置了各个属性，也就是在这其中配置了各个 bean 与池的其他属性。_\n\n## .3. 创建 bean 的方式\n\n> 共 3 种\n\n创建 bean 的三种方式：\n\n1. 构造器创建 bean ，最常见的创建方式。 如果不采用构造注入， spring 会自动加载此 bean 的默认无参构造器，并将其属性全部初始化（基本类型设置为 0/false，引用类型设为 null）\n2. 静态工厂方法创建 bean 。使用静态工厂创建 bean 时必须指定 `<bean class=\"\">` 这儿的 class 属性就是用来指定静态工厂， factory-method 属性指定工厂的创建方法， 如果此方法需要参数，通过 constructor-arg 属性来指定。\n3. 实例工厂方法创建 bean 。顾名思义，此方法与 静态工厂方法 的不同之处在于使用工厂实例进行创建 bean 。所以这儿能过 factory-bean 来指定工厂实例，再通过 factory-method 指定创建 bean 的方法。如果需要参数通过 constructor-arg 指定参数值。\n\n## .4. Bean Scope\n\nBean scope : bean 领域，指 bean 的生存策略，共 6 种，其中 4 种只存在于 web 应用 context 中。\n\n1. singleton，spring bean 默认的单例，但 spring bean scope 单例与设计模式的单例不同。设计模式中单例是对一个特定 java 类来说的，每个 classloader 只生产一个实例。而 spring bean scope 是指一个 bean 在同一个 IoC 容器只生产一个实例。\n2. prototype, 模版模式，每次请求此 bean 被注入其他 bean 中或通过 `getBean()` 方式获取容器中 bean 时都会创建一个实例。按惯例， prototype scope 用于带状态的 bean ，而 singleton scope 用于无状态 bean 。\n    1. 对于 prototype scope 的 bean ， IoC 容器只负责其初始化、装配、交给需要此 bean 的客户端，并不负责其后的生命周期。所以对一个 prototype scope bean 就算配置了生命周期中 destruction 销毁的回调 IoC 也不会执行，而负责此任务的是 client。\n    2. client 可使用 bean post-processor 对 bean 进行资源管理。在某些方面来讲，IoC 容器对于 prototype scope bean 相当于一个 java new operator。在此之后的生命周期管理都交给了 client。\n3. 当一个 singleton scope beanA 中依赖注入了 prototype scope beanB ，同时，在 beanA 中需要 beanB 的多个不同的实例。IoC 容器在初始化 beanB 时只会在 beanA 中初始化一个 beanB 的实例，当 IoC 容器按顺序给 beanA 装配时只会装配同一个 beanB 实例到 beanA 中。[reference](https://spring.io/blog/2004/08/06/method-injection/)\n   1. 解决问题的方案一：放弃 IoC ，让 beanA 实现 `ApplicationContextAware` 接口让其对 IoC 容器敏感，每个需要 bean 的地方使用 `ApplicationContext.getBean(Bean.class)` 的方式获取，这样获取的 bean 就是一个新的实例。缺点：业务代码与 spring 框架耦合在一起。\n   2. 方案二：IoC 容器方法注入。\n\n    ```xml\n    <bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n        <lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n    </bean>\n    ```\n\n    或使用 annotation `@Lookup(value=\"\")`\n    3. 方法可以是抽象方法也可是具体方法，IoC 容器会通过 CGLIB 为方法所在的类生成子类覆盖方法，所以 `@Lookup` 只能在 IoC 容器能通过常规构造器初始化的 bean 中才能生效。也就是：Lookup 不能为工厂方法生产 bean 方法所替代，因为不能动态地为工厂方法所生产的 bean 提供子类。method 与 class 均不能为 final 修辞。\n    4. 在 spring 使用场景中需要注意：需要为 Lookup 方法提供具体实现，否则 component scanning 之类会过滤掉抽象 bean。同时， Lookup method 不能在 configuration class 中配置的 `@Bean` 方法上生效，需要使用 `@Inject` 之类的注解代替。\n\n### .4.1. Web application bean scope\n\n request/session/application/websocket scope 都用于 web application context，如果是一个普通的应用程序，使胳膊这几个 scope 会抛出 IllegalStateException。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-sing-prot-interaction)\n\n初始化一个 web application configuration:\n\n1. 如果使用 spring mvc scoped this beans，只需要注册一个 `DispatherServlet` 在 web 配置中即可。\n2. 在初始化一个 web configuration 时，当使用的 Servlet2.5 web 容器，且请求非 spring mvc （struts 、 jsf 之类），需要注册 `org.springframework.web.context.request.RequestContextListener` 到 web 配置中，如果使用 servlet3.0 使用 `WebApplicationInitializer` 接口将自动完成以上注册。\n3. 如果使用 listener 还有问题，可注册 `org.springframework.web.filter.RequestContextFilter` 到 web 中。\n4. 前面的 servlet/listener/filter 的目标只有一个：将 HTTP request 对象按名绑定到服务此请求的线程上。这就让请求域与会话域的 bean 在调用链更下游可用。\n\n四个 web bean scope\n\n1. request scope\n   1. 在 xml 配置中： `<bean id=\"loginAction\" class=\"com.something.LoginAction\" scope=\"request\"/>`\n   2. java configuration: `@RequestScope` 在请求类上注解\n   3. 效果：每次请求调用此 bean 将会产生一个新的 bean 实例来处理此次请求，请求与请求之间不互扰。当此次请求完成，bean 被废弃。\n2. session scope\n   1. xml 配置方式: `<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\"/>`\n   2. java 配置方式: `@SessionScope`\n   3. 效果：bean 实例的产生取决于一个 HTTP session 的生命周期，在同一个 HTTP 会话中，此 bean 实例都是有效的。只有当此次 HTTP 会话结束，bean 才会被废弃。所以在同一次会话中，不同的请求的状态变化将会相互影响。\n3. application scope\n   1. xml 配置方式：`<bean id=\"appPreferences\" class=\"com.something.AppPreferences\" scope=\"application\"/>`\n   2. java 配置方式： `@ApplicationScope`\n   3. 效果：整个 web 应用只生产一个 application scope 的 bean 。bean 域被划分到 ServletContext 级别，并且被存储为一个常规的 ServletContext 属性。类似于 spring 的 singleton scope，但有两点不同：\n      1. application scope  是每个 servlet 生产一个实例，而 spring 的 singleton scope 是每个 ApplicationContext 生产一个实例（一个应用中可能有多个 ApplicationContext）。\n      2. application scope bean 实际上是显露在外的，在 ServletContext 中属性可见。\n4. 依赖域的 bean[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-custom)\n   1. 当需要将一个短生命周期的 beanA(session scope) 注入一个相对长生命周期的 beanB(singleton scope) 中时，会出现 beanA 已经被丢弃而 beanB 依然去调用 beanA。\n   2. 添加 AOP 代理配置到 beanA ，代理会将短生命周期的 beanA 序列化存储起来，在 beanB 需要调用时实际上调用代理，代理去查找需要实际调用的实例，找不到则反序列化成为对象 beanA 再次调用此 beanA。\n   3. 如果代理的对象是 ptototype scope，则代理每次调用时将产生一个新的 beanA 实例供调用。\n   4. 代理 scope 并非唯一的在长域 bean 访问短域 bean 的方式，也可定义注入点（构造器、setter argument、autowired field）为 `ObjectFactory<MyBean>` ，通过调用其 `getObject()` 获取新的实例 bean。\n\n### .4.2. 协调作用域不同的 bean\n\n> 当 singleton bean 依赖于 prototype bean 时，会因为 spring 窗口初始化时会先预初始化 singleton bean ，如果  singleton bean 依赖于 prototype bean ，就不得不先将依赖的 prototype bean 初始化好，再注入到 singleton bean。这就带来一个不同步的问题（多个 singleton bean 依赖了同一个 prototype bean）。\n\n解决不同步的方法：\n\n1. 放弃依赖注入。每次需要 prototype bean 时都向窗口请求新的 bean 实例，这样每次都会产生新的 bean 实例（但是作为 prototype bean 的确是每次都产生新的实例，这里没有搞懂）。\n2. 利用方法注入。通常使用 `lookup` 方法注入，此方法会让 spring 容器重写容器中的 bean 的抽象或具体方法，返回查找容器中其他 bean 的结果，被查找的 bean 通常是一个 non-singleton bean 。 spring 通过使用 JDK 动态代理或者 cglib 库修改客户端代码实现上述动作。\n   1. 为了使用lookup方法注入，大致需要如下两步：\n        1. 将调用者Bean的实现类定义为抽象类，并定义一个抽象方法来获取被依赖的Bean。\n        2. 在 `<bean.../>` 元素中添加 `<lookup-method.../>` 子元素让 Spring 为调用者 Bean 的实现类实现指定的抽象方法。\n\n_Spring会采用运行时动态增强的方式来实现 `<lookup-method.../>`元素所指定的抽象方法，如果目标抽象类实现过接口，Spring 会采用 JDK 动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0 的 spring-core-xxx.jar 包中已经集成了 cglib 类库。_\n\n## .5. Dependencies\n\nspring IoC 容器中各个 bean 相互依赖。\n\n### .5.1. Dependency injection\n\n依赖注入\n\n依赖注入的方法主要有两种：构造器注入、工厂方法注入、setter 注入\n\n区别：constructor 与工厂方法注入在初始化就注入，而 setter 注入在初始化后注入依赖。\n\n#### .5.1.1. constructor injection\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection)\n\n1. 构造器注入与工厂方法注入类似，都在本 bean 初始化时将依赖注入。\n2. 当构造参数或工厂方法参数存在继承关系时，参数匹配会模糊不清。解决方案：\n   1. 添加参数 index （从 0 开始）；\n   2. 指定参数类型：\n\n   ```xml\n   <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n        <constructor-arg type=\"int\" value=\"7500000\"/>\n        <constructor-arg type=\"java.lang.String\" value=\"42\"/>\n    </bean>\n   ```\n\n   1. 指定参数名，同时需要在方法上添加 `@ConstructorProperties({\"years\", \"ultimateAnswer\"})`；\n\n#### .5.1.2. setter injection\n\n在 bean 实例化后调用，同一个 bean 的依赖注入两种方式都可使用。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection)\n\n#### .5.1.3. 依赖解析\n\n1. `ApplicationContext` 通过配置元数据创建并初始化，配置数据可以通过 xml/Java code/annotations 完成。\n2. 每个 bean 的依赖表现为 bean 的属性、构造器参数、工厂方法参数形式，当 bean 被创建时，这些依赖已准备好。\n3. 对于 bean 来说，每个依赖等同于被设置的值或 IoC 容器中其他 bean 引用。\n4. bean 的每个属性实际上是从指定的格式转换为其需要的类型。spring 可以将一个 String 类型的值转换为内置的类型（如：int boolean long）。\n5. 默认 spring IoC 容器在创建时会将 bean scope 域定为 singleton，且会预先初始化 bean ，否则只有在请求时才会被创建。\n6. bean 的创建可能会形成图形结构：bean 的依赖的创建及其依赖的依赖的创建。\n\n##### .5.1.3.1. 循环依赖\n\nbean 之间相互 constructor 依赖。beanA 依赖了 beanB ，同时 beanB 依赖了 beanA，且两者的依赖都是通过构造器依赖。当出现循环依赖时，IoC 在运行时会抛出 `BeanCurrentlyInCreationException`。\n\n解决方案：配置其中一个（或全部） bean 使用 setter 注入。虽然不推荐，但可以使用 setter 注入配置循环依赖。\n\n循环依赖与正常依赖不同之处：循环依赖其中一个 bean 强制在完全初始化前注入另一个 bean 。_IoC container 来做的？_\n\n##### .5.1.3.2. spring 依赖加载特性\n\n1. spring 在容器加载时会自动检测配置的潜在问题，诸如：引用缺失、循环依赖；\n2. spring 实际创建 bean 时会尽晚地设置属性和解析依赖（在未使用某个依赖前并不注入此依赖），这意味着在 spring container 正确加载后请求对象会出现创建对象或其依赖的异常，比如：bean throws a exception of  a missing of invalid property。为此，`ApplicationContext` 的实现默认预先初始化 singleton scope beans。用预先的时间与内存消耗来初始化 bean 在 `ApplicationContext` 创建时显露出配置的问题。\n\n### .5.2. Depends On\n\n使用 `depends-on` 属性决定本 bean 的初始化依赖于其他的 bean，Spring 会在本 bean 初始化前完成依赖的 bean 的初始化，同时在销毁依赖的 bean 前先销毁本 bean 。\n\n### .5.3. lazy-initialized beans\n\n指定懒加载 bean 。\n\n- 使用 `lazy-init=true` 指定 bean 懒加载。\n- 使用懒加载的 bean 即使是 singleton scope 也不会在 container 初始化时预先初始化此 bean，而是在第一次请求到此 bean 时才会初始化。\n- 当一个懒加载的 bean 是一个非懒加载 singleton scope bean 的依赖时，此 bean 一样会因为需要预先实例化其他 bean 而被实例化用以装配。\n- 设置容器全局懒加载 `<beans default-lazy-init=\"true\">`。\n\n### .5.4. AutoWiring Collaborators\n\n设置自动装配 bean 。\n\n- 在 `<bean/>` 配置中添加 `autowire` 属性使用自动装配。\n- 自动装配有 4 种模式：\n    - `no` ，默认模式，不使用自动装配，在大型系统中不推荐覆盖此配置。显式地指定各个 bean 更利于清晰控制系统。\n    - `byName` ，通过 bean property 名自动装配，spring 在容器中查找与 property（此 property 必须有其 setter） 名相同的 bean 用以装配。\n    - `byType`，通过 porperty 类型自动装配，spring 在容器中查找类型与其一致的 bean 进行装配，如果未找到，此 property 将不会被装配，如果找到多个将抛出异常。\n    - `constructor`，与 `byType` 类似，不过只应用于 constructor 参数。如果没有类型一致的 bean，将抛出异常。\n- `byType` 和 `constructor` 可以装配一个类型匹配的数组或集合。这种情况下，容器中所有类型匹配的 bean 都会被装配在其中，如果使用 map 来接收，其 key 就是 bean name 。\n\n#### .5.4.1. 使用自动装配的不足\n\n1. 显式地指定装配会自动装配，同时自动装配不能装配一个基本类型数据、String、Class 和这些类型的数组；\n2. 自动装配相对显式装配指代不够清晰；\n3. 当容器中有多个符合条件的 bean 而装配处只需要单个时，会抛出错误。\n\n解决方案：\n\n1. 放弃使用自动装配，使用显式装配；\n2. 将被装配 bean `autowire-candidate` 设为 `false`（此属性只对 `byType` 自动装配有效，如果装配处指定自动装配为 `byName` 一样可以自动装配到此 bean）；\n3. 在多个符合条件的 bean 中挑选一个作为主候选 bean ，指定其 `<bean/>` 中属性 `primary=true`；\n4. 使用更细粒度控制的注解配置。\n\n## .6. 自定义 bean 特性\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-nature)\n\n- 使用 `@PostConstruct` 与 `@PreDestroy` 代替实现 `InitializingBean` 与 `DisposableBean` 接口，代码与 spring 解耦；\n- 指定 `<bean/>` 属性 `destroy-method=inferred`，可使 spring 自动推断 bean 销毁前执行公共回调方法，如：`close()/shutdown()`。同理在 `<beans/>` 中设定属性 `default-destroy-method=inferred` 可指定所有的 bean 的销毁前回调方法；\n- 可在 `<beans/>` 中添加属性 `default-init-method=\"init\"` 指定默认的初始化回调方法名，让配置中所有的 bean 都保持一致调用名此回调；\n\n### .6.1. 指定回调方法\n\n在 spring 2.5 后，指定回调方法有 3 种\n\n1. 实现 `InitializingBean` `DisposableBean` 回调接口；\n2. 自定义的 `init()` `close()` 方法；\n3. 使用 `@PostConstruct` `@PreDestroy` 注解在方法上。\n\n当 bean 有多个生命周期回调且方法不一样时，回调都将被执行，其顺序是 : 3 -> 1 -> 2\n\n**Note:** 回调方法执行是在当前对象的依赖都准备好之后，但在代理、拦截器这些机制应用之前，所以 init() 前置回调如果需要访问代理、拦截器之类是做不到的。\n\n### .6.2. Shutting Down the Spring IoC Container Gracefully in Non-Web Applications\n\n[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-shutdown)\n\n在 web 工程中， ApplicationContext 的实现代码会在工程关闭时正确地关闭 Spring IoC 容器。而在一个非 web 工程中需要手动地将 Spring IoC 容器关闭注册到 JVM ，以保证在关闭时能释放 singleton 资源。\n\n```java\npublic final class Boot {\n\n    public static void main(final String[] args) throws Exception {\n        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n\n        // add a shutdown hook for the above context...\n        ctx.registerShutdownHook();\n\n        // app runs here...\n\n        // main method exits, hook is called prior to the app shutting down...\n    }\n}\n```\n\n### .6.3. ApplicationContextAware and BeanNameAware\n\n[reference](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-processor)\n\n#### .6.3.1. ApplicationContextAware\n\n实现 ApplicationContextAware 接口获取 ApplicationContext 。以获得操纵 ApplicationContext 的方法。但这样会让业务代码与 Spring 耦合。\n\n可以使用 Spring AutoWiring 特性，自动注入 ApplicationContext 。\n\n#### .6.3.2. BeanNameAware\n\n实现此接口的 bean 会提供一个定义 bean name 的方法，在 bean properties 设置之后且在其初始化回调（`InitializingBean` `afterPorpertiesSet` 或自定义初始化方法）执行之前会执行此方法。\n\n```java\npublic interface BeanNameAware {\n    void setBeanName(String name) throws BeansException;\n}\n```\n\nNote: BeanNameAware 回调执行是在 bean 基础属性配置好之后，在初始化回调 自定义 init 方法/afterPropertiesSet/InitializingBean 执行之前。\n\n## .7. Bean Definition Inheritance\n\n[reference](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions)\n\n> Bean Definition 继承\n\n- xml bean 配置中添加 abstract=true　属性就指定此 bean definition 为抽象，抽象的可以不指定 class\n- `parent=beanId` 指定当前 bean definition 继承目标 bean 。被继承的 bean 可以是抽象的。\n- 抽象的 bean definition 不能被初始化。ApplicationContext 默认会预初始化所有的 singleton，因此所有想被当作模版用 parent bean definition 在指定了class 后一定要指定其为 abstract=true，否则 application context 会对其进行初始化。\n\n## .8. spring bean 零配置支持\n\n> spring 零配置是指通过**注解**来实现 beans.xml 中配置 spring bean 容器的功能\n> 在 spring 配置文件中指定自动扫描的包： `<context:component-scan base-package=\"package.path.name\"/>`\n\n- 使用注解完成配置相对于 xml 配置更为精简，但也与源码耦合，修改配置需要重新编译。通常同一个项目中混合使用两种配置方式。\n- xml 配置中兼容注解配置，使用 `<context:annotation-config/>`\n    - 此配置隐匿地注册了很多 post-processor 包括： `AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, and the aforementioned RequiredAnnotationBeanPostProcessor`\n    - 此配置只查询同一级别的应用上下文的注解，所以如果只是在 DispatcherServlet 的 `WebApplicationContext` 配置，那么就只会扫描到 Controller 而不会扫描到 Service 的注解。\n\n### .8.1. 自动装配与精确装配 spring 4.0\n\n`@Autowired` 指定自动装配\n\n- 可以用来修辞 setter方法/普通方法/实例变量/构造器\n- 使用的是 byType 策略从 spring 容器中查找 bean ，如果容器中有多个同一类型的 bean 就会拋出异常。同时确保所需要的至少有一个是 declared by type ，否则抛出 \"no type match found\"\n- 为解决上述问题，spring 4.0 就增加了 `@Qualifier` 注解\n    - `@Qualifier` 用于精确装配 bean ，其方法是在其中指定 bean id 。因此如果要使用此注解来装配，就得将被装配的 bean id（也就是 beanName，通常的标注注解就这一个属性，默认为 \"\"） 标注出来。\n- 对于 xml 配置与 classpath 扫描，容器能知道具体的类型。但对于工厂方法的 `@Bean` 需要保证返回类型足够明确，特别是对于实现多个接口的 bean ，最好返回 bean 的最具体的类型（至少指定到需要的 bean 类型）。\n- 注解在 bean 集合上\n    - 如果是有序集合（数据、List），可以使用 `@Ordered` `@Priority` 注解标明其顺序，如果未标注，则其顺序为其在容器中注册的顺序。\n    - 如果是 Map ，其 key 是 bean name (String)。\n- `BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource` 这些 Spring 基础工具都是自动解析，直接使用 `@AutoWired` 即可。\n- 可用于 Constructor 上标明此构造器用于生产 bean 用于自动装配。\n\n#### .8.1.1. 自动装配微调\n\n1. 使用 `@Primary` 指定众多实现 bean 中一个为主 bean，当自动装配时优先使用此 bean；\n2. 使用 `@Qualifier` 指定修辞词，在 bean 定义上加入修辞词：`<qualifier value=\"main\"/>` ，使用处加上注解 `@Qualifier(\"main\")` 即指定相应的 bean 为需要的装配对象。\n   1. bean name 是一个默认的后备 qualifier value，所以不用内嵌一个 qualifier 定义 bean，直接使用其 name/id 即可。\n   2. `@AutoWired` 其根本上是类型匹配，附加了 Qualifier 语义匹配。所以不管是指定一个 Qualifier value 还是使用备选的 bean name qualifier，会窄化类型匹配的含义。一个好的 qualifier value 应该独立于其 bean id/name 定义其组件角色，诸如：`main` `EMEA` `persistent`。bean id 在匿名定义时会自动生成。\n   3. 如果通过 bean name 查找 qualifier value 可以不用在注入点添加 `@Qualifier` ，Spring 在没有其他解析指示器（qualifier/primary）处，类型匹配到多个依赖的情况下，会自动匹配注入点名与 bean name 相同的 bean。\n   4. 在使用自动装配加上 `@Qualifier` 注解或相关的 bean name 标记模式下，其查询机制是在 类型匹配的结果集上再进行 bean name 匹配。而 `@Resource` 注解是直接使用 bean id/name 匹配。\n3. 如果注入本身定义为集合、数组类型的 bean，直接使用 `@Resource` 匹配其 bean id/name 。\n4. 从 Spring 4.3 开始，bean 注入可以注入自身。自注入只是一个备选方案，常规的注入中其他的依赖的有更高的优先权。如果注入时有其他可选项，bean 本身不会被注入。可以使用 `@Resource` 来指定 bean id 来注入本身。实际编码中，如果出现需要在事务中同一个 bean 中调用其他方法，就得使用自注入实现 bean 代理（可选的方案还有将需要事务代理的方法抽取到另一个 bean 中）。\n5. `@Resource` 如果注解在方法上，方法只能有一个参数。\n6. 自定义 Qualifier ，自定义一个Qualifier 注解，其被 `@Qualifier` 注解，可为其加上属性，定义 bean 时，为其加上属性值，在注放处加上注解并指定其属性，自动装配时会主动匹配各属性一致的 bean。\n7. 可使用范型约束来达到 qualifier 的效果。在 `@AutoWired` 注入依赖时，如果依赖实现的是一个范型接口，注入点就使用此范型类型作为 type 即可以注入此实现。\n8. `@Qualifier` 定义 bean metadata 直接注解于 class 或 method 之上即可。\n\n### .8.2. @Resource 匹配\n\n> 位于 javax.anotation 包\n\n- 使用 `@Resource` 配置一个 bean 类的依赖，用于指定协作 bean 。这就与 `<property ...>` 中的 ref 属性有相同的效果。\n- 可以用于修改 setter 方法\n- 还可以直接修辞 实例变量。这样使用更为简单，spring 将会使用 javaEE 规范的 field 注入，setter 方法都不用写了。\n- @Resource 注解主要基于 bean name 匹配，同时 byType 类型匹配将作为一个备选策略，如果在容器中找不到指定的 bean name，将进行类型匹工配。\n- 注解在 field 上与字段名匹配，注解在 setter 方法上与类的 property 名匹配。\n- `BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource` 这些 Spring 基础工具都是自动解析，不用 bean define 直接使用 `@Resource` 可进入注入。\n\n### .8.3. @Value 注入配置数据\n\n`@Value` 注入外部属性。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation)\n\n1. 在配置上下文添加外部文件：`@PropertySource(\"classpath:application.properties\")`\n2. 需要注入外部属性数据的地方：`@Value(\"${upper_case}\")` 会注入外部文件的值。\n3. Spring 默认的解析器会解析此配置，如果未找到此属性名，那么会注入此注解的 value `${upper_case}`。\n4. 如果需要更严格地控制外部数据注入，需要静态注入一个 bean : `PropertySourcesPlaceholderConfigurer`\n\n    ```java\n    @Bean\n    public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {\n        return new PropertySourcesPlaceholderConfigurer();\n    }\n    ```\n\n    1. 使用此配置 bean 作为解析器，在 Spring 上下文初始化时就需要保证各个配置点位符能被正确解析（ key 必须存在），否则会抛出错误。\n    2. 此解析器可以添加配置 key 的前后缀。使用方法： `setPlaceholderPrefix()` `setPlaceholderSuffix`\n    3. 可添加默认值：`@Value(\"${upper_case:true}\")`\n5. 内置的解析器提供了简单地类型转换，数据类型可以直接转换成相应类型。\n   1. 可自定义数据转换器\n\n        ```java\n        @Bean\n        public ConversionService conversionService() {\n            DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();\n            conversionService.addConverter(new MyCustomConverter());\n            return conversionService;\n        }\n        ```\n\n6. Spring Boot 默认使用 `PropertySourcesPlaceholderConfigurer` ，其配置的外部文件为 `application.properties` `application.yml`\n\n### .8.4. 使用注解来定制 bean 方法成员的生命周期\n\n现个注解实现(javax.annotation 包)：\n\n- `@PostConstruct` 顾名思义，是在 bean 构造之后执行，修辞的是 bean 的初始化方法；\n- `@PreDestroy` 修辞 bean 销毁之前执行的方法\n\n## .9. Classpath Scanning and Managed Components\n\n配置元数据，Spring 容器会根据元配置数据生成 BeanDefinition，bean 的注入可以通过前面介绍的使用注解实现，但基本的 bean 定义还是使用的 xml 配置。Spring 3.0 开始引入 classpath scan，用以检测 Spring bean 组件。在扫描到的 classes 中，匹配到指定条件且有在容器中注册相应的 bean 定义。\n\n- `@Component` 标注为一个基本组件类，所有的 bean 组件注解都继此元注解，Spring 组件管理的标版。\n- `@Repository` 标注为持久层 DAO 组件类\n- `@Service` 标注为一个 service 层业务逻辑组件类\n- `@Controller` 标注为一个表现层控制器组件类\n\n### .9.1. 自动检测 class 并注册 Bean Definition\n\n- Spring 会自动检测各个标准版本 class 并注册相应的 BeanDefinition 实例（ApplicationContext 信息）。\n- 需要在配置 `Configuration` 类上添加 `@ComponentScan` 注解，其中 `basePackages` 属性可以是基础包名也可以是多个 bean class（用 `,` `;` 或空格 ` ` 分隔）。\n\n### .9.2. Class Scanning Filter\n\n在 Spring Class 扫描中添加过滤器。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-value-annotations)\n\n- Spring 默认的过滤效果是将 `@Component, @Repository, @Service, @Controller, @RestController, @Configuration` 6 个和自定义的注解 class 过滤出来。\n- 在 `@ComponentScan` 中指定属性 `useDefaultFilters=false` 将取消默认扫描的类\n- `includeFilters` 添加过滤器\n- `excludeFilters` 拦截过滤器\n  \n#### .9.2.1. Filter 类型\n\n1. annotation 默认，指定有某个注解的类为目标组件\n2. assignable 指定某个类或接口为目标组件\n3. aspectj AspectJ 类型表达式匹配目标组件\n4. regex 正则表达式匹配目标组件的 bean name\n5. custom 自定义实现 `org.springframework.core.type.TypeFilter` 过滤器\n\n## .10. spring 容器中的 bean 实现不同方法\n\n[参考](https://www.cnblogs.com/duanxz/p/7493276.html)\n\n可以通过 java 配置类来实现 spring beans 的配置：\n\n- @Configuration 等价于 `<Beans></Beans>`\n- @Bean 等价于 `<Bean></Bean>`\n- @ComponentScan 等价于 `<context:component-scan base-package=\"com.dxz.demo\"/>`\n\n[获取 xml applicationContext 方法参考](https://www.cnblogs.com/yjbjingcha/p/6752265.html)\n\n### .10.1. @Bean Annotation\n\n使用 `@Bean` 注册一个实例到 IoC 容器中。\n\n- 当要配置一个需要构造函数构造的 bean 时，需要指定其构造函数的参数。[指定构造器参数 bean](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection)\n- `@Bean` 是一个方法级别的注解，使用在方法之上，方法返回类型即 bean 实例类型。\n- 推荐方法返回具体实例类型而不是接口类型。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation)\n- 对一个 bean 指定生命周期回调\n    - 在 `@Bean` 中指定 `initMethod` `destroyMethod` 两个 bean 方法名，用以决定 bean 在初始化后现销毁前的回调。\n    - `destroyMethod` 默认为 `deferred` 推断模式，在容器销毁前自行推断其销毁方法，如果想在容器销毁时保留 bean ，可以指定 `destroyMethod=\"\"`。\n\n## .11. Naming Bean\n\nbean 的命名[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics)\n\n- 按惯例， bean 命名使用小驼峰。\n- 命名规范保持一致，有助于读与理解。同时，有助于 AOP 通过名字查找 bean 进入增强。\n- 对于 component scan ，Spring 为未命名的 componet 命名。取类的 simple name 小驼峰化为其名。特例：对于类名字母数量不只1个且前两个字符都是大写字母的情况， spring 会保留其原名。\n- 指定多个名：可使用逗号 `,`，分号 `;`，空格 `` 加以分隔。\n\n### .11.1. Aliasing Bean\n\n给 bean 起别名。[reference](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics)\n\n`@Bean`\n当一个应用中存在多个子系统，系统之间需要使用同一个 bean\n","slug":"Spring/Spring_Bean","published":1,"updated":"2021-02-24T15:22:22.976Z","comments":1,"photos":[],"link":"","_id":"ckljnokt8007a2bhb7y9x0pyt","content":"<blockquote>\n<p><strong>前言：</strong><br>Spring 中的 bean 配置就是将各个类配置在 bean.xml 文件中，成为一个个的组件，方便实现各个组件之间的重新装配，这也是实现 spring 的依赖注入的方便法门；</p>\n<p>因此就可以理解，一个个的 bean 就是一个个的类的实例，但在 spring 运行时，spring 容器装配各个组件时初始化这些类实例时，也就会涉及到类的构造函数，装配各个组件时会涉及到各种类型参数；</p>\n<p>Spring中的配置各个 bean 时有许多不曾注意到的小知识点，这儿一并给总结出来。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"1-知识点\"><a href=\"#1-知识点\" class=\"headerlink\" title=\".1. 知识点\"></a>.1. 知识点</h2><ol>\n<li>Spring 容器初始化各个 bean 组件时，默认组件为 <strong>单态模式</strong>（singleton，也叫单例模式）也就是当这个类只有一个实例，如果要实现非单态（prototype，标准类型），则将这个 bean 的 <code>singleton</code> 属性设置为 <code>false</code> ；</li>\n<li><strong>构造函数</strong> 的参数的配置，使用 <code>&lt;constructor-arg&gt;</code> 标签，多个参数就使用多个此标签，且要保证各个参数的顺序要与构造函数的参数顺序保持一致；</li>\n<li>bean 的属性的配置的前提是这个类中相关的属性要有 <code>setter</code> 方法；</li>\n<li>在 bean 中配置属性使用 <code>&lt;property&gt;</code> 标签，给其赋值时可以后直接使用 <code>value</code> 属性也可以使用子元素 <code>&lt;value&gt;</code> 标签；</li>\n<li><strong>空字符</strong> 的设置： <code>&lt;value&gt;&lt;/value&gt;</code> 设置的是空字符串 <code>&quot;&quot;</code> ，如果要设置为 <code>null</code> ，要使用 <code>&lt;null/&gt;</code> 或者干脆不设置;</li>\n<li><strong>匿名对象的配置</strong> ，类似于 java 中的匿名对象，如果要在一个属性中配置一个未曾配置的对象（也就是这个对象只会被使用一次的情况下，如果专门给其装配一个 bean 组件会造成一定的内存浪费），则其配置时直接将该类的路径写在 <code>&lt;property&gt;</code> 标签中，而 <strong>不在其中引入需要提前配置好的 bean 的 id</strong></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dao&quot;</span>&gt;</span></span><br><span class=\"line\">    //使用匿名对象</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.springdemo.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>ref 与 idref 之间的区别：</p>\n<ol>\n<li>两者都是用来设置 bean 的注入对象的；</li>\n<li>两者检查其引用对象bean是否存在：<strong>ref</strong> 只有在第一次调用时会检查，也就是在 <strong>程序运行中才会抛出错误</strong> ，而 <strong>idref 在程序启动时就会抛出错误</strong> ；</li>\n<li><strong>idref只有bean、local属性，没有parent属性</strong> ，而 ref 三个属性都有。（ local 表示就在当前配置文件中查找相关的 id，而 parent 表示在父配置文件中找。而 bean 则不会限制，可以在其本身找也可以在其父配置文件中找）；</li>\n</ol>\n</li>\n<li><p>depends-on，设置依赖对象：</p>\n<ol>\n<li><p>当我们设置的 bean 实例 a 之前要确保另外一个 bean 实例先实例化，这时就可以使用 <code>depends-on</code> 属性：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;a&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.springdemo.A&quot;</span> <span class=\"attr\">depends-on</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;b&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.springdemo.B&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>初始化方法的执行：</strong> 当我们想要一个 bean 在实例化过程中执行一些初始化方法，同时这些初始化执行过程不能放在构造函数中，这是就可以借助初始化方法的属性 <code>init-method</code> 在配置中来达到执行初始化的目标；</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.kk.springdemo.A&quot;</span> <span class=\"attr\">init-method</span>=<span class=\"string\">&quot;initMethodName&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-spring-bean-的自动装配\"><a href=\"#2-spring-bean-的自动装配\" class=\"headerlink\" title=\".2. spring bean 的自动装配\"></a>.2. spring bean 的自动装配</h2><blockquote>\n<p>上述情况每个 bean 的装配都由我们自己来在 xml 文件中通过 ref 属性来显式指定。但 spring 中有更为方便的方法：自动装配。</p>\n</blockquote>\n<ul>\n<li>在 <code>&lt;beans&gt;</code> 中，指定自动装配的属性 <code>default-autowire</code> ，对整个 beans 中的 bean 都生效。</li>\n<li><code>&lt;bean&gt;</code> 中，指定自动装配的属性 <code>autowire</code> ，此属性只对当前 bean 生效。</li>\n</ul>\n<p><code>deault-autowire</code> 与 <code>autowire</code> 可以接受的值与其意义：</p>\n<ul>\n<li><code>no</code> 不使用自动装配。这个时候的 bean 的属性都得使用 ref 指定依赖。 <strong>默认值</strong> ，较大的部署环境中都这样，显式地指定出来方便后期检索。</li>\n<li><code>byName</code> 此种装配方法是 spring 会在 bean 库中去查找 bean 的 id 属性与当前需要装配的 setter 方法名（会将 setter 方法前面 <code>set</code> 去掉，并小写首字母）</li>\n<li><code>byType</code> 查找 setter 方法中形参的类型与 bean 库中的类型进行匹配。如果找到多个 bean 将会拋出异常，如果没找到不会发生动作</li>\n<li><code>constructor</code>  匹配 bean 的构造器与 setter 方法形参的构造器是否相同。同样如果找不到会拋出异常。</li>\n<li><code>autodetect</code> spring 根据 bean 的内部结构自行决定采用 byType 策略还是用 constructor 策略。</li>\n</ul>\n<p><em>当一个 Bean 既使用自动装配依赖，又使用 ref 显式指定依赖时，则<strong>显式指定的依赖覆盖自动装配依赖</strong>；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大降低了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。</em></p>\n<ul>\n<li>通过设置可以将 Bean 排除在自动装配之外</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--通过设置可以将Bean排除在自动装配之外--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">autowire-candidate</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">default-autowire-candidates</span>=<span class=\"string\">&quot;*abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>一个模块的 spring 配置文件根节点就是 <code>&lt;beans&gt;</code> ，也就是用这个节点来配置了一个 bean 池，再在这个里面配置了各个属性，也就是在这其中配置了各个 bean 与池的其他属性。</em></p>\n<h2 id=\"3-创建-bean-的方式\"><a href=\"#3-创建-bean-的方式\" class=\"headerlink\" title=\".3. 创建 bean 的方式\"></a>.3. 创建 bean 的方式</h2><blockquote>\n<p>共 3 种</p>\n</blockquote>\n<p>创建 bean 的三种方式：</p>\n<ol>\n<li>构造器创建 bean ，最常见的创建方式。 如果不采用构造注入， spring 会自动加载此 bean 的默认无参构造器，并将其属性全部初始化（基本类型设置为 0/false，引用类型设为 null）</li>\n<li>静态工厂方法创建 bean 。使用静态工厂创建 bean 时必须指定 <code>&lt;bean class=&quot;&quot;&gt;</code> 这儿的 class 属性就是用来指定静态工厂， factory-method 属性指定工厂的创建方法， 如果此方法需要参数，通过 constructor-arg 属性来指定。</li>\n<li>实例工厂方法创建 bean 。顾名思义，此方法与 静态工厂方法 的不同之处在于使用工厂实例进行创建 bean 。所以这儿能过 factory-bean 来指定工厂实例，再通过 factory-method 指定创建 bean 的方法。如果需要参数通过 constructor-arg 指定参数值。</li>\n</ol>\n<h2 id=\"4-Bean-Scope\"><a href=\"#4-Bean-Scope\" class=\"headerlink\" title=\".4. Bean Scope\"></a>.4. Bean Scope</h2><p>Bean scope : bean 领域，指 bean 的生存策略，共 6 种，其中 4 种只存在于 web 应用 context 中。</p>\n<ol>\n<li><p>singleton，spring bean 默认的单例，但 spring bean scope 单例与设计模式的单例不同。设计模式中单例是对一个特定 java 类来说的，每个 classloader 只生产一个实例。而 spring bean scope 是指一个 bean 在同一个 IoC 容器只生产一个实例。</p>\n</li>\n<li><p>prototype, 模版模式，每次请求此 bean 被注入其他 bean 中或通过 <code>getBean()</code> 方式获取容器中 bean 时都会创建一个实例。按惯例， prototype scope 用于带状态的 bean ，而 singleton scope 用于无状态 bean 。</p>\n<ol>\n<li>对于 prototype scope 的 bean ， IoC 容器只负责其初始化、装配、交给需要此 bean 的客户端，并不负责其后的生命周期。所以对一个 prototype scope bean 就算配置了生命周期中 destruction 销毁的回调 IoC 也不会执行，而负责此任务的是 client。</li>\n<li>client 可使用 bean post-processor 对 bean 进行资源管理。在某些方面来讲，IoC 容器对于 prototype scope bean 相当于一个 java new operator。在此之后的生命周期管理都交给了 client。</li>\n</ol>\n</li>\n<li><p>当一个 singleton scope beanA 中依赖注入了 prototype scope beanB ，同时，在 beanA 中需要 beanB 的多个不同的实例。IoC 容器在初始化 beanB 时只会在 beanA 中初始化一个 beanB 的实例，当 IoC 容器按顺序给 beanA 装配时只会装配同一个 beanB 实例到 beanA 中。<a href=\"https://spring.io/blog/2004/08/06/method-injection/\">reference</a></p>\n<ol>\n<li><p>解决问题的方案一：放弃 IoC ，让 beanA 实现 <code>ApplicationContextAware</code> 接口让其对 IoC 容器敏感，每个需要 bean 的地方使用 <code>ApplicationContext.getBean(Bean.class)</code> 的方式获取，这样获取的 bean 就是一个新的实例。缺点：业务代码与 spring 框架耦合在一起。</p>\n</li>\n<li><p>方案二：IoC 容器方法注入。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;commandManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">lookup-method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;createCommand&quot;</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;myCommand&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>或使用 annotation <code>@Lookup(value=&quot;&quot;)</code></p>\n</li>\n<li><p>方法可以是抽象方法也可是具体方法，IoC 容器会通过 CGLIB 为方法所在的类生成子类覆盖方法，所以 <code>@Lookup</code> 只能在 IoC 容器能通过常规构造器初始化的 bean 中才能生效。也就是：Lookup 不能为工厂方法生产 bean 方法所替代，因为不能动态地为工厂方法所生产的 bean 提供子类。method 与 class 均不能为 final 修辞。</p>\n</li>\n<li><p>在 spring 使用场景中需要注意：需要为 Lookup 方法提供具体实现，否则 component scanning 之类会过滤掉抽象 bean。同时， Lookup method 不能在 configuration class 中配置的 <code>@Bean</code> 方法上生效，需要使用 <code>@Inject</code> 之类的注解代替。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-1-Web-application-bean-scope\"><a href=\"#4-1-Web-application-bean-scope\" class=\"headerlink\" title=\".4.1. Web application bean scope\"></a>.4.1. Web application bean scope</h3><p> request/session/application/websocket scope 都用于 web application context，如果是一个普通的应用程序，使胳膊这几个 scope 会抛出 IllegalStateException。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-sing-prot-interaction\">reference</a></p>\n<p>初始化一个 web application configuration:</p>\n<ol>\n<li>如果使用 spring mvc scoped this beans，只需要注册一个 <code>DispatherServlet</code> 在 web 配置中即可。</li>\n<li>在初始化一个 web configuration 时，当使用的 Servlet2.5 web 容器，且请求非 spring mvc （struts 、 jsf 之类），需要注册 <code>org.springframework.web.context.request.RequestContextListener</code> 到 web 配置中，如果使用 servlet3.0 使用 <code>WebApplicationInitializer</code> 接口将自动完成以上注册。</li>\n<li>如果使用 listener 还有问题，可注册 <code>org.springframework.web.filter.RequestContextFilter</code> 到 web 中。</li>\n<li>前面的 servlet/listener/filter 的目标只有一个：将 HTTP request 对象按名绑定到服务此请求的线程上。这就让请求域与会话域的 bean 在调用链更下游可用。</li>\n</ol>\n<p>四个 web bean scope</p>\n<ol>\n<li>request scope<ol>\n<li>在 xml 配置中： <code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.something.LoginAction&quot; scope=&quot;request&quot;/&gt;</code></li>\n<li>java configuration: <code>@RequestScope</code> 在请求类上注解</li>\n<li>效果：每次请求调用此 bean 将会产生一个新的 bean 实例来处理此次请求，请求与请求之间不互扰。当此次请求完成，bean 被废弃。</li>\n</ol>\n</li>\n<li>session scope<ol>\n<li>xml 配置方式: <code>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;/&gt;</code></li>\n<li>java 配置方式: <code>@SessionScope</code></li>\n<li>效果：bean 实例的产生取决于一个 HTTP session 的生命周期，在同一个 HTTP 会话中，此 bean 实例都是有效的。只有当此次 HTTP 会话结束，bean 才会被废弃。所以在同一次会话中，不同的请求的状态变化将会相互影响。</li>\n</ol>\n</li>\n<li>application scope<ol>\n<li>xml 配置方式：<code>&lt;bean id=&quot;appPreferences&quot; class=&quot;com.something.AppPreferences&quot; scope=&quot;application&quot;/&gt;</code></li>\n<li>java 配置方式： <code>@ApplicationScope</code></li>\n<li>效果：整个 web 应用只生产一个 application scope 的 bean 。bean 域被划分到 ServletContext 级别，并且被存储为一个常规的 ServletContext 属性。类似于 spring 的 singleton scope，但有两点不同：<ol>\n<li>application scope  是每个 servlet 生产一个实例，而 spring 的 singleton scope 是每个 ApplicationContext 生产一个实例（一个应用中可能有多个 ApplicationContext）。</li>\n<li>application scope bean 实际上是显露在外的，在 ServletContext 中属性可见。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>依赖域的 bean<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-custom\">reference</a><ol>\n<li>当需要将一个短生命周期的 beanA(session scope) 注入一个相对长生命周期的 beanB(singleton scope) 中时，会出现 beanA 已经被丢弃而 beanB 依然去调用 beanA。</li>\n<li>添加 AOP 代理配置到 beanA ，代理会将短生命周期的 beanA 序列化存储起来，在 beanB 需要调用时实际上调用代理，代理去查找需要实际调用的实例，找不到则反序列化成为对象 beanA 再次调用此 beanA。</li>\n<li>如果代理的对象是 ptototype scope，则代理每次调用时将产生一个新的 beanA 实例供调用。</li>\n<li>代理 scope 并非唯一的在长域 bean 访问短域 bean 的方式，也可定义注入点（构造器、setter argument、autowired field）为 <code>ObjectFactory&lt;MyBean&gt;</code> ，通过调用其 <code>getObject()</code> 获取新的实例 bean。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-2-协调作用域不同的-bean\"><a href=\"#4-2-协调作用域不同的-bean\" class=\"headerlink\" title=\".4.2. 协调作用域不同的 bean\"></a>.4.2. 协调作用域不同的 bean</h3><blockquote>\n<p>当 singleton bean 依赖于 prototype bean 时，会因为 spring 窗口初始化时会先预初始化 singleton bean ，如果  singleton bean 依赖于 prototype bean ，就不得不先将依赖的 prototype bean 初始化好，再注入到 singleton bean。这就带来一个不同步的问题（多个 singleton bean 依赖了同一个 prototype bean）。</p>\n</blockquote>\n<p>解决不同步的方法：</p>\n<ol>\n<li>放弃依赖注入。每次需要 prototype bean 时都向窗口请求新的 bean 实例，这样每次都会产生新的 bean 实例（但是作为 prototype bean 的确是每次都产生新的实例，这里没有搞懂）。</li>\n<li>利用方法注入。通常使用 <code>lookup</code> 方法注入，此方法会让 spring 容器重写容器中的 bean 的抽象或具体方法，返回查找容器中其他 bean 的结果，被查找的 bean 通常是一个 non-singleton bean 。 spring 通过使用 JDK 动态代理或者 cglib 库修改客户端代码实现上述动作。<ol>\n<li>为了使用lookup方法注入，大致需要如下两步：<ol>\n<li>将调用者Bean的实现类定义为抽象类，并定义一个抽象方法来获取被依赖的Bean。</li>\n<li>在 <code>&lt;bean.../&gt;</code> 元素中添加 <code>&lt;lookup-method.../&gt;</code> 子元素让 Spring 为调用者 Bean 的实现类实现指定的抽象方法。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><em>Spring会采用运行时动态增强的方式来实现 <code>&lt;lookup-method.../&gt;</code>元素所指定的抽象方法，如果目标抽象类实现过接口，Spring 会采用 JDK 动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0 的 spring-core-xxx.jar 包中已经集成了 cglib 类库。</em></p>\n<h2 id=\"5-Dependencies\"><a href=\"#5-Dependencies\" class=\"headerlink\" title=\".5. Dependencies\"></a>.5. Dependencies</h2><p>spring IoC 容器中各个 bean 相互依赖。</p>\n<h3 id=\"5-1-Dependency-injection\"><a href=\"#5-1-Dependency-injection\" class=\"headerlink\" title=\".5.1. Dependency injection\"></a>.5.1. Dependency injection</h3><p>依赖注入</p>\n<p>依赖注入的方法主要有两种：构造器注入、工厂方法注入、setter 注入</p>\n<p>区别：constructor 与工厂方法注入在初始化就注入，而 setter 注入在初始化后注入依赖。</p>\n<h4 id=\"5-1-1-constructor-injection\"><a href=\"#5-1-1-constructor-injection\" class=\"headerlink\" title=\".5.1.1. constructor injection\"></a>.5.1.1. constructor injection</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection\">reference</a></p>\n<ol>\n<li><p>构造器注入与工厂方法注入类似，都在本 bean 初始化时将依赖注入。</p>\n</li>\n<li><p>当构造参数或工厂方法参数存在继承关系时，参数匹配会模糊不清。解决方案：</p>\n<ol>\n<li>添加参数 index （从 0 开始）；</li>\n<li>指定参数类型：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;exampleBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;int&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;7500000&quot;</span>/&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;java.lang.String&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;42&quot;</span>/&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>指定参数名，同时需要在方法上添加 <code>@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</code>；</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-1-2-setter-injection\"><a href=\"#5-1-2-setter-injection\" class=\"headerlink\" title=\".5.1.2. setter injection\"></a>.5.1.2. setter injection</h4><p>在 bean 实例化后调用，同一个 bean 的依赖注入两种方式都可使用。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection\">reference</a></p>\n<h4 id=\"5-1-3-依赖解析\"><a href=\"#5-1-3-依赖解析\" class=\"headerlink\" title=\".5.1.3. 依赖解析\"></a>.5.1.3. 依赖解析</h4><ol>\n<li><code>ApplicationContext</code> 通过配置元数据创建并初始化，配置数据可以通过 xml/Java code/annotations 完成。</li>\n<li>每个 bean 的依赖表现为 bean 的属性、构造器参数、工厂方法参数形式，当 bean 被创建时，这些依赖已准备好。</li>\n<li>对于 bean 来说，每个依赖等同于被设置的值或 IoC 容器中其他 bean 引用。</li>\n<li>bean 的每个属性实际上是从指定的格式转换为其需要的类型。spring 可以将一个 String 类型的值转换为内置的类型（如：int boolean long）。</li>\n<li>默认 spring IoC 容器在创建时会将 bean scope 域定为 singleton，且会预先初始化 bean ，否则只有在请求时才会被创建。</li>\n<li>bean 的创建可能会形成图形结构：bean 的依赖的创建及其依赖的依赖的创建。</li>\n</ol>\n<h5 id=\"5-1-3-1-循环依赖\"><a href=\"#5-1-3-1-循环依赖\" class=\"headerlink\" title=\".5.1.3.1. 循环依赖\"></a>.5.1.3.1. 循环依赖</h5><p>bean 之间相互 constructor 依赖。beanA 依赖了 beanB ，同时 beanB 依赖了 beanA，且两者的依赖都是通过构造器依赖。当出现循环依赖时，IoC 在运行时会抛出 <code>BeanCurrentlyInCreationException</code>。</p>\n<p>解决方案：配置其中一个（或全部） bean 使用 setter 注入。虽然不推荐，但可以使用 setter 注入配置循环依赖。</p>\n<p>循环依赖与正常依赖不同之处：循环依赖其中一个 bean 强制在完全初始化前注入另一个 bean 。<em>IoC container 来做的？</em></p>\n<h5 id=\"5-1-3-2-spring-依赖加载特性\"><a href=\"#5-1-3-2-spring-依赖加载特性\" class=\"headerlink\" title=\".5.1.3.2. spring 依赖加载特性\"></a>.5.1.3.2. spring 依赖加载特性</h5><ol>\n<li>spring 在容器加载时会自动检测配置的潜在问题，诸如：引用缺失、循环依赖；</li>\n<li>spring 实际创建 bean 时会尽晚地设置属性和解析依赖（在未使用某个依赖前并不注入此依赖），这意味着在 spring container 正确加载后请求对象会出现创建对象或其依赖的异常，比如：bean throws a exception of  a missing of invalid property。为此，<code>ApplicationContext</code> 的实现默认预先初始化 singleton scope beans。用预先的时间与内存消耗来初始化 bean 在 <code>ApplicationContext</code> 创建时显露出配置的问题。</li>\n</ol>\n<h3 id=\"5-2-Depends-On\"><a href=\"#5-2-Depends-On\" class=\"headerlink\" title=\".5.2. Depends On\"></a>.5.2. Depends On</h3><p>使用 <code>depends-on</code> 属性决定本 bean 的初始化依赖于其他的 bean，Spring 会在本 bean 初始化前完成依赖的 bean 的初始化，同时在销毁依赖的 bean 前先销毁本 bean 。</p>\n<h3 id=\"5-3-lazy-initialized-beans\"><a href=\"#5-3-lazy-initialized-beans\" class=\"headerlink\" title=\".5.3. lazy-initialized beans\"></a>.5.3. lazy-initialized beans</h3><p>指定懒加载 bean 。</p>\n<ul>\n<li>使用 <code>lazy-init=true</code> 指定 bean 懒加载。</li>\n<li>使用懒加载的 bean 即使是 singleton scope 也不会在 container 初始化时预先初始化此 bean，而是在第一次请求到此 bean 时才会初始化。</li>\n<li>当一个懒加载的 bean 是一个非懒加载 singleton scope bean 的依赖时，此 bean 一样会因为需要预先实例化其他 bean 而被实例化用以装配。</li>\n<li>设置容器全局懒加载 <code>&lt;beans default-lazy-init=&quot;true&quot;&gt;</code>。</li>\n</ul>\n<h3 id=\"5-4-AutoWiring-Collaborators\"><a href=\"#5-4-AutoWiring-Collaborators\" class=\"headerlink\" title=\".5.4. AutoWiring Collaborators\"></a>.5.4. AutoWiring Collaborators</h3><p>设置自动装配 bean 。</p>\n<ul>\n<li>在 <code>&lt;bean/&gt;</code> 配置中添加 <code>autowire</code> 属性使用自动装配。</li>\n<li>自动装配有 4 种模式：<ul>\n<li><code>no</code> ，默认模式，不使用自动装配，在大型系统中不推荐覆盖此配置。显式地指定各个 bean 更利于清晰控制系统。</li>\n<li><code>byName</code> ，通过 bean property 名自动装配，spring 在容器中查找与 property（此 property 必须有其 setter） 名相同的 bean 用以装配。</li>\n<li><code>byType</code>，通过 porperty 类型自动装配，spring 在容器中查找类型与其一致的 bean 进行装配，如果未找到，此 property 将不会被装配，如果找到多个将抛出异常。</li>\n<li><code>constructor</code>，与 <code>byType</code> 类似，不过只应用于 constructor 参数。如果没有类型一致的 bean，将抛出异常。</li>\n</ul>\n</li>\n<li><code>byType</code> 和 <code>constructor</code> 可以装配一个类型匹配的数组或集合。这种情况下，容器中所有类型匹配的 bean 都会被装配在其中，如果使用 map 来接收，其 key 就是 bean name 。</li>\n</ul>\n<h4 id=\"5-4-1-使用自动装配的不足\"><a href=\"#5-4-1-使用自动装配的不足\" class=\"headerlink\" title=\".5.4.1. 使用自动装配的不足\"></a>.5.4.1. 使用自动装配的不足</h4><ol>\n<li>显式地指定装配会自动装配，同时自动装配不能装配一个基本类型数据、String、Class 和这些类型的数组；</li>\n<li>自动装配相对显式装配指代不够清晰；</li>\n<li>当容器中有多个符合条件的 bean 而装配处只需要单个时，会抛出错误。</li>\n</ol>\n<p>解决方案：</p>\n<ol>\n<li>放弃使用自动装配，使用显式装配；</li>\n<li>将被装配 bean <code>autowire-candidate</code> 设为 <code>false</code>（此属性只对 <code>byType</code> 自动装配有效，如果装配处指定自动装配为 <code>byName</code> 一样可以自动装配到此 bean）；</li>\n<li>在多个符合条件的 bean 中挑选一个作为主候选 bean ，指定其 <code>&lt;bean/&gt;</code> 中属性 <code>primary=true</code>；</li>\n<li>使用更细粒度控制的注解配置。</li>\n</ol>\n<h2 id=\"6-自定义-bean-特性\"><a href=\"#6-自定义-bean-特性\" class=\"headerlink\" title=\".6. 自定义 bean 特性\"></a>.6. 自定义 bean 特性</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-nature\">reference</a></p>\n<ul>\n<li>使用 <code>@PostConstruct</code> 与 <code>@PreDestroy</code> 代替实现 <code>InitializingBean</code> 与 <code>DisposableBean</code> 接口，代码与 spring 解耦；</li>\n<li>指定 <code>&lt;bean/&gt;</code> 属性 <code>destroy-method=inferred</code>，可使 spring 自动推断 bean 销毁前执行公共回调方法，如：<code>close()/shutdown()</code>。同理在 <code>&lt;beans/&gt;</code> 中设定属性 <code>default-destroy-method=inferred</code> 可指定所有的 bean 的销毁前回调方法；</li>\n<li>可在 <code>&lt;beans/&gt;</code> 中添加属性 <code>default-init-method=&quot;init&quot;</code> 指定默认的初始化回调方法名，让配置中所有的 bean 都保持一致调用名此回调；</li>\n</ul>\n<h3 id=\"6-1-指定回调方法\"><a href=\"#6-1-指定回调方法\" class=\"headerlink\" title=\".6.1. 指定回调方法\"></a>.6.1. 指定回调方法</h3><p>在 spring 2.5 后，指定回调方法有 3 种</p>\n<ol>\n<li>实现 <code>InitializingBean</code> <code>DisposableBean</code> 回调接口；</li>\n<li>自定义的 <code>init()</code> <code>close()</code> 方法；</li>\n<li>使用 <code>@PostConstruct</code> <code>@PreDestroy</code> 注解在方法上。</li>\n</ol>\n<p>当 bean 有多个生命周期回调且方法不一样时，回调都将被执行，其顺序是 : 3 -&gt; 1 -&gt; 2</p>\n<p><strong>Note:</strong> 回调方法执行是在当前对象的依赖都准备好之后，但在代理、拦截器这些机制应用之前，所以 init() 前置回调如果需要访问代理、拦截器之类是做不到的。</p>\n<h3 id=\"6-2-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications\"><a href=\"#6-2-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications\" class=\"headerlink\" title=\".6.2. Shutting Down the Spring IoC Container Gracefully in Non-Web Applications\"></a>.6.2. Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-shutdown\">reference</a></p>\n<p>在 web 工程中， ApplicationContext 的实现代码会在工程关闭时正确地关闭 Spring IoC 容器。而在一个非 web 工程中需要手动地将 Spring IoC 容器关闭注册到 JVM ，以保证在关闭时能释放 singleton 资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Boot</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ConfigurableApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;beans.xml&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add a shutdown hook for the above context...</span></span><br><span class=\"line\">        ctx.registerShutdownHook();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// app runs here...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// main method exits, hook is called prior to the app shutting down...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-3-ApplicationContextAware-and-BeanNameAware\"><a href=\"#6-3-ApplicationContextAware-and-BeanNameAware\" class=\"headerlink\" title=\".6.3. ApplicationContextAware and BeanNameAware\"></a>.6.3. ApplicationContextAware and BeanNameAware</h3><p><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-processor\">reference</a></p>\n<h4 id=\"6-3-1-ApplicationContextAware\"><a href=\"#6-3-1-ApplicationContextAware\" class=\"headerlink\" title=\".6.3.1. ApplicationContextAware\"></a>.6.3.1. ApplicationContextAware</h4><p>实现 ApplicationContextAware 接口获取 ApplicationContext 。以获得操纵 ApplicationContext 的方法。但这样会让业务代码与 Spring 耦合。</p>\n<p>可以使用 Spring AutoWiring 特性，自动注入 ApplicationContext 。</p>\n<h4 id=\"6-3-2-BeanNameAware\"><a href=\"#6-3-2-BeanNameAware\" class=\"headerlink\" title=\".6.3.2. BeanNameAware\"></a>.6.3.2. BeanNameAware</h4><p>实现此接口的 bean 会提供一个定义 bean name 的方法，在 bean properties 设置之后且在其初始化回调（<code>InitializingBean</code> <code>afterPorpertiesSet</code> 或自定义初始化方法）执行之前会执行此方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanNameAware</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBeanName</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: BeanNameAware 回调执行是在 bean 基础属性配置好之后，在初始化回调 自定义 init 方法/afterPropertiesSet/InitializingBean 执行之前。</p>\n<h2 id=\"7-Bean-Definition-Inheritance\"><a href=\"#7-Bean-Definition-Inheritance\" class=\"headerlink\" title=\".7. Bean Definition Inheritance\"></a>.7. Bean Definition Inheritance</h2><p><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions\">reference</a></p>\n<blockquote>\n<p>Bean Definition 继承</p>\n</blockquote>\n<ul>\n<li>xml bean 配置中添加 abstract=true　属性就指定此 bean definition 为抽象，抽象的可以不指定 class</li>\n<li><code>parent=beanId</code> 指定当前 bean definition 继承目标 bean 。被继承的 bean 可以是抽象的。</li>\n<li>抽象的 bean definition 不能被初始化。ApplicationContext 默认会预初始化所有的 singleton，因此所有想被当作模版用 parent bean definition 在指定了class 后一定要指定其为 abstract=true，否则 application context 会对其进行初始化。</li>\n</ul>\n<h2 id=\"8-spring-bean-零配置支持\"><a href=\"#8-spring-bean-零配置支持\" class=\"headerlink\" title=\".8. spring bean 零配置支持\"></a>.8. spring bean 零配置支持</h2><blockquote>\n<p>spring 零配置是指通过<strong>注解</strong>来实现 beans.xml 中配置 spring bean 容器的功能<br>在 spring 配置文件中指定自动扫描的包： <code>&lt;context:component-scan base-package=&quot;package.path.name&quot;/&gt;</code></p>\n</blockquote>\n<ul>\n<li>使用注解完成配置相对于 xml 配置更为精简，但也与源码耦合，修改配置需要重新编译。通常同一个项目中混合使用两种配置方式。</li>\n<li>xml 配置中兼容注解配置，使用 <code>&lt;context:annotation-config/&gt;</code><ul>\n<li>此配置隐匿地注册了很多 post-processor 包括： <code>AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, and the aforementioned RequiredAnnotationBeanPostProcessor</code></li>\n<li>此配置只查询同一级别的应用上下文的注解，所以如果只是在 DispatcherServlet 的 <code>WebApplicationContext</code> 配置，那么就只会扫描到 Controller 而不会扫描到 Service 的注解。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-1-自动装配与精确装配-spring-4-0\"><a href=\"#8-1-自动装配与精确装配-spring-4-0\" class=\"headerlink\" title=\".8.1. 自动装配与精确装配 spring 4.0\"></a>.8.1. 自动装配与精确装配 spring 4.0</h3><p><code>@Autowired</code> 指定自动装配</p>\n<ul>\n<li>可以用来修辞 setter方法/普通方法/实例变量/构造器</li>\n<li>使用的是 byType 策略从 spring 容器中查找 bean ，如果容器中有多个同一类型的 bean 就会拋出异常。同时确保所需要的至少有一个是 declared by type ，否则抛出 “no type match found”</li>\n<li>为解决上述问题，spring 4.0 就增加了 <code>@Qualifier</code> 注解<ul>\n<li><code>@Qualifier</code> 用于精确装配 bean ，其方法是在其中指定 bean id 。因此如果要使用此注解来装配，就得将被装配的 bean id（也就是 beanName，通常的标注注解就这一个属性，默认为 “”） 标注出来。</li>\n</ul>\n</li>\n<li>对于 xml 配置与 classpath 扫描，容器能知道具体的类型。但对于工厂方法的 <code>@Bean</code> 需要保证返回类型足够明确，特别是对于实现多个接口的 bean ，最好返回 bean 的最具体的类型（至少指定到需要的 bean 类型）。</li>\n<li>注解在 bean 集合上<ul>\n<li>如果是有序集合（数据、List），可以使用 <code>@Ordered</code> <code>@Priority</code> 注解标明其顺序，如果未标注，则其顺序为其在容器中注册的顺序。</li>\n<li>如果是 Map ，其 key 是 bean name (String)。</li>\n</ul>\n</li>\n<li><code>BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource</code> 这些 Spring 基础工具都是自动解析，直接使用 <code>@AutoWired</code> 即可。</li>\n<li>可用于 Constructor 上标明此构造器用于生产 bean 用于自动装配。</li>\n</ul>\n<h4 id=\"8-1-1-自动装配微调\"><a href=\"#8-1-1-自动装配微调\" class=\"headerlink\" title=\".8.1.1. 自动装配微调\"></a>.8.1.1. 自动装配微调</h4><ol>\n<li>使用 <code>@Primary</code> 指定众多实现 bean 中一个为主 bean，当自动装配时优先使用此 bean；</li>\n<li>使用 <code>@Qualifier</code> 指定修辞词，在 bean 定义上加入修辞词：<code>&lt;qualifier value=&quot;main&quot;/&gt;</code> ，使用处加上注解 <code>@Qualifier(&quot;main&quot;)</code> 即指定相应的 bean 为需要的装配对象。<ol>\n<li>bean name 是一个默认的后备 qualifier value，所以不用内嵌一个 qualifier 定义 bean，直接使用其 name/id 即可。</li>\n<li><code>@AutoWired</code> 其根本上是类型匹配，附加了 Qualifier 语义匹配。所以不管是指定一个 Qualifier value 还是使用备选的 bean name qualifier，会窄化类型匹配的含义。一个好的 qualifier value 应该独立于其 bean id/name 定义其组件角色，诸如：<code>main</code> <code>EMEA</code> <code>persistent</code>。bean id 在匿名定义时会自动生成。</li>\n<li>如果通过 bean name 查找 qualifier value 可以不用在注入点添加 <code>@Qualifier</code> ，Spring 在没有其他解析指示器（qualifier/primary）处，类型匹配到多个依赖的情况下，会自动匹配注入点名与 bean name 相同的 bean。</li>\n<li>在使用自动装配加上 <code>@Qualifier</code> 注解或相关的 bean name 标记模式下，其查询机制是在 类型匹配的结果集上再进行 bean name 匹配。而 <code>@Resource</code> 注解是直接使用 bean id/name 匹配。</li>\n</ol>\n</li>\n<li>如果注入本身定义为集合、数组类型的 bean，直接使用 <code>@Resource</code> 匹配其 bean id/name 。</li>\n<li>从 Spring 4.3 开始，bean 注入可以注入自身。自注入只是一个备选方案，常规的注入中其他的依赖的有更高的优先权。如果注入时有其他可选项，bean 本身不会被注入。可以使用 <code>@Resource</code> 来指定 bean id 来注入本身。实际编码中，如果出现需要在事务中同一个 bean 中调用其他方法，就得使用自注入实现 bean 代理（可选的方案还有将需要事务代理的方法抽取到另一个 bean 中）。</li>\n<li><code>@Resource</code> 如果注解在方法上，方法只能有一个参数。</li>\n<li>自定义 Qualifier ，自定义一个Qualifier 注解，其被 <code>@Qualifier</code> 注解，可为其加上属性，定义 bean 时，为其加上属性值，在注放处加上注解并指定其属性，自动装配时会主动匹配各属性一致的 bean。</li>\n<li>可使用范型约束来达到 qualifier 的效果。在 <code>@AutoWired</code> 注入依赖时，如果依赖实现的是一个范型接口，注入点就使用此范型类型作为 type 即可以注入此实现。</li>\n<li><code>@Qualifier</code> 定义 bean metadata 直接注解于 class 或 method 之上即可。</li>\n</ol>\n<h3 id=\"8-2-Resource-匹配\"><a href=\"#8-2-Resource-匹配\" class=\"headerlink\" title=\".8.2. @Resource 匹配\"></a>.8.2. @Resource 匹配</h3><blockquote>\n<p>位于 javax.anotation 包</p>\n</blockquote>\n<ul>\n<li>使用 <code>@Resource</code> 配置一个 bean 类的依赖，用于指定协作 bean 。这就与 <code>&lt;property ...&gt;</code> 中的 ref 属性有相同的效果。</li>\n<li>可以用于修改 setter 方法</li>\n<li>还可以直接修辞 实例变量。这样使用更为简单，spring 将会使用 javaEE 规范的 field 注入，setter 方法都不用写了。</li>\n<li>@Resource 注解主要基于 bean name 匹配，同时 byType 类型匹配将作为一个备选策略，如果在容器中找不到指定的 bean name，将进行类型匹工配。</li>\n<li>注解在 field 上与字段名匹配，注解在 setter 方法上与类的 property 名匹配。</li>\n<li><code>BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource</code> 这些 Spring 基础工具都是自动解析，不用 bean define 直接使用 <code>@Resource</code> 可进入注入。</li>\n</ul>\n<h3 id=\"8-3-Value-注入配置数据\"><a href=\"#8-3-Value-注入配置数据\" class=\"headerlink\" title=\".8.3. @Value 注入配置数据\"></a>.8.3. @Value 注入配置数据</h3><p><code>@Value</code> 注入外部属性。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation\">reference</a></p>\n<ol>\n<li><p>在配置上下文添加外部文件：<code>@PropertySource(&quot;classpath:application.properties&quot;)</code></p>\n</li>\n<li><p>需要注入外部属性数据的地方：<code>@Value(&quot;$&#123;upper_case&#125;&quot;)</code> 会注入外部文件的值。</p>\n</li>\n<li><p>Spring 默认的解析器会解析此配置，如果未找到此属性名，那么会注入此注解的 value <code>$&#123;upper_case&#125;</code>。</p>\n</li>\n<li><p>如果需要更严格地控制外部数据注入，需要静态注入一个 bean : <code>PropertySourcesPlaceholderConfigurer</code></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PropertySourcesPlaceholderConfigurer <span class=\"title\">propertyPlaceholderConfigurer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>使用此配置 bean 作为解析器，在 Spring 上下文初始化时就需要保证各个配置点位符能被正确解析（ key 必须存在），否则会抛出错误。</li>\n<li>此解析器可以添加配置 key 的前后缀。使用方法： <code>setPlaceholderPrefix()</code> <code>setPlaceholderSuffix</code></li>\n<li>可添加默认值：<code>@Value(&quot;$&#123;upper_case:true&#125;&quot;)</code></li>\n</ol>\n</li>\n<li><p>内置的解析器提供了简单地类型转换，数据类型可以直接转换成相应类型。</p>\n<ol>\n<li><p>可自定义数据转换器</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConversionService <span class=\"title\">conversionService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DefaultFormattingConversionService conversionService = <span class=\"keyword\">new</span> DefaultFormattingConversionService();</span><br><span class=\"line\">    conversionService.addConverter(<span class=\"keyword\">new</span> MyCustomConverter());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conversionService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>Spring Boot 默认使用 <code>PropertySourcesPlaceholderConfigurer</code> ，其配置的外部文件为 <code>application.properties</code> <code>application.yml</code></p>\n</li>\n</ol>\n<h3 id=\"8-4-使用注解来定制-bean-方法成员的生命周期\"><a href=\"#8-4-使用注解来定制-bean-方法成员的生命周期\" class=\"headerlink\" title=\".8.4. 使用注解来定制 bean 方法成员的生命周期\"></a>.8.4. 使用注解来定制 bean 方法成员的生命周期</h3><p>现个注解实现(javax.annotation 包)：</p>\n<ul>\n<li><code>@PostConstruct</code> 顾名思义，是在 bean 构造之后执行，修辞的是 bean 的初始化方法；</li>\n<li><code>@PreDestroy</code> 修辞 bean 销毁之前执行的方法</li>\n</ul>\n<h2 id=\"9-Classpath-Scanning-and-Managed-Components\"><a href=\"#9-Classpath-Scanning-and-Managed-Components\" class=\"headerlink\" title=\".9. Classpath Scanning and Managed Components\"></a>.9. Classpath Scanning and Managed Components</h2><p>配置元数据，Spring 容器会根据元配置数据生成 BeanDefinition，bean 的注入可以通过前面介绍的使用注解实现，但基本的 bean 定义还是使用的 xml 配置。Spring 3.0 开始引入 classpath scan，用以检测 Spring bean 组件。在扫描到的 classes 中，匹配到指定条件且有在容器中注册相应的 bean 定义。</p>\n<ul>\n<li><code>@Component</code> 标注为一个基本组件类，所有的 bean 组件注解都继此元注解，Spring 组件管理的标版。</li>\n<li><code>@Repository</code> 标注为持久层 DAO 组件类</li>\n<li><code>@Service</code> 标注为一个 service 层业务逻辑组件类</li>\n<li><code>@Controller</code> 标注为一个表现层控制器组件类</li>\n</ul>\n<h3 id=\"9-1-自动检测-class-并注册-Bean-Definition\"><a href=\"#9-1-自动检测-class-并注册-Bean-Definition\" class=\"headerlink\" title=\".9.1. 自动检测 class 并注册 Bean Definition\"></a>.9.1. 自动检测 class 并注册 Bean Definition</h3><ul>\n<li>Spring 会自动检测各个标准版本 class 并注册相应的 BeanDefinition 实例（ApplicationContext 信息）。</li>\n<li>需要在配置 <code>Configuration</code> 类上添加 <code>@ComponentScan</code> 注解，其中 <code>basePackages</code> 属性可以是基础包名也可以是多个 bean class（用 <code>,</code> <code>;</code> 或空格 <code> </code> 分隔）。</li>\n</ul>\n<h3 id=\"9-2-Class-Scanning-Filter\"><a href=\"#9-2-Class-Scanning-Filter\" class=\"headerlink\" title=\".9.2. Class Scanning Filter\"></a>.9.2. Class Scanning Filter</h3><p>在 Spring Class 扫描中添加过滤器。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-value-annotations\">reference</a></p>\n<ul>\n<li><p>Spring 默认的过滤效果是将 <code>@Component, @Repository, @Service, @Controller, @RestController, @Configuration</code> 6 个和自定义的注解 class 过滤出来。</p>\n</li>\n<li><p>在 <code>@ComponentScan</code> 中指定属性 <code>useDefaultFilters=false</code> 将取消默认扫描的类</p>\n</li>\n<li><p><code>includeFilters</code> 添加过滤器</p>\n</li>\n<li><p><code>excludeFilters</code> 拦截过滤器</p>\n<h4 id=\"9-2-1-Filter-类型\"><a href=\"#9-2-1-Filter-类型\" class=\"headerlink\" title=\".9.2.1. Filter 类型\"></a>.9.2.1. Filter 类型</h4></li>\n</ul>\n<ol>\n<li>annotation 默认，指定有某个注解的类为目标组件</li>\n<li>assignable 指定某个类或接口为目标组件</li>\n<li>aspectj AspectJ 类型表达式匹配目标组件</li>\n<li>regex 正则表达式匹配目标组件的 bean name</li>\n<li>custom 自定义实现 <code>org.springframework.core.type.TypeFilter</code> 过滤器</li>\n</ol>\n<h2 id=\"10-spring-容器中的-bean-实现不同方法\"><a href=\"#10-spring-容器中的-bean-实现不同方法\" class=\"headerlink\" title=\".10. spring 容器中的 bean 实现不同方法\"></a>.10. spring 容器中的 bean 实现不同方法</h2><p><a href=\"https://www.cnblogs.com/duanxz/p/7493276.html\">参考</a></p>\n<p>可以通过 java 配置类来实现 spring beans 的配置：</p>\n<ul>\n<li>@Configuration 等价于 <code>&lt;Beans&gt;&lt;/Beans&gt;</code></li>\n<li>@Bean 等价于 <code>&lt;Bean&gt;&lt;/Bean&gt;</code></li>\n<li>@ComponentScan 等价于 <code>&lt;context:component-scan base-package=&quot;com.dxz.demo&quot;/&gt;</code></li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/yjbjingcha/p/6752265.html\">获取 xml applicationContext 方法参考</a></p>\n<h3 id=\"10-1-Bean-Annotation\"><a href=\"#10-1-Bean-Annotation\" class=\"headerlink\" title=\".10.1. @Bean Annotation\"></a>.10.1. @Bean Annotation</h3><p>使用 <code>@Bean</code> 注册一个实例到 IoC 容器中。</p>\n<ul>\n<li>当要配置一个需要构造函数构造的 bean 时，需要指定其构造函数的参数。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection\">指定构造器参数 bean</a></li>\n<li><code>@Bean</code> 是一个方法级别的注解，使用在方法之上，方法返回类型即 bean 实例类型。</li>\n<li>推荐方法返回具体实例类型而不是接口类型。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation\">reference</a></li>\n<li>对一个 bean 指定生命周期回调<ul>\n<li>在 <code>@Bean</code> 中指定 <code>initMethod</code> <code>destroyMethod</code> 两个 bean 方法名，用以决定 bean 在初始化后现销毁前的回调。</li>\n<li><code>destroyMethod</code> 默认为 <code>deferred</code> 推断模式，在容器销毁前自行推断其销毁方法，如果想在容器销毁时保留 bean ，可以指定 <code>destroyMethod=&quot;&quot;</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"11-Naming-Bean\"><a href=\"#11-Naming-Bean\" class=\"headerlink\" title=\".11. Naming Bean\"></a>.11. Naming Bean</h2><p>bean 的命名<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics\">reference</a></p>\n<ul>\n<li>按惯例， bean 命名使用小驼峰。</li>\n<li>命名规范保持一致，有助于读与理解。同时，有助于 AOP 通过名字查找 bean 进入增强。</li>\n<li>对于 component scan ，Spring 为未命名的 componet 命名。取类的 simple name 小驼峰化为其名。特例：对于类名字母数量不只1个且前两个字符都是大写字母的情况， spring 会保留其原名。</li>\n<li>指定多个名：可使用逗号 <code>,</code>，分号 <code>;</code>，空格 `` 加以分隔。</li>\n</ul>\n<h3 id=\"11-1-Aliasing-Bean\"><a href=\"#11-1-Aliasing-Bean\" class=\"headerlink\" title=\".11.1. Aliasing Bean\"></a>.11.1. Aliasing Bean</h3><p>给 bean 起别名。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics\">reference</a></p>\n<p><code>@Bean</code><br>当一个应用中存在多个子系统，系统之间需要使用同一个 bean</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>前言：</strong><br>Spring 中的 bean 配置就是将各个类配置在 bean.xml 文件中，成为一个个的组件，方便实现各个组件之间的重新装配，这也是实现 spring 的依赖注入的方便法门；</p>\n<p>因此就可以理解，一个个的 bean 就是一个个的类的实例，但在 spring 运行时，spring 容器装配各个组件时初始化这些类实例时，也就会涉及到类的构造函数，装配各个组件时会涉及到各种类型参数；</p>\n<p>Spring中的配置各个 bean 时有许多不曾注意到的小知识点，这儿一并给总结出来。</p>\n</blockquote>","more":"<h2 id=\"1-知识点\"><a href=\"#1-知识点\" class=\"headerlink\" title=\".1. 知识点\"></a>.1. 知识点</h2><ol>\n<li>Spring 容器初始化各个 bean 组件时，默认组件为 <strong>单态模式</strong>（singleton，也叫单例模式）也就是当这个类只有一个实例，如果要实现非单态（prototype，标准类型），则将这个 bean 的 <code>singleton</code> 属性设置为 <code>false</code> ；</li>\n<li><strong>构造函数</strong> 的参数的配置，使用 <code>&lt;constructor-arg&gt;</code> 标签，多个参数就使用多个此标签，且要保证各个参数的顺序要与构造函数的参数顺序保持一致；</li>\n<li>bean 的属性的配置的前提是这个类中相关的属性要有 <code>setter</code> 方法；</li>\n<li>在 bean 中配置属性使用 <code>&lt;property&gt;</code> 标签，给其赋值时可以后直接使用 <code>value</code> 属性也可以使用子元素 <code>&lt;value&gt;</code> 标签；</li>\n<li><strong>空字符</strong> 的设置： <code>&lt;value&gt;&lt;/value&gt;</code> 设置的是空字符串 <code>&quot;&quot;</code> ，如果要设置为 <code>null</code> ，要使用 <code>&lt;null/&gt;</code> 或者干脆不设置;</li>\n<li><strong>匿名对象的配置</strong> ，类似于 java 中的匿名对象，如果要在一个属性中配置一个未曾配置的对象（也就是这个对象只会被使用一次的情况下，如果专门给其装配一个 bean 组件会造成一定的内存浪费），则其配置时直接将该类的路径写在 <code>&lt;property&gt;</code> 标签中，而 <strong>不在其中引入需要提前配置好的 bean 的 id</strong></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dao&quot;</span>&gt;</span></span><br><span class=\"line\">    //使用匿名对象</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.springdemo.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>ref 与 idref 之间的区别：</p>\n<ol>\n<li>两者都是用来设置 bean 的注入对象的；</li>\n<li>两者检查其引用对象bean是否存在：<strong>ref</strong> 只有在第一次调用时会检查，也就是在 <strong>程序运行中才会抛出错误</strong> ，而 <strong>idref 在程序启动时就会抛出错误</strong> ；</li>\n<li><strong>idref只有bean、local属性，没有parent属性</strong> ，而 ref 三个属性都有。（ local 表示就在当前配置文件中查找相关的 id，而 parent 表示在父配置文件中找。而 bean 则不会限制，可以在其本身找也可以在其父配置文件中找）；</li>\n</ol>\n</li>\n<li><p>depends-on，设置依赖对象：</p>\n<ol>\n<li><p>当我们设置的 bean 实例 a 之前要确保另外一个 bean 实例先实例化，这时就可以使用 <code>depends-on</code> 属性：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;a&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.springdemo.A&quot;</span> <span class=\"attr\">depends-on</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;b&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.snail.springdemo.B&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>初始化方法的执行：</strong> 当我们想要一个 bean 在实例化过程中执行一些初始化方法，同时这些初始化执行过程不能放在构造函数中，这是就可以借助初始化方法的属性 <code>init-method</code> 在配置中来达到执行初始化的目标；</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.kk.springdemo.A&quot;</span> <span class=\"attr\">init-method</span>=<span class=\"string\">&quot;initMethodName&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-spring-bean-的自动装配\"><a href=\"#2-spring-bean-的自动装配\" class=\"headerlink\" title=\".2. spring bean 的自动装配\"></a>.2. spring bean 的自动装配</h2><blockquote>\n<p>上述情况每个 bean 的装配都由我们自己来在 xml 文件中通过 ref 属性来显式指定。但 spring 中有更为方便的方法：自动装配。</p>\n</blockquote>\n<ul>\n<li>在 <code>&lt;beans&gt;</code> 中，指定自动装配的属性 <code>default-autowire</code> ，对整个 beans 中的 bean 都生效。</li>\n<li><code>&lt;bean&gt;</code> 中，指定自动装配的属性 <code>autowire</code> ，此属性只对当前 bean 生效。</li>\n</ul>\n<p><code>deault-autowire</code> 与 <code>autowire</code> 可以接受的值与其意义：</p>\n<ul>\n<li><code>no</code> 不使用自动装配。这个时候的 bean 的属性都得使用 ref 指定依赖。 <strong>默认值</strong> ，较大的部署环境中都这样，显式地指定出来方便后期检索。</li>\n<li><code>byName</code> 此种装配方法是 spring 会在 bean 库中去查找 bean 的 id 属性与当前需要装配的 setter 方法名（会将 setter 方法前面 <code>set</code> 去掉，并小写首字母）</li>\n<li><code>byType</code> 查找 setter 方法中形参的类型与 bean 库中的类型进行匹配。如果找到多个 bean 将会拋出异常，如果没找到不会发生动作</li>\n<li><code>constructor</code>  匹配 bean 的构造器与 setter 方法形参的构造器是否相同。同样如果找不到会拋出异常。</li>\n<li><code>autodetect</code> spring 根据 bean 的内部结构自行决定采用 byType 策略还是用 constructor 策略。</li>\n</ul>\n<p><em>当一个 Bean 既使用自动装配依赖，又使用 ref 显式指定依赖时，则<strong>显式指定的依赖覆盖自动装配依赖</strong>；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大降低了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。</em></p>\n<ul>\n<li>通过设置可以将 Bean 排除在自动装配之外</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--通过设置可以将Bean排除在自动装配之外--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">autowire-candidate</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">default-autowire-candidates</span>=<span class=\"string\">&quot;*abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>一个模块的 spring 配置文件根节点就是 <code>&lt;beans&gt;</code> ，也就是用这个节点来配置了一个 bean 池，再在这个里面配置了各个属性，也就是在这其中配置了各个 bean 与池的其他属性。</em></p>\n<h2 id=\"3-创建-bean-的方式\"><a href=\"#3-创建-bean-的方式\" class=\"headerlink\" title=\".3. 创建 bean 的方式\"></a>.3. 创建 bean 的方式</h2><blockquote>\n<p>共 3 种</p>\n</blockquote>\n<p>创建 bean 的三种方式：</p>\n<ol>\n<li>构造器创建 bean ，最常见的创建方式。 如果不采用构造注入， spring 会自动加载此 bean 的默认无参构造器，并将其属性全部初始化（基本类型设置为 0/false，引用类型设为 null）</li>\n<li>静态工厂方法创建 bean 。使用静态工厂创建 bean 时必须指定 <code>&lt;bean class=&quot;&quot;&gt;</code> 这儿的 class 属性就是用来指定静态工厂， factory-method 属性指定工厂的创建方法， 如果此方法需要参数，通过 constructor-arg 属性来指定。</li>\n<li>实例工厂方法创建 bean 。顾名思义，此方法与 静态工厂方法 的不同之处在于使用工厂实例进行创建 bean 。所以这儿能过 factory-bean 来指定工厂实例，再通过 factory-method 指定创建 bean 的方法。如果需要参数通过 constructor-arg 指定参数值。</li>\n</ol>\n<h2 id=\"4-Bean-Scope\"><a href=\"#4-Bean-Scope\" class=\"headerlink\" title=\".4. Bean Scope\"></a>.4. Bean Scope</h2><p>Bean scope : bean 领域，指 bean 的生存策略，共 6 种，其中 4 种只存在于 web 应用 context 中。</p>\n<ol>\n<li><p>singleton，spring bean 默认的单例，但 spring bean scope 单例与设计模式的单例不同。设计模式中单例是对一个特定 java 类来说的，每个 classloader 只生产一个实例。而 spring bean scope 是指一个 bean 在同一个 IoC 容器只生产一个实例。</p>\n</li>\n<li><p>prototype, 模版模式，每次请求此 bean 被注入其他 bean 中或通过 <code>getBean()</code> 方式获取容器中 bean 时都会创建一个实例。按惯例， prototype scope 用于带状态的 bean ，而 singleton scope 用于无状态 bean 。</p>\n<ol>\n<li>对于 prototype scope 的 bean ， IoC 容器只负责其初始化、装配、交给需要此 bean 的客户端，并不负责其后的生命周期。所以对一个 prototype scope bean 就算配置了生命周期中 destruction 销毁的回调 IoC 也不会执行，而负责此任务的是 client。</li>\n<li>client 可使用 bean post-processor 对 bean 进行资源管理。在某些方面来讲，IoC 容器对于 prototype scope bean 相当于一个 java new operator。在此之后的生命周期管理都交给了 client。</li>\n</ol>\n</li>\n<li><p>当一个 singleton scope beanA 中依赖注入了 prototype scope beanB ，同时，在 beanA 中需要 beanB 的多个不同的实例。IoC 容器在初始化 beanB 时只会在 beanA 中初始化一个 beanB 的实例，当 IoC 容器按顺序给 beanA 装配时只会装配同一个 beanB 实例到 beanA 中。<a href=\"https://spring.io/blog/2004/08/06/method-injection/\">reference</a></p>\n<ol>\n<li><p>解决问题的方案一：放弃 IoC ，让 beanA 实现 <code>ApplicationContextAware</code> 接口让其对 IoC 容器敏感，每个需要 bean 的地方使用 <code>ApplicationContext.getBean(Bean.class)</code> 的方式获取，这样获取的 bean 就是一个新的实例。缺点：业务代码与 spring 框架耦合在一起。</p>\n</li>\n<li><p>方案二：IoC 容器方法注入。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;commandManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">lookup-method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;createCommand&quot;</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;myCommand&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>或使用 annotation <code>@Lookup(value=&quot;&quot;)</code></p>\n</li>\n<li><p>方法可以是抽象方法也可是具体方法，IoC 容器会通过 CGLIB 为方法所在的类生成子类覆盖方法，所以 <code>@Lookup</code> 只能在 IoC 容器能通过常规构造器初始化的 bean 中才能生效。也就是：Lookup 不能为工厂方法生产 bean 方法所替代，因为不能动态地为工厂方法所生产的 bean 提供子类。method 与 class 均不能为 final 修辞。</p>\n</li>\n<li><p>在 spring 使用场景中需要注意：需要为 Lookup 方法提供具体实现，否则 component scanning 之类会过滤掉抽象 bean。同时， Lookup method 不能在 configuration class 中配置的 <code>@Bean</code> 方法上生效，需要使用 <code>@Inject</code> 之类的注解代替。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-1-Web-application-bean-scope\"><a href=\"#4-1-Web-application-bean-scope\" class=\"headerlink\" title=\".4.1. Web application bean scope\"></a>.4.1. Web application bean scope</h3><p> request/session/application/websocket scope 都用于 web application context，如果是一个普通的应用程序，使胳膊这几个 scope 会抛出 IllegalStateException。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-sing-prot-interaction\">reference</a></p>\n<p>初始化一个 web application configuration:</p>\n<ol>\n<li>如果使用 spring mvc scoped this beans，只需要注册一个 <code>DispatherServlet</code> 在 web 配置中即可。</li>\n<li>在初始化一个 web configuration 时，当使用的 Servlet2.5 web 容器，且请求非 spring mvc （struts 、 jsf 之类），需要注册 <code>org.springframework.web.context.request.RequestContextListener</code> 到 web 配置中，如果使用 servlet3.0 使用 <code>WebApplicationInitializer</code> 接口将自动完成以上注册。</li>\n<li>如果使用 listener 还有问题，可注册 <code>org.springframework.web.filter.RequestContextFilter</code> 到 web 中。</li>\n<li>前面的 servlet/listener/filter 的目标只有一个：将 HTTP request 对象按名绑定到服务此请求的线程上。这就让请求域与会话域的 bean 在调用链更下游可用。</li>\n</ol>\n<p>四个 web bean scope</p>\n<ol>\n<li>request scope<ol>\n<li>在 xml 配置中： <code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.something.LoginAction&quot; scope=&quot;request&quot;/&gt;</code></li>\n<li>java configuration: <code>@RequestScope</code> 在请求类上注解</li>\n<li>效果：每次请求调用此 bean 将会产生一个新的 bean 实例来处理此次请求，请求与请求之间不互扰。当此次请求完成，bean 被废弃。</li>\n</ol>\n</li>\n<li>session scope<ol>\n<li>xml 配置方式: <code>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;/&gt;</code></li>\n<li>java 配置方式: <code>@SessionScope</code></li>\n<li>效果：bean 实例的产生取决于一个 HTTP session 的生命周期，在同一个 HTTP 会话中，此 bean 实例都是有效的。只有当此次 HTTP 会话结束，bean 才会被废弃。所以在同一次会话中，不同的请求的状态变化将会相互影响。</li>\n</ol>\n</li>\n<li>application scope<ol>\n<li>xml 配置方式：<code>&lt;bean id=&quot;appPreferences&quot; class=&quot;com.something.AppPreferences&quot; scope=&quot;application&quot;/&gt;</code></li>\n<li>java 配置方式： <code>@ApplicationScope</code></li>\n<li>效果：整个 web 应用只生产一个 application scope 的 bean 。bean 域被划分到 ServletContext 级别，并且被存储为一个常规的 ServletContext 属性。类似于 spring 的 singleton scope，但有两点不同：<ol>\n<li>application scope  是每个 servlet 生产一个实例，而 spring 的 singleton scope 是每个 ApplicationContext 生产一个实例（一个应用中可能有多个 ApplicationContext）。</li>\n<li>application scope bean 实际上是显露在外的，在 ServletContext 中属性可见。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>依赖域的 bean<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-custom\">reference</a><ol>\n<li>当需要将一个短生命周期的 beanA(session scope) 注入一个相对长生命周期的 beanB(singleton scope) 中时，会出现 beanA 已经被丢弃而 beanB 依然去调用 beanA。</li>\n<li>添加 AOP 代理配置到 beanA ，代理会将短生命周期的 beanA 序列化存储起来，在 beanB 需要调用时实际上调用代理，代理去查找需要实际调用的实例，找不到则反序列化成为对象 beanA 再次调用此 beanA。</li>\n<li>如果代理的对象是 ptototype scope，则代理每次调用时将产生一个新的 beanA 实例供调用。</li>\n<li>代理 scope 并非唯一的在长域 bean 访问短域 bean 的方式，也可定义注入点（构造器、setter argument、autowired field）为 <code>ObjectFactory&lt;MyBean&gt;</code> ，通过调用其 <code>getObject()</code> 获取新的实例 bean。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-2-协调作用域不同的-bean\"><a href=\"#4-2-协调作用域不同的-bean\" class=\"headerlink\" title=\".4.2. 协调作用域不同的 bean\"></a>.4.2. 协调作用域不同的 bean</h3><blockquote>\n<p>当 singleton bean 依赖于 prototype bean 时，会因为 spring 窗口初始化时会先预初始化 singleton bean ，如果  singleton bean 依赖于 prototype bean ，就不得不先将依赖的 prototype bean 初始化好，再注入到 singleton bean。这就带来一个不同步的问题（多个 singleton bean 依赖了同一个 prototype bean）。</p>\n</blockquote>\n<p>解决不同步的方法：</p>\n<ol>\n<li>放弃依赖注入。每次需要 prototype bean 时都向窗口请求新的 bean 实例，这样每次都会产生新的 bean 实例（但是作为 prototype bean 的确是每次都产生新的实例，这里没有搞懂）。</li>\n<li>利用方法注入。通常使用 <code>lookup</code> 方法注入，此方法会让 spring 容器重写容器中的 bean 的抽象或具体方法，返回查找容器中其他 bean 的结果，被查找的 bean 通常是一个 non-singleton bean 。 spring 通过使用 JDK 动态代理或者 cglib 库修改客户端代码实现上述动作。<ol>\n<li>为了使用lookup方法注入，大致需要如下两步：<ol>\n<li>将调用者Bean的实现类定义为抽象类，并定义一个抽象方法来获取被依赖的Bean。</li>\n<li>在 <code>&lt;bean.../&gt;</code> 元素中添加 <code>&lt;lookup-method.../&gt;</code> 子元素让 Spring 为调用者 Bean 的实现类实现指定的抽象方法。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><em>Spring会采用运行时动态增强的方式来实现 <code>&lt;lookup-method.../&gt;</code>元素所指定的抽象方法，如果目标抽象类实现过接口，Spring 会采用 JDK 动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0 的 spring-core-xxx.jar 包中已经集成了 cglib 类库。</em></p>\n<h2 id=\"5-Dependencies\"><a href=\"#5-Dependencies\" class=\"headerlink\" title=\".5. Dependencies\"></a>.5. Dependencies</h2><p>spring IoC 容器中各个 bean 相互依赖。</p>\n<h3 id=\"5-1-Dependency-injection\"><a href=\"#5-1-Dependency-injection\" class=\"headerlink\" title=\".5.1. Dependency injection\"></a>.5.1. Dependency injection</h3><p>依赖注入</p>\n<p>依赖注入的方法主要有两种：构造器注入、工厂方法注入、setter 注入</p>\n<p>区别：constructor 与工厂方法注入在初始化就注入，而 setter 注入在初始化后注入依赖。</p>\n<h4 id=\"5-1-1-constructor-injection\"><a href=\"#5-1-1-constructor-injection\" class=\"headerlink\" title=\".5.1.1. constructor injection\"></a>.5.1.1. constructor injection</h4><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection\">reference</a></p>\n<ol>\n<li><p>构造器注入与工厂方法注入类似，都在本 bean 初始化时将依赖注入。</p>\n</li>\n<li><p>当构造参数或工厂方法参数存在继承关系时，参数匹配会模糊不清。解决方案：</p>\n<ol>\n<li>添加参数 index （从 0 开始）；</li>\n<li>指定参数类型：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;exampleBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;int&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;7500000&quot;</span>/&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;java.lang.String&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;42&quot;</span>/&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>指定参数名，同时需要在方法上添加 <code>@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</code>；</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-1-2-setter-injection\"><a href=\"#5-1-2-setter-injection\" class=\"headerlink\" title=\".5.1.2. setter injection\"></a>.5.1.2. setter injection</h4><p>在 bean 实例化后调用，同一个 bean 的依赖注入两种方式都可使用。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection\">reference</a></p>\n<h4 id=\"5-1-3-依赖解析\"><a href=\"#5-1-3-依赖解析\" class=\"headerlink\" title=\".5.1.3. 依赖解析\"></a>.5.1.3. 依赖解析</h4><ol>\n<li><code>ApplicationContext</code> 通过配置元数据创建并初始化，配置数据可以通过 xml/Java code/annotations 完成。</li>\n<li>每个 bean 的依赖表现为 bean 的属性、构造器参数、工厂方法参数形式，当 bean 被创建时，这些依赖已准备好。</li>\n<li>对于 bean 来说，每个依赖等同于被设置的值或 IoC 容器中其他 bean 引用。</li>\n<li>bean 的每个属性实际上是从指定的格式转换为其需要的类型。spring 可以将一个 String 类型的值转换为内置的类型（如：int boolean long）。</li>\n<li>默认 spring IoC 容器在创建时会将 bean scope 域定为 singleton，且会预先初始化 bean ，否则只有在请求时才会被创建。</li>\n<li>bean 的创建可能会形成图形结构：bean 的依赖的创建及其依赖的依赖的创建。</li>\n</ol>\n<h5 id=\"5-1-3-1-循环依赖\"><a href=\"#5-1-3-1-循环依赖\" class=\"headerlink\" title=\".5.1.3.1. 循环依赖\"></a>.5.1.3.1. 循环依赖</h5><p>bean 之间相互 constructor 依赖。beanA 依赖了 beanB ，同时 beanB 依赖了 beanA，且两者的依赖都是通过构造器依赖。当出现循环依赖时，IoC 在运行时会抛出 <code>BeanCurrentlyInCreationException</code>。</p>\n<p>解决方案：配置其中一个（或全部） bean 使用 setter 注入。虽然不推荐，但可以使用 setter 注入配置循环依赖。</p>\n<p>循环依赖与正常依赖不同之处：循环依赖其中一个 bean 强制在完全初始化前注入另一个 bean 。<em>IoC container 来做的？</em></p>\n<h5 id=\"5-1-3-2-spring-依赖加载特性\"><a href=\"#5-1-3-2-spring-依赖加载特性\" class=\"headerlink\" title=\".5.1.3.2. spring 依赖加载特性\"></a>.5.1.3.2. spring 依赖加载特性</h5><ol>\n<li>spring 在容器加载时会自动检测配置的潜在问题，诸如：引用缺失、循环依赖；</li>\n<li>spring 实际创建 bean 时会尽晚地设置属性和解析依赖（在未使用某个依赖前并不注入此依赖），这意味着在 spring container 正确加载后请求对象会出现创建对象或其依赖的异常，比如：bean throws a exception of  a missing of invalid property。为此，<code>ApplicationContext</code> 的实现默认预先初始化 singleton scope beans。用预先的时间与内存消耗来初始化 bean 在 <code>ApplicationContext</code> 创建时显露出配置的问题。</li>\n</ol>\n<h3 id=\"5-2-Depends-On\"><a href=\"#5-2-Depends-On\" class=\"headerlink\" title=\".5.2. Depends On\"></a>.5.2. Depends On</h3><p>使用 <code>depends-on</code> 属性决定本 bean 的初始化依赖于其他的 bean，Spring 会在本 bean 初始化前完成依赖的 bean 的初始化，同时在销毁依赖的 bean 前先销毁本 bean 。</p>\n<h3 id=\"5-3-lazy-initialized-beans\"><a href=\"#5-3-lazy-initialized-beans\" class=\"headerlink\" title=\".5.3. lazy-initialized beans\"></a>.5.3. lazy-initialized beans</h3><p>指定懒加载 bean 。</p>\n<ul>\n<li>使用 <code>lazy-init=true</code> 指定 bean 懒加载。</li>\n<li>使用懒加载的 bean 即使是 singleton scope 也不会在 container 初始化时预先初始化此 bean，而是在第一次请求到此 bean 时才会初始化。</li>\n<li>当一个懒加载的 bean 是一个非懒加载 singleton scope bean 的依赖时，此 bean 一样会因为需要预先实例化其他 bean 而被实例化用以装配。</li>\n<li>设置容器全局懒加载 <code>&lt;beans default-lazy-init=&quot;true&quot;&gt;</code>。</li>\n</ul>\n<h3 id=\"5-4-AutoWiring-Collaborators\"><a href=\"#5-4-AutoWiring-Collaborators\" class=\"headerlink\" title=\".5.4. AutoWiring Collaborators\"></a>.5.4. AutoWiring Collaborators</h3><p>设置自动装配 bean 。</p>\n<ul>\n<li>在 <code>&lt;bean/&gt;</code> 配置中添加 <code>autowire</code> 属性使用自动装配。</li>\n<li>自动装配有 4 种模式：<ul>\n<li><code>no</code> ，默认模式，不使用自动装配，在大型系统中不推荐覆盖此配置。显式地指定各个 bean 更利于清晰控制系统。</li>\n<li><code>byName</code> ，通过 bean property 名自动装配，spring 在容器中查找与 property（此 property 必须有其 setter） 名相同的 bean 用以装配。</li>\n<li><code>byType</code>，通过 porperty 类型自动装配，spring 在容器中查找类型与其一致的 bean 进行装配，如果未找到，此 property 将不会被装配，如果找到多个将抛出异常。</li>\n<li><code>constructor</code>，与 <code>byType</code> 类似，不过只应用于 constructor 参数。如果没有类型一致的 bean，将抛出异常。</li>\n</ul>\n</li>\n<li><code>byType</code> 和 <code>constructor</code> 可以装配一个类型匹配的数组或集合。这种情况下，容器中所有类型匹配的 bean 都会被装配在其中，如果使用 map 来接收，其 key 就是 bean name 。</li>\n</ul>\n<h4 id=\"5-4-1-使用自动装配的不足\"><a href=\"#5-4-1-使用自动装配的不足\" class=\"headerlink\" title=\".5.4.1. 使用自动装配的不足\"></a>.5.4.1. 使用自动装配的不足</h4><ol>\n<li>显式地指定装配会自动装配，同时自动装配不能装配一个基本类型数据、String、Class 和这些类型的数组；</li>\n<li>自动装配相对显式装配指代不够清晰；</li>\n<li>当容器中有多个符合条件的 bean 而装配处只需要单个时，会抛出错误。</li>\n</ol>\n<p>解决方案：</p>\n<ol>\n<li>放弃使用自动装配，使用显式装配；</li>\n<li>将被装配 bean <code>autowire-candidate</code> 设为 <code>false</code>（此属性只对 <code>byType</code> 自动装配有效，如果装配处指定自动装配为 <code>byName</code> 一样可以自动装配到此 bean）；</li>\n<li>在多个符合条件的 bean 中挑选一个作为主候选 bean ，指定其 <code>&lt;bean/&gt;</code> 中属性 <code>primary=true</code>；</li>\n<li>使用更细粒度控制的注解配置。</li>\n</ol>\n<h2 id=\"6-自定义-bean-特性\"><a href=\"#6-自定义-bean-特性\" class=\"headerlink\" title=\".6. 自定义 bean 特性\"></a>.6. 自定义 bean 特性</h2><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-nature\">reference</a></p>\n<ul>\n<li>使用 <code>@PostConstruct</code> 与 <code>@PreDestroy</code> 代替实现 <code>InitializingBean</code> 与 <code>DisposableBean</code> 接口，代码与 spring 解耦；</li>\n<li>指定 <code>&lt;bean/&gt;</code> 属性 <code>destroy-method=inferred</code>，可使 spring 自动推断 bean 销毁前执行公共回调方法，如：<code>close()/shutdown()</code>。同理在 <code>&lt;beans/&gt;</code> 中设定属性 <code>default-destroy-method=inferred</code> 可指定所有的 bean 的销毁前回调方法；</li>\n<li>可在 <code>&lt;beans/&gt;</code> 中添加属性 <code>default-init-method=&quot;init&quot;</code> 指定默认的初始化回调方法名，让配置中所有的 bean 都保持一致调用名此回调；</li>\n</ul>\n<h3 id=\"6-1-指定回调方法\"><a href=\"#6-1-指定回调方法\" class=\"headerlink\" title=\".6.1. 指定回调方法\"></a>.6.1. 指定回调方法</h3><p>在 spring 2.5 后，指定回调方法有 3 种</p>\n<ol>\n<li>实现 <code>InitializingBean</code> <code>DisposableBean</code> 回调接口；</li>\n<li>自定义的 <code>init()</code> <code>close()</code> 方法；</li>\n<li>使用 <code>@PostConstruct</code> <code>@PreDestroy</code> 注解在方法上。</li>\n</ol>\n<p>当 bean 有多个生命周期回调且方法不一样时，回调都将被执行，其顺序是 : 3 -&gt; 1 -&gt; 2</p>\n<p><strong>Note:</strong> 回调方法执行是在当前对象的依赖都准备好之后，但在代理、拦截器这些机制应用之前，所以 init() 前置回调如果需要访问代理、拦截器之类是做不到的。</p>\n<h3 id=\"6-2-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications\"><a href=\"#6-2-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications\" class=\"headerlink\" title=\".6.2. Shutting Down the Spring IoC Container Gracefully in Non-Web Applications\"></a>.6.2. Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h3><p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-shutdown\">reference</a></p>\n<p>在 web 工程中， ApplicationContext 的实现代码会在工程关闭时正确地关闭 Spring IoC 容器。而在一个非 web 工程中需要手动地将 Spring IoC 容器关闭注册到 JVM ，以保证在关闭时能释放 singleton 资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Boot</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ConfigurableApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;beans.xml&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add a shutdown hook for the above context...</span></span><br><span class=\"line\">        ctx.registerShutdownHook();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// app runs here...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// main method exits, hook is called prior to the app shutting down...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-3-ApplicationContextAware-and-BeanNameAware\"><a href=\"#6-3-ApplicationContextAware-and-BeanNameAware\" class=\"headerlink\" title=\".6.3. ApplicationContextAware and BeanNameAware\"></a>.6.3. ApplicationContextAware and BeanNameAware</h3><p><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-processor\">reference</a></p>\n<h4 id=\"6-3-1-ApplicationContextAware\"><a href=\"#6-3-1-ApplicationContextAware\" class=\"headerlink\" title=\".6.3.1. ApplicationContextAware\"></a>.6.3.1. ApplicationContextAware</h4><p>实现 ApplicationContextAware 接口获取 ApplicationContext 。以获得操纵 ApplicationContext 的方法。但这样会让业务代码与 Spring 耦合。</p>\n<p>可以使用 Spring AutoWiring 特性，自动注入 ApplicationContext 。</p>\n<h4 id=\"6-3-2-BeanNameAware\"><a href=\"#6-3-2-BeanNameAware\" class=\"headerlink\" title=\".6.3.2. BeanNameAware\"></a>.6.3.2. BeanNameAware</h4><p>实现此接口的 bean 会提供一个定义 bean name 的方法，在 bean properties 设置之后且在其初始化回调（<code>InitializingBean</code> <code>afterPorpertiesSet</code> 或自定义初始化方法）执行之前会执行此方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanNameAware</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBeanName</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: BeanNameAware 回调执行是在 bean 基础属性配置好之后，在初始化回调 自定义 init 方法/afterPropertiesSet/InitializingBean 执行之前。</p>\n<h2 id=\"7-Bean-Definition-Inheritance\"><a href=\"#7-Bean-Definition-Inheritance\" class=\"headerlink\" title=\".7. Bean Definition Inheritance\"></a>.7. Bean Definition Inheritance</h2><p><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions\">reference</a></p>\n<blockquote>\n<p>Bean Definition 继承</p>\n</blockquote>\n<ul>\n<li>xml bean 配置中添加 abstract=true　属性就指定此 bean definition 为抽象，抽象的可以不指定 class</li>\n<li><code>parent=beanId</code> 指定当前 bean definition 继承目标 bean 。被继承的 bean 可以是抽象的。</li>\n<li>抽象的 bean definition 不能被初始化。ApplicationContext 默认会预初始化所有的 singleton，因此所有想被当作模版用 parent bean definition 在指定了class 后一定要指定其为 abstract=true，否则 application context 会对其进行初始化。</li>\n</ul>\n<h2 id=\"8-spring-bean-零配置支持\"><a href=\"#8-spring-bean-零配置支持\" class=\"headerlink\" title=\".8. spring bean 零配置支持\"></a>.8. spring bean 零配置支持</h2><blockquote>\n<p>spring 零配置是指通过<strong>注解</strong>来实现 beans.xml 中配置 spring bean 容器的功能<br>在 spring 配置文件中指定自动扫描的包： <code>&lt;context:component-scan base-package=&quot;package.path.name&quot;/&gt;</code></p>\n</blockquote>\n<ul>\n<li>使用注解完成配置相对于 xml 配置更为精简，但也与源码耦合，修改配置需要重新编译。通常同一个项目中混合使用两种配置方式。</li>\n<li>xml 配置中兼容注解配置，使用 <code>&lt;context:annotation-config/&gt;</code><ul>\n<li>此配置隐匿地注册了很多 post-processor 包括： <code>AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, and the aforementioned RequiredAnnotationBeanPostProcessor</code></li>\n<li>此配置只查询同一级别的应用上下文的注解，所以如果只是在 DispatcherServlet 的 <code>WebApplicationContext</code> 配置，那么就只会扫描到 Controller 而不会扫描到 Service 的注解。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-1-自动装配与精确装配-spring-4-0\"><a href=\"#8-1-自动装配与精确装配-spring-4-0\" class=\"headerlink\" title=\".8.1. 自动装配与精确装配 spring 4.0\"></a>.8.1. 自动装配与精确装配 spring 4.0</h3><p><code>@Autowired</code> 指定自动装配</p>\n<ul>\n<li>可以用来修辞 setter方法/普通方法/实例变量/构造器</li>\n<li>使用的是 byType 策略从 spring 容器中查找 bean ，如果容器中有多个同一类型的 bean 就会拋出异常。同时确保所需要的至少有一个是 declared by type ，否则抛出 “no type match found”</li>\n<li>为解决上述问题，spring 4.0 就增加了 <code>@Qualifier</code> 注解<ul>\n<li><code>@Qualifier</code> 用于精确装配 bean ，其方法是在其中指定 bean id 。因此如果要使用此注解来装配，就得将被装配的 bean id（也就是 beanName，通常的标注注解就这一个属性，默认为 “”） 标注出来。</li>\n</ul>\n</li>\n<li>对于 xml 配置与 classpath 扫描，容器能知道具体的类型。但对于工厂方法的 <code>@Bean</code> 需要保证返回类型足够明确，特别是对于实现多个接口的 bean ，最好返回 bean 的最具体的类型（至少指定到需要的 bean 类型）。</li>\n<li>注解在 bean 集合上<ul>\n<li>如果是有序集合（数据、List），可以使用 <code>@Ordered</code> <code>@Priority</code> 注解标明其顺序，如果未标注，则其顺序为其在容器中注册的顺序。</li>\n<li>如果是 Map ，其 key 是 bean name (String)。</li>\n</ul>\n</li>\n<li><code>BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource</code> 这些 Spring 基础工具都是自动解析，直接使用 <code>@AutoWired</code> 即可。</li>\n<li>可用于 Constructor 上标明此构造器用于生产 bean 用于自动装配。</li>\n</ul>\n<h4 id=\"8-1-1-自动装配微调\"><a href=\"#8-1-1-自动装配微调\" class=\"headerlink\" title=\".8.1.1. 自动装配微调\"></a>.8.1.1. 自动装配微调</h4><ol>\n<li>使用 <code>@Primary</code> 指定众多实现 bean 中一个为主 bean，当自动装配时优先使用此 bean；</li>\n<li>使用 <code>@Qualifier</code> 指定修辞词，在 bean 定义上加入修辞词：<code>&lt;qualifier value=&quot;main&quot;/&gt;</code> ，使用处加上注解 <code>@Qualifier(&quot;main&quot;)</code> 即指定相应的 bean 为需要的装配对象。<ol>\n<li>bean name 是一个默认的后备 qualifier value，所以不用内嵌一个 qualifier 定义 bean，直接使用其 name/id 即可。</li>\n<li><code>@AutoWired</code> 其根本上是类型匹配，附加了 Qualifier 语义匹配。所以不管是指定一个 Qualifier value 还是使用备选的 bean name qualifier，会窄化类型匹配的含义。一个好的 qualifier value 应该独立于其 bean id/name 定义其组件角色，诸如：<code>main</code> <code>EMEA</code> <code>persistent</code>。bean id 在匿名定义时会自动生成。</li>\n<li>如果通过 bean name 查找 qualifier value 可以不用在注入点添加 <code>@Qualifier</code> ，Spring 在没有其他解析指示器（qualifier/primary）处，类型匹配到多个依赖的情况下，会自动匹配注入点名与 bean name 相同的 bean。</li>\n<li>在使用自动装配加上 <code>@Qualifier</code> 注解或相关的 bean name 标记模式下，其查询机制是在 类型匹配的结果集上再进行 bean name 匹配。而 <code>@Resource</code> 注解是直接使用 bean id/name 匹配。</li>\n</ol>\n</li>\n<li>如果注入本身定义为集合、数组类型的 bean，直接使用 <code>@Resource</code> 匹配其 bean id/name 。</li>\n<li>从 Spring 4.3 开始，bean 注入可以注入自身。自注入只是一个备选方案，常规的注入中其他的依赖的有更高的优先权。如果注入时有其他可选项，bean 本身不会被注入。可以使用 <code>@Resource</code> 来指定 bean id 来注入本身。实际编码中，如果出现需要在事务中同一个 bean 中调用其他方法，就得使用自注入实现 bean 代理（可选的方案还有将需要事务代理的方法抽取到另一个 bean 中）。</li>\n<li><code>@Resource</code> 如果注解在方法上，方法只能有一个参数。</li>\n<li>自定义 Qualifier ，自定义一个Qualifier 注解，其被 <code>@Qualifier</code> 注解，可为其加上属性，定义 bean 时，为其加上属性值，在注放处加上注解并指定其属性，自动装配时会主动匹配各属性一致的 bean。</li>\n<li>可使用范型约束来达到 qualifier 的效果。在 <code>@AutoWired</code> 注入依赖时，如果依赖实现的是一个范型接口，注入点就使用此范型类型作为 type 即可以注入此实现。</li>\n<li><code>@Qualifier</code> 定义 bean metadata 直接注解于 class 或 method 之上即可。</li>\n</ol>\n<h3 id=\"8-2-Resource-匹配\"><a href=\"#8-2-Resource-匹配\" class=\"headerlink\" title=\".8.2. @Resource 匹配\"></a>.8.2. @Resource 匹配</h3><blockquote>\n<p>位于 javax.anotation 包</p>\n</blockquote>\n<ul>\n<li>使用 <code>@Resource</code> 配置一个 bean 类的依赖，用于指定协作 bean 。这就与 <code>&lt;property ...&gt;</code> 中的 ref 属性有相同的效果。</li>\n<li>可以用于修改 setter 方法</li>\n<li>还可以直接修辞 实例变量。这样使用更为简单，spring 将会使用 javaEE 规范的 field 注入，setter 方法都不用写了。</li>\n<li>@Resource 注解主要基于 bean name 匹配，同时 byType 类型匹配将作为一个备选策略，如果在容器中找不到指定的 bean name，将进行类型匹工配。</li>\n<li>注解在 field 上与字段名匹配，注解在 setter 方法上与类的 property 名匹配。</li>\n<li><code>BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource</code> 这些 Spring 基础工具都是自动解析，不用 bean define 直接使用 <code>@Resource</code> 可进入注入。</li>\n</ul>\n<h3 id=\"8-3-Value-注入配置数据\"><a href=\"#8-3-Value-注入配置数据\" class=\"headerlink\" title=\".8.3. @Value 注入配置数据\"></a>.8.3. @Value 注入配置数据</h3><p><code>@Value</code> 注入外部属性。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation\">reference</a></p>\n<ol>\n<li><p>在配置上下文添加外部文件：<code>@PropertySource(&quot;classpath:application.properties&quot;)</code></p>\n</li>\n<li><p>需要注入外部属性数据的地方：<code>@Value(&quot;$&#123;upper_case&#125;&quot;)</code> 会注入外部文件的值。</p>\n</li>\n<li><p>Spring 默认的解析器会解析此配置，如果未找到此属性名，那么会注入此注解的 value <code>$&#123;upper_case&#125;</code>。</p>\n</li>\n<li><p>如果需要更严格地控制外部数据注入，需要静态注入一个 bean : <code>PropertySourcesPlaceholderConfigurer</code></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PropertySourcesPlaceholderConfigurer <span class=\"title\">propertyPlaceholderConfigurer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>使用此配置 bean 作为解析器，在 Spring 上下文初始化时就需要保证各个配置点位符能被正确解析（ key 必须存在），否则会抛出错误。</li>\n<li>此解析器可以添加配置 key 的前后缀。使用方法： <code>setPlaceholderPrefix()</code> <code>setPlaceholderSuffix</code></li>\n<li>可添加默认值：<code>@Value(&quot;$&#123;upper_case:true&#125;&quot;)</code></li>\n</ol>\n</li>\n<li><p>内置的解析器提供了简单地类型转换，数据类型可以直接转换成相应类型。</p>\n<ol>\n<li><p>可自定义数据转换器</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConversionService <span class=\"title\">conversionService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DefaultFormattingConversionService conversionService = <span class=\"keyword\">new</span> DefaultFormattingConversionService();</span><br><span class=\"line\">    conversionService.addConverter(<span class=\"keyword\">new</span> MyCustomConverter());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conversionService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>Spring Boot 默认使用 <code>PropertySourcesPlaceholderConfigurer</code> ，其配置的外部文件为 <code>application.properties</code> <code>application.yml</code></p>\n</li>\n</ol>\n<h3 id=\"8-4-使用注解来定制-bean-方法成员的生命周期\"><a href=\"#8-4-使用注解来定制-bean-方法成员的生命周期\" class=\"headerlink\" title=\".8.4. 使用注解来定制 bean 方法成员的生命周期\"></a>.8.4. 使用注解来定制 bean 方法成员的生命周期</h3><p>现个注解实现(javax.annotation 包)：</p>\n<ul>\n<li><code>@PostConstruct</code> 顾名思义，是在 bean 构造之后执行，修辞的是 bean 的初始化方法；</li>\n<li><code>@PreDestroy</code> 修辞 bean 销毁之前执行的方法</li>\n</ul>\n<h2 id=\"9-Classpath-Scanning-and-Managed-Components\"><a href=\"#9-Classpath-Scanning-and-Managed-Components\" class=\"headerlink\" title=\".9. Classpath Scanning and Managed Components\"></a>.9. Classpath Scanning and Managed Components</h2><p>配置元数据，Spring 容器会根据元配置数据生成 BeanDefinition，bean 的注入可以通过前面介绍的使用注解实现，但基本的 bean 定义还是使用的 xml 配置。Spring 3.0 开始引入 classpath scan，用以检测 Spring bean 组件。在扫描到的 classes 中，匹配到指定条件且有在容器中注册相应的 bean 定义。</p>\n<ul>\n<li><code>@Component</code> 标注为一个基本组件类，所有的 bean 组件注解都继此元注解，Spring 组件管理的标版。</li>\n<li><code>@Repository</code> 标注为持久层 DAO 组件类</li>\n<li><code>@Service</code> 标注为一个 service 层业务逻辑组件类</li>\n<li><code>@Controller</code> 标注为一个表现层控制器组件类</li>\n</ul>\n<h3 id=\"9-1-自动检测-class-并注册-Bean-Definition\"><a href=\"#9-1-自动检测-class-并注册-Bean-Definition\" class=\"headerlink\" title=\".9.1. 自动检测 class 并注册 Bean Definition\"></a>.9.1. 自动检测 class 并注册 Bean Definition</h3><ul>\n<li>Spring 会自动检测各个标准版本 class 并注册相应的 BeanDefinition 实例（ApplicationContext 信息）。</li>\n<li>需要在配置 <code>Configuration</code> 类上添加 <code>@ComponentScan</code> 注解，其中 <code>basePackages</code> 属性可以是基础包名也可以是多个 bean class（用 <code>,</code> <code>;</code> 或空格 <code> </code> 分隔）。</li>\n</ul>\n<h3 id=\"9-2-Class-Scanning-Filter\"><a href=\"#9-2-Class-Scanning-Filter\" class=\"headerlink\" title=\".9.2. Class Scanning Filter\"></a>.9.2. Class Scanning Filter</h3><p>在 Spring Class 扫描中添加过滤器。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-value-annotations\">reference</a></p>\n<ul>\n<li><p>Spring 默认的过滤效果是将 <code>@Component, @Repository, @Service, @Controller, @RestController, @Configuration</code> 6 个和自定义的注解 class 过滤出来。</p>\n</li>\n<li><p>在 <code>@ComponentScan</code> 中指定属性 <code>useDefaultFilters=false</code> 将取消默认扫描的类</p>\n</li>\n<li><p><code>includeFilters</code> 添加过滤器</p>\n</li>\n<li><p><code>excludeFilters</code> 拦截过滤器</p>\n<h4 id=\"9-2-1-Filter-类型\"><a href=\"#9-2-1-Filter-类型\" class=\"headerlink\" title=\".9.2.1. Filter 类型\"></a>.9.2.1. Filter 类型</h4></li>\n</ul>\n<ol>\n<li>annotation 默认，指定有某个注解的类为目标组件</li>\n<li>assignable 指定某个类或接口为目标组件</li>\n<li>aspectj AspectJ 类型表达式匹配目标组件</li>\n<li>regex 正则表达式匹配目标组件的 bean name</li>\n<li>custom 自定义实现 <code>org.springframework.core.type.TypeFilter</code> 过滤器</li>\n</ol>\n<h2 id=\"10-spring-容器中的-bean-实现不同方法\"><a href=\"#10-spring-容器中的-bean-实现不同方法\" class=\"headerlink\" title=\".10. spring 容器中的 bean 实现不同方法\"></a>.10. spring 容器中的 bean 实现不同方法</h2><p><a href=\"https://www.cnblogs.com/duanxz/p/7493276.html\">参考</a></p>\n<p>可以通过 java 配置类来实现 spring beans 的配置：</p>\n<ul>\n<li>@Configuration 等价于 <code>&lt;Beans&gt;&lt;/Beans&gt;</code></li>\n<li>@Bean 等价于 <code>&lt;Bean&gt;&lt;/Bean&gt;</code></li>\n<li>@ComponentScan 等价于 <code>&lt;context:component-scan base-package=&quot;com.dxz.demo&quot;/&gt;</code></li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/yjbjingcha/p/6752265.html\">获取 xml applicationContext 方法参考</a></p>\n<h3 id=\"10-1-Bean-Annotation\"><a href=\"#10-1-Bean-Annotation\" class=\"headerlink\" title=\".10.1. @Bean Annotation\"></a>.10.1. @Bean Annotation</h3><p>使用 <code>@Bean</code> 注册一个实例到 IoC 容器中。</p>\n<ul>\n<li>当要配置一个需要构造函数构造的 bean 时，需要指定其构造函数的参数。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection\">指定构造器参数 bean</a></li>\n<li><code>@Bean</code> 是一个方法级别的注解，使用在方法之上，方法返回类型即 bean 实例类型。</li>\n<li>推荐方法返回具体实例类型而不是接口类型。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation\">reference</a></li>\n<li>对一个 bean 指定生命周期回调<ul>\n<li>在 <code>@Bean</code> 中指定 <code>initMethod</code> <code>destroyMethod</code> 两个 bean 方法名，用以决定 bean 在初始化后现销毁前的回调。</li>\n<li><code>destroyMethod</code> 默认为 <code>deferred</code> 推断模式，在容器销毁前自行推断其销毁方法，如果想在容器销毁时保留 bean ，可以指定 <code>destroyMethod=&quot;&quot;</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"11-Naming-Bean\"><a href=\"#11-Naming-Bean\" class=\"headerlink\" title=\".11. Naming Bean\"></a>.11. Naming Bean</h2><p>bean 的命名<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics\">reference</a></p>\n<ul>\n<li>按惯例， bean 命名使用小驼峰。</li>\n<li>命名规范保持一致，有助于读与理解。同时，有助于 AOP 通过名字查找 bean 进入增强。</li>\n<li>对于 component scan ，Spring 为未命名的 componet 命名。取类的 simple name 小驼峰化为其名。特例：对于类名字母数量不只1个且前两个字符都是大写字母的情况， spring 会保留其原名。</li>\n<li>指定多个名：可使用逗号 <code>,</code>，分号 <code>;</code>，空格 `` 加以分隔。</li>\n</ul>\n<h3 id=\"11-1-Aliasing-Bean\"><a href=\"#11-1-Aliasing-Bean\" class=\"headerlink\" title=\".11.1. Aliasing Bean\"></a>.11.1. Aliasing Bean</h3><p>给 bean 起别名。<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-basics\">reference</a></p>\n<p><code>@Bean</code><br>当一个应用中存在多个子系统，系统之间需要使用同一个 bean</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckljnokqj00092bhbherl78k9","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokqr000f2bhb1e7f5phl"},{"post_id":"ckljnokq800012bhb0hdwauqj","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokqt000j2bhbcxa5an3k"},{"post_id":"ckljnokqm000a2bhb0k1fdeun","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokqv000l2bhb5arj5sqf"},{"post_id":"ckljnokqp000d2bhbc8n7728q","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokqx000o2bhb151p6k9p"},{"post_id":"ckljnokqc00032bhb79va8ox5","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokqy000r2bhbcpw44saz"},{"post_id":"ckljnokqq000e2bhb26ho7n3q","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokr0000v2bhbb7aa6qf1"},{"post_id":"ckljnokqs000i2bhb7conetq9","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokr1000y2bhb5ex74zc2"},{"post_id":"ckljnokqh00072bhb7qf4fji2","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokr300122bhbaih8320i"},{"post_id":"ckljnokqu000k2bhb8k78hhro","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokr400162bhbc6p86zom"},{"post_id":"ckljnokqw000n2bhb8h34g94o","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokr500182bhbh2dghtqn"},{"post_id":"ckljnokqy000q2bhbdobqe45s","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokr7001d2bhb5bnec16w"},{"post_id":"ckljnokqz000u2bhb7k2pgkbq","category_id":"ckljnokqe00042bhb7ca6c5od","_id":"ckljnokr8001g2bhb134u4kiz"},{"post_id":"ckljnokr0000x2bhbh6ry95mr","category_id":"ckljnokr300142bhbbn8n86bx","_id":"ckljnokra001l2bhb0xp496ap"},{"post_id":"ckljnokrb001m2bhb9ayyexuk","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrh001t2bhb9r5kdm0o"},{"post_id":"ckljnokr400152bhb1gcs2uip","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrj001w2bhb0ymw3ymt"},{"post_id":"ckljnokre001o2bhbat7u4ome","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrk001z2bhb645f5k4i"},{"post_id":"ckljnokrf001q2bhb7rc8g4pv","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrm00232bhbbzwwcq2a"},{"post_id":"ckljnokr500172bhbeesi1ob9","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrn00262bhbdbrnheap"},{"post_id":"ckljnokrh001s2bhb7q72buqn","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrp002b2bhb13omed7t"},{"post_id":"ckljnokri001v2bhb60jabt8u","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrr002e2bhbbnne0ys0"},{"post_id":"ckljnokr6001b2bhbaqbt41uf","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrs002i2bhb00r51pkv"},{"post_id":"ckljnokr8001f2bhbghbxgeg5","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrt002k2bhb3goi83uo"},{"post_id":"ckljnokr200112bhb7sdpclh6","category_id":"ckljnokr300142bhbbn8n86bx","_id":"ckljnokrv002n2bhbekxa13bl"},{"post_id":"ckljnokr200112bhb7sdpclh6","category_id":"ckljnokro00282bhb489c5qvr","_id":"ckljnokrv002p2bhbfx77evsz"},{"post_id":"ckljnokr9001j2bhb8yt0a5iq","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrw002t2bhbf82h4uz5"},{"post_id":"ckljnokrt002j2bhb395uhn4s","category_id":"ckljnokra001k2bhb6eyjcotx","_id":"ckljnokrx002v2bhb69kaab73"},{"post_id":"ckljnokrk001y2bhb898wb4j7","category_id":"ckljnokru002m2bhb115qgdd0","_id":"ckljnokrx002x2bhbe590897t"},{"post_id":"ckljnokrl00222bhbdev0eu3s","category_id":"ckljnokrw002s2bhb06gv3c4p","_id":"ckljnokry00332bhb23za7fyu"},{"post_id":"ckljnokrn00252bhb8pom6gmq","category_id":"ckljnokru002m2bhb115qgdd0","_id":"ckljnokrz00372bhb515icapx"},{"post_id":"ckljnokrp002a2bhbca5gdgz8","category_id":"ckljnokry00322bhb5aygcpuw","_id":"ckljnoks0003e2bhbhce42z17"},{"post_id":"ckljnokrq002d2bhbbjl45jxs","category_id":"ckljnokry00322bhb5aygcpuw","_id":"ckljnoks1003g2bhbbmzsdtr7"},{"post_id":"ckljnokrs002h2bhb52vv2k73","category_id":"ckljnokru002m2bhb115qgdd0","_id":"ckljnoks1003j2bhb2ag7fu2h"},{"post_id":"ckljnokt0006n2bhbdsl5g6je","category_id":"ckljnokr300142bhbbn8n86bx","_id":"ckljnokt4006t2bhb1tobeno9"},{"post_id":"ckljnokt1006o2bhbgkkw4ht6","category_id":"ckljnokru002m2bhb115qgdd0","_id":"ckljnokt4006v2bhbbrww29k9"},{"post_id":"ckljnokt2006q2bhb314xeove","category_id":"ckljnokry00322bhb5aygcpuw","_id":"ckljnokt5006y2bhbffj06xsp"},{"post_id":"ckljnokt3006s2bhb4g2m8nhc","category_id":"ckljnokru002m2bhb115qgdd0","_id":"ckljnokt500702bhb2m7r1lwr"},{"post_id":"ckljnokt700792bhb32habdbg","category_id":"ckljnokru002m2bhb115qgdd0","_id":"ckljnokta007d2bhb4l0zer6l"},{"post_id":"ckljnokt8007a2bhb7y9x0pyt","category_id":"ckljnokru002m2bhb115qgdd0","_id":"ckljnoktb007f2bhb0jtu4w1s"}],"PostTag":[{"post_id":"ckljnokq800012bhb0hdwauqj","tag_id":"ckljnokqg00052bhbh3zg81ga","_id":"ckljnokqx000p2bhbhizmgizz"},{"post_id":"ckljnokq800012bhb0hdwauqj","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokqz000s2bhbgptt5ze9"},{"post_id":"ckljnokq800012bhb0hdwauqj","tag_id":"ckljnokqs000h2bhb14ri33xu","_id":"ckljnokr0000w2bhb805a64gn"},{"post_id":"ckljnokqw000n2bhb8h34g94o","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokr1000z2bhbe4yxe5jw"},{"post_id":"ckljnokqw000n2bhb8h34g94o","tag_id":"ckljnokqg00052bhbh3zg81ga","_id":"ckljnokr300132bhb8v42fg2q"},{"post_id":"ckljnokqc00032bhb79va8ox5","tag_id":"ckljnokqw000m2bhb3km11nu2","_id":"ckljnokr6001a2bhbh77g9vcb"},{"post_id":"ckljnokqc00032bhb79va8ox5","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokr8001e2bhb6xcyel11"},{"post_id":"ckljnokqc00032bhb79va8ox5","tag_id":"ckljnokr200102bhbechh6s8c","_id":"ckljnokr9001i2bhbfluad4qy"},{"post_id":"ckljnokqh00072bhb7qf4fji2","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokrl00212bhb68dw5q13"},{"post_id":"ckljnokqh00072bhb7qf4fji2","tag_id":"ckljnokr8001h2bhbe9oietx3","_id":"ckljnokrm00242bhbglh3gzx3"},{"post_id":"ckljnokqh00072bhb7qf4fji2","tag_id":"ckljnokre001n2bhb0e681v4w","_id":"ckljnokro00292bhb9ei75ajd"},{"post_id":"ckljnokqh00072bhb7qf4fji2","tag_id":"ckljnokrg001r2bhbafrf9xwm","_id":"ckljnokrq002c2bhb8mq34dvp"},{"post_id":"ckljnokqj00092bhbherl78k9","tag_id":"ckljnokrj001x2bhb0dnacn7i","_id":"ckljnokrv002o2bhbck1k9140"},{"post_id":"ckljnokqj00092bhbherl78k9","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokrv002q2bhbft1468bj"},{"post_id":"ckljnokqj00092bhbherl78k9","tag_id":"ckljnokrr002f2bhb4o175qix","_id":"ckljnokrw002u2bhb14aebzxo"},{"post_id":"ckljnokqm000a2bhb0k1fdeun","tag_id":"ckljnokqg00052bhbh3zg81ga","_id":"ckljnokrx002z2bhba2o43jpo"},{"post_id":"ckljnokqm000a2bhb0k1fdeun","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokry00302bhb3ebbal3i"},{"post_id":"ckljnokqm000a2bhb0k1fdeun","tag_id":"ckljnokqs000h2bhb14ri33xu","_id":"ckljnokry00342bhb595y1gjl"},{"post_id":"ckljnokqp000d2bhbc8n7728q","tag_id":"ckljnokrx002w2bhbhs6s5lbw","_id":"ckljnokry00352bhb9vvfharj"},{"post_id":"ckljnokqp000d2bhbc8n7728q","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokrz00382bhbdf5j0y46"},{"post_id":"ckljnokqq000e2bhb26ho7n3q","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokrz003a2bhb5nwr8zma"},{"post_id":"ckljnokqq000e2bhb26ho7n3q","tag_id":"ckljnokry00312bhbek219q35","_id":"ckljnoks0003c2bhbchnlg818"},{"post_id":"ckljnokqs000i2bhb7conetq9","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnoks1003h2bhb6l3a4dxc"},{"post_id":"ckljnokqs000i2bhb7conetq9","tag_id":"ckljnokry00312bhbek219q35","_id":"ckljnoks1003i2bhbgc716ai9"},{"post_id":"ckljnokqs000i2bhb7conetq9","tag_id":"ckljnoks0003b2bhbeoxw143v","_id":"ckljnoks2003l2bhb1a39ers5"},{"post_id":"ckljnokqu000k2bhb8k78hhro","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnoks2003n2bhb8hcyhs8c"},{"post_id":"ckljnokqu000k2bhb8k78hhro","tag_id":"ckljnoks2003k2bhb2wze5ucr","_id":"ckljnoks3003o2bhb8xekadc7"},{"post_id":"ckljnokqy000q2bhbdobqe45s","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnoks3003q2bhbggnca95n"},{"post_id":"ckljnokqy000q2bhbdobqe45s","tag_id":"ckljnoks2003m2bhb4mrh33ct","_id":"ckljnoks3003r2bhbgl95bz6l"},{"post_id":"ckljnokqz000u2bhb7k2pgkbq","tag_id":"ckljnoks3003p2bhbaw6sgmma","_id":"ckljnoks4003u2bhbcmq69pai"},{"post_id":"ckljnokqz000u2bhb7k2pgkbq","tag_id":"ckljnokry00312bhbek219q35","_id":"ckljnoks4003v2bhba9l78a9y"},{"post_id":"ckljnokr0000x2bhbh6ry95mr","tag_id":"ckljnokqg00052bhbh3zg81ga","_id":"ckljnoks5003y2bhbb5n8col7"},{"post_id":"ckljnokr0000x2bhbh6ry95mr","tag_id":"ckljnoks4003t2bhb39mga6hj","_id":"ckljnoks5003z2bhb5r2i65nw"},{"post_id":"ckljnokr0000x2bhbh6ry95mr","tag_id":"ckljnoks4003w2bhba5mk0zv4","_id":"ckljnoks600412bhb55rdhtbj"},{"post_id":"ckljnokr200112bhb7sdpclh6","tag_id":"ckljnokqg00052bhbh3zg81ga","_id":"ckljnoks600432bhbcm7uew2e"},{"post_id":"ckljnokr200112bhb7sdpclh6","tag_id":"ckljnoks4003t2bhb39mga6hj","_id":"ckljnoks600442bhb6uya1sw2"},{"post_id":"ckljnokr200112bhb7sdpclh6","tag_id":"ckljnoks4003w2bhba5mk0zv4","_id":"ckljnoks700462bhb262p9a30"},{"post_id":"ckljnokr400152bhb1gcs2uip","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoks800492bhbgaaq3bj7"},{"post_id":"ckljnokr400152bhb1gcs2uip","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoks8004a2bhb8na41pfp"},{"post_id":"ckljnokr400152bhb1gcs2uip","tag_id":"ckljnoks700472bhb6t9fdmyn","_id":"ckljnoks8004c2bhbhs1r9pci"},{"post_id":"ckljnokr500172bhbeesi1ob9","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksa004f2bhbcxhb1hfm"},{"post_id":"ckljnokr500172bhbeesi1ob9","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoksa004g2bhb42o04725"},{"post_id":"ckljnokr500172bhbeesi1ob9","tag_id":"ckljnoks700472bhb6t9fdmyn","_id":"ckljnoksa004i2bhb7ram5mhs"},{"post_id":"ckljnokr6001b2bhbaqbt41uf","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksb004l2bhb7d2lez7u"},{"post_id":"ckljnokr6001b2bhbaqbt41uf","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoksc004m2bhbf60g16ga"},{"post_id":"ckljnokr6001b2bhbaqbt41uf","tag_id":"ckljnoksb004j2bhba91r227f","_id":"ckljnoksc004o2bhb3omee7ar"},{"post_id":"ckljnokr8001f2bhbghbxgeg5","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksd004q2bhbgq8qcz1m"},{"post_id":"ckljnokr8001f2bhbghbxgeg5","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoksd004r2bhbhsvt2sj1"},{"post_id":"ckljnokr9001j2bhb8yt0a5iq","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnokse004v2bhb0qso40pa"},{"post_id":"ckljnokr9001j2bhb8yt0a5iq","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnokse004w2bhb34ea9pnt"},{"post_id":"ckljnokr9001j2bhb8yt0a5iq","tag_id":"ckljnoksd004t2bhb9dencrj3","_id":"ckljnoksf004y2bhb9ada3nrh"},{"post_id":"ckljnokrb001m2bhb9ayyexuk","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksg00512bhbbupne3m0"},{"post_id":"ckljnokrb001m2bhb9ayyexuk","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoksg00522bhbh0d9cv88"},{"post_id":"ckljnokrb001m2bhb9ayyexuk","tag_id":"ckljnoksf004z2bhb18hq832g","_id":"ckljnoksh00542bhbc64m55st"},{"post_id":"ckljnokre001o2bhbat7u4ome","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksi00582bhb9vak2bwg"},{"post_id":"ckljnokre001o2bhbat7u4ome","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoksi00592bhb0kanch3v"},{"post_id":"ckljnokre001o2bhbat7u4ome","tag_id":"ckljnoks3003p2bhbaw6sgmma","_id":"ckljnoksj005b2bhbfxftcrvc"},{"post_id":"ckljnokre001o2bhbat7u4ome","tag_id":"ckljnoksh00562bhb6j2vgct6","_id":"ckljnoksj005c2bhbazs5ebsh"},{"post_id":"ckljnokrf001q2bhb7rc8g4pv","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksk005f2bhb8y3c7kyu"},{"post_id":"ckljnokrf001q2bhb7rc8g4pv","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoksk005g2bhbd4j23u91"},{"post_id":"ckljnokrf001q2bhb7rc8g4pv","tag_id":"ckljnoks2003k2bhb2wze5ucr","_id":"ckljnoksl005i2bhb6l03hjwz"},{"post_id":"ckljnokrh001s2bhb7q72buqn","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksl005k2bhbf38x1jwp"},{"post_id":"ckljnokrh001s2bhb7q72buqn","tag_id":"ckljnoks700452bhb4jd82h6s","_id":"ckljnoksl005l2bhb6llw6mv1"},{"post_id":"ckljnokri001v2bhb60jabt8u","tag_id":"ckljnoks600422bhbhf2514fb","_id":"ckljnoksm005n2bhb7sm3c7qd"},{"post_id":"ckljnokrk001y2bhb898wb4j7","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnoksn005q2bhb4927d1xu"},{"post_id":"ckljnokrk001y2bhb898wb4j7","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnoksn005r2bhbbddig9zw"},{"post_id":"ckljnokrk001y2bhb898wb4j7","tag_id":"ckljnoksm005o2bhbbt8p9by1","_id":"ckljnoksn005t2bhb9bje4v43"},{"post_id":"ckljnokrl00222bhbdev0eu3s","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnokso005v2bhb4jkd29gy"},{"post_id":"ckljnokrl00222bhbdev0eu3s","tag_id":"ckljnoksn005s2bhbb9g5d6oj","_id":"ckljnokso005w2bhbdg8va8ag"},{"post_id":"ckljnokrn00252bhb8pom6gmq","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnoksq00602bhb8pmm0jho"},{"post_id":"ckljnokrn00252bhb8pom6gmq","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnoksq00612bhb6i7b47ag"},{"post_id":"ckljnokrn00252bhb8pom6gmq","tag_id":"ckljnoksp005y2bhb6val2704","_id":"ckljnokst00632bhbfb4i6rag"},{"post_id":"ckljnokrp002a2bhbca5gdgz8","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokst00642bhb2w5p6jio"},{"post_id":"ckljnokrp002a2bhbca5gdgz8","tag_id":"ckljnoksp005z2bhbe2fj3jvh","_id":"ckljnokst00662bhbcpt9ejhb"},{"post_id":"ckljnokrq002d2bhbbjl45jxs","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnoksu00682bhbgdmhake0"},{"post_id":"ckljnokrq002d2bhbbjl45jxs","tag_id":"ckljnoksp005z2bhbe2fj3jvh","_id":"ckljnoksu00692bhb6mm8gpdv"},{"post_id":"ckljnokrs002h2bhb52vv2k73","tag_id":"ckljnoksu00672bhb01pn68m7","_id":"ckljnoksw006f2bhbgsh7fy4o"},{"post_id":"ckljnokrs002h2bhb52vv2k73","tag_id":"ckljnoksu006a2bhbc36w0yma","_id":"ckljnoksx006g2bhb4z8lclez"},{"post_id":"ckljnokrs002h2bhb52vv2k73","tag_id":"ckljnoksv006b2bhb61kr8v4v","_id":"ckljnoksx006h2bhbazzyg9qj"},{"post_id":"ckljnokrs002h2bhb52vv2k73","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnoksx006i2bhbbgvs75jp"},{"post_id":"ckljnokrs002h2bhb52vv2k73","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnoksx006j2bhb9ttodskw"},{"post_id":"ckljnokrt002j2bhb395uhn4s","tag_id":"ckljnokqw000m2bhb3km11nu2","_id":"ckljnoksx006k2bhbg0u8c35n"},{"post_id":"ckljnokrt002j2bhb395uhn4s","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnoksy006l2bhb1j0a0wsu"},{"post_id":"ckljnokrt002j2bhb395uhn4s","tag_id":"ckljnoksw006e2bhb9pujcabz","_id":"ckljnoksy006m2bhb1zvt3xfm"},{"post_id":"ckljnokt1006o2bhbgkkw4ht6","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnokt3006r2bhb5d7rcf00"},{"post_id":"ckljnokt1006o2bhbgkkw4ht6","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnokt4006u2bhb3qc587is"},{"post_id":"ckljnokt0006n2bhbdsl5g6je","tag_id":"ckljnokqg00052bhbh3zg81ga","_id":"ckljnokt5006x2bhb7z2shqcx"},{"post_id":"ckljnokt0006n2bhbdsl5g6je","tag_id":"ckljnoks4003t2bhb39mga6hj","_id":"ckljnokt5006z2bhb6z783t4e"},{"post_id":"ckljnokt0006n2bhbdsl5g6je","tag_id":"ckljnokt2006p2bhb7pkb51il","_id":"ckljnokt600722bhb8nqi3e1o"},{"post_id":"ckljnokt2006q2bhb314xeove","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnokt600732bhb3ztngs35"},{"post_id":"ckljnokt2006q2bhb314xeove","tag_id":"ckljnoksp005z2bhbe2fj3jvh","_id":"ckljnokt600742bhben33gmr5"},{"post_id":"ckljnokt2006q2bhb314xeove","tag_id":"ckljnokt4006w2bhb2ubo4102","_id":"ckljnokt600752bhb1tji1wgb"},{"post_id":"ckljnokt2006q2bhb314xeove","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnokt600762bhbb345eeb3"},{"post_id":"ckljnokt3006s2bhb4g2m8nhc","tag_id":"ckljnokqn000c2bhbb0t9gvcx","_id":"ckljnokt600772bhb8xya3rp8"},{"post_id":"ckljnokt3006s2bhb4g2m8nhc","tag_id":"ckljnokt500712bhbeiyc4y36","_id":"ckljnokt600782bhb7pww4nyq"},{"post_id":"ckljnokt8007a2bhb7y9x0pyt","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnokta007c2bhbgl8lfhtn"},{"post_id":"ckljnokt8007a2bhb7y9x0pyt","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnoktb007e2bhbg4bx4zrc"},{"post_id":"ckljnokt700792bhb32habdbg","tag_id":"ckljnoks1003f2bhb2kex06qw","_id":"ckljnoktb007g2bhbaxfv4ju9"},{"post_id":"ckljnokt700792bhb32habdbg","tag_id":"ckljnoksl005m2bhbfpfp5jmb","_id":"ckljnoktb007h2bhbbfj57apx"},{"post_id":"ckljnokt700792bhb32habdbg","tag_id":"ckljnokta007b2bhb82z1gpu5","_id":"ckljnoktb007i2bhbaduvhnsy"}],"Tag":[{"name":"programming","_id":"ckljnokqg00052bhbh3zg81ga"},{"name":"java","_id":"ckljnokqn000c2bhbb0t9gvcx"},{"name":"HashMap","_id":"ckljnokqs000h2bhb14ri33xu"},{"name":"framework","_id":"ckljnokqw000m2bhb3km11nu2"},{"name":"URI","_id":"ckljnokr200102bhbechh6s8c"},{"name":"jar","_id":"ckljnokr8001h2bhbe9oietx3"},{"name":"package","_id":"ckljnokre001n2bhb0e681v4w"},{"name":"jvm","_id":"ckljnokrg001r2bhbafrf9xwm"},{"name":"shadowing","_id":"ckljnokrj001x2bhb0dnacn7i"},{"name":"IO","_id":"ckljnokrr002f2bhb4o175qix"},{"name":"generic","_id":"ckljnokrx002w2bhbhs6s5lbw"},{"name":"concurrent","_id":"ckljnokry00312bhbek219q35"},{"name":"JMM","_id":"ckljnoks0003b2bhbeoxw143v"},{"name":"Java","_id":"ckljnoks1003f2bhb2kex06qw"},{"name":"Lock","_id":"ckljnoks2003k2bhb2wze5ucr"},{"name":"volatile","_id":"ckljnoks2003m2bhb4mrh33ct"},{"name":"lock","_id":"ckljnoks3003p2bhbaw6sgmma"},{"name":"linux","_id":"ckljnoks4003t2bhb39mga6hj"},{"name":"shell","_id":"ckljnoks4003w2bhba5mk0zv4"},{"name":"mysql","_id":"ckljnoks600422bhbhf2514fb"},{"name":"InnoDB","_id":"ckljnoks700452bhb4jd82h6s"},{"name":"Deadlock","_id":"ckljnoks700472bhb6t9fdmyn"},{"name":"index","_id":"ckljnoksb004j2bhba91r227f"},{"name":"commit","_id":"ckljnoksd004t2bhb9dencrj3"},{"name":"InnoDB Locking","_id":"ckljnoksf004z2bhb18hq832g"},{"name":"SQL","_id":"ckljnoksh00562bhb6j2vgct6"},{"name":"Spring","_id":"ckljnoksl005m2bhbfpfp5jmb"},{"name":"SpEL","_id":"ckljnoksm005o2bhbbt8p9by1"},{"name":"AOP","_id":"ckljnoksn005s2bhbb9g5d6oj"},{"name":"test","_id":"ckljnoksp005y2bhb6val2704"},{"name":"SpringBoot","_id":"ckljnoksp005z2bhbe2fj3jvh"},{"name":"validating","_id":"ckljnoksu00672bhb01pn68m7"},{"name":"data binding","_id":"ckljnoksu006a2bhbc36w0yma"},{"name":"type conversion","_id":"ckljnoksv006b2bhb61kr8v4v"},{"name":"spring boot","_id":"ckljnoksw006e2bhb9pujcabz"},{"name":"OS","_id":"ckljnokt2006p2bhb7pkb51il"},{"name":"Configuration","_id":"ckljnokt4006w2bhb2ubo4102"},{"name":"spring","_id":"ckljnokt500712bhbeiyc4y36"},{"name":"SpringMVC","_id":"ckljnokta007b2bhb82z1gpu5"}]}}