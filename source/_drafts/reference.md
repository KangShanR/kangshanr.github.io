---
title: Java Reference
tags: [Java, Reference, Pointer]
---

## 方法参数传递

Java 方法中引用指向传入的参数,如果在方法中将此引用指向一个新的值将不会对参数有任何影响,而如果将此参数引用指向的对象中的字段进行修改却会作用在外部参数中.这是因为方法参数在方法中只是一个引用指向了此参数对象,通过引用找到对象后修改其字段直接作用在参数对象上,这与直接修改参数引用指向不同.

## JMM

### 指令重排发生的地方
#### JIT 动态编译器

> 创建一个对象的语句 `Object obj = new Object();`步骤及 JMM 相关指令重排.

1. ref = allocate(Object.class) 根据 Object 类对象在内存上分配一块地址,ref 指向此内存地址;
2. invokeconstructor(ref) 针对此内存地址执行构造函数,初始化对象,给实例变量赋值;
3. obj = ref 将内存地址赋值给 obj 引用;

这三个步骤可能发和一指令重排为 1 -> 3 -> 2.这也是 double check 单例发生错误的根源.解决此问题就使用 volatile 修辞对象防止指令重排.

#### 处理器

- 多个指令按顺序发送到处理器中,处理器执行时可能不按指令进入的顺序执行,执行完成后按指令进来的顺序将指令结果写到写缓冲器或高速缓存中.
- 猜测执行: 处理器执行时可能会先执行 if 语句块内,再判断 if 的条件

#### 内存

> 高速缓存或写缓冲器中的指令重排

- 当处理器对调整缓存或写缓冲器发起 load 和 store 指令时候,其他线程可能看到在写缓冲器中的指令是乱的.比如 loadload 本来先执行读 W1 再执行 W2,其他线程看到的可能是先执行 W2 再执行 W1 .


