<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Kang Shan
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Java-Concurrent"><a href="#Java-Concurrent" class="headerlink" title="Java Concurrent"></a>Java Concurrent</h1><blockquote>
<p>Java 多线程</p>
</blockquote>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>Java 异步编程的神器，利用执行器 Executor 去执行多个任务时内置多个整合异步执行结果的方法，且全面支持 Java8 的函数式接口。</p>
<p>然而完全不能用于异步，只能在当前线程外开启异步而不能异步于当前线程执行任务。也就是说执行再多的异步任务，当前线程还是得等到 CompletableFuture 聚合出结果来才能执行下一步。 要在当前线程执行任务，使用线程池 ThreadPoolExecutor 。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><blockquote>
<p>使用线程池实现多线程编程</p>
</blockquote>
<p>工厂类 Executors 提供了便捷的构造线程池的方法，</p>
<ol>
<li>Executors.newCachedThreadPool() 无限线程数量，自动回收线程</li>
<li>newFixedThreadPool() 固定线程数量线程池</li>
<li>newSingleThreadExecutor() 单线程执行器</li>
</ol>
<p>如果需要更详细地控制微调线程池，就需要使用类中其他参数。</p>
<h3 id="Core-and-Maximum-Pool-Size"><a href="#Core-and-Maximum-Pool-Size" class="headerlink" title="Core and Maximum Pool Size"></a>Core and Maximum Pool Size</h3><p>ThreadPoolExecutor 会根据 corePoolSize 与 maximumPoolSize 自动调整线程池 pool size 。</p>
<p>当一个新的任务通过 execute(Runnable r) 方法被提交时，如果正在运行的线程数量低于 corePoolSize，这时会创建一个新的线程用以执行任务，不管此时其他已初始化好的线程是否是空闲状态。如果正运行的线程数量超过 corePoolSize 但少于 maximumPoolSize ，只有当队列是满的时才会创建新的线程执行任务。设置 corePoolSize == maximumPoolSize 就是设置了一个 fixed size Thread Pool 。如果设置 maximumPoolSize 为无限大（ Integer.MAX_VALUE ），就让线程池可并发执行任意数量的任务。一般来说， core Pool size 与 maximum pool size 在构造时设置好，但也可以使用 setCorePoolSize() 与 setMaximumPoolSize() 方法动态设置。</p>
<h3 id="Queuing-任务队列"><a href="#Queuing-任务队列" class="headerlink" title="Queuing 任务队列"></a>Queuing 任务队列</h3><blockquote>
<p>用于放置提交的不能当前执行的任务。BlockingQueue</p>
</blockquote>
<p>队列与 pool size 关系：</p>
<ul>
<li>如果正在运行的线程数量低于 corePoolSize ，执行器将添加一个线程而非放入队列。</li>
<li>如果运行的线程数量超过 corePoolSize，执行器将排队入队列而非添加线程。</li>
<li>当请求不能放置入队列，如果运行线程数量未超过 maximumPoolSize 将新添加一个线程，否则将拒绝请求。</li>
</ul>
<h3 id="三种排列策略"><a href="#三种排列策略" class="headerlink" title="三种排列策略"></a>三种排列策略</h3><ol>
<li>直接移交 direct handoff 。SynchronousQueue ，直接将任务提交给执行器不放置入队列。</li>
<li>无限队列 LinkedBlockingQueue</li>
<li>有限队列 ArrayBlockingQueue</li>
</ol>
<h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>当运行线程数量与队列容量都有限且已饱和，此时执行器将拒绝提交的任务。RejectedExecutionHandler#rejectExecution(Runnable, ThreadPoolExecutor).预定义的四种拒绝策略：</p>
<ol>
<li>默认的 ThreadPoolExecutor.AbortPolicy ，直接抛出运行时异常 RejectedExecutionException。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy，让提交任务的线程自己运行任务。可以降低高峰时请求任务执行数量。</li>
<li>ThreadPoolExecutor.DiscardPolicy，直接丢弃提交的任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy，丢弃队列中最老的任务。</li>
</ol>
<p>可自定义任务拒绝策略。实现 RejectedExecutionHandler .</p>
<h3 id="Hook-Methods"><a href="#Hook-Methods" class="headerlink" title="Hook Methods"></a>Hook Methods</h3><p>在每个线程任务执行前后添加钩子用以执行自定义。如果钩子方法抛出异常，内部线程执行可能执行失败并被中断。</p>
<ol>
<li>beforeExecute(Thread, Runnable)</li>
<li>afterExecute(Runnable, Throwable)</li>
</ol>
<h3 id="队列维护-Queue-Maintenance"><a href="#队列维护-Queue-Maintenance" class="headerlink" title="队列维护 Queue Maintenance"></a>队列维护 Queue Maintenance</h3><p>getQueue() 方法允许访问队列，但只推荐用以监控与 debug。当大量任务被取消，可使用 remove() purge() 方法回收队列空间。</p>
<h3 id="线程池析构"><a href="#线程池析构" class="headerlink" title="线程池析构"></a>线程池析构</h3><p>如果线程池不再被引用且没有线程在其中，将自动关闭 shutdown 。如果需要保证不被引用的线程池未被用户调用 shutdown() 方法被回收，需要将无用的线程死亡。方法是设置恰当的生命时长 keep-alive time ，低于0 的 corePoolSize 或 allowCoreThreadTimeOut(true)。</p>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Kang | <a target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder">Theme: Hexo-Coder</a></h4>
        <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="light">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>