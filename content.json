[{"title":"每天的问题与更新的答案","date":"2017-09-01T05:04:38.000Z","path":"2017/09/01/today's questions/","text":"今日问题 9/1/2017 6:00:51 PM 在实现同步代码块时，synchronized()这个()中的对象应该放入什么对象？ 通常放入了这个类的class对象，形如：synchronized(this,getClass()){} 9/3/2017 6:01:28 PM 对于一个子类，其继承的父类与实现的接口之间无关系，但这两者都有相同签名的方法，是什么样的情况？ 亲测有效，在子类实现父类与接口的同名方法一次就行，最终执行结果与所写代码块一致； 这个父类的方法不管是抽象方法，对结果并无影响； 对于面向对象多态的实现中，使用父类或接口来接收一个子类或实现类的对象时，这个对象并不会拥有自己扩展的变量或成员，只能拥有父类或接口的成员； main方法对于一个java程序的意义及它是如何被调用的，它的参数意义在哪？","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"访问修辞符","slug":"访问修辞符","permalink":"https://kangshanr.github.io/tags/访问修辞符/"},{"name":"java内部类","slug":"java内部类","permalink":"https://kangshanr.github.io/tags/java内部类/"},{"name":"迭代器","slug":"迭代器","permalink":"https://kangshanr.github.io/tags/迭代器/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"https://kangshanr.github.io/tags/匿名内部类/"}]},{"title":"Mybatis框架的应用与理解","date":"2017-08-31T05:12:34.000Z","path":"2017/08/31/mybatis/","text":"mybatis框架的使用与理解Mybatis与JDBC概述： MyBatis是一个半自动的面向sql的orm框架； JDBC全称：java database connectivity，是java封装在在java.sql包里的API，其设计目的在于连接数据库，通过java语言实现sql查询语言在数据库中的操作； Mybatis就是对JDBC的封装，使其操作数据库更为灵活，更多的数据与实体之间的映射交给配置文件来实现； JDBC作为java连接数据库的底层框架， 实现数据库连接功能的步骤： 加载驱动 获取数据库连接 准备语句（获取状态对象） 执行语句 处理结果集 关闭数据库（释放资源） 异常处理 可以看到在整个流程中的JDBC功能实现的缺陷： jdbc的硬编码不方便维护，需要不停地连接、释放数据库资源； 参数绑定在硬编码中，查询条件不定，修改语句也不方便； 所以，就有了MyBatis存在的必要； MyBatis的实现在一个工程中要使用MyBatis框架： 将MyBatis的核心包、依赖包引入。如果是Maven项目，直接在pom.xml中引入依赖：&lt;dependencies&gt; &lt;!-- 实现连接数据库的包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志记录的包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入相关的jar包后，就可以对mybatis进行配置： mybatis.xml文件中，配置mybatis的标签是： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 引入配置文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot; /&gt; &lt;!--自定义别名 --&gt; &lt;typeAliases&gt; &lt;!--定义单个别名 ,不区别大小写 --&gt; &lt;!-- &lt;typeAlias type=&quot;com.woniuxy.mybatis.entity.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;!-- 批量定义别名，该包内所有的类的类名直接作为别名，不区分大小写 --&gt; &lt;package name=&quot;com.woniuxy.mybatis.entity&quot; /&gt; &lt;/typeAliases&gt; &lt;!-- jdbc的配置信息 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射资源 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mappings/Users.xml&quot; /&gt; &lt;mapper resource=&quot;mappings/UserMapper.xml&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 其根标签是：&lt;configuration&gt; 解析上述各标签： properties:属性文件的引入，将java属性文件引入到该配置文件中，如上所述：引入了jdbc.properties文件，就可以在配置数据源属性时，通过点位符&amp;｛｝来获取到装配进来的属性文件中的属性值； typeAliases:别名的设定，可以指定单个类的别名，也可以使用子标签package 指定整个包的别名为类的simpleName; environments配置中，除了配置了JDBC数据库连接信息(数据源类型：POOLED)外,还得设定事务管理器类型：JDBC； mappers:映射各个实体类或映射类配置文件到此配置文件中去； mappers中的配置文件： Users.xml文件是指定了这个user类与数据库中操作的方法，包括这些方法的参数与返回值类型； &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;test2&quot;&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; SELECT * FROM t_user WHERE ID = #{id} &lt;/select&gt; &lt;!-- 根据用户名获取用户列表 --&gt; &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt; SELECT * FROM t_user WHERE user_name like &apos;%${value}%&apos; &lt;/select&gt; &lt;!-- 添加用户数据 --&gt; &lt;insert id=&quot;saveUserInfo&quot; parameterType=&quot;User&quot;&gt; &lt;!-- 使用selectkey返回插入数据的id --&gt; &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; &lt;!-- 如果主键使用uuid，则可以通过下面方法把id转出 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;string&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() &lt;/selectKey&gt; --&gt; INSERT INTO t_user(user_name,cnname,sex,mobile,email,note) VALUES (#{user_name},#{cnname},#{sex},#{mobile},#{email},#{note}) &lt;/insert&gt; &lt;!-- 删除数据 --&gt; &lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; DELETE from t_user where id=#{value} &lt;/delete&gt; &lt;!-- 更新数据 --&gt; &lt;update id=&quot;updateUserInfo&quot; parameterType=&quot;User&quot;&gt; UPDATE t_user SET user_name=#{user_name},cnname=#{cnname},sex=#{sex},mobile=#{mobile},email=#{email},note=#{note} WHERE id=#{id} &lt;/update&gt; &lt;/mapper&gt; #{}与${}的区别： #{} 表示占位符号，相当于实现了JDBC中的paparedStatement占位符的作用，也就实现了防止sql注入； 同时实现了java类型与jdbc类型转换，可以接收简单类型值与pojo属性值； 如果传输单个简单类型值，｛｝中可以是value或其它名称； ${} 表示sql字符串拼接，也就是将｛｝中的内容拼接在sql中且不进行jdbc类型转换； 可以接收简单类型值或pojo值，如果是简单类型值｛｝中只能是’value’; 文档头可以看出这是mabatis3映射的定义文档类型，所以其根标签为mapper，其中各子标签或属性： namespace属性，指定其命名空间，这样在其它地方要调用此配置文件中的各语句时，就需要通过这个命名空间来访问到此文档中定义id的各个语句，通过session对象的方法来调用时，这些语句就作为参数执行方法：`session.selectOne(“findUserById()”,user)； session的来源： /** * 测试前的预备工作 */ @Before public void before(){ System.out.println(Before.class); try { // 读入mybatis配置文件到输入流中 is = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factoryBuilder = new SqlSessionFactoryBuilder(); //使用输入流创建sqlSessionFactory factory = factoryBuilder.build(is); //打开sqlSession session = factory.openSession(); } catch (IOException e) { e.printStackTrace(); } } 上述代码是利用junit包实现了测试功能，@Before注解标这个方法在@Test方法之前运行，从该方法就可以看出myBaitis的运行流程： 将mybatis.xml配置文件读放流中，再使用sessionFactoryBuilder对该流进行创建工厂（抽象工厂模式）； 调用工厂的openSession()方法打开会话，获得sesison实例； 操作数据库最后一步就是调用session对象的方法：List&lt;User&gt; users = session.selectList(&quot;test.findUserByUsername&quot;, &quot;k&quot;); 这儿的test就是之前指定的namespace，这儿指定的id的语句执行，并将另外的参数传入，形成完整的sql语句； 这个流程是最初级的，而我们现实中常常不使用这样的形式，而使用接口来将所有方法的调用都交由接口来实现： 在获取到session时，就通过session.getMapper(Class mapper)方法来获取到相关的mapper接口的对象，而在使用过程中，就直接调用这个接口对象的方法（方法执行时就调用相应的语句执行），这个方法与语句之间映射就由指定了nameSpace的xml配置文件来实现，这种方法实现原理叫Mapper动态代理； 从上面的例子就可以看出Mybatis解决了的jdbc的问题： 数据库的链接的创建与释放者造成系统资源的浪费，而使用数据库连接池就可以此问题，在Mybatis的配置中设置； sql语句写在java代码中造成的不易维护，而Mybatis就将这些sql语句配置在相应的配置文件中，这样就与java代码实现了分离； 使用映射好的java对象来作为sql语句的statemente的参数，而不用像在jdbc的执行方法中定义输入参数的类型； 对于结果集的解析在JDBC中需要一层层遍历，并将各个属性封装到entity中再装入集合中。Mybatis将这些封装好，直接将结果映射到java对象中； 同时，上面例子并没有在持久层操作，也就是DAO层并没有进行开发，直接使用在TEST中进行调用抽象工厂的构造方法来构造工厂与sqlSession，再用sqlSession对象的方法，sqlSession的方法中调用配置好的sql语句与参数； 如果要实现持久层的开发不过是把上面构造SqlSessionFactory/SqlSession的方法封装进Dao类中实现； 使用Mapper代理开发概述： 动态代理开发，就是让生成Mapper对象的这个过程交给SqlSession对象的getMapper（Class mapper)方法，这时的SqlSession可以理解为工厂，也就是通过了工厂来构造获取Mapper接口的对象； Mapper对象就是Mapper接口的实例，这个接口与写好相关的mapper.xml配置文件相关联，Mybatis就用这个接口作为代理与被代理的mapper的公共接口，这个对象的方法执行时就与相关联的Mapper.xml配置文件里的sql语句来执行sql方法； Mapper接口与Mapper.xml配置文件相关联的规则（此规则由Mybatis规定，符合此规则便形成关联）： Mapper.xml文件中的namespce与mapper接口的类路径相同； Mapper接口方法名和Mapper.xml中定义的每个statement的id相同； 接口方法的输入参数类型和配置文件中的sql的parameterType的类型相同； 接口方法的返回数据类型与配置文件中的resultType类型相同的； 实现代理开发就意味着之前的session方法执行都交给这个Mapper对象，所有的操作方法都由这个接口定义，调用这个方法就只用传入定义的参数类型，这也就实现了由Mapper对象的方法来代理SqlSession对象中的操作数据库的方法(这儿涉及到代理设计模式的理解)，相对于直接使用SqlSession的各种执行方法更为简便； 动态代理开发中的小点： 动态代理在使用时，Mybatis会生成一个动态代理对象，至于这个动态代理对象会调用SqlSession的的selectOne()方法还是selectList()方法根据定义的mapper接口方法的返回值决定，如果返回List则调用selectList()方法，如果返回单个对象就调用selectOne()方法； 使用mapper代理开发就不用写mapper接口实现类，输入参数也可以直接使用map对象或pojo对象，保证了dao的通用性；","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://kangshanr.github.io/tags/Mybatis/"}]},{"title":"设计模式之适配器","date":"2017-08-29T05:04:38.000Z","path":"2017/08/29/adapter_pattern/","text":"适配器模式 适配器是行为型模式，将原有的行为经过组合进行扩展； 顾名思义，适配器就是将原本不适的接口或功能适配到目标对象上。 最简单的理解类型是缺省型适配器：将各个接口实现在一个适配器上，再让目标继承这个适配器（可省，直接用这个适配器new出对象来也一样可以实现），想扩展什么接口功能就重写相应的方法，就实现了适配器的扩展功能； 而比起缺省型适配器，还有类的适配器和对象适配器： 类适配器：将目标功能的接口执行并继承被适配者 被适配者：想在此类上扩展目标接口的功能（适配器的设计初衷在于，被适配者并不能直接实现目标接口）public class Adaptee { void run(){ System.out.println(&quot;Adaptee.run..........&quot;); } } 目标接口：public interface Target { void fly(); } 适配器：public class Adapter extends Adaptee implements Target { @Override//继承父类被适配者，并能方便地扩展其方法 public void run() { super.run(); System.out.println(&quot;Adapter.run.......&quot;); } //实现目标接口的方法 @Override public void fly() { System.out.println(&quot;Adapter.fly...........&quot;); } } 测试：public static void main(String[] args) { Adapter adaptee = new Adapter(); adaptee.fly(); adaptee.run(); } 测试结果：Adapter.fly........... Adaptee.run.......... Adapter.run....... note:这样的一个适配器在某种程度上来说与缺省的适配器并没有什么本质上的区别，都是将各种功能行为通过继承或实现聚合到同一个适配器上； 对象适配器模式： 与类适配器不同在于，对象适配器将被适配的类注入到适配器，再让适配器实现想要实现的接口，而让适配器聚合了这两者的成员； 被适配者与目标接口与上面例子一样，但适配器变成：public class Adapter implements Target { private Adaptee adaptee; public Adapter (Adaptee adaptee){ this.adaptee = adaptee; } //扩展被适配者方法相对来说要被动一点 public void run() { this.adaptee.run(); System.out.println(&quot;Adapter.run.......&quot;); } //实现目标接口的方法 @Override public void fly() { System.out.println(&quot;Adapter.fly...........&quot;); } } 可以看出来，对象适配器是将被适配者作为一个对象注入到适配者中，实现聚合其方法； Note: 适配器的好处在于：将各个部门不同的功能聚合到同一个对象上，而实现各个不同的功能都可以通过一个对象实现，达到了高聚合的效果； 适配器的缺点：各个不同的接口聚合到同一个类中，而让这个对象的接口变得混乱，当这个对象实现某一个功能时，会不清楚实现这个功能到底来自于哪个接口；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"设计模式之单例模式","date":"2017-08-29T04:54:30.000Z","path":"2017/08/29/singleton_pattern/","text":"设计模式之单例模式 单例模式是设计模式最常用到的模式之一，从字面上理解就是，该对象类只产生一个实例。这样做的理由在于开发过程中很多类（比如：管理类）都只用一个实例就够了，这样做也更节省资源。但是项目开发做会有一个多线程的问题，也就是当多个线程访问同一个类的单例时，这时会产生线程安全问题，为解决这个问题，单例模式分成了6种不同类型。 单例模式的设计目的就在于：不想让一个全局使用的类频繁地被创建再销毁其实例，要达到这样的效果就让其构造函数不能被不停地调用，也就是私有化其构造函数； 单例模式的6种类型： 非线程安全的懒汉式public class UserManager{ //静态单例 private static UserManager ins; //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ ins = new UserManager(); } return ins; } //其他的执行方法 ｝ 这种类型的单例就是没有考虑线程安全的单例，之所以叫“懒汉式”在于其实现了这个单例的懒加载，也就是第一次使用时才会实例化这个单例； 其缺陷在于当多线程同时第一次访问这个单例时，会构造出多个单例来，也就是说严格上讲它并不单例模式； 线程安全的懒汉式public class UserManager{ //静态单例 private static UserManager ins; //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static synchronized UserManager getIns(){ if(ins == null){ ins = new UserManager(); } return ins; } //其他的执行方法 ｝ 这处线程安全的懒汉式只是简单地在获取单例的方法上加上synchronized同步锁，同时也实现了懒加载； 这样做缺陷在于效率上的低下，想要获取这个类的单例所有线程都得等待上一个线程释放资源；-饿汉式 public class UserManager{//静态单例定义为类成员 private static UserManager ins = new UseManager(); //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ return ins; } //其他的执行方法 ｝ 这种单例定义为类成员，也就是类加载时就将这个单例初始化完成，未实现懒加载，会造成资源的浪费； 并没有使用同步锁而实现了多线程只访问同一个实例，效率上更高； 双检锁（双重校验锁），DCL（double-checked locking)public class UserManager{ //静态单例 private static UserManager ins; private Object lock = new Object(); //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ //第一次检查 synchronized(lock){ //保证不产生多余的实例 if(ins == null){ //第二次检查 ins = new UserManager(); } } } return ins; } //其他的执行方法 } 这种类型就实现了高性能与懒加载，逻辑上也相对复杂一点； 两次检验都放在getIns方法内，第一次校验确保只有ins实例第一次被创建时进入到同步锁块中，也就是多线程下会有多个线程进入到这一步，这时最先拿到控制权的线程构造实例后，其他的线程不能再构造实例了，所以就得在同步锁中再次进入第二次检验了； 静态内部类（登记式）public class UserManager{ //定义私有的静态内部类 private static class ManagerHolder{ //定义私有的静态属性，其值为我们想要的实例 private static final UserManager INSTANCE = new UserManager(); } //私有化构造函数 private UserManger(){} //获取单例的方法 public static UserManager getIns(){ return ManagerHolder.INSTANCE; } } 这种类型的单例模式效果和双检锁效果差不多，同样实现了懒加载，且没有使用同步锁； 枚举public enum UserManager{ //单例 INSTANCE; //其他的方法 } 这种方式是目前实现单例的最佳方法，但目前还没推广（jdk1.5之后才加入enum)，更简洁，自动支持序列化机制，绝对防止多次实例化； 6种单例模式中，前两种懒汉模式不推荐使用，第一种并非纯正的单例模式，第二种懒汉模式在多线程中效率低下，更不推荐，只要进入getIns方法就得等待上一个线程释放控制权；当对反序列化机制有严格要求时，就使用枚举方式；当要明确使用lazy loading时，就使用静态内部类方式或者双检锁方式；","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"单例模式","slug":"单例模式","permalink":"https://kangshanr.github.io/tags/单例模式/"},{"name":"线程安全","slug":"线程安全","permalink":"https://kangshanr.github.io/tags/线程安全/"}]},{"title":"得到例会：关于找工作","date":"2017-08-28T18:04:38.000Z","path":"2017/08/29/20170829IgotMeeting/","text":"得到例会8/29/2017 9:41:18 PM今天得到例会，快刀谈到找他招人的感想，觉得对自己很有用，记录下并找到之前他们拉过的清单，这儿一并引用过来，谈谈自己的看法: 快刀： 找交互设计大咖后，站在一个招技术人才的业务管理角度上谈谈自己对来聘人员的几点看法： 非应届生一定要了解应聘的公司，一定要做充足的准备； 自我介绍的作用：抓住重点，不能陷入自传； 诚实：圈子内信息透明； 为什么想离开？说前任公司坏话只会损坏自己形象； 问问题：跟以后的工作做了解的问题才是王道，关于细节上的五险一金、加班费、各种福利，这些问题都不是问业务主管的回答的； 快刀与娘娘分别在罗辑思维上推过关于找工作写简历的清单，个人认为很有参考意义，这儿一并贴出来： 快刀： 关于如何准备一份制胜简历的清单引言：简历是公司了解求职者的第一个途径，也是求职者获取工作的敲门砖。可是，有多少人明明很优秀，却败给了一份不合格的简历？ 简历是你的第一份产品，一定要认真对待，大方得体是王道。从招聘网站下载一个垃圾模板，随便填一大堆无用的信息，谁能相信你会认真对待自己的工作？ 贴照片要谨慎，只能选择清晰的大头证件照。绝不要贴游客照和婚纱照，谁知道哪个是求职的。也不要工作10年了，还贴高中的准考证照片。 除了没有任何实习经验的在校生，删掉自己在社团、学生会、班级、寝室里获得的各种奖励。它们除了告诉别人你很嫩之外，没有任何用。 要让别人从简历中看出你的经历和核心竞争力。最好做到逻辑清晰无废话，能一张纸写完绝不用两张。 个人资料的必备字段是：姓名、年龄、电话、邮箱、毕业学校。不会有任何一家正经公司，希望在简历里看到饮食口味、三围、罩杯之类的信息。 如果是做设计或产品的，简历只用一到两种字体，不要炫技。附带的作品集，保证有3-5个能代表最高水平的就好，不要连练手的作品都放进来。东西越多，机会越少。 不能加分的东西就会减分。越长的简历，越容易出错。例如，你是曼联球迷，你觉得面试官说“我也是”的机会很大。但可能初筛时，就被一个迷恋阿森纳的HR砍了。与工作无关的爱好，一笔带过，不要展开。 自我评价不要超过1条微博的长度。写800字那是高考作文，没人想看你给自己写的自传。 别作死。作死会让别人记住你，但是并不会让人招你。5年前，我在老东家时，收到过一封让我至今仍刻骨铭心的简历。邮件第一句话是，“其实我并不喜欢你们公司”，不喜欢你投简历干什么。 不要一遍又一遍的在简历里强调“我什么都不会，但是我很努力，我可以学”。活了20多年都没学会，凭什么相信你入职就能学会？ 凡是列了一大堆精通，里面还有Office的，几乎都会被刷。正如凡是写精通Excel的，真正问起来，懂透视表与各种公式的，基本没有。 附件除了Word版本，最好再附一个图片或者PDF版本。附件名字不要用“个人简历”或者“我的简历”，设想一下面试官电脑里有几十份“我的简历”的情形。用“应聘XX职位-X年工作经验-姓名”就足够了，也可以加上手机号。 作为职场中人，常备一份定期更新的简历是很必要的。不要等到看到机会再准备。定期根据实际情况来增减改删，只留下能代表自己最高实力的项目详情，其他项目一笔带过。 一岗一写，不要指望一份简历包打天下。针对每一个不同的公司或者岗位，单独改写简历。这就意味着不要海投简历，提前去媒体或社交网站上，了解这个公司的创始人或者高管，有助于你针对性改写。 用什么邮箱并不重要，但不要直接发一份带附件的空白邮件。邮件正文可以简单地描述一下自己的情况，但绝对不要空。 简历的核心作用是“争取到面试机会”，不要把自己的底牌都放在简历里。可以展示项目的成果数据，但是具体做法等到面试时再说。 最后提醒一句：不要逗贫。你不知道看简历的人笑点高低，一不注意会显得Low。 娘娘清单｜拿下目标职位的16个必杀技 我是脱不花，罗辑思维CEO。 三年来，我坚持面试加入团队的每一位员工，平均每周至少有八个小时投入在面试上。我经常会发白日梦，看着眼前面试的人，琢磨如果我是Ta，此时此刻此情此景我会做什么。 时间久了，这套代入法，成了一种练习，一种面对不同问题的沙盘推演。很好玩，也是内观、自省的方式。 我不会海量投递简历。我会把所有目标单位，按照自己的评价体系，分出梯队，一次只给特定的三四家公司投简历。一批如果失败，再启动下一批。 值得纳入评价体系的公司指标包括：公司成长性、能担任重要岗位的时间周期、薪酬、认识牛人的机会和频率、是否可以获得特别敬仰的师父、行业先进性、与我特长优势的匹配度、招收同龄同届人员的规模、公司整体的审美水平。 在投出简历之前，做足功课。研究这家公司的官网或者官微；认真阅读媒体动态，特别是创始人的讲话；体验这家公司的产品，尤其是非主力产品；上论坛或者贴吧看看相关评论，但不尽信。 我会把投出的每份简历，视为对这家公司的一次特定的沟通。没有标准简历一说，每份简历都是专门准备的。 我的简历核心内容只会有一页，其他皆为附件。简历首页是有助于建立信任的基本信息，要尽可能简洁。比如毕业院校、取得的最高荣誉、能为我背书的人、目标岗位、能力匹配，还有一张体面的标准照，而不是艺术照、生活照、自拍照。 简历里附件包括：我对公司的认同和对目标工作的理解，我以往的实际经验和相应的证明人，我的其他背景资料，主动提供社交媒体账号。 我在发送简历时，不会抖机灵，不会耍幽默。只会老老实实地写一封诚恳的邮件，把核心信息写在邮件正文里，而不是扔在附件里，用最小的格式把简历做成附件，发出。不会附上特别大的图片或者其他文件，也不会需要对方多次打开不同链接，而是一个可以快速打开、一次性看完的信息组合方式。 如果我极其渴望一份特定的工作，我会努力在投递简历前，做一些外围的示好。比如，结合自己的专业，帮这家公司做一些建设性的事情。 在面试时，进入公司现场，我会注意感受整体氛围：是否够开放？人与人之间是否有很多交流？每个人的状态看起来如何？我的直觉感受是怎样的？ 面试时，我会用简洁的表达方式。有问，必有答。回答中经常引用和提及在做功课时获得的公司信息，表现出对公司的熟悉度。 表现出愿意学习的态度，但要表达能为公司做的贡献，而不是表达自己是来学习的。 对薪酬问题，用坦率的态度直接谈，有弹性，但也要有底线。弹性让我不错过长期来看的好机会，底线让我避免掉进坑里。如果在薪酬上做了较大让步，开口提出建设性的办法，比如，达到什么标准公司应该加薪。 当面试官让我发问时，绝对不问五险一金和年假制度（这种有的是机会私下问HR）。我会问几个好问题，比如：我会和谁一起工作？如果我遇到问题，我可以通过哪些方式获得指导？公司鼓励什么样的沟通方式？公司希望我在三个月左右能达到什么水平？在我以前，公司里最优秀的新人是什么样的？ 精心打扮，但不过分。手机调整到无声。坐下就拿出笔记本。对面试官不要叫“某总”，张嘴就叫“老师”。 永远不要让对方知道，也许我手里还有其他Offer。这种故作紧俏的做法非常不体面。有经验的面试官不会因此紧张，反而怀疑你的诚意。 简历里不写错别字。面试时一直笑眯眯。 Q: 上面的16条心法，你在求职时做到了几条，最后的结果如何？你又有什么独家的心法呢？ 我的体会：总的看来，上面几十条都是在这几点： 我很靠谱，事情交到我手上可以有交代地被移交给他人； 我很善于合作，我善于连接； 我不笨； 另外，在这次例会中，快刀的关于找工作只是很小的一部分，只是这一点对我很有触动，全展开来了。娘娘这次的干货中很有启发的一点是：学习了一定要强制输出，每周写一篇文章发布在自己的朋友圈中，不仅仅是让自己学到底，更能让自己在朋友圈中树立一个靠谱有建树的形象，这也是重要的社交货币。","tags":[{"name":"job","slug":"job","permalink":"https://kangshanr.github.io/tags/job/"}]},{"title":"设计模式之工厂模式","date":"2017-08-28T02:04:03.000Z","path":"2017/08/28/factory_pattern/","text":"工厂模式 生成一个类交由相关的工厂类实现，而不由直接的类来实现； 相关的类继承同一个接口，实现这个接口的类都可以由工厂类中同一个方法来实现实例化； 例如简单工厂模式： //定义同一个类的抽象接口 public interface Shape{ void draw(); } //实现shape接口的类有： //Circle类 public class Circle implements Shape{ @Override public void draw(){ system.out.println(&quot;circle.draw&quot;); } } //Square类 public class Square implements Shape{ @Override public void draw(){ system.out.println(&quot;square.draw&quot;); } } //创建实例的工厂类 public class ShapeFactory{ //创建图形实例的方法 public Shape createShape(String shape){ if(shape.equalsIgnoreCase(&quot;CIRCLE”){ return new Circle(); } if(shape.equalsIgnoreCase(&quot;SQUARE”){ return new Square(); } reutnr null; } } 模式理解： 通过工厂来实现对各个类的实例化，都在工厂实现； 通过反射机制实现，增加一个同一接口的类不需要改变工厂的代码,只需要增加一个实现这个实现对应接口的类： 其工厂的代码：public class ShapeFactory{ //创建工厂的方法 public Shape createShape(Class&lt;? extends Shape&gt; clazz){ try{ return Class.forName(clazz.getName()).newInstance(); }catch(Exception e){ e.printStackTrace(); } } } 工厂方法模式 相较于简单工厂模式，工厂方法模式实现了“用扩展取代修改”，简单工厂中要增加减少实现产品的构造需要对工厂的代码进行修改，而工厂方法模式将这些都放在子类的实现中； 示例：生产iphone与miphone两种手机，将手机与工厂的接口抽取出来，分别用不同的工厂生产不同的手机； 手机接口：public abstract class Phone { } 手机类：public class Iphone extends Phone { public Iphone(){ System.out.println(&quot;Iphone.constracting.....&quot;); } } public class Miphone extends Phone { public Miphone(){ System.out.println(&quot;Miphone.constracting......&quot;); } } 工厂接口：public interface Factory { Phone createPhone(); } 工厂类：public class IphoneFactory implements Factory { @Override public Iphone createPhone() { return new Iphone(); } } public class MiphoneFactory implements Factory { @Override public Miphone createPhone() { return new Miphone(); } } 测试：public static void main(String[] args) { //创建iphone过程，先建工厂，再在工厂中创建iphone IphoneFactory facIphone = new IphoneFactory(); Iphone iphone = facIphone.createPhone(); //创建miphone过程： MiphoneFactory facMiphone = new MiphoneFactory(); Miphone miphone = facMiphone.createPhone(); } 测试结果：Iphone.constracting..... Miphone.constracting...... 工厂方法模式将对象的创建进行了很好的包装，但也正因此而每增加一个产品的类就不得不增加一个工厂来实现其构造，这在某种程度上来说是不科学的； 抽象工厂模式 相比较于工厂模式，抽象工厂模式在工厂模式的基础上增加生成工厂的工厂类，那么生产出来的工厂都要继承一个接口或父类； 该模式的优点：把同一个产品类集成到同一个工厂内，这样使用时就直接调用工厂中的方法，而生成同一个工厂里预备好的类对象，也更方便管理； 它是为了解决子工厂的扩展性问题，而将系列产品装配在同一个工厂中，也就实现了不同产品之间相互组合不同最终产品，而子工厂中不同产品抽取接口或父类方法出来成为抽象工厂； 示例：生产手机需要手机引擎、手机音乐盒这两种产品，这两种产品分别有两种类型，那么，一个引擎加一个播放器组成一个手机产品集 引擎接口：public interface Engine { } 引擎产品的两个类：public class EngineAmd implements Engine { public EngineAmd(){ System.out.println(&quot;EngineAmd.constracting....&quot;); } } public class EngineIntel implements Engine { public EngineIntel (){ System.out.println(&quot;EngineIntel.constracting.......&quot;); } } 音乐盒接口：public interface MusicBox { } 音乐盒的两个不同产品类：public class NokiaMusic implements MusicBox { public NokiaMusic(){ System.out.println(&quot;NokiaMusic.constracting...&quot;); } } public class SonyMusic implements MusicBox { public SonyMusic(){ System.out.println(&quot;SonyMusic.constracting...&quot;); } } 抽象工厂类，规定手机工厂要生产的两个产品：一个引擎一个音乐盒，这儿可以用接口也可以用抽象类public abstract class AbstractFactory { abstract Engine createEngine(); abstract MusicBox createMusicBox(); } 两个工厂类，实现抽象工厂，实现装配两个产品到一个工厂中//苹果手机厂，使用intel引擎与sony的音乐盒 public class AppleFactory extends AbstractFactory { @Override public EngineIntel createEngine() { return new EngineIntel(); } @Override public SonyMusic createMusicBox() { return new SonyMusic(); } } //联想手机，使用amd的内核与Nokia的音乐盒 public class LenovoFactory extends AbstractFactory { @Override public EngineAmd createEngine() { return new EngineAmd(); } @Override public NokiaMusic createMusicBox() { return new NokiaMusic(); } } 测试，将工厂创建出来由它们来创建手机的子产品public static void main(String[] args) { Apple apple4s = new Apple(); Lenovo lenovo3 = new Lenovo(); //apple生产过程 AbstractFactory appleFactory = new AppleFactory(); apple4s.engine=appleFactory.createEngine(); apple4s.musicBox=appleFactory.createMusicBox(); //Lenovo生产过程 LenovoFactory lenovoFactory = new LenovoFactory(); lenovo3.engine=lenovoFactory.createEngine(); lenovo3.musicBox=lenovoFactory.createMusicBox(); } 测试结果：EngineIntel.constracting....... SonyMusic.constracting... EngineAmd.constracting.... NokiaMusic.constracting... Note: 从上面例子可以看出： 抽象工厂可以实现组合产品集，一个工厂组合一个产品集，同时想要实现产品集的扩展也很方便。想要订制同一个产品集不同型号，直接实现一个工厂类。如果要不同产品集，则需要对抽象工厂进行扩展修改；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"无题","date":"2017-08-26T14:19:02.000Z","path":"2017/08/26/今日无题/","text":"刚才重看了一遍《当幸福来敲门》，看到Chris在实习期间，为了促进与客户的联系与第一个客户去包厢看football game，这就便结识了一众上流的客户。 我便想到，这个时候要是我是他，我做得到吗？Chris很穷，比现阶段的我还穷，但他在与他的精英客户一起看比赛的过程中，一点也不含糊，用着最专业的语言与人交流铺垫后面的工作事务。而如果是我，我肯定会在内心深处认为自己干不了这个事。这也是一般人的的认知上的缺陷。大家都会认为自己不熟悉的东西都不是自己的东西，会直接把这些东西排除在自己的思考范围之外。Chris为什么能做到？为什么我有同样的境遇时，我会把所有松懈归因到外界？同时，我为什么会松懈？因为我对自己要求低，为什么很容易让自己得过且过？因为我从来没有把自己当做一个有追求的人，并没有在内心深处认同自己是一个精英。或者说我根本不知道自己想要什么，想要成为一个什么样的人。这些最本质的思考从来没有进行过，而每次自以为是很与众不同的认知不过是用来平抚自己焦虑的安慰剂。关键点在于，没有把自己看起。从心理学角度来看，并不是一个高自尊的人。一个高自尊的人会在内心深处高看自己一眼，会把与精英互动当成理所当然，也就不会露出任何胆怯。 这也让我想到之前看到很多公号里的文章里介绍，一个强大的父亲是即使整个人都废掉了依然每天整洁清爽，并不因为穷困而开始潦倒，而是给儿女一个很爱护自己形象很会约束自己行为，随时准备与自己的贵人相遇的形象。 因此：别受到与自己水平差不多的人观念的影响，要随时与更厉害的人交流，探索他们的思维与观念，多接受别人的思考方法，学习别人的优点，思考自己的思维缺陷；保持自己的追求，当懈怠时，看看自己是不是总在寻找所谓的“小确幸”，用以填补内心的空虚。这种时候一般的表现是，做事情并没有什么效果，只是追求形式上的参与（这里不得不祭出陈昊老师一句话：参与感带来存在感，存在感带来优越感。仔细想想，是不是当下做的事只是为了满足自己的优越感）。 另外，今天在神游意淫某个与故人吹牛的场景时，想起一句诗：把酒话桑麻。原著：过故人庄——刘禹锡故人具鸡黍，邀我至田家。绿树村边合，青山郭外斜。开轩面场圃，把酒话桑麻。待到重阳日，还来就菊花。 曾经听说过欧阳老师与一个牛逼甲方在吃饭喝酒时，双方行酒令，关于“酒”的诗。双方你一句我一句，看得在场其他人目瞪口呆。忍不住，来一段： 酒逢知己千杯少，话不投机半句多。人生得意须尽欢，莫使金樽空对月。劝君更尽一杯酒，西出阳关无故人。（这一句在14年黄露家送别时酒桌上吟过，不知道在场的有没有觉得当时我很傻逼）对酒当歌，人生几何！明月几时有，把酒问青天。……实在想不起其他的了：”九九女儿红“……收工！！！","tags":[{"name":"essay","slug":"essay","permalink":"https://kangshanr.github.io/tags/essay/"},{"name":"观影无感","slug":"观影无感","permalink":"https://kangshanr.github.io/tags/观影无感/"}]},{"title":"神片试撸《巴霍巴利王II》","date":"2017-08-25T14:04:38.000Z","path":"2017/08/25/神片试撸《巴霍巴利王II》/","text":"今天晚上撸了一印度神片电影《巴霍巴利王II》，一部刺激荷尔蒙狂飙的电影，一部用视觉效果与背景音乐带着剧情与逻辑飞的电影，让人看了想谈恋爱想战斗想改变全世界。 绝美3D大场景， 各种虚光焦（妹子眼睛太好看了，忍不住再放一张）， 各种慢镜头， 各种高颜值， 各种强对比， 各种细节特写， 各种秀肌肉， 各种经典画面构图。 单看剧情人物性格构造说它脑残也不过分，为了个人英雄而强行让剧情与配角全都为这个英雄服务，观众能猜到下十分钟的剧情。 比起刚在国内下场不久的《摔跤吧，爸爸！》，可以预料，不管在商业上还是口碑上可能都差一截，但这片子把印度电影的长处发挥得淋漓尽致。该耍帅耍帅，该跳舞跳舞一点也不含糊，背景音乐超带感，整部电影简直串起了若干个MV，用视听效果来带着整部电影飞。总的来说，不错的片子。 另外提一句，特效渲染是国内的一家叫“蓝海创意”团队做的，国内的特效技术其实一直都是杠杠的。该片其实早在今天4月份就在印度与北美上映，也就是说上映时间早于《摔跤吧，爸爸》。国内的话，就算上映也不会有多少票房了，优酷上都可以看了，大众还会有几个愿意买单呢。","tags":[{"name":"movie","slug":"movie","permalink":"https://kangshanr.github.io/tags/movie/"}]},{"title":"得到直播：薛兆丰用经济学思维提升个人投资水平","date":"2017-08-24T00:04:38.000Z","path":"2017/08/24/薛兆丰：经济学思维与个人投资/","text":"得到直播：薛兆丰用经济学思维提升个人投资水平这里有直播的概要记录，也在最后有一些自己的思考。 中国经济会怎样？ 一个国家的经济会不会好？5个标准： 是否有一套完整的价值体系，过去30年中国改革开放的变化，一句话表述：由一个认人的社会变成了一个认钱的社会；一个认人的社会，社会资源的浪费会很大，一个认钱的社会会让社会的损耗降到最低。价格机制基本完善。 当中的制度让当中的人：一人做事一人当，别人做事别人当；每个人双手都放在自己的口袋里过日子。欧洲目前的难民危机：有一条难以接受，难民在欧洲领到救济，但不能工作。过去中国街头上有一群无所事事的年轻人，要成英雄用弹吉他、打架来定，但外资来了，工厂开过来了，这些一夜之间消失了。现在中国，每一个人，努力多一点，收获就多一点。年轻人上升的空间从来没有这么大，现在工作几年就可以独当一面，过去你想分到一套房要等到退休。 产权保护基于经济属性不基于物理属性。中国对共享经济、新兴产业的保护程度、接受程度比起欧洲好很多。日本做不通，劳动力贵。 政府是否有给新兴势力发展留有空间，新旧利益的交替是否顺利。Uber一兴起，社会的犯罪率就下降。人们对生活有了更多的期待。一碗水端平。 创新创业是不是受到保护。光看这些年国内举世无双的互联网、移动互联网产业，他们的兴起离不开整个社会体制的宽容与开放； 人机矛盾 人工智能来了，机器人带着大数据一路高歌猛进。人该怎么办？ 知识是集中不起来的，知识很重要，但生产一支铅笔的所有知识，没有人能完全弄懂的。这里面的知识是完全分散到各个人脑子里的，机器不能解决这个问题，人工智能不能把这样一个带着权重的任务处理好的。登山这个需求不是实际问题的解决方案，是人想要与人不同的人辛苦地做一件没有实际价值的事，人工智能只能派直升机把你送上去。 未来不可预测，为什么？社会的发展会受到知识的影响，人们的知识变化、想法变化，知识总在增长，知识的增量对人的影响也不可预测，哪怕人工智能已经来了，它也不可能预测的； 人的想像力是机器不能替代的。从数据到逻辑理论当中始终有一个迁跃，这里面不是一条连续的逻辑推演。计算机可以作出曲子来，但它永远不知道这首曲子好不好听。 比较优势原理，机器很多的地方，人很贵的。 人怎么办？人去学机器做不到的事。学耐用的知识：数学，学习学习的方法，保持对知识的好奇心；有了好奇心，这个世界到处都是平台给你学习，人跟机器互动。人工智能不能替代人，人工智能只会让人更有价值，蒸汽机只会让更多的工作机会产生； 投资身外物 当你有一笔可投资的钱，投在哪个地方？房产、比特币、股票、出国…… 买房目的：是用来自用还是投资。长久租金应该与产权费差不多，租售同权一出，买房的意义又少一些。你的需要是什么？中国的买房费用与租金相差3倍之多。人往哪儿挤？不是嘴上说的开门见南山的山清水秀之地，而是人聚积的大城市；聚积的好处：高楼成本很高，积聚一来，规模来了，细化分工，人的价值开始提升，周围地价就上升了。 博弈论：你想去的地方，别人也一样想去，你想得到的东西，别人也一样想得到，你能想到的好点子，别人一样也想得到；世界区分：物理的世界按过程一步一步来，每一步都按照固定规律来；经济的世界，人对世界的预期来决定世物的价格，人们事物的预测来决定价值，一切皆不可预测，一旦人们预测到了，这个东西就不再被纳入价格预测之中，价格不可预测，股市也不可预测；有没有内幕消息？会不会比别人早知道消息？没有，那么只买长线吧，看好一个国家一个公司肯定在未来上升的； 比特币，要成为货币还有很长一段距离。它有一个兴旺发展的过程，但这也是一个庞氏骗局的温床。击鼓传花的游戏中，谁来接这最后一棒？ 投资个人 对于自己的投资，更能掌控最可靠的投资方式 美国种族简历，所有人的收入统计起来，犹太人最富。地产会被外族收走，就投资首饰，首饰也被没收，就不得不选择知识、智力。 对知识的投资才是财富增长的根本原因。温度、资源都不是原因，人力资本才是改变个人改变世界的引擎； 学习各种各样的成功学，要记住别人的成功永远不可能复制过来的，永远不要忘记做自己手头能够做的事情。收入不均的问题， 不同的行业不同的人力有不同收入。用远大的目标来校正今天当下的行为。我们要追求的不是一刹那的幸福，不是当下的收入，而是一生幸福的总和，一辈子总收入。我们要看中二三十年后幸福收入总和。李嘉诚现在是赚很多钱，不是说当年他受过多少苦，他最让人佩服的是当年他在黑暗的隧道里眼前一样难以看到希望的时候，依然选择了努力，选择了学习。 后记：8/24/2017 10:02:53 PM 得到直播都是晚8点开始，这次薛老师一直讲到9点半，中途休息过两次都是讲得太久不得不喝口水休息一下，广告只在结束后小娴来拉的。 讲得很生动，听得我一直没有停下来过。听了之后开始反思这一段时间对自己的放松，这么长一段时间来自己对自己要求的降低，追求内心满足于小事，并不是让自信来源于自律，只来自于想像。 这个经济学课一开始就订阅了，刚开始的时候还听得挺认真，也有留言过，也有入选过一次精选，但后面开始学代码时，就没有抽时间来专门学习了，每天也只是在路上带着耳机听下，没有进行过深入思考。但具体反思一下，就算在开始认真听这个产品时，我也常常觉得这个还没学等待会有时间了就认真听一下，像故事中的狐狸一样，安慰自己只有在神奇岛上才能跳出最神奇的舞蹈，但别人都知道，我每天都踩在神奇岛的土地上。反观这个故事，其实狐狸也在骗自己，在某种天时地利下，自己可以跳出感动世界的舞，但这个行动一直没有实践过，也就导致了狐狸永远地看不到自己舞姿的拙劣，在各种小事中来获取满足感。这种心理机制的逻辑： 没自信面对自己失败的尴尬，导致一直把可能导致这种尴尬的情况给排开，并骗自己后面时机一到就亮绝活； 再在生活中找所谓的”小确幸“，并满足于这些众多的自嗨的”小确幸“； 直到无可挽回的地步时，就找到另外一个可以让自己隐藏自己可怜的实力点，再进入到第一步开始下一轮循环； 在这个死循环中，哪里一环可以被打破？每一环。每一环都应该提醒自己自信地面对自己，把手头的事做好就是打破魔咒的法宝。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"},{"name":"经济学","slug":"经济学","permalink":"https://kangshanr.github.io/tags/经济学/"}]},{"title":"科学思维看世间百态","date":"2017-08-23T00:02:42.000Z","path":"2017/08/23/卓老板：科学思维看世间百态/","text":"今天得到直播卓老板聊科技：用科学思维看世界运行的脉络，怎么看？直播的一些记要与心得： 科学思维三板斧： 等比缩放：WHO建议少吃糖，男性一天不超过28.5g，怎么算你的食物中有多少的糖？等比缩放。 把原来没有关系的两个事物放在自己能触及的地方； 比如：纳米和亿之间的关联怎么与你相关？ 我的身高是米，cpu的粒子是14纳米，我跟cpu就是亿倍关系。 滴答声一下是1秒，10亿意味着什么？就是32年。对于我们来说32年意味着什么大家肯定就有自己的概念了。 近似计算：通过简单地计算把一个问题定位到一个大概的范围，计算出一个大概的结果； 思维游戏问题：举国之电力，都由太阳能实现行不行？ 假如国家的财力无穷无尽，帝国时代游戏一般来设计我们太阳能？在沙漠中来铺开太阳能板 在高速公路两边的绿带铺开？下雨、阴天、维修，全国13万公里的高速公路， 近似计算鼻祖：费米，第一颗原子弹在内华达州的试爆，用纸片受远距离冲击波影响的飘距来近似计算爆炸当量（算得1万吨TNT当量，事后科学计算得2万吨），误差只有一倍（在质能方程中，估算当量误差往往很大） 对于陌生世界与陌生事物临到面前时，近似计算能力对于掌握新事物的到来很有帮助；平常生活中，这一项能力十分有用； 财务或其他对接事务时：不能有太多约束；比如，坟墓的占地在多久后会把人类居住地占完？但两代人后，人们不会对祖先的领地维护的。 建立模型：如果把人类的知识分类， 自下而上的知识，比如，考古，它的建立是一点一点地累积下来的，只能一块一块地拼图，最开始在边缘上找，再一点点往前推，在这个过程中，我们只能一点点积累证据，一点点接近真理； 自上而下的知识：流行病学，怎么传播，设定一些参数。建立一个模型，再用这个模型来推算其发展形态；如果生活中有问题能用一个模型来解释，那么就用这个模型来计算； 后记： 科学思维不能让你计算出未来事情准确发展动向，但能让你对事态的发展有一个大概地了解，不会一脸懞逼，而失去行事重心。 开始一场话之前，要对这场进行预判，在这场谈话中要达到什么目的； 如果这场话的目的在于让对方有一个很好的感受，那么在谈话过程中就尽量赞许对方，让对方流畅地表达出内心地骄傲； 如果要把自己突显出来，一定要话少，但一定要言必有物，每次场话有两三次谈话让别人印象深刻就很成功了。如果你的科学思维让你比别人看事物问题的角度更新颖开放，那么，一场谈话下来，很容易抓住这两个点让别人刮目相看。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"},{"name":"科技","slug":"科技","permalink":"https://kangshanr.github.io/tags/科技/"}]},{"title":"得到直播：打造工作方法","date":"2017-08-23T00:02:42.000Z","path":"2017/08/23/得到直播：打造工作方法/","text":"今天得到直播:打造工作方法有些启发，直播的一些记要与心得： 罗胖:打造工作方法 复制，任何行业，拿走的最多的红利的人不是最顶尖高手的人，而是专业力不错，但同时会复制传播的人，最直接简单的方式：写作，演讲； 怎么把成本覆盖掉，怎么把利复制？王石，任何一个麻烦找上我，我想法就是怎么让这个麻烦下次不再找上我； 正收益能不能复制？怎么提高自己的可复制性？ 三个字：确定性。 工作方法的高下就一点，能不能给确定性？ 能力的确定性； 靠谱与闭环，大家要知道你能力的边界，能力再小，网络中价值中都极大；老干妈，这个产品水平极高吗？不，但海外留学生都知道，想吃到中国味，老干妈一定没错；凡事有交待，件件有回应，不能成为反馈黑洞； 态度的确定性 态度不好拿，想得太多； 找到最基本简单的态度，坚持下去； 范围的确定性 每个人不管在什么层级，都是在创业； 时时刻刻要在所有人面前要表现，你在掌握全局； 思维： 上推，上推具体的操作到正式制度性抽象概念，高级餐厅的牛排旁边一定要放几朵西兰花，这样才显得高级； 下沉，你不是不写嘛，我来，你要觉得这个可以接受，那么我自己做点事，像水一样，把其他的地方勾勒出来，当对方接收到这个动作时，对方被水包裹后自然而然会被牵动； 最后有一段充满力量的话：王朔给女儿:（核心：把握自己，确定性；） 煲汤比写诗重要；自己的手艺比男人的重要；头发、胸、腰、屁股比脸重要；内心强大到混蛋比什么都重要； 在网上查了下，冯唐写这段话应该更早的，王朔应该是借用的冯唐的。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"}]},{"title":"spring框架的学习","date":"2017-08-15T04:14:38.000Z","path":"2017/08/15/spring/","text":"spring配置beans的底层原理就在于通过封装好的解析xml类，将xml文件中配置好的bean实例出一个对象来，再通过配置实现bean之间的相互引用，而实现将要用到的bean（实用类）实例化并使用； Core模块 bean标签： id属性指定这个实例的唯一标识； class属性，用来指定这个实例的类定义； property子元素，指定这个对象的属性，比如：user对象中有属性name,那么这个这个user的bean对象就应该有一个子元素标签property，同时如果这个属性是另外一个本地的bean，name属性指向这个属性：&lt;property name=&quot;advice&quot; id=&quot;beanId&quot;&gt;直接使用id属性来引用到其他的bean的id就行； AOP模块 Aspect Oriented Programming,面向切面编程 切面Aspect:可以理解为模块，比如，读写数据库、权限检查、异常情况记录； Advice,增强：拦截器实现增强接口Advisor，不同的拦截器实现不同的增强接口，比如：方法前拦截器MethodBeforeInterceptor implements MethodBeforeAdvice{ //方法前拦截器 //调用对象的方法前将执行该方法。参数分别为被调用的方法、参数、对象 public void before(Method method, Object[] args, Object instance) throws Throwable{ System.out.println(&quot;即将要执行的方法：“+method.getName()); //如果是Service if(instance instanceof WaiterServiceImpl) String name = ((AopServiceImpl) instance).geName(); if(name == null)//检查是否为空 throw new NullPointerException(&quot;name属性不能为null&quot;); } method.invoke(instance,args); } } 拦截器，interceptor，也是pointcut的核心: spring拦截器的配置实现，通过增加配置：&lt;bean id=&quot;aopMethodBeforeInterceptor&quot; class=&quot;org.springframework.aop.supoort.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot;&gt; &lt;bean class=&quot;com.snail.aopdemo.advice.MethodBeforeInterceptor&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;mappedName&quot; value=&quot;withAop&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 从上面的代码可以看出： spring实现拦截器都是通过增强器Advisor，而这个增强器是一个代理，将参数（自定义的Advice）作为参数传入其中； 同时mappedName属性用来指定拦截的方法，这个方法并不是增加类中的方法，而是到时要执行到的所有的匹配方法名字段的方法； 同时：spring支持由正则表达式配置切入点：&lt;property name=&quot;patterns&quot;&gt; &lt;!-- 正则表达式配置切入点--&gt; &lt;list&gt; &lt;value&gt;.*get.*&lt;/value&gt; &lt;!--包含get字段的方法就被拦截&gt; &lt;value&gt;.*absquatulate&lt;/value&gt; &lt;!--包含absquatutulat字段的方法被拦截&gt; &lt;/list&gt; &lt;/property&gt; ORM模块 Object RelativeDatabase Mapping,对象关系型数据库映射 简介： 此模块对Hibernate/JDO/TopLink、iBatis等ORM框架提供支持； Spring提供在DAO层提供HibernateDaoSupport类与JDBCTemplate类； 在Spring里，Hibernate与SessionFactory等只是Spring一个特殊的Bean，由Spring负责实例化与销毁；所以也就不需要与Hibernate的API打交道，不需要开启关闭Hibernate的Session、Transaction，Spring自动维护这些对象； 实体类这儿用User类举例： 使用注解来让User中属性与数据库中表的列相关联； Entity类的注解： @Entity，表明这个类为实体类； @Table（name=”users”),指明此实体类与数据库users表相关联； 属性的注解： @Id，主键注解，表明这属性为数据库表中的主键 @GeneratedValue（strategy=GenerationType.IDENTITY),指明该主键生成策略为自增 @Temporal（value = TemporalType.Date),表明列属性为Date DAO层接口，不同的Entity对应不同的DAO接口： UserDao接口，就定义对User表的操作：public interface UserDao{ public void saveUser(User user); public List&lt;User&gt; findUsers(); public int getCount (); public User findUserByName(String name); } UserDao接口的实现类，UserDaoImpl： 这个实现类要继承HibernateDaoSupport类，这就意味着从父类继承了Hibernate与HibernateTimplate对象，该对象就对实体对象进行各类操作；public class UserDaoImpl extends HibernateDaoSupport implements UserDao{ //实现接口中的方法 public void saveUser(User user){ this.getHibernateTemplate().persist(user);//使用父类方法get到Template,并调用其persist方法将user存入 } } public int getCount(){ //查询记录条数 Number num = (Number)this.getSession(true).createQuery(&quot;select count (*) from User).uniqueResult(); return n.intValue(); } public List&lt;User&gt; findUsers(){ //查询所有的user return this.getHibernateTemplate().find(&quot;select * from User&quot;); } public User findUserByName(String name){ //根据用户名查询用户 List&lt;User&gt; users = this.getHibernateTemplate().find{&quot;select * from User u where u.name=?&quot;, name); //使用Template if(users.size() &gt; 0) return users.get(0);返回第一条 return null; } } 从上述代码例子中可以看出： 查询(Read)、创建(Create)都由父类HibernateDaoSupport提供的getHibernateTemplate方法获取到实例并执行实例的方法来实现，其中查询使用实例方法find(String sql, Stirng 拼接String），而save则用持久化方法persist(Object user); 当要涉及到数据库计算时，则用getSession获取到与数据库的会话对象，让会话对象执行sql统计语句； 同时，所有sql语言的操作对象都指向实体类，而没有对数据库中的表进行组织sql语句； 个人理解：spring通过封装Hibernate在框架中，让DAO接口的实现类继承HibernateDaoSupport尖，就将Hibernate对象创建出来，而直接操作这个对象的方法来获取session/Hibernate对象直接与数据库交互，而就节省了操作JDBC的代码； 配置集成Hibernate 在spring的bean.xml文件中配置集成hibernate到目前这一步只需要配置三个bean： 数据源datasource，这是一切的基础，所有的操作最终都会落到对数据库的操作上；&lt;bean id=&quot;datasource&quot; class=&quot;org.apache.commonsdbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; class=&quot;org.gjt.mm.mysql.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc\\:mysql\\://localhost\\:3306/ssh&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;propery name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; - 数据源的配置就是用依赖包中的一个封装好的类（这儿就是BasicDataSource）的对象，并将这个对象的属性值配置好，这些属性就包括了数据库的驱动、连接的url、连接数据库的用户名、密码。可以想象的是，这个处理数据库的对象封装了所有的连接数据库的方法，使用密码与用户名，交给驱动对象，这个驱动对象就按照提供的url连接到主机上的数据库，并登录到数据库； 有了数据源，就可以将关联连接库的数据源配置到sessionFactory中去：&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.annotation.AnnotationSessionFactoryBean&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;dataSource&quot;&gt; &lt;ref bean=&quot;dataSource&quot;/&gt; &lt;property/&gt; &lt;property name=&quot;annotatedClasses&quot;&gt; &lt;list&gt; &lt;value&gt;com.woniuxy.orm.class_qulified_name&lt;/value&gt; &lt;/list&gt; &lt;property/&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;pros&gt; &lt;pro key=&quot;hibernate.dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/pro&gt; &lt;pro key=&quot;hibernate.show_sql&quot;&gt;true&lt;/pro&gt; &lt;pro key=&quot;hibernate.format_sql&quot;&gt;true&lt;/pro&gt; &lt;pro key=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/pro&gt; &lt;/pros&gt; &lt;/property&gt; &lt;/bean&gt; 配置会话工厂（因为我们的实体类使用的注解映射，所以就使用注解会话工厂AnnotationSessionFatoryBean)其中包括了：数据源、实体类还有hibernate,而hibernate的配置就包括了方言、输出sql语句、格式化sql语句、创建表结构 有了会话工厂，距离操作数据库就只有让Dao配置为bean，而操作代码就getBean来获取到这个Dao的实例，让这个实例来操作数据库：&lt;bean id=&quot;userDao&quot; class=&quot;daoImpl_qualified_name&quot;&gt; &lt;property name=&quot;sessionfactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; 在Dao的bean中，将前面配置好的sessionFactory装配到其中 以上情况是实体类User是使用注解来配置的，这种情况下，使用的sessionFactory是AnnotationSessionFactoryBean,但当实体类是使用xml文件来配置时，使用的配置bean应该是LocalSessionFactoryBean。同时，sessionFactory中配置实体的方式也变成：&lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:entiteis_配置文件的路径&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; Hibernate的事务管理 分层的做法：应用层调用Service层，Service层对数据进行检查（是否重复之类），然后Service层（注入一个Dao属性）调用Dao层，Dao层调用Hibernate实现数据的操作。原则上不允许跨层访问，业务层次分明。 事务管理transaction，对应的层为Service层； spring的bean.xml配置文件的理解 所有的操作都基于对数据库的crud，所以所有的配置都围绕着操作数据库； 所以，第一个bean的是数据源：dataSource 其中的属性就包括： 连接数据库的驱动：driverClassName 数据库连接url:url 数据库连接用户名：username 数据库连接密码：password 通常情况下，我们把数据源信息都单独分离在jdbc.properties文件中，并在要用到的配置文件中将其配置为上下文&lt;context:property-placeholder&gt; location=&quot;classpath:jdbc.properties/&gt;，之后就可以在数据源dataSource中配置其中的属性：&lt;property name=&quot;driverClass&quot; value=&quot;${driver}&quot;&gt;&lt;/property&gt; 第二个配置的bean：sessionFactory 这儿就把上一次配置好的dataSource数据源装配到sessionFactory的属性中：&lt;!-- 配置本地会话工厂bean --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 指定hibernate配置文件--&gt; &lt;property name=&quot;configLocations&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt; &lt;!-- 指定hibernate映射文件--&gt; &lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:mappings/*.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; Note:这儿配置spring的sessionFactory属性就会把Hibernatek r sessionFactory属性覆盖； configLocations属性：将指定路径的配置文件都加载进去，相应的LocalSessionFactoryBean中的的此属性的setter方法的参数为可变参数:public void setConfigLocations(Resource... configLocations) { this.configLocations = configLocations; } 而在上述代码中，hibernate的配置文件也直接引入到sessionFatory中来，而在外部的hibernate配置文件： &lt;session-factory&gt; &lt;!-- 配置方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- session上下文控制权:交给session来控制 --&gt; &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;org.springframework.orm.hibernate5.SpringSessionContext&lt;/property&gt; &lt;!-- 格式化sql语句 --&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 显示sql语句 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 表的生成策略 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;/session-factory&gt; 其中配置了部分的Hibernate属性，同时也可以配置c3p0的属性在其中； 第三个配置：事务管理器transactionManager 将前面配置好的sessionFactory装配到这个bean中，作为sessionFactory属性值； 第四个配置：tx:advice，配置事务的传播特性，指定具备事务的方法名； &lt;!-- 事务配置增强 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txMng&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;batch*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;load*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;!-- 统配 --&gt; &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 最后一行统配就指定了所有的方法都配置上事务，同时isolation指此事务的隔离级别，propagation指事务的传播属性，read-only指是否为只读； 第五个配置aop:config，配置事务的切入点，以及被管理的对象&lt;aop:config&gt; &lt;aop:pointcut id=&quot;interceptorPointCuts&quot; expression=&quot;execution(* com.woniuxy.sshdemo.service.impl.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;interceptorPointCuts&quot;/&gt; &lt;/aop:config&gt; 先将切面的切点配置进来，也就是各个service的执行对象。再将这此切点配置到advisor中 其它的配置： dao的执行类，配置一个id加上sessionFactory; service的执行类,配置上dao这个属性的对象； 使用注解来实现事务的配置 这时bean.xml： 数据源不变 sessionFactory不变； 事务管理器trasactionManager依然不变； 变的是：添加一个事务注解驱动tx:annotation-driven trasaction-manager=&quot;transactionManager&quot;/&gt;，添加这个驱动配置后，对产生事务的类添加注解@Transactional，标记这个类为事务类，对其中的事务方法添加注解@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)注解（标明了这个方法的隔离水平与传播水平）。这样的注解就取代了上面例子中tx:advice与aop:config两个配置节点的功能；","tags":[{"name":"framework","slug":"framework","permalink":"https://kangshanr.github.io/tags/framework/"}]},{"title":"java底层之引用","date":"2017-08-13T04:04:38.000Z","path":"2017/08/13/java_reference/","text":"直接引用与符号引用JVM运行类加载后， 在类的解析阶段，JVM会把类的二进制数据中的符号引用替换为直接引用。 符号引用：Symbolic References 以一组符号来描述 所引用的目标，而这个符号可以是任何形式的字面量，只要使用时可以无歧义定位到目标即可; 存在的原因：在编译阶段，java类并不知道所引用类的实际地址，只能使用符号来表示类的地址。而且在不同JVM实现的内存地址也不尽相同，经过符号引用这一道工序，同一个类，其符号引用必然一致； 类在解析过程中，就根据JVM实时产生的内存分配状况，将符号引用转为直接引用； 直接引用：Direct References- 直接引用是和虚拟机的布局直接相关的，同一个符号引用在不同的JVM上翻译出来的直接引用也不尽相同。某个目标有了直接引用，那说明这个目标已经被加载到内存中了 直接引用可以是： 直接指向目标的指针（如，指向类型class对象、类变量、类方法的直接引用就是指向方法区的指针）； 相对偏移量：如指向实例变量、实例方法的直接引用都是偏移量； 一个能直接定位到目标的句柄； Note: 也就是说通过符号引用转换为直接引用来实现了引用的跨平台（对于同一个数据对象的引用都用同一个符号引用来实现，而在不同的平台上不同的JVM运行时转换成不同的直接引用）","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"JVM","slug":"JVM","permalink":"https://kangshanr.github.io/tags/JVM/"},{"name":"跨平台","slug":"跨平台","permalink":"https://kangshanr.github.io/tags/跨平台/"}]},{"title":"java枚举","date":"2017-07-29T04:04:38.000Z","path":"2017/07/29/java_enum/","text":"java枚举简介： 枚举enum是在jdk1.5后引入的，是java高级特性之一； 枚举的定义关键字：enum public enum season{}，其与普通类一样拥有属性、方法、构造函数 枚举是特殊的类，其成员全都是固定下来的；枚举特性： 枚举的构造函数默认是私有的，可以自定义枚举私有的构造函数 所有枚举的公共基类为abstract Enum","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"enum","slug":"enum","permalink":"https://kangshanr.github.io/tags/enum/"}]},{"title":"原创小段子之人物没原型","date":"2017-07-25T17:04:38.000Z","path":"2017/07/26/原创小段子—人物没原型/","text":"暑假了，女儿欢欢喜喜大学归家。到了家门，嗲声嗲气叫：爹。。。娘。。。 爹娘笑嘻嘻看了女儿两眼后，转过头去：关于生活费，你能不能把买吃的和买穿的比例对调一下。。。","tags":[{"name":"tale","slug":"tale","permalink":"https://kangshanr.github.io/tags/tale/"}]},{"title":"Java多线程","date":"2017-07-14T04:04:38.000Z","path":"2017/07/14/java_multithread/","text":"线程安全 在一个运行程序中，当另外一个线程对这个程序发起请求时，相当于重新执行其中方法，但一个类中某些属性在程序执行过程中需要保持状态的统一性，这时就需要在一个线程执行完毕后再让另一个线程执行相关的方法。这就需要实现线程安全； 实现线程安全的方法： 将方法修辞为线程安全的方法（加上修辞符synchronized)：public synchronized void doPay(int money){ if(balance &gt;= money){ balance -= money; }else{ system.out.println(&quot;你的余额不足！”） ｝ system.out.println(&quot;你的余额为：“+balance); } 使用同步块：synchronized(Object object){ //要同步的代码块 ｝ 实现同步机制是基于”监视器“这一概念，java中所有对象都拥有自己的监视器，加上同步锁，就是让这个对象进入监视中； 在各个project中，对于各管理类使用单例模式时，常常容易忽略多线程做成伪单例。也就是做成单例只单单在单线程中可以实现，在多线程环境中实现不了单例。public class Manager{ private static Manager ins; //私有化构造函数 private Manager(){} //获取单例 public static Manager getIns(){ if(this.ins == null){ this.ins = new Manager(); } return this.ins; } } 这种单例的实现就必须在依赖单线程的运行环境； 但现实中往往是多线程环境，这时要实现单例就得双重校验锁：public class Manager{ private static Manager ins; private Object lock; //私有化构造函数 private Manager(){} //获取单例 public static Manager getIns(){ if(ins == null){ //第一次校验，当多个线程执行获取单例的方法时，先对单例是否为空进行判定，为空才进入同步状态 synchronized(lock){ if(this.ins == null){ //第二次校验，进入同步锁状态，对单例进行校验，为空的话才进行构造单例 this.ins = new Manager(); } } } return this.ins; } } 一定要理解到这儿使用的双重校验缺一不可：两次校验才能实现同步线程对多线程操作的效率： 如果单单全用一次校验在方法上，也就是所有访问到这个方法的线程就直接进入到同步锁状态，那么就会造成大多访问线程的滞留，后部都等到第一个线程执行方法完毕再依次进入到方法中执行，这样明显是不合理的； 如果在方法内部同步块之前只使用一次判定，就会造成多个线程同时执行这个获取单例方法时ins被判定为null，多个线程同同时等待同步块执行完，这样在第一个执行的线程构造单例后，虽然这时执行getIns()方法的线程不会进入到同步块等待了，但之前进入到同步块等待的线程还是会依次等待前面线程释放控制权后继续构造单例；所以才会在这同步块内再次校验ins是否为空，形成双重校验","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"单例模式","slug":"单例模式","permalink":"https://kangshanr.github.io/tags/单例模式/"}]},{"title":"项目开发模型","date":"2017-06-22T18:14:38.000Z","path":"2017/06/23/项目开发模型/","text":"瀑布模型：(政府银行类项目） 工程开发流程： 需求分析（提出一个idea）； 可行性分析（看目前条件下是否能实现这个idea）； 总体分析：通过可行性分析后，用哪些工具包进行开发； 详细设计：当前要用哪些工具，详细的模板功能，甚至每个功能实现变量方法的名称都定下来； 垒代码：完成模板； 测试:（分系统测试，单元测试，看划分力度），带着测试去编程，bug更，性能更佳； 上线： 迭代螺旋模型：（阴阳师） 开发流程： 先出来一个粗糙模型原型，马上上线，抢占市场； 马上一次迭代，小步快跑，每一周就可以迭代一次，不停地壮大； 不同开发模型中就是使用以上的流程不同方式（周期，频次）,除了瀑布模型与螺旋模型，常用的项目开发模型还有： 迭代模型 增量模型（钱产够的情况下，先将能上线赚钱的模块开发出来上线，后续根据需求来增加不同的项目模块）","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"项目开发","slug":"项目开发","permalink":"https://kangshanr.github.io/tags/项目开发/"}]},{"title":"设计模式之代理模式","date":"2017-06-13T04:14:12.000Z","path":"2017/06/13/proxy_pattern/","text":"设计模式之代理模式简介： 代理(Proxy)提供了对目标对象另外的访问方式;即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. 这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 下面就来简单介绍下代理模式的三种方式： 静态代理 可以让代理类同时实现真正想的对象的类实现的接口，而在代理类中有一个真正类的属性，当想要这个真正类时，对上述属性判空，再实例化，这样通过代理类执行接口中的方法时就是执行的真正想要的类的方法了； 简单地讲，代理就是将其他的类的各种实现方法，交由代理来实现。而要达到这种效果，就可以让代理与其他的类实现同一个接口，再在代理中实现接口方法中去实现这个类的方法。这也是代理的核心，一般代理中要注入一个代理对象，调用代理方法时，就对此对象初始化并调用其相关的方法； 定义接口：public interface Draw { void draw(String name); } 实现类：public class RealDraw implements Draw { @Override public void draw(String name) { System.out.println(name+&quot;.RealDraw...........&quot;); } } 代理：public class ProxyDraw implements Draw { RealDraw realDraw; public ProxyDraw (RealDraw draw){ this.realDraw = draw; } @Override public void draw(String name) { realDraw.draw(name); } } 测试：public static void main(String[] args) { RealDraw realDraw = new RealDraw(); ProxyDraw proxyDraw = new ProxyDraw(realDraw); proxyDraw.draw(&quot;test&quot;); } 测试结果：test.RealDraw........... 静态代理的总结： 做到了代理的基本功能，不对所代理对象的更改实现对象的功能，也可以在代理中对功能进行扩展； 局限在于：代理与被代理都得继承接口，耦合过高，扩展不便； 也正因为有了静态代理的局限，所以才有下面的动态代理： 动态代理 动态代理相对于静态代理的优势： 代理不用继承接口，代理由java内置的java.lang.reflect包中的Proxy类生成： 其中生成代理静态的方法：static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)； 此方法的三个参数： loader：代理目标的类加载器； interfaces：代理目标实现的接口； handler：执行处理器，指调用此代理实现接口的处理器，此处理器必须实现InvocationHandler接口，并实现其public Object invoke(Object proxy, Method method, Object[] args)方法; 具体实现： 接口：public interface Draw { void draw(String name); } 被代理的类：public class RealDraw implements Draw { @Override public void draw(String name) { System.out.println(&quot;RealDraw.draw&quot;+name); } } 代理（使用了匿名内部类）：public class ProxyDraw { Object target; public ProxyDraw(Object target){ this.target = target; } /* * 获取代理实例，动态代理实现的核心 * @see designpatrern.dynamicproxy.Draw#draw(java.lang.String) */ public Object getProxyIns() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;Porxy_start&quot;); Object returnValue = method.invoke(target, args); System.out.println(&quot;Porxy_end&quot;); return returnValue; } }); } } 测试：public static void main(String[] args) { //动态代理的实现 Draw realDraw = new RealDraw(); Draw proxyDraw = (Draw)new ProxyDraw(realDraw).getProxyIns(); proxyDraw.draw(&quot;....test.end&quot;); } 测试结果：Porxy_start RealDraw.draw....testend Porxy_end 上面代理的实现中，new一个代理实例的handler参数使用了匿名内部类，具体参照匿名内部类。 匿名内部类所做的是创建了一个InvocationHandler接口的实例，这个实例的invoke()方法是用代理目标作为对象（将代理方法分发到这个代理对象上去）； Proxy.newProxyInstance()方法中指定了目标类的类加载器，目标执行的接口，方法调用时所用的方法调用处理器； cglib代理 /子类代理 此类型代理需要用到spring核心包推荐使用spring-core 3.2.5版本及以上； 动态代理与静态代理都是向上抽取依赖，要求实现接口，而cglib代理则是通过目标对象子类来实现对目标对象功能的扩展； 其实现方法： 引入的功能包能够动态地在内在中构造子类； cglib的强大在于高效生成代码，在运行期扩展java类与接口，spring赖以生存的AOP拦截的就是大量地使用了cglib的强大功能； cglib的底层：使用字节码处理框架ASM转换字节码并生成新的类（并没有弄的懂的地方，涉及JVM中内部结构，诸如：class文件的格式秘指令集） 注意：cglib的实现是依赖于代理的扩展子类，需要对代理目标进行扩展 也就是说代理类不能为final修辞； 同时，目标对象的方法不能为final/static所修辞； 实现例子： 目标类：public class Target { public void targetMethod(){ System.out.println(&quot;cglib.RealDraw.draw............&quot;); } } 代理工厂类：public class ProxyFactory implements MethodInterceptor{ private Object target; //构造函数中将目标确定 public ProxyFactory(Object obj){ this.target = obj; } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(&quot;开始事务拦截。。。。。。。。&quot;); Object result = method.invoke(target, args); System.out.println(&quot;结束事务拦截。。。。。。。。&quot;); return result ; } /** * 获取代理的方法 * @return */ Object getProxyIns(){ //增强工具对象 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数（本实例） en.setCallback(this); //创建子类 return en.create(); } } 测试：public static void main(String[] args) { target.targetMethod(); target = (Target)new ProxyFactory(target).getProxyIns(); target.targetMethod(); } 测试结果：开始事务拦截。。。。。。。。 cglib.RealDraw.draw............ 结束事务拦截。。。。。。。。 实现动态代理:新建一个Target2类，并测试将Target2实例传入代理工厂对象： 目标类Target2： public class Target2 {void targetMethod(){ System.out.println(&quot;Target2.target2Method...........&quot;); } } 测试：public static void main(String[] args) { Target target = new Target(); Target2 target2 = new Target2(); target2 = (Target2)new ProxyFactory(target2).getProxyIns(); target2.targetMethod(); } 测试结果：开始事务拦截。。。。。。。。 Target2.target2Method........... 结束事务拦截。。。。。。。。 note: 静态代理所涉及到的知识点相对更容易理解； 动态代理与子类代理都用到了类反射中的Method方法，其核心是利用类反射来实现将扩展的方法体加在指定目标的方法的前后； 在Spring的AOP编程中: 如果加入容器的目标对象有实现接口,用JDK代理 如果目标对象没有实现接口,用Cglib代理 参考博客：岑宇-java的三种代理模式","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"控制台操作数据库","date":"2017-05-23T04:54:30.000Z","path":"2017/05/23/控制台数据库操作/","text":"mysql数据库控制台操作今天在使用控制台操作mysql数据库过程中，摸索了下之前没怎么搞懂的地方，现拉出一个清单方便以后理解(现使用的mysql数据库，其他的数据库一样使用）： 当安装了mysql之后，配置了环境变量之后，就可以在控制台输入命令来实现启动相关的程序。不管在Linux系统中还是在Windows系统下，输入mysql命令就意味着启动mysql数据库； 本机上设置了root用户的密码时，直接启动mysql命令会被拒绝访问，这时需要使用命令mysql -u root -p;，表示登录用户root，接下来会提示输入密码，后再进入到到该root用户中，这时才能访问数据库，输入查询语句进行查询； Navicat只是一个数据库的可视化IDE，平常使用它能很方便地操作查看数据库，但在控制台中操作数据库能让操作者深刻地理解数据库； 数据库查询语言在控制台输入时一定记得在句末加上；，否则执行语句时会被认为没有结束的语句； 安装完成Navicat后可以看到很多默认的数据库已经在其中了，这些是mysql必须的数据库，其中mysql数据库中存储了本机上数据库的诸多信息，包括user表的host信息，要进行这些信息的修改，同样使用use mysql进入到该数据库，对其中的信息进行修改；","tags":[{"name":"mysql","slug":"mysql","permalink":"https://kangshanr.github.io/tags/mysql/"},{"name":"控制台","slug":"控制台","permalink":"https://kangshanr.github.io/tags/控制台/"}]},{"title":"设计原则","date":"2017-05-13T04:32:48.000Z","path":"2017/05/13/design_principle/","text":"设计模式的六大原则简称“六大设计原则”，用于整个面向对象编程过程中设计各种模式甚至到各个接口与类的设计都需要参考的原则。这些原则的宗旨是尽量减少程序的耦合性，让程序的可扩展性更高，在接触越多的编程后，越会感受到这些原则的重要性； 开闭原则(Open Close Principle)： 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 这也是我们在设计程序过程中，尽量使用功能功能明确单一的接口，尽量把类抽象成基类，让派生类继承其公共的属性与方法的目的。 与依赖倒置原则相呼应。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。 里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。也就是在设计各类程序块时，用父类、接口来接收实现的对象，这也是java多态实现基础； 依赖倒置原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体，一个具体的优势就是减少代码的重写，甚至可以减少方法的重载。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计原则","slug":"设计原则","permalink":"https://kangshanr.github.io/tags/设计原则/"}]},{"title":"java内部类","date":"2017-04-29T05:04:38.000Z","path":"2017/04/29/java_inner_class/","text":"java内部类 java的内部类指定义在类之中的类，这个类中的范围可以是是类成员也可以在局部方法中，还可以是作用域中； 内部类只是在编译时的概念，在本质上，当经过编译后，外部类会生成outer.class文件，而其中的内部类会生成outer$inner.class类文件，也就是就算定义成内部类，其本质依然是个类； 那么内部类有什么存在的必要呢？ 内部类是外部类的内容，在内部类之外加上一层外部类，就意味着： 内部类可为public、default之外的访问修辞符所修辞，这一点能很大程度上区别开外部类； 有了以上一点，那在类中定义内部类就会在很多时候有用了，比如：静态内部类的单例模式中，将单例通过静态内部私有类的方法来获取，这样利用外部其它的类不能访问这个私有的内部类而达到控制内部类的初始化类加载，这样只有在这个相关外部类中调用时才会调用到内部类，在这样一个单例模式中就实现了单例的懒加载； 在迭代器模式中，在迭代器容器中创建了个内部类：- 容器实现类： public class Repository implements Container { String elements[] = {&quot;kfc&quot;,&quot;jfk&quot;,&quot;mcd&quot;}; /** * 返回内部类的对象，注意这儿的依赖倒置 */ @Override public Iterator getIterator() { return new DoIterator(); } /** * 内部类，实现迭代器接口 * @author Administrator * */ public class DoIterator implements Iterator{ int index; /** * 判定索引是否指向在集合之中，如果还在就返加true */ @Override public boolean hasNext() { if(index &lt; elements.length) return true; return false; } /** * 实现迭代器核心算法，如果后面还有元素就返回这个元素，最后的结果就是index会与集合的长度相等，索引指向最后的一个的后面 */ @Override public Object next() { if(this.hasNext()){ Object obj = elements[index++]; return obj; } return null; } } - 最后在外部其他的类中来构造一个此内部类： - 先引入此内部类的包：`import designpatrern.iteratorpattern.Repository.DoIterator;` - 先构造一个外部类的对象：` Repository rep = new Repository();` - 再来构造内部类对象：`DoIterator ite2 = rep.new DoIterator();` 当这个内部类的修辞符为private时，这时在其他非相关的外部类中就不能导入此类，更名别说构造对象了； 匿名内部类： 这种情况多数用于一个抽象的类或者接口想要生成一个对象，这时不得不用一个子类来实现其抽象方法或新产品才能实现，但如果这个子类只用一次的话，专门创建一个子类来装载时会造成系统资源的浪费，那么这时使用匿名内部类会更合理： 接口定义 public interface Draw {void draw(String name); } 这时我们只想实现一次特殊的draw()方法，而且只用得到一次，如果创建一个类实现这个接口（或者抽象父类），就会造成系统资源的浪费，所以就使用匿名内部类实现： main方法中测试：public static void main(String[] args) { Draw draw = new Draw(){ @Override public void draw(String name) { System.out.println(&quot;Draw.Draw....&quot;+name); } }; draw.draw(&quot;test&quot;); } 测试结果：Draw.Draw....test 其中先用接口new一个对象出来，再在这个对象中创建一个匿名的内部类并实现其draw()方法，因为是匿名的类，所以只能看到其方法在对象体{}中。 同时要实现这个匿名内部类的效果，不一定要在接口中或抽象类的抽象方法中，普通类的普通方法也一样可以实现这样的重写方法，再一次调用：//实现类的匿名内部类，这个类不一定抽象类方法也不一定是抽象方法，一样都可以实现 ProxyDraw proxy = new ProxyDraw(draw){ @Override public void draw(String name){ System.out.println(&quot;anonymity&quot;+name); } }; proxy.draw(&quot;&quot;); 测试结果：anonymity 在动态代理模式中，匿名内部类会有很好的体现，共具体实现： 接口：public interface Draw { void draw(String name); } 被代理的类：public class RealDraw implements Draw { @Override public void draw(String name) { System.out.println(&quot;RealDraw.draw&quot;+name); } } 代理（使用了匿名内部类）：public class ProxyDraw { Object target; public ProxyDraw(Object target){ this.target = target; } /* * 获取代理实例 * @see designpatrern.dynamicproxy.Draw#draw(java.lang.String) */ public Object getProxyIns() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;Porxy_start&quot;); Object returnValue = method.invoke(target, args); System.out.println(&quot;Porxy_end&quot;); return returnValue; } }); } } 测试：public static void main(String[] args) { //动态代理的实现 Draw realDraw = new RealDraw(); Draw proxyDraw = (Draw)new ProxyDraw(realDraw).getProxyIns(); proxyDraw.draw(&quot;....test.end&quot;); } 测试结果：Porxy_start RealDraw.draw....testend Porxy_end 上面代理的实现中，new一个代理实例的handler参数使用了匿名内部类，如果不使用匿名内部类，其实现过程： 将代理中匿名内部类的实现提取出来：public class InvokeHandler implements InvocationHandler { //在构造函数中就注入要调用方法的对象 Object obj; public InvokeHandler(Object obj){ this.obj = obj; } /* * 实现InvocationHandler接口（其中只有一个invoke方法） */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;invoke.start....&quot;); Object resultValue = method.invoke(obj, args); System.out.println(&quot;invoke.end....&quot;); return resultValue; } } 而代理类中获取代理的方法就应该是：public Object getProxyIns2() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvokeHandler(this.target)); } 测试：public static void main(String[] args) { //动态代理的实现 Draw realDraw = new RealDraw(); Draw proxyDraw = (Draw)new ProxyDraw(realDraw).getProxyIns2(); proxyDraw.draw(&quot;....test.end&quot;); } 测试结果：invoke.start.... RealDraw.draw....test.end invoke.end....","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"访问修辞符","slug":"访问修辞符","permalink":"https://kangshanr.github.io/tags/访问修辞符/"},{"name":"java内部类","slug":"java内部类","permalink":"https://kangshanr.github.io/tags/java内部类/"},{"name":"迭代器","slug":"迭代器","permalink":"https://kangshanr.github.io/tags/迭代器/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"https://kangshanr.github.io/tags/匿名内部类/"}]},{"title":"项目开发流程","date":"2017-04-28T20:33:30.000Z","path":"2017/04/29/项目开发流程（详细）/","text":"整个流程包括： 需求挖掘（核心就是用户痛点）： 作为一个商业项目的程序员，一定要搞明白项目的赢利点在哪里； 要解决用户痛点； 用户分为：直接用户、最终用户 直接用户就是项目开发中，直接对接的用户，通俗的可以理解为给钱的； 最终用户是产品开发出来后使用产品的用户； 比如给一个公司开发的无纸化办公软件，这个产品的直接用户是这个公司的管理层，他们把项目交到我们手上来开发。但最终用户就是这个公司的各类普通职员，是他们在使用这个成型的产品； 在外包项目中，在需求挖掘的过程中往往涉及到： 用户访谈 需求探索 卖家会议 领导意见 而在这整个过程中，作为开发人员不能刻意引导对方，使用引导性对话往往会带出客户的伪需求，这就会需求分析带来干扰 需求分析：在作需求分析的对象只有两个：测试人员，普通使用者；这就决定了：写需求分析说明书时，措词要易懂清晰，少用专业词汇； 整个过程是开发人员、测试人员、客户各方不断讨论的过程 一旦有新的决定性需求确定下来，比如定稿时，一定要客户签字确认，各方责任要清晰； 当定稿之后客户要求修改需求，或修改需求成本太高，一定要出需求变更说明书，同样要求客户签字； 概要设计（数据库设计E-R图可同步进行） 比如一个简单的邮箱功能，其中的数据应该包括： 发件人名师 收件人列表 主题 内容 是否有附件 抄送人列表 详细设计 数据库设计（模型图） 用例图（PowerDesigner、Visio)：描述参与者与用例之间的关系，不能用crud之类的语言，比如：开发票与销毁发票，而不是用新建发票、删除发票；注意参与者可以是人但也可以是其他角色； 时序图（PowerDesigner)：操作到哪个对象，操作后返回什么对象 流程图（Visio)： 跨职能流程图中：每一个泳道代表一个职能； 菱形：判定，出来两根线，一个是，一个否； 矩形：流程 圆角矩形：开始或结束 平行四边形：输入数据 包图（Powerdesigner) 类图（Powerdesigner) 编码 测试","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"项目开发","slug":"项目开发","permalink":"https://kangshanr.github.io/tags/项目开发/"}]},{"title":"java访问修辞符","date":"2017-01-31T05:12:34.000Z","path":"2017/01/31/java_modifier/","text":"访问修辞符 java的访问修辞符包括了四个等级：Public,protected,(default/friendly),private; 它们决定了所修辞的成员的被访问权限从高到低： public:最高权限，项目中都可以访问； protected:受保护权限，只有在同包中或者在不同包的子类可以访问； default/friendly:默认的权限，不写出来。只有在同包中可以访问； private:私有权限，只有在同类中可以被访问，也就是在哪儿被声明就只有在哪儿可以被访问； Note: 外部类只能被public和default两种修辞符，内部类可以有所有的访问修辞符； 这儿涉及到内部类的知识点： 与外部类的区别： 内部类可以被各种访问修辞符修辞，这一点区别于外部类； 当内部类的成员被声明为静态时，该内部类必须被声明为静态，这是另一点区别于外部类； 当内部类被声明为private私有时，只能在外部类中构造该内部类的对象。在迭代器模式中，让内部类实现迭代器接口，利用依赖倒置，获取到内部类（迭代器）对象用接口接收，从而实现在外部得到这个内部类。这也充分地体现了依赖于抽象而不依赖于具体，关闭了具体实现，只开放了接口； 当内部类声明为其它可以在外部访问的类型时，在外部引入这个类后，要直接构造一个内部类的实例必须先构造一个相关的外部类的对象，利用这个外部类的对象来构造才能实现。迭代器模式中例子：","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"访问修辞符","slug":"访问修辞符","permalink":"https://kangshanr.github.io/tags/访问修辞符/"}]},{"title":"hexo+github=your website","date":"2017-01-22T18:04:38.000Z","path":"2017/01/23/hexo+github=website/","text":"在学习使用hexo过程中的笔记，大部分来自于hexo官方网站的文档介绍；还有搭建网站过程中，参考了不少其他站主的文章：小茗的搭建网站博客使用blueLake的教程生成新浪微博秀； hexo generate 根据已提供的md文件资料生成静态网页，放在public文件夹中； hexo generate –watch 对比查看文件的改动，只有当文件改动被审查过才会执行generate命令生成静态网页； hexo generate –deploy与hexo deploy –generate 两者效果一样都在generate后执行布置命令deploy 新建md文档：hexo new [dir] filename 使用这个命令生成md文档时，当指定其生成的目录为_draft时，hexo会自动将文档的头加上： --- title: hexo+github=your website date: 2017-01-23 02:04:38 --- 而当指定目录为_post时，其效果会加上标签： --- title: hexo+github=your website date: 2017-01-23 02:04:38 tags: --- 但是全部的信息包括： --- title: hexo+github=your website date: 2017-01-23 02:04:38 categories: 默认分类 #分类，这一点用到的地方不少，*善用分类与标签* tags: [tag1,tag2,tag3]#文章标签，可空；使用多标签时，将`[]`符号带上，并且标签之间用`,`分开 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 --- Hexo默认的文件头只有title、date、tags属性，生成的html会缺少Meta信息，不利于搜索引擎收录。建议自行在文件头中添加keywords和description属性。categories属性可自行选择是否添加。标准包含全部meta信息的头应该是： --- title: ##文章标题 date: ##时间，格式为 YYYY-MM-DD HH:mm:ss categories: ##分类 tags: ##标签，多标签格式为 [tag1,tag2,...] keywords: ##文章关键词，多关键词格式为 keyword1,keywords2,... description: ##文章描述 --- 正文 生成md文档还有另外一个命令：hexo new page newpage 与上一个命令不同之处在于：生成的md文件放在了根目录而不会放在source/_post中，而会在source文件夹中生在一个newpage的folder，并在其中生一个index.md，且这个md文档的title会被设置成newpage，也就是生成了这样一个页面，而这个页面并未在网页目录中，但我们就可以好好地设置这个页面用于在其他的文档引用； 实现readmore:在任何你想要预览到此的位置加上标签&lt;!--more--&gt;，即可实现； 使用过程中摸索的小问题： 每次部署前generate一次就把public中的所有文件先覆盖了，而这样再deploy时就把github远程上资料全部覆盖，这样在github上添加readme都会被覆盖，也就导致了远程机上没有自定义的东西全是生成好的，而且每次一部署都会将先前的重新生成一次再覆盖，感觉造成了许多资源的浪费也很自定义自己想要的网页效果，问题就在于可不可以每次只生成新的资源，再只将新的资源push到master branch上，或者push到其它的branch上，再merge到一起，只要生成新的资源时不会与老资源冲突，也就能达到效果。 在landscape主题中，据观察也只变化了首页index.html与相应的日期的folder,其它的folder与file都没有改变，所以上述的方法是可行的； 但是，这样操作还有一个问题需要注意，新生成的网页的目录结构都还在，这就需要把新生成的目录结构给拷到之前已存在的目录中，并在这个添加了新网页的目录中push； 实验失败：8/25/2017 7:52:15 AM 将新的几个md文件放在source文件夹下面的_post中生成新的页面并添加在github的仓库中push上去，网站上并没部署这几个新的页面（仓库中已经有这几个新的页面的html了）； 所以，还是用最暴力的方法更新，每次重新生成整个仓库的资源，将整个仓库资源deploy到github上； 调整整个背景颜色与图片的信息： 进入到相关的主题folder中，再依次进入source--&gt;css--&gt;style.styl，打开这个文件，找到body在这个级别下就有各种配置参数可以调整，包括了background: color_value url(图片路径) 每新建一个hexo目录（也就是说当你在其它托管网站上新建一个项目时）在这个hexo目录中依然要执行上面安装所有的插件到hexo中，比如安部署器deployer：npm install hexo-deployer-git --save","tags":[{"name":"hexo","slug":"hexo","permalink":"https://kangshanr.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://kangshanr.github.io/tags/github/"}]},{"title":"快速排序算法","date":"2016-12-03T04:54:38.000Z","path":"2016/12/03/快速排序算法的理解/","text":"今日所得 今天复习了下快速排序（使用递归），据说是效率最高的一种排序算法（相比于冒泡排序、选择排序）； 之前学习C#时领教过，当想把这个算法迁移到java中来写一个时发现久了不练都手生了； 前面多次使用递归的算法写一些方法（诸如二分法查找已经排好序数组元素的索引、递归生成满足条件（非纯数字或字母）的字符串；使用多次但没有想到过使用递归时可以无返回值； 二分排序时，必须使用无返回值的递归方法。因为二分之后返回的是数组的一部分，最后把这一部分返回给递归前方法，这时要接收这一部分的元素需要对这一部分进行遍历； 二分法排序(升序，若要降序则相反）流程： 把数组第一个元素作为中间值，从最大索引(这个还必须从后往前找，因为我们用的第一个元素作为中间值，如果从前往后找，第一个较大值会直接覆盖最大索引的值；所以，如果想实现从前往后找就得把最大索引元素值作为中间值)开始往前找，找到比这个间值小的元素就把这个值赋予给最小索引的元素； 再从最小索引元素开始往后找，找到这中间值大的元素，把这个元素值赋予给最大索引处的元素（找的过程不满足条件就把索引依次自增或自减）； 依次这样后面往前找一趟，前面往后找一趟，直到最大与最小索引相等。这时把中间值赋予给这个索引，这样就完成了一次把数组分成两个部分，前面部分值比中间值小，后面部分比中间值大； 这用上面一套流程对中间值两边的元素进行递归操作，递归缺口就是数组操作部分只有一个元素； 代码：public int getPivotIndex(int[] arr, int minIndex, int maxIndex){ int pivot = arr[minIndex]; while (minIndex &lt; maxIndex) { while (arr[maxIndex] &gt;= pivot &amp;&amp; minIndex &lt; maxIndex) { maxIndex--; } if(minIndex != maxIndex){ arr[minIndex] = arr[maxIndex]; } if(minIndex != maxIndex){ arr[minIndex] = arr[maxIndex]; } while (arr[minIndex] &lt;= pivot &amp;&amp; minIndex &lt; maxIndex) { minIndex++; } arr[maxIndex] = arr[minIndex]; } arr[minIndex] = pivot; return minIndex; } *二分法排序的流程 * @param arr * @param minIndex * @param maxIndex */ public void dichotomySort(int[] arr, int minIndex, int maxIndex){ if(minIndex &lt; maxIndex){ int index = this.getPivotIndex(arr, minIndex, maxIndex); dichotomySort(arr, minIndex, index - 1); dichotomySort(arr, index + 1, maxIndex); }else{ return; } } 二分法排序算法核心在于每一次查找把中间那一个值给定下来，并对中间值两边的数组分别再次排序,再对两边的数组分别进行同样的操作，直到不能再分割;","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://kangshanr.github.io/tags/算法/"}]},{"title":"java编程中你不知道的一两点","date":"2016-11-23T04:04:38.000Z","path":"2016/11/23/some_tips_about_java/","text":"Java中，你不知道的一两点 关键字new是运算符: 我们都知道new是用来开辟并新的内存空间创建对象的，但大多不知道这个功能是由运算符来实现； 运算符（type）： 强制类型转换，括号中加类型，强制类型转换，它也只是个运算符 运算符instanceof： 二元布尔运算符，前跟实例名后跟类名，判定实例是否可以用此类接收； 成员访问符“.”，访问类或实例的成员； 方法调用()，除了用于强制运算顺序，括号还用于调用方法；","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"关于“上火”的科学点子","date":"2016-11-23T04:04:38.000Z","path":"2016/11/23/关于“上火”的事/","text":"所谓上火：现代医学中并没有“上火”的概念。 而现实生活中，我们的“火”是从哪儿上来的呢？ 吃辣上火： 我们对吃辣上瘾的原因在于，辣椒刺激口腔内部产生类似灼烧的感觉，而这种感觉会促使大脑分泌多巴胺（多巴胺是人产生快感的来源，人类大部分上瘾行为都和它相关），从而上瘾； 因为辣椒素残留口中，持续对口腔刺激。吃辣后，刷牙漱口就行了； 吃爪子上火： 瓜子本身并不会让你上火，让你不舒服的原因在于瓜子外壳上的脏东西。不信的话，下次吃瓜子只买瓜子仁吃，看会不会上火。","tags":[{"name":"tips","slug":"tips","permalink":"https://kangshanr.github.io/tags/tips/"}]},{"title":"springMVC","date":"2016-08-20T05:29:17.000Z","path":"2016/08/20/springMVC/","text":"核心对象：中央处理器：在web.xml中配置springmvc的servlet12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中load-on-startup这个属性来指定这个中央处理器被初始化的时机： 当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些； 当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序； 核心对象： 页面控制器，处理请求并给出响应； 处理器映射器HandlerMapping：设置handler处理器与url资源的映射 使用BeanNameUrlHandlerMapping这个类时，就会将handler的name属性值作为url映射，访问这个处理器就填写其name属性值:&lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController&quot;/&gt; 如上，就可能过name属性值，设置 &lt;a href=&quot;loginController.do&gt;登录&lt;/a&gt; SimpleUrlHandlerMapping，这个类型的映射要求映射url与controller的配置id相对应，并在这个节点内将controller的id与生意人key对应起来；&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!--配置指定的url与bean的id映射,可添加多个--&gt; &lt;prop key=&quot;/login.do&quot;&gt;login&lt;/prop&gt; &lt;prop key=&quot;/login2.do&quot;&gt;login2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController&quot;/&gt; &lt;bean id=&quot;login2&quot; name=&quot;loginController2.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController2&quot;/&gt; 使用注解实现处理器与url的映射&lt;!-- 注解映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; 这个配置节点就决定了处理器与其中的方法可以被注解@RequestMapping（”url_name”）映射并指定url 处理器适配器：HandlerAdapter，用于规定处理器的编写规则 使用接口来配置适配器： 当指定为SimpleControllerHandlerAdapter时，它就规定了要想成为处理器，就要实现Controller这个接口； HttpRequestHandlerAdapter:这个适配器要求所有的Handler都必须实现HttpRequestAdapter接口； 使用注解实现配置适配器：&lt;!-- 注解适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; 这个配置节点就决定了，有@controller注解的类就是处理器 在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象； springMVC中的处理器 controller: 中央处理器DispatcherServlet在web.xml中被配置成一个servlet,并通过初始化上下文配置参数springmvc.xml的路径与设置其启动时机与该servlet初始化时机； 1234567891011121314 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 通过上一步实现来自前端请求必须都通过web.xml文件中指定的servlet处理，也就是大部分请求都是交给了springmvc，所有的springmvc的配置都在springmvc.xml文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。 springmvc.xml配置中就指定了适配器映射，使用@Controller注解就让该类成为处理器 @RequestMapping(“url_name”)则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url; 注解使用时映射的方法中，可以与前端数据相通的参数有： 简单数据类型 pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password session/request/response：用法与之前一致，可以用分发请求也可以重定向； Model/ModelAndView： 也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中； 注解@RequestParam的使用： 其中有参数： name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法； required：boolean类型，当其值为true时，请求必须带有这个参数； 使用controller处理器时，各类方法返回数据类型： ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图） String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串”response:+方法映射”； “forward:+方法映射”，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到； Restful架构 只是一种规范，终极的目标是资源URI","tags":[{"name":"framework","slug":"framework","permalink":"https://kangshanr.github.io/tags/framework/"}]},{"title":"JDBC的理解","date":"2016-07-24T04:14:32.000Z","path":"2016/07/24/JDBC/","text":"JDBC全称：fava database connectivity,专用于java数据库连接，其中封装了基本的连接数据库的API,数据库连接的高级框架（诸如：Mybatis/Hibernate)的使用都基于JDBC的原理，也就是理解了JDBC对于我们更理解各种持久层数据连接层的框架很有帮助； 一个简单的JDBC实现/** * 获取数据库连接的方法 * @return */ public static Connection getConnection(){ Connection con = null; try{ // 获取连接mysql数据库的驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 设置连接数据库的url String url = &quot;jdbc:mysql://localhost:3306/agileone1?useUnicode=true&amp;characterEncoding=UTF-8&quot;; // 连接数据库的用户名 String userName = &quot;root&quot;; // 连接数据库的密码 String userPass=&quot;&quot;; // 从而获取到数据库连接connection con = DriverManager.getConnection(url, userName, userPass); }catch (Exception e){ e.printStackTrace(); } return con; } 上述代码块就通过java.sql包里封装好的各个类与类反射获取到了连接指定数据库的链接； 接下来就可以利用这个连接来进行crud类操作- /** * 插入数据进入数据库的方法 * @param username * @param password */ static void insertData(String username, String password){ Connection con = getConnection(); String sql = &quot;INSERT INTO Userdata (username, userPass) VALUES(&apos;&quot;+username+&quot;&apos;, &apos;&quot;+password+&quot;&apos;)&quot;; try { // 从连接创建状态 Statement state = con.createStatement(); // 执行更新语句，返回影响行数 int re = state.executeUpdate(sql); System.out.println(re); } catch (SQLException e) { e.printStackTrace(); } } /** * 模糊查询的方法 * @param name */ static void query(String name){ Connection con = getConnection(); // sql语句 String sql = &quot;SELECT * FROM userdata WHERE username = &apos;&quot; +name+&quot;&apos;&quot;; try{ Statement state = con.createStatement(); // 执行查询语句，返回批量结果集 ResultSet re = state.executeQuery(sql); // 对结果集进行迭代输出 while(re.next()){ System.out.println(&quot;id:&quot; + re.getInt(&quot;id&quot;)); System.out.println(&quot;username:&quot; + re.getString(&quot;username&quot;)); System.out.println(&quot;id:&quot; + re.getString(&quot;userPass&quot;)); } }catch(SQLException e){ e.printStackTrace(); } } 当sql语句执行完成，需要对上面建立的各个连接与状态进行关闭：/** * 关闭连接与状态的方法 */ static void close(Connection con){ if(con !=null){ try { con.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 其中针对不同的方法与连接状态，关闭的对象也不一样，除了Connection还有Statement,Prestatement,resultSet，各个对象都是调用其Close方法； 通常情况下，调用对象的Close()方法放在finally语句块中，这样就可以执行完查询语句方法后，交接将各个对象关闭； Note: 以上的代码基本实现了JDBC的整个流程，从创建连接到执行查询语句，再到关闭连接、状态、结果集 JDBC中封装的连接数据库的API包：java.sql是连接sql的基础包，使用JDBC就得引入这个jar包：mysql-connector-java-5.1.38-bin.jar","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://kangshanr.github.io/tags/数据库/"}]},{"title":"设计模式","date":"2016-06-13T04:14:38.000Z","path":"2016/06/13/DesignPattern/","text":"Design Pattern，对于编程过程中遇到各种问题的总结与归纳，是编程（通常为面向对象）过程诸多问题的优秀解决方案；菜鸟教程之设计模式 Gang of Four，四人帮提出设计模式的设计原则： 对接口编程而不是对实现编程； 优先使用对象组合而不是继承； 简介： 共23种设计模式，分为三类： 创建型Creational Patterns：提供创建对象的同时隐藏创建的逻辑，而不是用new运算符直接创建对象； - 结构型Structural Patterns:关注类和对象的组合，继承的概念被用来组合接口和定义组合对象的新功能； 行为型Behavioral Patterns:关注对象之间的通信 单例模式 对于管理类，通常只需要一个实例对象即可达到管理的目的，这种时候如果实例多个对象只会造成系统资源上的浪费，所以通常我们使用单例模式来解决这种问题； 实现单例的思路： 将构造函数私有化，并在类中实现静态单例的共享；public class UserManager{ //静态单例 private static UserManager ins; //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ ins = new UserManager(); } return ins; } //其他的执行方法 public void updateUserInfo(){} ｝ 上面例子里有个线程上的缺陷，当多线程访问这个管理类时，会造成线程不安全，为解决这个问题，就得使用双重检查锁单例：public class UserManager{ //静态单例 private static UserManager ins; private Object lock = new Object(); //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ //第一次检查 synchronized(lock){ //保证不产生多余的实例 if(ins == null){ //第二次检查 ins = new UserManager(); } } } return ins; } //其他的执行方法 public void updateUserInfo(){} ｝ 关于多线程安全的实现在单例模式中有6种不同的方式，具体参照单例模式页面； 代理模式 代理模式：与工厂模式不同在于，可能产生多个实例，同时会帮Action做事（工厂模式属于创建型模式，而代理模式属于结构型模式）； 代理(Proxy)提供了对目标对象另外的访问方式;即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. 这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 代理模式就是将要实例的对象通过代理类来实现，不通过原本的类来实例，具体实现有三种方式： 静态代理： 可以让代理类同时实现真正想的对象的类实现的接口，而在代理类中有一个真正类的属性，当想要这个真正类时，对上述属性判空，再实例化，这样通过代理类执行接口中的方法时就是执行的真正想要的类的方法了； 简单地讲，代理就是将其他的类的各种实现方法，交由代理来实现。而要达到这种效果，就可以让代理与其他的类实现同一个接口，再在代理中实现接口方法中去实现这个类的方法。这也是代理的核心，一般代理中要注入一个代理对象，调用代理方法时，就对此对象初始化并调用其相关的方法； 动态代理： 代理不用继承接口，代理由java内置的java.lang.reflect包中的Proxy类生成： 其中生成代理静态的方法：static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)； 此方法的三个参数： loader：代理目标的类加载器； interfaces：代理目标实现的接口； handler：执行处理器，指调用此代理实现接口的处理器，此处理器必须实现InvocationHandler接口，并实现其public Object invoke(Object proxy, Method method, Object[] args)方法; cglib代理（子类代理）： 此类型代理需要用到spring核心包推荐使用spring-core 3.2.5版本及以上； 动态代理与静态代理都是向上抽取依赖，要求实现接口，而cglib代理则是通过目标对象子类来实现对目标对象功能的扩展； 其实现方法： 引入的功能包能够动态地在内在中构造子类； cglib的强大在于高效生成代码，在运行期扩展java类与接口，spring赖以生存的AOP拦截的就是大量地使用了cglib的强大功能； cglib的底层：使用字节码处理框架ASM转换字节码并生成新的类（并没有弄的懂的地方，涉及JVM中内部结构，诸如：class文件的格式秘指令集） 注意：cglib的实现是依赖于代理的扩展子类，需要对代理目标进行扩展 也就是说代理类不能为final修辞； 同时，目标对象的方法不能为final/static所修辞； 工厂模式 生成一个类交由相关的工厂类实现，而不由直接的类来实现； 相关的类继承同一个接口，实现这个接口的类都可以由工厂类中同一个方法来实现实例化； 例如： //定义同一个类的抽象接口 public interface Shape{ void draw(); } //实现shape接口的类有： //Circle类 public class Circle implements Shape{ @Override public void draw(){ system.out.println(&quot;circle.draw&quot;); } } //Square类 public class Square implements Shape{ @Override public void draw(){ system.out.println(&quot;square.draw&quot;); } } //创建实例的工厂类 public class ShapeFactory{ //创建图形实例的方法 public Shape createShape(String shape){ if(shape.equalsIgnoreCase(&quot;CIRCLE”){ return new Circle(); } if(shape.equalsIgnoreCase(&quot;SQUARE”){ return new Square(); } reutnr null; } } 模式理解： 通过工厂来实现对各个类的实例化，都在工厂实现； 通过反射机制实现，增加一个同一接口的类不需要改变工厂的代码,只需要增加一个实现这个实现对应接口的类： 其工厂的代码：public class ShapeFactory{ //创建工厂的方法 public Shape createShape(Class&lt;? extends Shape&gt; clazz){ try{ return Class.forName(clazz.getName()).newInstance(); }catch(Exception e){ e.printStackTrace(); } } } 抽象工厂模式 相比较于工厂模式，抽象工厂模式在工厂模式的基础上增加生成工厂的工厂类，那么生产出来的工厂都要继承一个接口或父类，没理解到的点就在于，这个类一定要是一个抽象类吗？可以是个接口或者非抽象类吗? 该模式的优点：把同一个产品类集成到同一个工厂内，这样使用时就直接调用工厂中的方法，而生成同一个工厂里预备好的类对象，也更方便管理； 它是为了解决子工厂的扩展性问题 迭代器模式 迭代器模式的设计目的只是，用自己写迭代器来实现迭代聚合数据，而将集体或聚合的数据的遍历分离出来来达到既能访问到集合的内部数据又不暴露集合的内部结构； - 迭代器接口： public interface Iterator { public boolean hasNext(); public Object next(); } - 容器接口： public interface Container { public Iterator getIterator(); } - 容器实现类： public class Repository implements Container { String elements[] = {&quot;kfc&quot;,&quot;jfk&quot;,&quot;mcd&quot;}; /** * 返回内部类的对象，注意这儿的依赖倒置 */ @Override private Iterator getIterator() { return new DoIterator(); } /** * 内部类，实现迭代器接口 * @author Administrator */ private class DoIterator implements Iterator{ int index; /** * 判定索引是否指向在集合之中，如果还在就返加true */ @Override public boolean hasNext() { if(index &lt; elements.length) return true; return false; } /** * 实现迭代器核心算法，如果后面还有元素就返回这个元素，最后的结果就是index会与集合的长度相等，索引指向最后的一个的后面 */ @Override public Object next() { if(this.hasNext()){ Object obj = elements[index++]; return obj; } return null; } } 最后在main方法测试中写for循环实现迭代：for(Iterator iter = new Repository().getIterator();iter.hasNext();){ String ele = (String)iter.next(); System.out.println(ele); } 输出：kfc jfk mcd 适配器模式 适配器是行为型模式，将原有的行为经过组合进行扩展； 顾名思义，适配器就是将原本不适的接口或功能适配到目标对象上。 最简单的理解类型是缺省型适配器：将各个接口实现在一个适配器上，再让目标继承这个适配器（可省，直接用这个适配器new出对象来也一样可以实现），想扩展什么接口功能就重写相应的方法，就实现了适配器的扩展功能； 而比起缺省型适配器，还有类的适配器和对象适配器： 类适配器：将目标功能的接口执行并继承被适配者 被适配者：想在此类上扩展目标接口的功能（适配器的设计初衷在于，被适配者并不能直接实现目标接口）public class Adaptee { void run(){ System.out.println(&quot;Adaptee.run..........&quot;); } } 目标接口：public interface Target { void fly(); } 适配器：public class Adapter extends Adaptee implements Target { @Override//继承父类被适配者，并能方便地扩展其方法 public void run() { super.run(); System.out.println(&quot;Adapter.run.......&quot;); } //实现目标接口的方法 @Override public void fly() { System.out.println(&quot;Adapter.fly...........&quot;); } } 测试：public static void main(String[] args) { Adapter adaptee = new Adapter(); adaptee.fly(); adaptee.run(); } 测试结果：Adapter.fly........... Adaptee.run.......... Adapter.run....... note:这样的一个适配器在某种程度上来说与缺省的适配器并没有什么本质上的区别，都是将各种功能行为通过继承或实现聚合到同一个适配器上； 对象适配器模式： 装饰器模式 未完待续","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"}]},{"title":"数据结构与算法","date":"2016-05-03T11:04:34.000Z","path":"2016/05/03/数据结构/","text":"通俗地理解，数据结构就是数据在内存中存入的结构。语言中的各类集合就是对数据结构的实现。 这其中包括了物理结构与逻辑结构； 物理结构又叫存储结构： 包括了顺序物理结构，数据元素存放在地址连续的存储单元里，数据元素之间的物理关系与逻辑关系是一致的（逻辑结构上是一对一？）（数组）； 链式物理结构，数据元素分散在任意存储单位，可以不连续，前后用指针关联； 逻辑结构：反应数据之间逻辑关系的数据结构，表示数据之间前后关系，与数据在内存中的存储位置无关； 集合结构：数据元素同属一个集合，他们之间并列，没有其他关系； 线性结构：数据元素之间一对一的相互关系； 树形结构：数据元素之间存在一对多的相互关系； 图形结构（网状结构）：数据元素存在多对多的关系； 参考博客 个人理解： 目前在编程语言学习中接触到的集合各类中的元素之间逻辑关系都是的集合结构，包括字典、列表，它们其中的元素之间只有并列关系，没有其他任何关系； 而在集合元素内部的属性关系（键值对）是一对一的线性结构（一个键对就一个值）； 数组是一个典型的顺序物理学结构，且其逻辑结构是一对一； 实例与实例的成员关系在逻辑上是一对多，一个实例对应了多个成员；方法与方法执行块，参数，都是一对多的树状逻辑关系；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"markdownPad使用攻略","date":"2015-04-29T04:54:38.000Z","path":"2015/04/29/markdown/","text":"说明：这是一篇在使用markdown记录笔记过程中自己总结一些使用小技巧； 首先来一个： 官方的使用说明 包括了常用的快捷键使用： Welcome to GitHub Pages You can use the editor on GitHub to maintain and preview the content for your website in Markdown files. Whenever you commit to this repository, GitHub Pages will run Jekyll to rebuild the pages in your site, from the content in your Markdown files. MarkdownMarkdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for 123456789101112131415Syntax highlighted code block# Header 1## Header 2### Header 3- Bulleted- List1. Numbered2. List**Bold** and _Italic_ and `Code` text[Link](url) and ![Image](src) Shortcut: Bold (Ctrl+B) and Italic (Ctrl+I) Quotes (Ctrl+Q) Code blocks (Ctrl+K) Headings 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) Lists (Ctrl+U and Ctrl+Shift+O) Timestamp(Ctrl+T) Horizontal Rule(Ctrl+R) For more details see GitHub Flavored Markdown. Jekyll ThemesYour Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings. The name of this theme is saved in the Jekyll _config.yml configuration file. Support or ContactHaving trouble with Pages? Check out our documentation or contact support and we’ll help you sort it out. 新得到的小点子诸多功能：为知笔记中提供的一些功能，其中包括了表格的实现等没怎么用到但很实现的功能； 其他在使用过程中摸索出来的小点有： 段落：一级段落使用一个“&gt;”符号，以此类推，二级就用”&gt;&gt;”，三级就用“&gt;&gt;&gt;”，可以有n多级；得注意的是，这种格式经过hexo生成后在网站上显示为水平居中，字体放大一号，同时左边并没有段落的竖线； 插入链接：[百度](http://www.baidu.com &quot;百度一下&quot;)示范一下：百度，可以看到[]中放的是显示的字符串，()里放的是url与提示；注意，各个标识符都是小写状态，快捷键ctrl+l； 想要插入代码: 在&lt; pre &gt;标签中插入代码:这儿就是插入pre标签后的效果 在每一行代码前插入三个table符，记住是每一行代码都要在前面加上三个table符； 快捷键ctrl+k,这种方式适合短小的单行代码，因为一旦换行，就打破了代码块；","tags":[]},{"title":"html_base标签","date":"2015-03-25T07:39:42.000Z","path":"2015/03/25/html_'base'_label/","text":"简介：用于规定页面上所有的链接的默认URL和默认目标：&lt;base href=&quot;http://……“ target=&quot;_blank&quot;&gt; base标签放在标签之中; 最好把base标签排在head标签中第一个元素，这样其它的元素就可以使用base元素的信息； 一个文档中最多能使用一个base元素； 如果使用了base标签，至少要具备href属性或者target属性其中一个； 其中的元素： href：规定页面中相对链接的基准URL，其值就是一个URL; target:规定页面中所有的超链接和表单在何处打开，但该属性会被每个单独的链接中的target属性所覆盖，其值包括： _blank，打开新的页面 _ parent，在父页面打开 _self，在当前页面打开 _top，在浏览器头页面打开 framename base标签支持的属性 支持HTML的全局属性，如：class,id,style等 不支持事件属性，如:onClick之类；","tags":[{"name":"html","slug":"html","permalink":"https://kangshanr.github.io/tags/html/"}]},{"title":"meta标签.md","date":"2015-03-23T06:41:48.000Z","path":"2015/03/23/meta_label/","text":"标签简介： 位于文档的头部标签之中，不包含任何内容； 所有的信息都由属性来存储，包含了文档的名称/值对； 其作用：搜索引擎优化（SEO)，定义的页面使用语言，自动刷新并指向新的页面，实现页面转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口； meta属性（就两个）： name属性： 用于描述网页与之对应的属性值为content,其中的内容便于搜索机器人查找和分类信息用； 其语法格式：&lt;meta name=&quot;参数“ content=&quot;具体的参数值&quot;&gt; name属性有以下几种参数： Keywords，用来指定关键字&lt;meta name=&quot;keywords&quot; content=&quot;meta总结、html/meta、meta属性、meta跳转”&gt; desription，网站内容描述 robots,机器人向导 author，标网页的作者 generator，代表说明网站采用的什么软件制作 COPYRIGHT,版权信息 revisit-after,代表网站征文，7days代表7天 http-equiv,相当于文件头作用，可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content,其中的内容就是各个参数的变量值；&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值”&gt; Expires，期限，设定的到期时间，一旦网页过期，呢额胆固醇服务器上重新传输。（必须使用GMT的时间格式化） Pragma（cache模式） 禁止浏览器从本地计算机的缓存中访问页面内容&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;no-cache&quot;&gt; 这样设计，说教将无法脱机浏览 Refresh(刷新），自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot;content=&quot;2;URL=http://www.haorooms.com&quot;&gt; //(注意后面的引号，分别在秒数的前面和网址的后面) Sett-Cookie(cookie设定），如果网页过期，存盘的cookie将被删除&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt; 必须使用GMT的时间格式 Window-target(显示窗口的设定），强制页面在当前窗口以独立页面显示&lt;meta http-equiv=&quot;Window-target&quot;content=&quot;_top&quot;&gt; 用来毕业后公开了我在框架里调用自己的页面 content-Type，设定显示字符集&lt;meta http-equiv=&quot;content-Type&quot;content=&quot;text/html;charset=gb2312&quot;&gt; meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文； BIG5:繁体中文； iso-2022:日文； ks_c_5601:韩文； ISO-8859-1:英文； UTF-8:世界通用的语言编码； content-Language,设定显示语言&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot;/&gt; Cache-Control，指定评语和响应遵循的缓存机制 imagetollbar,指定是否显示图片工具栏，当为false娃给显示，当为true代表显示； Content-Script-Type,W3C网页规范，指明页面中脚本中的类型；","tags":[{"name":"html5","slug":"html5","permalink":"https://kangshanr.github.io/tags/html5/"},{"name":"jsp","slug":"jsp","permalink":"https://kangshanr.github.io/tags/jsp/"}]}]