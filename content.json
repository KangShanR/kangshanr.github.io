[{"title":"面试心得","date":"2017-09-06T04:54:30.000Z","path":"2017/09/06/interview170906/","text":"面试过程中需要反思的问题： 今天参加了一场面试，面试过程中，发现的问题：当表达时会不自觉的手部动作幅度过大，表现得过于浮夸。这一点在今后的面试中需要注意。另外，面试前过于紧张，以致于自我介绍时没有把特色表现出来，整个过程需要前面一段时间表达才能进入状态。进入状态后表现得更好，但这样找感觉的做法是不妥的，因为不知道会遇到什么样的面试过程，这个感觉不能够很准确地把握好，这个得多练习这种中长时间的发言，平常应该多把握这样发言的机会。 另外一点，在面试过程中特别是在发言过程中有点过于逃避面试官的眼神，这一点在进入状态时，应该要微笑面对面试官，很真诚地给出自己的最聪明的答案。 同时一起群面的人说我在面试时，没有尽量地多说，有一点像挤牙膏的感觉，面试官问一点我说一点，没有把面试官当作一个很尊重的人。从这一点我想到了，当时面试的时候面试官在主动给我挖坑，我并没有很积极地配合他绕过这些坑，在看到明显地坑在面前时，内心是慌乱的，没有冷静地绕过去，给他一个漂亮地回答。但我感觉在面试官面前不应该说过多的话，应该把最精准的话表达出来，达到表现自己精练准确的目的就够了，但这也要当时当地保持冷静的头脑，积极地思考。 面试题 递归求6！。 截取字符串：用户输入一个字符串和需要截取的字节数，返回截取后的字符串，注意中文一定要截取完整，如:（”人ABC”,3）,截取的结果是：”人A”，又如:（”人abc们de”，6），结果应该是：”人abc”。public static void main(String[] args) { int byteNumber =0, strIndex =0,endIndex = 5; String str = &quot;要df地sd dsfg/.在家 城&quot;,strRes = &quot;&quot;; char charStr; for(strIndex=0;byteNumber&lt;=endIndex;strIndex++){ charStr = str.charAt(strIndex); if((int)charStr&lt;128) byteNumber++; else byteNumber+=2; if(byteNumber&lt;=endIndex) strRes+=charStr; } System.out.println(strRes); } Orical数据库的事务隔离级别： 先引入三个概念： 幻想读：事务T1读取一条where条件语句，T2插入一行也符合的，这时T1再次查询可以看到新数据，这叫幻想读 不可重复读：T1读取，T2修改了数据，T1再次读时就讲到修改过的数据，这叫不可重复读 脏读：T1更新了数据，但未提交，这时T2读取更新后的数据，但T1回滚操作，T2读取就无效，这就叫脏读 事务隔离级别： READ UNCOMMITED,允许以上三种 READ COMMITED,允许幻想读、不可重复读，不允许脏读 REPEATABLE READ:允许幻想读，不允许不可重复读与脏读 SERIALIAZABLE,三者都不允许 Oracle不支持脏读，默认使用READ COMMITED,支持READ COMMITED/SERIALIZABLE SQL标准定义的默认事务隔离级别是SERIALIZABLE 数据库索引：（参照其他博客） 数据库引擎：（参照其他博客） ISAM，读取速度很快且不占用大量的内在和储存资源。不支持事务处理也不容错。 MyISAM，上者的扩展，也是缺省的数据库引擎。表损坏后不能恢复数据。 HEAP，只允许驻留在内在里的临时表格，这也让其读取速度最快，但也是缺陷来源，没有保存就关机也就丢失所有数据。 InnoDB，支持事务与外键，也就意味着慢。 CSS常用选择器并说明： id选择器,选择指定唯一标识id属性的元素 类选择器，选择同一类属性的元素 属性选择器，选择同一属性值的元素 元素选择器，直接选择指定文档元素 派生选择器，依赖上下文来应用或避免某种规则 Conllection与Conllections的区别: Collection： java集合框架（Java Collections Framework)中的一个接口，它为具体的集合规定了最大化统一操作方式； Collections： 一个java集合的包装类，java集合框架中的一个成员；public class Collections extends Object 此类中除继承而来的成员外，大部分是静态成员，而且此类不能实例化出对象来； 其中有一个很有用的方法：sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)，将指定的list进行排序，有重载方法不指定比较器则按默认的从小到大的方式进行排序；","tags":[{"name":"job","slug":"job","permalink":"https://kangshanr.github.io/tags/job/"},{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"oracle","slug":"oracle","permalink":"https://kangshanr.github.io/tags/oracle/"}]},{"title":"每天的问题与更新的答案","date":"2017-09-01T05:04:38.000Z","path":"2017/09/01/today's questions/","text":"今日问题 9/1/2017 6:00:51 PM 在实现同步代码块时，synchronized()这个()中的对象应该放入什么对象？ 通常放入了这个类的class对象，形如：synchronized(this.getClass()){} 9/3/2017 6:01:28 PM 对于一个子类，其继承的父类与实现的接口之间无关系，但这两者都有相同签名的方法，是什么样的情况？ 亲测有效，在子类实现父类与接口的同名方法一次就行，最终执行结果与所写代码块一致； 这个父类的方法不管是抽象方法，对结果并无影响； 对于面向对象多态的实现中，使用父类或接口来接收一个子类或实现类的对象时，这个对象并不会拥有自己扩展的变量或成员，只能拥有父类或接口的成员； main方法对于一个java程序的意义及它是如何被调用的，它的参数意义在哪？","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"Mybatis框架的应用与理解","date":"2017-08-31T05:12:34.000Z","path":"2017/08/31/mybatis/","text":"mybatis框架的使用与理解Mybatis与JDBC概述： MyBatis是一个半自动的面向sql的orm框架； JDBC全称：java database connectivity，是java封装在在java.sql包里的API，其设计目的在于连接数据库，通过java语言实现sql查询语言在数据库中的操作； Mybatis就是对JDBC的封装，使其操作数据库更为灵活，更多的数据与实体之间的映射交给配置文件来实现； JDBC作为java连接数据库的底层框架， 实现数据库连接功能的步骤： 加载驱动 获取数据库连接 准备语句（获取状态对象） 执行语句 处理结果集 关闭数据库（释放资源） 异常处理 可以看到在整个流程中的JDBC功能实现的缺陷： jdbc的硬编码不方便维护，需要不停地连接、释放数据库资源； 参数绑定在硬编码中，查询条件不定，修改语句也不方便； 所以，就有了MyBatis存在的必要； MyBatis的实现在一个工程中要使用MyBatis框架： 将MyBatis的核心包、依赖包引入。如果是Maven项目，直接在pom.xml中引入依赖：&lt;dependencies&gt; &lt;!-- 实现连接数据库的包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志记录的包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入相关的jar包后，就可以对mybatis进行配置： mybatis.xml文件中，配置mybatis的标签是： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 引入配置文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot; /&gt; &lt;!--自定义别名 --&gt; &lt;typeAliases&gt; &lt;!--定义单个别名 ,不区别大小写 --&gt; &lt;!-- &lt;typeAlias type=&quot;com.woniuxy.mybatis.entity.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;!-- 批量定义别名，该包内所有的类的类名直接作为别名，不区分大小写 --&gt; &lt;package name=&quot;com.woniuxy.mybatis.entity&quot; /&gt; &lt;/typeAliases&gt; &lt;!-- jdbc的配置信息 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射资源 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mappings/Users.xml&quot; /&gt; &lt;mapper resource=&quot;mappings/UserMapper.xml&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 其根标签是：&lt;configuration&gt; 解析上述各标签： properties:属性文件的引入，将java属性文件引入到该配置文件中，如上所述：引入了jdbc.properties文件，就可以在配置数据源属性时，通过点位符&amp;｛｝来获取到装配进来的属性文件中的属性值； typeAliases:别名的设定，可以指定单个类的别名，也可以使用子标签package 指定整个包的别名为类的simpleName; environments配置中，除了配置了JDBC数据库连接信息(数据源类型：POOLED)外,还得设定事务管理器类型：JDBC； mappers:映射各个实体类或映射类配置文件到此配置文件中去； mappers中的配置文件： Users.xml文件是指定了这个user类与数据库中操作的方法，包括这些方法的参数与返回值类型； &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;test2&quot;&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; SELECT * FROM t_user WHERE ID = #{id} &lt;/select&gt; &lt;!-- 根据用户名获取用户列表 --&gt; &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt; SELECT * FROM t_user WHERE user_name like &apos;%${value}%&apos; &lt;/select&gt; &lt;!-- 添加用户数据 --&gt; &lt;insert id=&quot;saveUserInfo&quot; parameterType=&quot;User&quot;&gt; &lt;!-- 使用selectkey返回插入数据的id --&gt; &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; &lt;!-- 如果主键使用uuid，则可以通过下面方法把id转出 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;string&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() &lt;/selectKey&gt; --&gt; INSERT INTO t_user(user_name,cnname,sex,mobile,email,note) VALUES (#{user_name},#{cnname},#{sex},#{mobile},#{email},#{note}) &lt;/insert&gt; &lt;!-- 删除数据 --&gt; &lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; DELETE from t_user where id=#{value} &lt;/delete&gt; &lt;!-- 更新数据 --&gt; &lt;update id=&quot;updateUserInfo&quot; parameterType=&quot;User&quot;&gt; UPDATE t_user SET user_name=#{user_name},cnname=#{cnname},sex=#{sex},mobile=#{mobile},email=#{email},note=#{note} WHERE id=#{id} &lt;/update&gt; &lt;/mapper&gt; #{}与${}的区别： #{} 表示占位符号，相当于实现了JDBC中的paparedStatement占位符的作用，也就实现了防止sql注入； 同时实现了java类型与jdbc类型转换，可以接收简单类型值与pojo属性值； 如果传输单个简单类型值，｛｝中可以是value或其它名称； ${} 表示sql字符串拼接，也就是将｛｝中的内容拼接在sql中且不进行jdbc类型转换； 可以接收简单类型值或pojo值，如果是简单类型值｛｝中只能是’value’; 文档头可以看出这是mabatis3映射的定义文档类型，所以其根标签为mapper，其中各子标签或属性： namespace属性，指定其命名空间，这样在其它地方要调用此配置文件中的各语句时，就需要通过这个命名空间来访问到此文档中定义id的各个语句，通过session对象的方法来调用时，这些语句就作为参数执行方法：`session.selectOne(“findUserById()”,user)； session的来源： /** * 测试前的预备工作 */ @Before public void before(){ System.out.println(Before.class); try { // 读入mybatis配置文件到输入流中 is = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factoryBuilder = new SqlSessionFactoryBuilder(); //使用输入流创建sqlSessionFactory factory = factoryBuilder.build(is); //打开sqlSession session = factory.openSession(); } catch (IOException e) { e.printStackTrace(); } } 上述代码是利用junit包实现了测试功能，@Before注解标这个方法在@Test方法之前运行，从该方法就可以看出myBaitis的运行流程： 将mybatis.xml配置文件读放流中，再使用sessionFactoryBuilder对该流进行创建工厂（抽象工厂模式）； 调用工厂的openSession()方法打开会话，获得sesison实例； 操作数据库最后一步就是调用session对象的方法：List&lt;User&gt; users = session.selectList(&quot;test.findUserByUsername&quot;, &quot;k&quot;); 这儿的test就是之前指定的namespace，这儿指定的id的语句执行，并将另外的参数传入，形成完整的sql语句； 这个流程是最初级的，而我们现实中常常不使用这样的形式，而使用接口来将所有方法的调用都交由接口来实现： 在获取到session时，就通过session.getMapper(Class mapper)方法来获取到相关的mapper接口的对象，而在使用过程中，就直接调用这个接口对象的方法（方法执行时就调用相应的语句执行），这个方法与语句之间映射就由指定了nameSpace的xml配置文件来实现，这种方法实现原理叫Mapper动态代理； 从上面的例子就可以看出Mybatis解决了的jdbc的问题： 数据库的链接的创建与释放者造成系统资源的浪费，而使用数据库连接池就可以此问题，在Mybatis的配置中设置； sql语句写在java代码中造成的不易维护，而Mybatis就将这些sql语句配置在相应的配置文件中，这样就与java代码实现了分离； 使用映射好的java对象来作为sql语句的statemente的参数，而不用像在jdbc的执行方法中定义输入参数的类型； 对于结果集的解析在JDBC中需要一层层遍历，并将各个属性封装到entity中再装入集合中。Mybatis将这些封装好，直接将结果映射到java对象中； 同时，上面例子并没有在持久层操作，也就是DAO层并没有进行开发，直接使用在TEST中进行调用抽象工厂的构造方法来构造工厂与sqlSession，再用sqlSession对象的方法，sqlSession的方法中调用配置好的sql语句与参数； 如果要实现持久层的开发不过是把上面构造SqlSessionFactory/SqlSession的方法封装进Dao类中实现； 使用Mapper代理开发概述： 动态代理开发，就是让生成Mapper对象的这个过程交给SqlSession对象的getMapper（Class mapper)方法，这时的SqlSession可以理解为工厂，也就是通过了工厂来构造获取Mapper接口的对象； Mapper对象就是Mapper接口的实例，这个接口与写好相关的mapper.xml配置文件相关联，Mybatis就用这个接口作为代理与被代理的mapper的公共接口，这个对象的方法执行时就与相关联的Mapper.xml配置文件里的sql语句来执行sql方法； Mapper接口与Mapper.xml配置文件相关联的规则（此规则由Mybatis规定，符合此规则便形成关联）： Mapper.xml文件中的namespce与mapper接口的类路径相同； Mapper接口方法名和Mapper.xml中定义的每个statement的id相同； 接口方法的输入参数类型和配置文件中的sql的parameterType的类型相同； 接口方法的返回数据类型与配置文件中的resultType类型相同的； 实现代理开发就意味着之前的session方法执行都交给这个Mapper对象，所有的操作方法都由这个接口定义，调用这个方法就只用传入定义的参数类型，这也就实现了由Mapper对象的方法来代理SqlSession对象中的操作数据库的方法(这儿涉及到代理设计模式的理解)，相对于直接使用SqlSession的各种执行方法更为简便； 动态代理开发中的小点： 动态代理在使用时，Mybatis会生成一个动态代理对象，至于这个动态代理对象会调用SqlSession的的selectOne()方法还是selectList()方法根据定义的mapper接口方法的返回值决定，如果返回List则调用selectList()方法，如果返回单个对象就调用selectOne()方法； 使用mapper代理开发就不用写mapper接口实现类，输入参数也可以直接使用map对象或pojo对象，保证了dao的通用性；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"设计模式之适配器","date":"2017-08-29T05:04:38.000Z","path":"2017/08/29/adapter_pattern/","text":"适配器模式 适配器是行为型模式，将原有的行为经过组合进行扩展； 顾名思义，适配器就是将原本不适的接口或功能适配到目标对象上。 最简单的理解类型是缺省型适配器：将各个接口实现在一个适配器上，再让目标继承这个适配器（可省，直接用这个适配器new出对象来也一样可以实现），想扩展什么接口功能就重写相应的方法，就实现了适配器的扩展功能； 而比起缺省型适配器，还有类的适配器和对象适配器： 类适配器：将目标功能的接口执行并继承被适配者 被适配者：想在此类上扩展目标接口的功能（适配器的设计初衷在于，被适配者并不能直接实现目标接口）public class Adaptee { void run(){ System.out.println(&quot;Adaptee.run..........&quot;); } } 目标接口：public interface Target { void fly(); } 适配器：public class Adapter extends Adaptee implements Target { @Override//继承父类被适配者，并能方便地扩展其方法 public void run() { super.run(); System.out.println(&quot;Adapter.run.......&quot;); } //实现目标接口的方法 @Override public void fly() { System.out.println(&quot;Adapter.fly...........&quot;); } } 测试：public static void main(String[] args) { Adapter adaptee = new Adapter(); adaptee.fly(); adaptee.run(); } 测试结果：Adapter.fly........... Adaptee.run.......... Adapter.run....... note:这样的一个适配器在某种程度上来说与缺省的适配器并没有什么本质上的区别，都是将各种功能行为通过继承或实现聚合到同一个适配器上； 对象适配器模式： 与类适配器不同在于，对象适配器将被适配的类注入到适配器，再让适配器实现想要实现的接口，而让适配器聚合了这两者的成员； 被适配者与目标接口与上面例子一样，但适配器变成：public class Adapter implements Target { private Adaptee adaptee; public Adapter (Adaptee adaptee){ this.adaptee = adaptee; } //扩展被适配者方法相对来说要被动一点 public void run() { this.adaptee.run(); System.out.println(&quot;Adapter.run.......&quot;); } //实现目标接口的方法 @Override public void fly() { System.out.println(&quot;Adapter.fly...........&quot;); } } 可以看出来，对象适配器是将被适配者作为一个对象注入到适配者中，实现聚合其方法； Note: 适配器的好处在于：将各个部门不同的功能聚合到同一个对象上，而实现各个不同的功能都可以通过一个对象实现，达到了高聚合的效果； 适配器的缺点：各个不同的接口聚合到同一个类中，而让这个对象的接口变得混乱，当这个对象实现某一个功能时，会不清楚实现这个功能到底来自于哪个接口；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"设计模式之单例模式","date":"2017-08-29T04:54:30.000Z","path":"2017/08/29/singleton_pattern/","text":"设计模式之单例模式 单例模式是设计模式最常用到的模式之一，从字面上理解就是，该对象类只产生一个实例。这样做的理由在于开发过程中很多类（比如：管理类）都只用一个实例就够了，这样做也更节省资源。但是项目开发做会有一个多线程的问题，也就是当多个线程访问同一个类的单例时，这时会产生线程安全问题，为解决这个问题，单例模式分成了6种不同类型。 单例模式的设计目的就在于：不想让一个全局使用的类频繁地被创建再销毁其实例，要达到这样的效果就让其构造函数不能被不停地调用，也就是私有化其构造函数； 单例模式的6种类型： 非线程安全的懒汉式public class UserManager{ //静态单例 private static UserManager ins; //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ ins = new UserManager(); } return ins; } //其他的执行方法 ｝ 这种类型的单例就是没有考虑线程安全的单例，之所以叫“懒汉式”在于其实现了这个单例的懒加载，也就是第一次使用时才会实例化这个单例； 其缺陷在于当多线程同时第一次访问这个单例时，会构造出多个单例来，也就是说严格上讲它并不单例模式； 线程安全的懒汉式public class UserManager{ //静态单例 private static UserManager ins; //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static synchronized UserManager getIns(){ if(ins == null){ ins = new UserManager(); } return ins; } //其他的执行方法 ｝ 这处线程安全的懒汉式只是简单地在获取单例的方法上加上synchronized同步锁，同时也实现了懒加载； 这样做缺陷在于效率上的低下，想要获取这个类的单例所有线程都得等待上一个线程释放资源；-饿汉式 public class UserManager{//静态单例定义为类成员 private static UserManager ins = new UseManager(); //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ return ins; } //其他的执行方法 ｝ 这种单例定义为类成员，也就是类加载时就将这个单例初始化完成，未实现懒加载，会造成资源的浪费； 并没有使用同步锁而实现了多线程只访问同一个实例，效率上更高； 双检锁（双重校验锁），DCL（double-checked locking)public class UserManager{ //静态单例 private static UserManager ins; private Object lock = new Object(); //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ //第一次检查 synchronized(lock){ //保证不产生多余的实例 if(ins == null){ //第二次检查 ins = new UserManager(); } } } return ins; } //其他的执行方法 } 这种类型就实现了高性能与懒加载，逻辑上也相对复杂一点； 两次检验都放在getIns方法内，第一次校验确保只有ins实例第一次被创建时进入到同步锁块中，也就是多线程下会有多个线程进入到这一步，这时最先拿到控制权的线程构造实例后，其他的线程不能再构造实例了，所以就得在同步锁中再次进入第二次检验了； 静态内部类（登记式）public class UserManager{ //定义私有的静态内部类 private static class ManagerHolder{ //定义私有的静态属性，其值为我们想要的实例 private static final UserManager INSTANCE = new UserManager(); } //私有化构造函数 private UserManger(){} //获取单例的方法 public static UserManager getIns(){ return ManagerHolder.INSTANCE; } } 这种类型的单例模式效果和双检锁效果差不多，同样实现了懒加载，且没有使用同步锁； 枚举public enum UserManager{ //单例 INSTANCE; //其他的方法 } 这种方式是目前实现单例的最佳方法，但目前还没推广（jdk1.5之后才加入enum)，更简洁，自动支持序列化机制，绝对防止多次实例化； 6种单例模式中，前两种懒汉模式不推荐使用，第一种并非纯正的单例模式，第二种懒汉模式在多线程中效率低下，更不推荐，只要进入getIns方法就得等待上一个线程释放控制权；当对反序列化机制有严格要求时，就使用枚举方式；当要明确使用lazy loading时，就使用静态内部类方式或者双检锁方式；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"得到例会：关于找工作","date":"2017-08-28T18:04:38.000Z","path":"2017/08/29/20170829IgotMeeting/","text":"得到例会8/29/2017 9:41:18 PM今天得到例会，快刀谈到找他招人的感想，觉得对自己很有用，记录下并找到之前他们拉过的清单，这儿一并引用过来，谈谈自己的看法: 快刀： 找交互设计大咖后，站在一个招技术人才的业务管理角度上谈谈自己对来聘人员的几点看法： 非应届生一定要了解应聘的公司，一定要做充足的准备； 自我介绍的作用：抓住重点，不能陷入自传； 诚实：圈子内信息透明； 为什么想离开？说前任公司坏话只会损坏自己形象； 问问题：跟以后的工作做了解的问题才是王道，关于细节上的五险一金、加班费、各种福利，这些问题都不是问业务主管的回答的； 快刀与娘娘分别在罗辑思维上推过关于找工作写简历的清单，个人认为很有参考意义，这儿一并贴出来： 快刀： 关于如何准备一份制胜简历的清单引言：简历是公司了解求职者的第一个途径，也是求职者获取工作的敲门砖。可是，有多少人明明很优秀，却败给了一份不合格的简历？ 简历是你的第一份产品，一定要认真对待，大方得体是王道。从招聘网站下载一个垃圾模板，随便填一大堆无用的信息，谁能相信你会认真对待自己的工作？ 贴照片要谨慎，只能选择清晰的大头证件照。绝不要贴游客照和婚纱照，谁知道哪个是求职的。也不要工作10年了，还贴高中的准考证照片。 除了没有任何实习经验的在校生，删掉自己在社团、学生会、班级、寝室里获得的各种奖励。它们除了告诉别人你很嫩之外，没有任何用。 要让别人从简历中看出你的经历和核心竞争力。最好做到逻辑清晰无废话，能一张纸写完绝不用两张。 个人资料的必备字段是：姓名、年龄、电话、邮箱、毕业学校。不会有任何一家正经公司，希望在简历里看到饮食口味、三围、罩杯之类的信息。 如果是做设计或产品的，简历只用一到两种字体，不要炫技。附带的作品集，保证有3-5个能代表最高水平的就好，不要连练手的作品都放进来。东西越多，机会越少。 不能加分的东西就会减分。越长的简历，越容易出错。例如，你是曼联球迷，你觉得面试官说“我也是”的机会很大。但可能初筛时，就被一个迷恋阿森纳的HR砍了。与工作无关的爱好，一笔带过，不要展开。 自我评价不要超过1条微博的长度。写800字那是高考作文，没人想看你给自己写的自传。 别作死。作死会让别人记住你，但是并不会让人招你。5年前，我在老东家时，收到过一封让我至今仍刻骨铭心的简历。邮件第一句话是，“其实我并不喜欢你们公司”，不喜欢你投简历干什么。 不要一遍又一遍的在简历里强调“我什么都不会，但是我很努力，我可以学”。活了20多年都没学会，凭什么相信你入职就能学会？ 凡是列了一大堆精通，里面还有Office的，几乎都会被刷。正如凡是写精通Excel的，真正问起来，懂透视表与各种公式的，基本没有。 附件除了Word版本，最好再附一个图片或者PDF版本。附件名字不要用“个人简历”或者“我的简历”，设想一下面试官电脑里有几十份“我的简历”的情形。用“应聘XX职位-X年工作经验-姓名”就足够了，也可以加上手机号。 作为职场中人，常备一份定期更新的简历是很必要的。不要等到看到机会再准备。定期根据实际情况来增减改删，只留下能代表自己最高实力的项目详情，其他项目一笔带过。 一岗一写，不要指望一份简历包打天下。针对每一个不同的公司或者岗位，单独改写简历。这就意味着不要海投简历，提前去媒体或社交网站上，了解这个公司的创始人或者高管，有助于你针对性改写。 用什么邮箱并不重要，但不要直接发一份带附件的空白邮件。邮件正文可以简单地描述一下自己的情况，但绝对不要空。 简历的核心作用是“争取到面试机会”，不要把自己的底牌都放在简历里。可以展示项目的成果数据，但是具体做法等到面试时再说。 最后提醒一句：不要逗贫。你不知道看简历的人笑点高低，一不注意会显得Low。 娘娘清单｜拿下目标职位的16个必杀技 我是脱不花，罗辑思维CEO。 三年来，我坚持面试加入团队的每一位员工，平均每周至少有八个小时投入在面试上。我经常会发白日梦，看着眼前面试的人，琢磨如果我是Ta，此时此刻此情此景我会做什么。 时间久了，这套代入法，成了一种练习，一种面对不同问题的沙盘推演。很好玩，也是内观、自省的方式。 我不会海量投递简历。我会把所有目标单位，按照自己的评价体系，分出梯队，一次只给特定的三四家公司投简历。一批如果失败，再启动下一批。 值得纳入评价体系的公司指标包括：公司成长性、能担任重要岗位的时间周期、薪酬、认识牛人的机会和频率、是否可以获得特别敬仰的师父、行业先进性、与我特长优势的匹配度、招收同龄同届人员的规模、公司整体的审美水平。 在投出简历之前，做足功课。研究这家公司的官网或者官微；认真阅读媒体动态，特别是创始人的讲话；体验这家公司的产品，尤其是非主力产品；上论坛或者贴吧看看相关评论，但不尽信。 我会把投出的每份简历，视为对这家公司的一次特定的沟通。没有标准简历一说，每份简历都是专门准备的。 我的简历核心内容只会有一页，其他皆为附件。简历首页是有助于建立信任的基本信息，要尽可能简洁。比如毕业院校、取得的最高荣誉、能为我背书的人、目标岗位、能力匹配，还有一张体面的标准照，而不是艺术照、生活照、自拍照。 简历里附件包括：我对公司的认同和对目标工作的理解，我以往的实际经验和相应的证明人，我的其他背景资料，主动提供社交媒体账号。 我在发送简历时，不会抖机灵，不会耍幽默。只会老老实实地写一封诚恳的邮件，把核心信息写在邮件正文里，而不是扔在附件里，用最小的格式把简历做成附件，发出。不会附上特别大的图片或者其他文件，也不会需要对方多次打开不同链接，而是一个可以快速打开、一次性看完的信息组合方式。 如果我极其渴望一份特定的工作，我会努力在投递简历前，做一些外围的示好。比如，结合自己的专业，帮这家公司做一些建设性的事情。 在面试时，进入公司现场，我会注意感受整体氛围：是否够开放？人与人之间是否有很多交流？每个人的状态看起来如何？我的直觉感受是怎样的？ 面试时，我会用简洁的表达方式。有问，必有答。回答中经常引用和提及在做功课时获得的公司信息，表现出对公司的熟悉度。 表现出愿意学习的态度，但要表达能为公司做的贡献，而不是表达自己是来学习的。 对薪酬问题，用坦率的态度直接谈，有弹性，但也要有底线。弹性让我不错过长期来看的好机会，底线让我避免掉进坑里。如果在薪酬上做了较大让步，开口提出建设性的办法，比如，达到什么标准公司应该加薪。 当面试官让我发问时，绝对不问五险一金和年假制度（这种有的是机会私下问HR）。我会问几个好问题，比如：我会和谁一起工作？如果我遇到问题，我可以通过哪些方式获得指导？公司鼓励什么样的沟通方式？公司希望我在三个月左右能达到什么水平？在我以前，公司里最优秀的新人是什么样的？ 精心打扮，但不过分。手机调整到无声。坐下就拿出笔记本。对面试官不要叫“某总”，张嘴就叫“老师”。 永远不要让对方知道，也许我手里还有其他Offer。这种故作紧俏的做法非常不体面。有经验的面试官不会因此紧张，反而怀疑你的诚意。 简历里不写错别字。面试时一直笑眯眯。 Q: 上面的16条心法，你在求职时做到了几条，最后的结果如何？你又有什么独家的心法呢？ 我的体会：总的看来，上面几十条都是在这几点： 我很靠谱，事情交到我手上可以有交代地被移交给他人； 我很善于合作，我善于连接； 我不笨； 另外，在这次例会中，快刀的关于找工作只是很小的一部分，只是这一点对我很有触动，全展开来了。娘娘这次的干货中很有启发的一点是：学习了一定要强制输出，每周写一篇文章发布在自己的朋友圈中，不仅仅是让自己学到底，更能让自己在朋友圈中树立一个靠谱有建树的形象，这也是重要的社交货币。","tags":[{"name":"job","slug":"job","permalink":"https://kangshanr.github.io/tags/job/"}]},{"title":"设计模式之工厂模式","date":"2017-08-28T02:04:03.000Z","path":"2017/08/28/factory_pattern/","text":"工厂模式 生成一个类交由相关的工厂类实现，而不由直接的类来实现； 相关的类继承同一个接口，实现这个接口的类都可以由工厂类中同一个方法来实现实例化； 例如简单工厂模式： //定义同一个类的抽象接口 public interface Shape{ void draw(); } //实现shape接口的类有： //Circle类 public class Circle implements Shape{ @Override public void draw(){ system.out.println(&quot;circle.draw&quot;); } } //Square类 public class Square implements Shape{ @Override public void draw(){ system.out.println(&quot;square.draw&quot;); } } //创建实例的工厂类 public class ShapeFactory{ //创建图形实例的方法 public Shape createShape(String shape){ if(shape.equalsIgnoreCase(&quot;CIRCLE”){ return new Circle(); } if(shape.equalsIgnoreCase(&quot;SQUARE”){ return new Square(); } reutnr null; } } 模式理解： 通过工厂来实现对各个类的实例化，都在工厂实现； 通过反射机制实现，增加一个同一接口的类不需要改变工厂的代码,只需要增加一个实现这个实现对应接口的类： 其工厂的代码：public class ShapeFactory{ //创建工厂的方法 public Shape createShape(Class&lt;? extends Shape&gt; clazz){ try{ return Class.forName(clazz.getName()).newInstance(); }catch(Exception e){ e.printStackTrace(); } } } 工厂方法模式 相较于简单工厂模式，工厂方法模式实现了“用扩展取代修改”，简单工厂中要增加减少实现产品的构造需要对工厂的代码进行修改，而工厂方法模式将这些都放在子类的实现中； 示例：生产iphone与miphone两种手机，将手机与工厂的接口抽取出来，分别用不同的工厂生产不同的手机； 手机接口：public abstract class Phone { } 手机类：public class Iphone extends Phone { public Iphone(){ System.out.println(&quot;Iphone.constracting.....&quot;); } } public class Miphone extends Phone { public Miphone(){ System.out.println(&quot;Miphone.constracting......&quot;); } } 工厂接口：public interface Factory { Phone createPhone(); } 工厂类：public class IphoneFactory implements Factory { @Override public Iphone createPhone() { return new Iphone(); } } public class MiphoneFactory implements Factory { @Override public Miphone createPhone() { return new Miphone(); } } 测试：public static void main(String[] args) { //创建iphone过程，先建工厂，再在工厂中创建iphone IphoneFactory facIphone = new IphoneFactory(); Iphone iphone = facIphone.createPhone(); //创建miphone过程： MiphoneFactory facMiphone = new MiphoneFactory(); Miphone miphone = facMiphone.createPhone(); } 测试结果：Iphone.constracting..... Miphone.constracting...... 工厂方法模式将对象的创建进行了很好的包装，但也正因此而每增加一个产品的类就不得不增加一个工厂来实现其构造，这在某种程度上来说是不科学的； 抽象工厂模式 相比较于工厂模式，抽象工厂模式在工厂模式的基础上增加生成工厂的工厂类，那么生产出来的工厂都要继承一个接口或父类； 该模式的优点：把同一个产品类集成到同一个工厂内，这样使用时就直接调用工厂中的方法，而生成同一个工厂里预备好的类对象，也更方便管理； 它是为了解决子工厂的扩展性问题，而将系列产品装配在同一个工厂中，也就实现了不同产品之间相互组合不同最终产品，而子工厂中不同产品抽取接口或父类方法出来成为抽象工厂； 示例：生产手机需要手机引擎、手机音乐盒这两种产品，这两种产品分别有两种类型，那么，一个引擎加一个播放器组成一个手机产品集 引擎接口：public interface Engine { } 引擎产品的两个类：public class EngineAmd implements Engine { public EngineAmd(){ System.out.println(&quot;EngineAmd.constracting....&quot;); } } public class EngineIntel implements Engine { public EngineIntel (){ System.out.println(&quot;EngineIntel.constracting.......&quot;); } } 音乐盒接口：public interface MusicBox { } 音乐盒的两个不同产品类：public class NokiaMusic implements MusicBox { public NokiaMusic(){ System.out.println(&quot;NokiaMusic.constracting...&quot;); } } public class SonyMusic implements MusicBox { public SonyMusic(){ System.out.println(&quot;SonyMusic.constracting...&quot;); } } 抽象工厂类，规定手机工厂要生产的两个产品：一个引擎一个音乐盒，这儿可以用接口也可以用抽象类public abstract class AbstractFactory { abstract Engine createEngine(); abstract MusicBox createMusicBox(); } 两个工厂类，实现抽象工厂，实现装配两个产品到一个工厂中//苹果手机厂，使用intel引擎与sony的音乐盒 public class AppleFactory extends AbstractFactory { @Override public EngineIntel createEngine() { return new EngineIntel(); } @Override public SonyMusic createMusicBox() { return new SonyMusic(); } } //联想手机，使用amd的内核与Nokia的音乐盒 public class LenovoFactory extends AbstractFactory { @Override public EngineAmd createEngine() { return new EngineAmd(); } @Override public NokiaMusic createMusicBox() { return new NokiaMusic(); } } 测试，将工厂创建出来由它们来创建手机的子产品public static void main(String[] args) { Apple apple4s = new Apple(); Lenovo lenovo3 = new Lenovo(); //apple生产过程 AbstractFactory appleFactory = new AppleFactory(); apple4s.engine=appleFactory.createEngine(); apple4s.musicBox=appleFactory.createMusicBox(); //Lenovo生产过程 LenovoFactory lenovoFactory = new LenovoFactory(); lenovo3.engine=lenovoFactory.createEngine(); lenovo3.musicBox=lenovoFactory.createMusicBox(); } 测试结果：EngineIntel.constracting....... SonyMusic.constracting... EngineAmd.constracting.... NokiaMusic.constracting... Note: 从上面例子可以看出： 抽象工厂可以实现组合产品集，一个工厂组合一个产品集，同时想要实现产品集的扩展也很方便。想要订制同一个产品集不同型号，直接实现一个工厂类。如果要不同产品集，则需要对抽象工厂进行扩展修改；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"无题","date":"2017-08-26T14:19:02.000Z","path":"2017/08/26/titleless/","text":"刚才重看了一遍《当幸福来敲门》，看到Chris在实习期间，为了促进与客户的联系与第一个客户去包厢看football game，这就便结识了一众上流的客户。 我便想到，这个时候要是我是他，我做得到吗？Chris很穷，比现阶段的我还穷，但他在与他的精英客户一起看比赛的过程中，一点也不含糊，用着最专业的语言与人交流铺垫后面的工作事务。而如果是我，我肯定会在内心深处认为自己干不了这个事。这也是一般人的的认知上的缺陷。大家都会认为自己不熟悉的东西都不是自己的东西，会直接把这些东西排除在自己的思考范围之外。Chris为什么能做到？为什么我有同样的境遇时，我会把所有松懈归因到外界？同时，我为什么会松懈？因为我对自己要求低，为什么很容易让自己得过且过？因为我从来没有把自己当做一个有追求的人，并没有在内心深处认同自己是一个精英。或者说我根本不知道自己想要什么，想要成为一个什么样的人。这些最本质的思考从来没有进行过，而每次自以为是很与众不同的认知不过是用来平抚自己焦虑的安慰剂。关键点在于，没有把自己看起。从心理学角度来看，并不是一个高自尊的人。一个高自尊的人会在内心深处高看自己一眼，会把与精英互动当成理所当然，也就不会露出任何胆怯。 这也让我想到之前看到很多公号里的文章里介绍，一个强大的父亲是即使整个人都废掉了依然每天整洁清爽，并不因为穷困而开始潦倒，而是给儿女一个很爱护自己形象很会约束自己行为，随时准备与自己的贵人相遇的形象。 因此：别受到与自己水平差不多的人观念的影响，要随时与更厉害的人交流，探索他们的思维与观念，多接受别人的思考方法，学习别人的优点，思考自己的思维缺陷；保持自己的追求，当懈怠时，看看自己是不是总在寻找所谓的“小确幸”，用以填补内心的空虚。这种时候一般的表现是，做事情并没有什么效果，只是追求形式上的参与（这里不得不祭出陈昊老师一句话：参与感带来存在感，存在感带来优越感。仔细想想，是不是当下做的事只是为了满足自己的优越感）。 另外，今天在神游意淫某个与故人吹牛的场景时，想起一句诗：把酒话桑麻。原著：过故人庄——刘禹锡故人具鸡黍，邀我至田家。绿树村边合，青山郭外斜。开轩面场圃，把酒话桑麻。待到重阳日，还来就菊花。 曾经听说过欧阳老师与一个牛逼甲方在吃饭喝酒时，双方行酒令，关于“酒”的诗。双方你一句我一句，看得在场其他人目瞪口呆。忍不住，来一段： 酒逢知己千杯少，话不投机半句多。人生得意须尽欢，莫使金樽空对月。劝君更尽一杯酒，西出阳关无故人。（这一句在14年黄露家送别时酒桌上吟过，不知道在场的有没有觉得当时我很傻逼）对酒当歌，人生几何！明月几时有，把酒问青天。……实在想不起其他的了：”九九女儿红“……收工！！！","tags":[{"name":"essay","slug":"essay","permalink":"https://kangshanr.github.io/tags/essay/"},{"name":"movie","slug":"movie","permalink":"https://kangshanr.github.io/tags/movie/"}]},{"title":"得到直播：薛兆丰用经济学思维提升个人投资水平","date":"2017-08-24T00:04:38.000Z","path":"2017/08/24/薛兆丰：经济学思维与个人投资/","text":"得到直播：薛兆丰用经济学思维提升个人投资水平这里有直播的概要记录，也在最后有一些自己的思考。 中国经济会怎样？ 一个国家的经济会不会好？5个标准： 是否有一套完整的价值体系，过去30年中国改革开放的变化，一句话表述：由一个认人的社会变成了一个认钱的社会；一个认人的社会，社会资源的浪费会很大，一个认钱的社会会让社会的损耗降到最低。价格机制基本完善。 当中的制度让当中的人：一人做事一人当，别人做事别人当；每个人双手都放在自己的口袋里过日子。欧洲目前的难民危机：有一条难以接受，难民在欧洲领到救济，但不能工作。过去中国街头上有一群无所事事的年轻人，要成英雄用弹吉他、打架来定，但外资来了，工厂开过来了，这些一夜之间消失了。现在中国，每一个人，努力多一点，收获就多一点。年轻人上升的空间从来没有这么大，现在工作几年就可以独当一面，过去你想分到一套房要等到退休。 产权保护基于经济属性不基于物理属性。中国对共享经济、新兴产业的保护程度、接受程度比起欧洲好很多。日本做不通，劳动力贵。 政府是否有给新兴势力发展留有空间，新旧利益的交替是否顺利。Uber一兴起，社会的犯罪率就下降。人们对生活有了更多的期待。一碗水端平。 创新创业是不是受到保护。光看这些年国内举世无双的互联网、移动互联网产业，他们的兴起离不开整个社会体制的宽容与开放； 人机矛盾 人工智能来了，机器人带着大数据一路高歌猛进。人该怎么办？ 知识是集中不起来的，知识很重要，但生产一支铅笔的所有知识，没有人能完全弄懂的。这里面的知识是完全分散到各个人脑子里的，机器不能解决这个问题，人工智能不能把这样一个带着权重的任务处理好的。登山这个需求不是实际问题的解决方案，是人想要与人不同的人辛苦地做一件没有实际价值的事，人工智能只能派直升机把你送上去。 未来不可预测，为什么？社会的发展会受到知识的影响，人们的知识变化、想法变化，知识总在增长，知识的增量对人的影响也不可预测，哪怕人工智能已经来了，它也不可能预测的； 人的想像力是机器不能替代的。从数据到逻辑理论当中始终有一个迁跃，这里面不是一条连续的逻辑推演。计算机可以作出曲子来，但它永远不知道这首曲子好不好听。 比较优势原理，机器很多的地方，人很贵的。 人怎么办？人去学机器做不到的事。学耐用的知识：数学，学习学习的方法，保持对知识的好奇心；有了好奇心，这个世界到处都是平台给你学习，人跟机器互动。人工智能不能替代人，人工智能只会让人更有价值，蒸汽机只会让更多的工作机会产生； 投资身外物 当你有一笔可投资的钱，投在哪个地方？房产、比特币、股票、出国…… 买房目的：是用来自用还是投资。长久租金应该与产权费差不多，租售同权一出，买房的意义又少一些。你的需要是什么？中国的买房费用与租金相差3倍之多。人往哪儿挤？不是嘴上说的开门见南山的山清水秀之地，而是人聚积的大城市；聚积的好处：高楼成本很高，积聚一来，规模来了，细化分工，人的价值开始提升，周围地价就上升了。 博弈论：你想去的地方，别人也一样想去，你想得到的东西，别人也一样想得到，你能想到的好点子，别人一样也想得到；世界区分：物理的世界按过程一步一步来，每一步都按照固定规律来；经济的世界，人对世界的预期来决定世物的价格，人们事物的预测来决定价值，一切皆不可预测，一旦人们预测到了，这个东西就不再被纳入价格预测之中，价格不可预测，股市也不可预测；有没有内幕消息？会不会比别人早知道消息？没有，那么只买长线吧，看好一个国家一个公司肯定在未来上升的； 比特币，要成为货币还有很长一段距离。它有一个兴旺发展的过程，但这也是一个庞氏骗局的温床。击鼓传花的游戏中，谁来接这最后一棒？ 投资个人 对于自己的投资，更能掌控最可靠的投资方式 美国种族简历，所有人的收入统计起来，犹太人最富。地产会被外族收走，就投资首饰，首饰也被没收，就不得不选择知识、智力。 对知识的投资才是财富增长的根本原因。温度、资源都不是原因，人力资本才是改变个人改变世界的引擎； 学习各种各样的成功学，要记住别人的成功永远不可能复制过来的，永远不要忘记做自己手头能够做的事情。收入不均的问题， 不同的行业不同的人力有不同收入。用远大的目标来校正今天当下的行为。我们要追求的不是一刹那的幸福，不是当下的收入，而是一生幸福的总和，一辈子总收入。我们要看中二三十年后幸福收入总和。李嘉诚现在是赚很多钱，不是说当年他受过多少苦，他最让人佩服的是当年他在黑暗的隧道里眼前一样难以看到希望的时候，依然选择了努力，选择了学习。 后记：8/24/2017 10:02:53 PM 得到直播都是晚8点开始，这次薛老师一直讲到9点半，中途休息过两次都是讲得太久不得不喝口水休息一下，广告只在结束后小娴来拉的。 讲得很生动，听得我一直没有停下来过。听了之后开始反思这一段时间对自己的放松，这么长一段时间来自己对自己要求的降低，追求内心满足于小事，并不是让自信来源于自律，只来自于想像。 这个经济学课一开始就订阅了，刚开始的时候还听得挺认真，也有留言过，也有入选过一次精选，但后面开始学代码时，就没有抽时间来专门学习了，每天也只是在路上带着耳机听下，没有进行过深入思考。但具体反思一下，就算在开始认真听这个产品时，我也常常觉得这个还没学等待会有时间了就认真听一下，像故事中的狐狸一样，安慰自己只有在神奇岛上才能跳出最神奇的舞蹈，但别人都知道，我每天都踩在神奇岛的土地上。反观这个故事，其实狐狸也在骗自己，在某种天时地利下，自己可以跳出感动世界的舞，但这个行动一直没有实践过，也就导致了狐狸永远地看不到自己舞姿的拙劣，在各种小事中来获取满足感。这种心理机制的逻辑： 没自信面对自己失败的尴尬，导致一直把可能导致这种尴尬的情况给排开，并骗自己后面时机一到就亮绝活； 再在生活中找所谓的”小确幸“，并满足于这些众多的自嗨的”小确幸“； 直到无可挽回的地步时，就找到另外一个可以让自己隐藏自己可怜的实力点，再进入到第一步开始下一轮循环； 在这个死循环中，哪里一环可以被打破？每一环。每一环都应该提醒自己自信地面对自己，把手头的事做好就是打破魔咒的法宝。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"},{"name":"经济学","slug":"经济学","permalink":"https://kangshanr.github.io/tags/经济学/"}]},{"title":"科学思维看世间百态","date":"2017-08-23T00:02:42.000Z","path":"2017/08/23/卓老板：科学思维看世间百态/","text":"今天得到直播卓老板聊科技：用科学思维看世界运行的脉络，怎么看？直播的一些记要与心得： 科学思维三板斧： 等比缩放：WHO建议少吃糖，男性一天不超过28.5g，怎么算你的食物中有多少的糖？等比缩放。 把原来没有关系的两个事物放在自己能触及的地方； 比如：纳米和亿之间的关联怎么与你相关？ 我的身高是米，cpu的粒子是14纳米，我跟cpu就是亿倍关系。 滴答声一下是1秒，10亿意味着什么？就是32年。对于我们来说32年意味着什么大家肯定就有自己的概念了。 近似计算：通过简单地计算把一个问题定位到一个大概的范围，计算出一个大概的结果； 思维游戏问题：举国之电力，都由太阳能实现行不行？ 假如国家的财力无穷无尽，帝国时代游戏一般来设计我们太阳能？在沙漠中来铺开太阳能板 在高速公路两边的绿带铺开？下雨、阴天、维修，全国13万公里的高速公路， 近似计算鼻祖：费米，第一颗原子弹在内华达州的试爆，用纸片受远距离冲击波影响的飘距来近似计算爆炸当量（算得1万吨TNT当量，事后科学计算得2万吨），误差只有一倍（在质能方程中，估算当量误差往往很大） 对于陌生世界与陌生事物临到面前时，近似计算能力对于掌握新事物的到来很有帮助；平常生活中，这一项能力十分有用； 财务或其他对接事务时：不能有太多约束；比如，坟墓的占地在多久后会把人类居住地占完？但两代人后，人们不会对祖先的领地维护的。 建立模型：如果把人类的知识分类， 自下而上的知识，比如，考古，它的建立是一点一点地累积下来的，只能一块一块地拼图，最开始在边缘上找，再一点点往前推，在这个过程中，我们只能一点点积累证据，一点点接近真理； 自上而下的知识：流行病学，怎么传播，设定一些参数。建立一个模型，再用这个模型来推算其发展形态；如果生活中有问题能用一个模型来解释，那么就用这个模型来计算； 后记： 科学思维不能让你计算出未来事情准确发展动向，但能让你对事态的发展有一个大概地了解，不会一脸懞逼，而失去行事重心。 开始一场话之前，要对这场进行预判，在这场谈话中要达到什么目的； 如果这场话的目的在于让对方有一个很好的感受，那么在谈话过程中就尽量赞许对方，让对方流畅地表达出内心地骄傲； 如果要把自己突显出来，一定要话少，但一定要言必有物，每次场话有两三次谈话让别人印象深刻就很成功了。如果你的科学思维让你比别人看事物问题的角度更新颖开放，那么，一场谈话下来，很容易抓住这两个点让别人刮目相看。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"}]},{"title":"得到直播：打造工作方法","date":"2017-08-23T00:02:42.000Z","path":"2017/08/23/得到直播：打造工作方法/","text":"今天得到直播:打造工作方法有些启发，直播的一些记要与心得： 罗胖:打造工作方法 复制，任何行业，拿走的最多的红利的人不是最顶尖高手的人，而是专业力不错，但同时会复制传播的人，最直接简单的方式：写作，演讲； 怎么把成本覆盖掉，怎么把利复制？王石，任何一个麻烦找上我，我想法就是怎么让这个麻烦下次不再找上我； 正收益能不能复制？怎么提高自己的可复制性？ 三个字：确定性。 工作方法的高下就一点，能不能给确定性？ 能力的确定性； 靠谱与闭环，大家要知道你能力的边界，能力再小，网络中价值中都极大；老干妈，这个产品水平极高吗？不，但海外留学生都知道，想吃到中国味，老干妈一定没错；凡事有交待，件件有回应，不能成为反馈黑洞； 态度的确定性 态度不好拿，想得太多； 找到最基本简单的态度，坚持下去； 范围的确定性 每个人不管在什么层级，都是在创业； 时时刻刻要在所有人面前要表现，你在掌握全局； 思维： 上推，上推具体的操作到正式制度性抽象概念，高级餐厅的牛排旁边一定要放几朵西兰花，这样才显得高级； 下沉，你不是不写嘛，我来，你要觉得这个可以接受，那么我自己做点事，像水一样，把其他的地方勾勒出来，当对方接收到这个动作时，对方被水包裹后自然而然会被牵动； 最后有一段充满力量的话：王朔给女儿:（核心：把握自己，确定性；） 煲汤比写诗重要；自己的手艺比男人的重要；头发、胸、腰、屁股比脸重要；内心强大到混蛋比什么都重要； 在网上查了下，冯唐写这段话应该更早的，王朔应该是借用的冯唐的。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"}]},{"title":"spring框架的学习","date":"2017-08-15T04:14:38.000Z","path":"2017/08/15/spring/","text":"spring配置beans的底层原理就在于通过封装好的解析xml类，将xml文件中配置好的bean实例出一个对象来，再通过配置实现bean之间的相互引用，而实现将要用到的bean（实用类）实例化并使用； Core模块 bean标签： id属性指定这个实例的唯一标识； class属性，用来指定这个实例的类定义； property子元素，指定这个对象的属性，比如：user对象中有属性name,那么这个这个user的bean对象就应该有一个子元素标签property，同时如果这个属性是另外一个本地的bean，name属性指向这个属性：&lt;property name=&quot;advice&quot; id=&quot;beanId&quot;&gt;直接使用id属性来引用到其他的bean的id就行； AOP模块 Aspect Oriented Programming,面向切面编程 切面Aspect:可以理解为模块，比如，读写数据库、权限检查、异常情况记录； Advice,增强：拦截器实现增强接口Advisor，不同的拦截器实现不同的增强接口，比如：方法前拦截器MethodBeforeInterceptor implements MethodBeforeAdvice{ //方法前拦截器 //调用对象的方法前将执行该方法。参数分别为被调用的方法、参数、对象 public void before(Method method, Object[] args, Object instance) throws Throwable{ System.out.println(&quot;即将要执行的方法：“+method.getName()); //如果是Service if(instance instanceof WaiterServiceImpl) String name = ((AopServiceImpl) instance).geName(); if(name == null)//检查是否为空 throw new NullPointerException(&quot;name属性不能为null&quot;); } method.invoke(instance,args); } } 拦截器，interceptor，也是pointcut的核心: spring拦截器的配置实现，通过增加配置：&lt;bean id=&quot;aopMethodBeforeInterceptor&quot; class=&quot;org.springframework.aop.supoort.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot;&gt; &lt;bean class=&quot;com.snail.aopdemo.advice.MethodBeforeInterceptor&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;mappedName&quot; value=&quot;withAop&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 从上面的代码可以看出： spring实现拦截器都是通过增强器Advisor，而这个增强器是一个代理，将参数（自定义的Advice）作为参数传入其中； 同时mappedName属性用来指定拦截的方法，这个方法并不是增加类中的方法，而是到时要执行到的所有的匹配方法名字段的方法； 同时：spring支持由正则表达式配置切入点：&lt;property name=&quot;patterns&quot;&gt; &lt;!-- 正则表达式配置切入点--&gt; &lt;list&gt; &lt;value&gt;.*get.*&lt;/value&gt; &lt;!--包含get字段的方法就被拦截&gt; &lt;value&gt;.*absquatulate&lt;/value&gt; &lt;!--包含absquatutulat字段的方法被拦截&gt; &lt;/list&gt; &lt;/property&gt; ORM模块 Object RelativeDatabase Mapping,对象关系型数据库映射 简介： 此模块对Hibernate/JDO/TopLink、iBatis等ORM框架提供支持； Spring提供在DAO层提供HibernateDaoSupport类与JDBCTemplate类； 在Spring里，Hibernate与SessionFactory等只是Spring一个特殊的Bean，由Spring负责实例化与销毁；所以也就不需要与Hibernate的API打交道，不需要开启关闭Hibernate的Session、Transaction，Spring自动维护这些对象； 实体类这儿用User类举例： 使用注解来让User中属性与数据库中表的列相关联； Entity类的注解： @Entity，表明这个类为实体类； @Table（name=”users”),指明此实体类与数据库users表相关联； 属性的注解： @Id，主键注解，表明这属性为数据库表中的主键 @GeneratedValue（strategy=GenerationType.IDENTITY),指明该主键生成策略为自增 @Temporal（value = TemporalType.Date),表明列属性为Date DAO层接口，不同的Entity对应不同的DAO接口： UserDao接口，就定义对User表的操作：public interface UserDao{ public void saveUser(User user); public List&lt;User&gt; findUsers(); public int getCount (); public User findUserByName(String name); } UserDao接口的实现类，UserDaoImpl： 这个实现类要继承HibernateDaoSupport类，这就意味着从父类继承了Hibernate与HibernateTimplate对象，该对象就对实体对象进行各类操作；public class UserDaoImpl extends HibernateDaoSupport implements UserDao{ //实现接口中的方法 public void saveUser(User user){ this.getHibernateTemplate().persist(user);//使用父类方法get到Template,并调用其persist方法将user存入 } } public int getCount(){ //查询记录条数 Number num = (Number)this.getSession(true).createQuery(&quot;select count (*) from User).uniqueResult(); return n.intValue(); } public List&lt;User&gt; findUsers(){ //查询所有的user return this.getHibernateTemplate().find(&quot;select * from User&quot;); } public User findUserByName(String name){ //根据用户名查询用户 List&lt;User&gt; users = this.getHibernateTemplate().find{&quot;select * from User u where u.name=?&quot;, name); //使用Template if(users.size() &gt; 0) return users.get(0);返回第一条 return null; } } 从上述代码例子中可以看出： 查询(Read)、创建(Create)都由父类HibernateDaoSupport提供的getHibernateTemplate方法获取到实例并执行实例的方法来实现，其中查询使用实例方法find(String sql, Stirng 拼接String），而save则用持久化方法persist(Object user); 当要涉及到数据库计算时，则用getSession获取到与数据库的会话对象，让会话对象执行sql统计语句； 同时，所有sql语言的操作对象都指向实体类，而没有对数据库中的表进行组织sql语句； 个人理解：spring通过封装Hibernate在框架中，让DAO接口的实现类继承HibernateDaoSupport尖，就将Hibernate对象创建出来，而直接操作这个对象的方法来获取session/Hibernate对象直接与数据库交互，而就节省了操作JDBC的代码； 配置集成Hibernate 在spring的bean.xml文件中配置集成hibernate到目前这一步只需要配置三个bean： 数据源datasource，这是一切的基础，所有的操作最终都会落到对数据库的操作上；&lt;bean id=&quot;datasource&quot; class=&quot;org.apache.commonsdbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; class=&quot;org.gjt.mm.mysql.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc\\:mysql\\://localhost\\:3306/ssh&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;propery name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; - 数据源的配置就是用依赖包中的一个封装好的类（这儿就是BasicDataSource）的对象，并将这个对象的属性值配置好，这些属性就包括了数据库的驱动、连接的url、连接数据库的用户名、密码。可以想象的是，这个处理数据库的对象封装了所有的连接数据库的方法，使用密码与用户名，交给驱动对象，这个驱动对象就按照提供的url连接到主机上的数据库，并登录到数据库； 有了数据源，就可以将关联连接库的数据源配置到sessionFactory中去：&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.annotation.AnnotationSessionFactoryBean&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;dataSource&quot;&gt; &lt;ref bean=&quot;dataSource&quot;/&gt; &lt;property/&gt; &lt;property name=&quot;annotatedClasses&quot;&gt; &lt;list&gt; &lt;value&gt;com.woniuxy.orm.class_qulified_name&lt;/value&gt; &lt;/list&gt; &lt;property/&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;pros&gt; &lt;pro key=&quot;hibernate.dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/pro&gt; &lt;pro key=&quot;hibernate.show_sql&quot;&gt;true&lt;/pro&gt; &lt;pro key=&quot;hibernate.format_sql&quot;&gt;true&lt;/pro&gt; &lt;pro key=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/pro&gt; &lt;/pros&gt; &lt;/property&gt; &lt;/bean&gt; 配置会话工厂（因为我们的实体类使用的注解映射，所以就使用注解会话工厂AnnotationSessionFatoryBean)其中包括了：数据源、实体类还有hibernate,而hibernate的配置就包括了方言、输出sql语句、格式化sql语句、创建表结构 有了会话工厂，距离操作数据库就只有让Dao配置为bean，而操作代码就getBean来获取到这个Dao的实例，让这个实例来操作数据库：&lt;bean id=&quot;userDao&quot; class=&quot;daoImpl_qualified_name&quot;&gt; &lt;property name=&quot;sessionfactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; 在Dao的bean中，将前面配置好的sessionFactory装配到其中 以上情况是实体类User是使用注解来配置的，这种情况下，使用的sessionFactory是AnnotationSessionFactoryBean,但当实体类是使用xml文件来配置时，使用的配置bean应该是LocalSessionFactoryBean。同时，sessionFactory中配置实体的方式也变成：&lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:entiteis_配置文件的路径&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; Hibernate的事务管理 分层的做法：应用层调用Service层，Service层对数据进行检查（是否重复之类），然后Service层（注入一个Dao属性）调用Dao层，Dao层调用Hibernate实现数据的操作。原则上不允许跨层访问，业务层次分明。 事务管理transaction，对应的层为Service层； spring的bean.xml配置文件的理解 所有的操作都基于对数据库的crud，所以所有的配置都围绕着操作数据库； 所以，第一个bean的是数据源：dataSource 其中的属性就包括： 连接数据库的驱动：driverClassName 数据库连接url:url 数据库连接用户名：username 数据库连接密码：password 通常情况下，我们把数据源信息都单独分离在jdbc.properties文件中，并在要用到的配置文件中将其配置为上下文&lt;context:property-placeholder&gt; location=&quot;classpath:jdbc.properties/&gt;，之后就可以在数据源dataSource中配置其中的属性：&lt;property name=&quot;driverClass&quot; value=&quot;${driver}&quot;&gt;&lt;/property&gt; 第二个配置的bean：sessionFactory 这儿就把上一次配置好的dataSource数据源装配到sessionFactory的属性中：&lt;!-- 配置本地会话工厂bean --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 指定hibernate配置文件--&gt; &lt;property name=&quot;configLocations&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt; &lt;!-- 指定hibernate映射文件--&gt; &lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:mappings/*.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; Note:这儿配置spring的sessionFactory属性就会把Hibernatek r sessionFactory属性覆盖； configLocations属性：将指定路径的配置文件都加载进去，相应的LocalSessionFactoryBean中的的此属性的setter方法的参数为可变参数:public void setConfigLocations(Resource... configLocations) { this.configLocations = configLocations; } 而在上述代码中，hibernate的配置文件也直接引入到sessionFatory中来，而在外部的hibernate配置文件： &lt;session-factory&gt; &lt;!-- 配置方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- session上下文控制权:交给session来控制 --&gt; &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;org.springframework.orm.hibernate5.SpringSessionContext&lt;/property&gt; &lt;!-- 格式化sql语句 --&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 显示sql语句 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 表的生成策略 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;/session-factory&gt; 其中配置了部分的Hibernate属性，同时也可以配置c3p0的属性在其中； 第三个配置：事务管理器transactionManager 将前面配置好的sessionFactory装配到这个bean中，作为sessionFactory属性值； 第四个配置：tx:advice，配置事务的传播特性，指定具备事务的方法名； &lt;!-- 事务配置增强 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txMng&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;batch*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;load*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;!-- 统配 --&gt; &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 最后一行统配就指定了所有的方法都配置上事务，同时isolation指此事务的隔离级别，propagation指事务的传播属性，read-only指是否为只读； 第五个配置aop:config，配置事务的切入点，以及被管理的对象&lt;aop:config&gt; &lt;aop:pointcut id=&quot;interceptorPointCuts&quot; expression=&quot;execution(* com.woniuxy.sshdemo.service.impl.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;interceptorPointCuts&quot;/&gt; &lt;/aop:config&gt; 先将切面的切点配置进来，也就是各个service的执行对象。再将这此切点配置到advisor中 其它的配置： dao的执行类，配置一个id加上sessionFactory; service的执行类,配置上dao这个属性的对象； 使用注解来实现事务的配置 这时bean.xml： 数据源不变 sessionFactory不变； 事务管理器trasactionManager依然不变； 变的是：添加一个事务注解驱动tx:annotation-driven trasaction-manager=&quot;transactionManager&quot;/&gt;，添加这个驱动配置后，对产生事务的类添加注解@Transactional，标记这个类为事务类，对其中的事务方法添加注解@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)注解（标明了这个方法的隔离水平与传播水平）。这样的注解就取代了上面例子中tx:advice与aop:config两个配置节点的功能；","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"framework","slug":"framework","permalink":"https://kangshanr.github.io/tags/framework/"}]},{"title":"java底层之引用","date":"2017-08-13T04:04:38.000Z","path":"2017/08/13/java_reference/","text":"直接引用与符号引用JVM运行类加载后， 在类的解析阶段，JVM会把类的二进制数据中的符号引用替换为直接引用。 符号引用：Symbolic References 以一组符号来描述 所引用的目标，而这个符号可以是任何形式的字面量，只要使用时可以无歧义定位到目标即可; 存在的原因：在编译阶段，java类并不知道所引用类的实际地址，只能使用符号来表示类的地址。而且在不同JVM实现的内存地址也不尽相同，经过符号引用这一道工序，同一个类，其符号引用必然一致； 类在解析过程中，就根据JVM实时产生的内存分配状况，将符号引用转为直接引用； 直接引用：Direct References- 直接引用是和虚拟机的布局直接相关的，同一个符号引用在不同的JVM上翻译出来的直接引用也不尽相同。某个目标有了直接引用，那说明这个目标已经被加载到内存中了 直接引用可以是： 直接指向目标的指针（如，指向类型class对象、类变量、类方法的直接引用就是指向方法区的指针）； 相对偏移量：如指向实例变量、实例方法的直接引用都是偏移量； 一个能直接定位到目标的句柄； Note: 也就是说通过符号引用转换为直接引用来实现了引用的跨平台（对于同一个数据对象的引用都用同一个符号引用来实现，而在不同的平台上不同的JVM运行时转换成不同的直接引用）","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"java枚举","date":"2017-07-29T04:04:38.000Z","path":"2017/07/29/java_enum/","text":"java枚举简介： 枚举enum是在jdk1.5后引入的，是java高级特性之一； 枚举的定义关键字：enum public enum season{}，其与普通类一样拥有属性、方法、构造函数 枚举是特殊的类，其成员全都是固定下来的；枚举特性： 枚举的构造函数默认是私有的，可以自定义枚举私有的构造函数 所有枚举的公共基类为abstract Enum","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"原创小段子之人物没原型","date":"2017-07-25T17:04:38.000Z","path":"2017/07/26/原创小段子—人物没原型/","text":"暑假了，女儿欢欢喜喜大学归家。到了家门，嗲声嗲气叫：爹。。。娘。。。 爹娘笑嘻嘻看了女儿两眼后，转过头去：关于生活费，你能不能把买吃的和买穿的比例对调一下。。。","tags":[{"name":"tale","slug":"tale","permalink":"https://kangshanr.github.io/tags/tale/"}]},{"title":"Java多线程","date":"2017-07-14T04:04:38.000Z","path":"2017/07/14/java_multithread/","text":"线程安全 在一个运行程序中，当另外一个线程对这个程序发起请求时，相当于重新执行其中方法，但一个类中某些属性在程序执行过程中需要保持状态的统一性，这时就需要在一个线程执行完毕后再让另一个线程执行相关的方法。这就需要实现线程安全； 实现线程安全的方法： 将方法修辞为线程安全的方法（加上修辞符synchronized)：public synchronized void doPay(int money){ if(balance &gt;= money){ balance -= money; }else{ system.out.println(&quot;你的余额不足！”） ｝ system.out.println(&quot;你的余额为：“+balance); } 使用同步块：synchronized(Object object){ //要同步的代码块 ｝ 实现同步机制是基于”监视器“这一概念，java中所有对象都拥有自己的监视器，加上同步锁，就是让这个对象进入监视中； 在各个project中，对于各管理类使用单例模式时，常常容易忽略多线程做成伪单例。也就是做成单例只单单在单线程中可以实现，在多线程环境中实现不了单例。public class Manager{ private static Manager ins; //私有化构造函数 private Manager(){} //获取单例 public static Manager getIns(){ if(this.ins == null){ this.ins = new Manager(); } return this.ins; } } 这种单例的实现就必须在依赖单线程的运行环境； 但现实中往往是多线程环境，这时要实现单例就得双重校验锁：public class Manager{ private static Manager ins; private Object lock; //私有化构造函数 private Manager(){} //获取单例 public static Manager getIns(){ if(ins == null){ //第一次校验，当多个线程执行获取单例的方法时，先对单例是否为空进行判定，为空才进入同步状态 synchronized(lock){ if(this.ins == null){ //第二次校验，进入同步锁状态，对单例进行校验，为空的话才进行构造单例 this.ins = new Manager(); } } } return this.ins; } } 一定要理解到这儿使用的双重校验缺一不可：两次校验才能实现同步线程对多线程操作的效率： 如果单单全用一次校验在方法上，也就是所有访问到这个方法的线程就直接进入到同步锁状态，那么就会造成大多访问线程的滞留，后部都等到第一个线程执行方法完毕再依次进入到方法中执行，这样明显是不合理的； 如果在方法内部同步块之前只使用一次判定，就会造成多个线程同时执行这个获取单例方法时ins被判定为null，多个线程同同时等待同步块执行完，这样在第一个执行的线程构造单例后，虽然这时执行getIns()方法的线程不会进入到同步块等待了，但之前进入到同步块等待的线程还是会依次等待前面线程释放控制权后继续构造单例；所以才会在这同步块内再次校验ins是否为空，形成双重校验","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"项目开发模型","date":"2017-06-22T18:14:38.000Z","path":"2017/06/23/项目开发模型/","text":"瀑布模型：(政府银行类项目） 工程开发流程： 需求分析（提出一个idea）； 可行性分析（看目前条件下是否能实现这个idea）； 总体分析：通过可行性分析后，用哪些工具包进行开发； 详细设计：当前要用哪些工具，详细的模板功能，甚至每个功能实现变量方法的名称都定下来； 垒代码：完成模板； 测试:（分系统测试，单元测试，看划分力度），带着测试去编程，bug更，性能更佳； 上线： 迭代螺旋模型：（阴阳师） 开发流程： 先出来一个粗糙模型原型，马上上线，抢占市场； 马上一次迭代，小步快跑，每一周就可以迭代一次，不停地壮大； 不同开发模型中就是使用以上的流程不同方式（周期，频次）,除了瀑布模型与螺旋模型，常用的项目开发模型还有： 迭代模型 增量模型（钱产够的情况下，先将能上线赚钱的模块开发出来上线，后续根据需求来增加不同的项目模块）","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"XML的认识","date":"2017-06-13T07:02:43.000Z","path":"2017/06/13/xml/","text":"XML概述 XML：eXtensible Markup Language,可扩展标记语言：被设计用来传输和储存数据。HTML： Hyper Text Markup Language超文本标记语言。 XML与HTML两种语言的区别： HTML是被设计用来显示数据，XML被设计用来存储传输数据； HTML的焦点是数据的外观，而XML的焦点在于数据的内容； XML不是对HTML的替代，它们之间形式类似，但功能在本质上有区别； &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;note&gt; &lt;to&gt;Ross&lt;/to&gt; &lt;from&gt;Jack&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget me.&lt;/body&gt; &lt;/note&gt; 这就是一个简单的XML文件，它不会做任何事情，只是把数据定义好； ps:在编程语言中，看到缩写为ML的首先想到是Markup Language标记语言 XML是W3C推荐标准： WWW:World Wide Web万维网 W3C： world wide web consortium万维网联盟 XML的特点： 标签可自定义，比如上面的这些标签都是创建者自己写的 对XML最好的描述是：独立于软件与硬件的独立传输工具； XML无处不在，不亚于HTML对于web的意义； XML以纯文本格式存储 XML有很强的自我描述性 XML的树形结构： 像HTML标记语言一样，其结构明确，子元素包含于父元素中 XML必须有根元素 XML的声明如果有必须放在第一行 上面例子 就声明了XML的版本与编码字符集为UTF-8，SQL,JS,HTML5，PHP的默认编码都是UTF-8 所有的XML标签必须有一个关闭标签(声明不算是内容），这一点与HTML不同，HTML中有部分标签不用关闭标签eg： XML对大小写敏感 嵌套要正确，当一个标签在另一个标签中打开，那么它的关闭也必须在这一个标签中 XML的属性值必须加引号&lt;note date=&quot;2011.10.5&quot;&gt; &lt;to&gt;Jack&lt;/to&gt; &lt;from&gt;Ross&lt;/form&gt; &lt;content&gt;Thanks&lt;/content&gt; &lt;/note&gt; 语法： 所有xml元素必须有一个关闭标签 xml标签对大小写敏感； XML标签必须嵌套：成对出现 &lt;user&gt; &lt;id value=&quot;1&quot;/&gt; &lt;username&gt;kfc&lt;/username&gt; &lt;/user&gt; xml文档必须有根元素 xml属性值必须加引号 从上面的xml中，我们可以看到根元素是user，其中又有两个子元素：id/username；而id这个元素有一个属性value这个属性值为“1”，而另外一个子元素username有内容“kfc”； ##xml文档的生成与解析方式:## 共4种方式： DOM生成和解析xml文档； 解析器将读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以使用DOM接口来操作这个树结构； 因为DOM是基于信息层次的，所以DOM被认为是基于树或基于对象的，而树在内存中是持久的，因此可以通过修改树来实现应用程序对数据和结构作出更改；也因为持久性的原因，DOM使用起来也要简单地得多； 因此，其优点就在于整个文档在内存（包括无用的节点）便于操作；支持删除、修改、重新排列等多种功能；其缺点就在于是整个文档在内存中浪费时间与空间； 使用场合：一里弄解析了文档还需多次访问这些数据；硬件资源充足（内存、cpu）； SAX生成和解析xml文档； 基于事件驱动解析，当解析器发现元素开始、元素结束、文本、文档的开始或结束等时，发送事件，响应事件的代码由程序员来编写，保存数据之类的； 采用基于事件的模型，对于大型文档的解析比起DOM要更快且对内存的要求也更低； 优点，不用事先地调入整个文档，占用资源少，加载负荷更小，加载的速度也更快。解析代码比DOM解析器代码少，适于Applet、下载； 缺点，不是持久的，事件过后，若没有保存数据，那么数据就丢失，无状态性。从事件中只能得到文本，但不知道文本属于哪个元素； 使用场合：Applet；只需xml文档的少量内容，很少回头访问，机器内存少； JDOM生成和解析xml文档； 设计目的是java特定文档模型，20-80原则（使用20%的精力解决80%的java、xml问题），解决DOM、SAX的编码量； 本身不包含解析器，使用SAX2解析器来解析和验证输入XML文档； 使用场合：实现功能简单，如解析、创建等； DOM4J生成和解析xml文档； 性能优异，功能强大，易用； 也是一个开源的软件，Sun的JaxM也在用DOM4J，Hiberbate也使用Dom4j读取xml文件; 总结： xml文件解析之后，成为一个document对象； DOM4J性能最好，应用也更广泛； JDOM和DOM在性能测试时表现不佳，在测试10M文档时内存溢出，在小文档情况下使用他们更好。但同时，DOM的跨语言解析要强一些，也正因为如此获得W3C的推荐； SAX基于其事件驱动的解析方式，其在检测即将到来的xml流但并不载入内存中，让它在小文档解析中有一定的优势。 xml声明部分 声明部分是xml文件的可选部分，如果存在就一定放在文档的第一行； 其内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 声明了xml的版本，与encoding格式，同时UTF-8 也是 HTML5, CSS, JavaScript, PHP, 和 SQL 的默认编码。 实体引用 在 XML 中，一些字符拥有特殊的意义。 如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。 这样会产生 XML 错误： &lt;message&gt;if salary &lt; 1000 then&lt;/message&gt; 为了避免这个错误，请用实体引用来代替 “&lt;” 字符： &lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt; 在 XML 中，有 5 个预定义的实体引用： &amp;lt; &lt; less than &amp;gt; &gt; greater than &amp;amp; &amp; ampersand &amp;apos; &apos; apostrophe &amp;quot; &quot; quotation mark 注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。参考博客 xml的可扩展性 任何一个xml的标签都可以无限扩展开，比如在中，有一个元素为,我们可以将年月日按一定格式存储进去 &lt;bean&gt; &lt;date&gt;2017_7_30&lt;/date&gt; &lt;/bean&gt; 利用元素的可扩展性就可以让我们这们来写： &lt;bean&gt; &lt;date&gt; &lt;year&gt;2017&lt;/year&gt; &lt;month&gt;7&lt;/month&gt; &lt;date&gt;30&lt;/date&gt; &lt;/date&gt; &lt;/bean&gt; 这样我们的数据的扩展性变得更大哥；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"leadingEnd","slug":"leadingEnd","permalink":"https://kangshanr.github.io/tags/leadingEnd/"}]},{"title":"设计模式之代理模式","date":"2017-06-13T04:14:12.000Z","path":"2017/06/13/proxy_pattern/","text":"设计模式之代理模式简介： 代理(Proxy)提供了对目标对象另外的访问方式;即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. 这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 下面就来简单介绍下代理模式的三种方式： 静态代理 可以让代理类同时实现真正想的对象的类实现的接口，而在代理类中有一个真正类的属性，当想要这个真正类时，对上述属性判空，再实例化，这样通过代理类执行接口中的方法时就是执行的真正想要的类的方法了； 简单地讲，代理就是将其他的类的各种实现方法，交由代理来实现。而要达到这种效果，就可以让代理与其他的类实现同一个接口，再在代理中实现接口方法中去实现这个类的方法。这也是代理的核心，一般代理中要注入一个代理对象，调用代理方法时，就对此对象初始化并调用其相关的方法； 定义接口：public interface Draw { void draw(String name); } 实现类：public class RealDraw implements Draw { @Override public void draw(String name) { System.out.println(name+&quot;.RealDraw...........&quot;); } } 代理：public class ProxyDraw implements Draw { RealDraw realDraw; public ProxyDraw (RealDraw draw){ this.realDraw = draw; } @Override public void draw(String name) { realDraw.draw(name); } } 测试：public static void main(String[] args) { RealDraw realDraw = new RealDraw(); ProxyDraw proxyDraw = new ProxyDraw(realDraw); proxyDraw.draw(&quot;test&quot;); } 测试结果：test.RealDraw........... 静态代理的总结： 做到了代理的基本功能，不对所代理对象的更改实现对象的功能，也可以在代理中对功能进行扩展； 局限在于：代理与被代理都得继承接口，耦合过高，扩展不便； 也正因为有了静态代理的局限，所以才有下面的动态代理： 动态代理 动态代理相对于静态代理的优势： 代理不用继承接口，代理由java内置的java.lang.reflect包中的Proxy类生成： 其中生成代理静态的方法：static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)； 此方法的三个参数： loader：代理目标的类加载器； interfaces：代理目标实现的接口； handler：执行处理器，指调用此代理实现接口的处理器，此处理器必须实现InvocationHandler接口，并实现其public Object invoke(Object proxy, Method method, Object[] args)方法; 具体实现： 接口：public interface Draw { void draw(String name); } 被代理的类：public class RealDraw implements Draw { @Override public void draw(String name) { System.out.println(&quot;RealDraw.draw&quot;+name); } } 代理（使用了匿名内部类）：public class ProxyDraw { Object target; public ProxyDraw(Object target){ this.target = target; } /* * 获取代理实例，动态代理实现的核心 * @see designpatrern.dynamicproxy.Draw#draw(java.lang.String) */ public Object getProxyIns() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;Porxy_start&quot;); Object returnValue = method.invoke(target, args); System.out.println(&quot;Porxy_end&quot;); return returnValue; } }); } } 测试：public static void main(String[] args) { //动态代理的实现 Draw realDraw = new RealDraw(); Draw proxyDraw = (Draw)new ProxyDraw(realDraw).getProxyIns(); proxyDraw.draw(&quot;....test.end&quot;); } 测试结果：Porxy_start RealDraw.draw....testend Porxy_end 上面代理的实现中，new一个代理实例的handler参数使用了匿名内部类，具体参照匿名内部类。 匿名内部类所做的是创建了一个InvocationHandler接口的实例，这个实例的invoke()方法是用代理目标作为对象（将代理方法分发到这个代理对象上去）； Proxy.newProxyInstance()方法中指定了目标类的类加载器，目标执行的接口，方法调用时所用的方法调用处理器； cglib代理 /子类代理 此类型代理需要用到spring核心包推荐使用spring-core 3.2.5版本及以上； 动态代理与静态代理都是向上抽取依赖，要求实现接口，而cglib代理则是通过目标对象子类来实现对目标对象功能的扩展； 其实现方法： 引入的功能包能够动态地在内在中构造子类； cglib的强大在于高效生成代码，在运行期扩展java类与接口，spring赖以生存的AOP拦截的就是大量地使用了cglib的强大功能； cglib的底层：使用字节码处理框架ASM转换字节码并生成新的类（并没有弄的懂的地方，涉及JVM中内部结构，诸如：class文件的格式秘指令集） 注意：cglib的实现是依赖于代理的扩展子类，需要对代理目标进行扩展 也就是说代理类不能为final修辞； 同时，目标对象的方法不能为final/static所修辞； 实现例子： 目标类：public class Target { public void targetMethod(){ System.out.println(&quot;cglib.RealDraw.draw............&quot;); } } 代理工厂类：public class ProxyFactory implements MethodInterceptor{ private Object target; //构造函数中将目标确定 public ProxyFactory(Object obj){ this.target = obj; } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(&quot;开始事务拦截。。。。。。。。&quot;); Object result = method.invoke(target, args); System.out.println(&quot;结束事务拦截。。。。。。。。&quot;); return result ; } /** * 获取代理的方法 * @return */ Object getProxyIns(){ //增强工具对象 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数（本实例） en.setCallback(this); //创建子类 return en.create(); } } 测试：public static void main(String[] args) { target.targetMethod(); target = (Target)new ProxyFactory(target).getProxyIns(); target.targetMethod(); } 测试结果：开始事务拦截。。。。。。。。 cglib.RealDraw.draw............ 结束事务拦截。。。。。。。。 实现动态代理:新建一个Target2类，并测试将Target2实例传入代理工厂对象： 目标类Target2： public class Target2 {void targetMethod(){ System.out.println(&quot;Target2.target2Method...........&quot;); } } 测试：public static void main(String[] args) { Target target = new Target(); Target2 target2 = new Target2(); target2 = (Target2)new ProxyFactory(target2).getProxyIns(); target2.targetMethod(); } 测试结果：开始事务拦截。。。。。。。。 Target2.target2Method........... 结束事务拦截。。。。。。。。 note: 静态代理所涉及到的知识点相对更容易理解； 动态代理与子类代理都用到了类反射中的Method方法，其核心是利用类反射来实现将扩展的方法体加在指定目标的方法的前后； 在Spring的AOP编程中: 如果加入容器的目标对象有实现接口,用JDK代理 如果目标对象没有实现接口,用Cglib代理 参考博客：岑宇-java的三种代理模式","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"控制台操作数据库","date":"2017-05-23T04:54:30.000Z","path":"2017/05/23/控制台数据库操作/","text":"mysql数据库控制台操作今天在使用控制台操作mysql数据库过程中，摸索了下之前没怎么搞懂的地方，现拉出一个清单方便以后理解(现使用的mysql数据库，其他的数据库一样使用）： 当安装了mysql之后，配置了环境变量之后，就可以在控制台输入命令来实现启动相关的程序。不管在Linux系统中还是在Windows系统下，输入mysql命令就意味着启动mysql数据库； 本机上设置了root用户的密码时，直接启动mysql命令会被拒绝访问，这时需要使用命令mysql -u root -p;，表示登录用户root，接下来会提示输入密码，后再进入到到该root用户中，这时才能访问数据库，输入查询语句进行查询； Navicat只是一个数据库的可视化IDE，平常使用它能很方便地操作查看数据库，但在控制台中操作数据库能让操作者深刻地理解数据库； 数据库查询语言在控制台输入时一定记得在句末加上；，否则执行语句时会被认为没有结束的语句； 安装完成Navicat后可以看到很多默认的数据库已经在其中了，这些是mysql必须的数据库，其中mysql数据库中存储了本机上数据库的诸多信息，包括user表的host信息，要进行这些信息的修改，同样使用use mysql进入到该数据库，对其中的信息进行修改；","tags":[{"name":"database","slug":"database","permalink":"https://kangshanr.github.io/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://kangshanr.github.io/tags/mysql/"}]},{"title":"设计原则","date":"2017-05-13T04:32:48.000Z","path":"2017/05/13/design_principle/","text":"设计模式的六大原则简称“六大设计原则”，用于整个面向对象编程过程中设计各种模式甚至到各个接口与类的设计都需要参考的原则。这些原则的宗旨是尽量减少程序的耦合性，让程序的可扩展性更高，在接触越多的编程后，越会感受到这些原则的重要性； 开闭原则(Open Close Principle)： 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 这也是我们在设计程序过程中，尽量使用功能功能明确单一的接口，尽量把类抽象成基类，让派生类继承其公共的属性与方法的目的。 与依赖倒置原则相呼应。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。 里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。也就是在设计各类程序块时，用父类、接口来接收实现的对象，这也是java多态实现基础； 依赖倒置原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体，一个具体的优势就是减少代码的重写，甚至可以减少方法的重载。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"面向对象","slug":"面向对象","permalink":"https://kangshanr.github.io/tags/面向对象/"},{"name":"设计原则","slug":"设计原则","permalink":"https://kangshanr.github.io/tags/设计原则/"}]},{"title":"CSS常用选择器","date":"2017-05-13T04:14:12.000Z","path":"2017/05/13/CSS_Chooser/","text":"CSS_chooser CSS中常用的选择器有点： id选择器,选择指定唯一标识id属性的元素 类选择器，选择同一类属性的元素 属性选择器，选择同一属性值的元素 元素选择器，直接选择指定文档元素 派生选择器，依赖上下文来应用或避免某种规则","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"leadingEnd","slug":"leadingEnd","permalink":"https://kangshanr.github.io/tags/leadingEnd/"},{"name":"CSS","slug":"CSS","permalink":"https://kangshanr.github.io/tags/CSS/"}]},{"title":"HTTP协议的理解与认识","date":"2017-05-06T01:54:30.000Z","path":"2017/05/06/HTTP_protocol/","text":"#HTTP协议# 概念： http：hyper text transfer protocol，超文本传协议，其设计之初的目的只是提供一种接收和发布html页面的方法； 用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。所谓无状态协议，是指这一次客户端的请求与上一次的请求无关。 Http协议的主要特点： 支持客户端/服务器模式（cs模式）； 简单快速：客户端向服务器发送请求服务时，只需传送请求方法与路径。常用的请求方法：GET、POST、HEAD、PUT、DELETE等； HTTP协议简单，这也便利HTTP服务器的程序规模小，通信速度快； 灵活，HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记； 无连接，限制每次连接只处理一个服务器处理完客户的请求，并收到客户的应答后，即断开连接。这样也更节省时间； 无状态：对于事务的处理没有记忆能力，这也意味着如果后续处理需要前面的信息，它必须重传 明文传输，不支持加密处理，所以在安全性方面是硬伤。目前解决这一安全问题的方法是使用HTTPS协议； http的post和get方法性能上的区别： get是从服务器上获取数据，post是向服务器传送数据。 get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 因此建议： get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式； 在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式； web交互过程 简单地讲，浏览器与服务器交互过程就是由请求与响应组成，而这个请求的发送与响应的接收就是使用HTTP协议来时行； 当请求被发送出去后： 如果请求的是一个静态的HTML页面，服务器不做任何处理，直接将该页面文件从服务器端的硬盘中读取到内存交将其响应给客户端，交由浏览器来解析和处理HTML与JS； 如果请求的是一个web交互过程（ASP、JSP、PHP），则该类脚本将由服务器的脚本处理引擎解析处理完成后将其转换成标准的HTML页面再响应给客户端的浏览器来处理。 当我们访问一个网页时：如：http://www.baidu.com 这个网址包含四个部分的内容： 协议类型：http，如果访问的是一个FTP网站，则url前缀应该是ftp； 主机名：这里的www.baidu.com，也可以是ip地址，两者是等价的，但我们对于IP地址往往不容易记住，就像身份证之于我们本人一样，所以常用域名来表示；这个例子中的顶级域名是：baidu.com，而www只是子域名，其下面还有tieba.baidu.com等都是子域名； 端口号，端口号之于url就像房间号之于大楼，我们寄一封信给某人，在指定域名后，再指定端口就是指定大楼后再加上门牌号。指定主机名后，请求就行到达这个网卡，但一个网卡上可以指定0~65535(2的16次方）个端口，一个端口对就是个服务； 端口的管理是由TCP/IP协议决定的，在0~1024这一批端口是由知名的服务占用，比如：系统中觉的服务； 常用的端口： HTTP协议：80 FTP协议：21 SSH协议：22 MySql数据库：3306 SQLServer数据库：1433 Oracle数据库：1521 这也是我们常常访问某个网址并没有输入端口号的原因，我们使用了默认的端口号来建立健全连接； 页面文件，我们在访问百度首页时，并没有指定页面文件而我们得到了一个页面，原因在于在这个文件夹下我们指定了一个默认的页面，诸如：index.html/index.php/default.asp之类的文件。在web系统中，/表示根目录，再往下一层也使用/来分隔； 我们最终都是请求这类型的页面文件，最终我们在浏览器上看到的都是此类的文件，只不过我们常常请求的动态页面是由服务器来生成的，最终交给浏览器来显示； 附加部分（URL地址参数）： 一个标准的URL地址是前四部分，如果我们请求页面显示404，说明这个URL在服务器上不存在或没有生成访页面或者路径有误(总的来说，就是url前四部分有误，只要有误就是404）。但我们在确保前四部分无误的情况下，要以自定义第五部分，附加的参数，这一部分有误不会影响页面的请求（最典型的sql注入就是通过url地址） 使用？连接前四部分，参数之间使用&amp;分隔：http://china.huanqiu.com/article/2017-09/11232393.html?from=bdwz OSI模型 概念：Open System Interconnect，开放式系统互联 这个模型把网络通信的工作分为7层： 由低到高：物理层（Physical Layer），设备：中继器，集线器，单位：比特（bit） 数据链路层（Data Link Layer)，设备：二层交换机、网桥，单位：帧（frame) 网络层（Network Layer)，设备：路由器，单位：数据包（packet)，相关：ip地址、数据包、路由协议、ARP（地址解析协议） 传输层（Transport Layer)，提供端到端的透明数据传输服务，单位：数据包（packets) 会话层（Session Layer)，建立访问验证会话管理在内的建立维护应用之间通信的机制 表示层（Presentation Layer)，格式化的表示和转换数据服务，数据的压缩与解压，加密与解密 应用层（Application Layer)，操作系统或网络应用程序提供访问网络服务的接口，此层协议就包括了：Http,FTP,SNMP,Telnet 低三层负责创建通信连接的链路，高四层负责端到端的数据通信； 网络通信在发送端自上而下，在接收端自下而上依层进行；但也不一定要经过全七层，比如：中继器之间的连接只需要在物理层中进行，而路由器之间的连接只需通过下三层； 但双方端端之间的通信必须是对等的，不可能存在不对等层次间的通信（也就是在发送端通过了哪些层，在接收端也要反序通过这些层）； TCP/IP模型 OSI系统只是提供了网络通信的模型，实际应用中，我们使用的最成熟最广的互联协议是TCP/IP模型基础上建立的，它相对于OSI模型更为精简；TCP：传输控制协议（Transport Control Protocol)IP：Internet Protocol，网络协议UDP：User Datagram Protocol,用户数据包协议 分为四层： 网络访问层：对应OSI的物理层+数据链路层 Internet层：对应OSI网络层 传输层：对应OSI的传输层 应用层：对应OSI的会话层、表示层、应用层 TCP的三次握手 TCP的三次握手是为了保证数据通信时安全性，确保请求方与响应方是正确对应的。 通俗用一个发送机密文件的例子来理解： 发送方为确保机密，先将文件上锁寄给接收方，接收方收到文件后再上一把自己的锁并将这个上过两次锁的文件再寄给发送方，发送方收到后将自己的锁解掉，再寄给接收方，这时接收方就可以收到只有自己的锁的文件了； 那么在TCP协议中，这个三次握手过程是怎么实现的？ 第一次握手：请求方先发送位码：syn=1,随机产生seq number=200的数据包到响应方（服务器），这时接收方由syn=1得知发送方要求实现同步联机； 第二次握手：响应方收到请求联机后，要确认此信息，便向发送方发送ack number=(seq+1),syn=1,ack=1,再随机产生seq number=500的包； 第三次握手：发送方收到来自接收方的数据包，检查接收到的数据中ack number是不是与自己刚才发送的随机码(seq nubmer+1)相等，以及位码ack是不是为1，如果两项无误证明是自己需要的对方，便再发送ack number=(刚收到来自响应方的seq number+1)，ack=1，响应方确认seq number值无误与ack=1，便可以确认连接建立成功，三次握手完成。 Note: 每一次握手只要需要对就方响应就会随机生成一个序列码：seq number,对方收到响应时便在这个序列码基础上进行加1，当作响应码ack number再返给原来请求方，这样一个过程来确保连接双方无误； 同时，第一次发起请求同步有一个syn=1码，这是一个请求同步，发起请求的码； 每次响应，不管是请求方在握手过程中响应响应方还是响应方响应请求，都会有一个ack=1码，来确认自己是在应答对方； TCP的四次挥手 TCP的四次挥手是指双方要关闭连接， 这时出现的情况可能是双方任一方发起close请求也可能是双方同时发起； 当其中一方发起关闭请求时： 第一次挥手：请求方发起一个fin用来关闭请求方给响应方的数据传送，这时请求方进入到fin_wait状态，同时肯定还是要发送随机生成的请求序号； 第二次挥手：响应方收到fin后，发送一个ACK给请求方，同时发送确认序号（为收到的请求序号+1），这个时候响应方进入到CLOSE_WAIT状态，同时要发送随机序号seq； 第三次挥手：响应方发送一个FIN，用来关闭响应方到请求方的数据传送，这时响应方进入到LAST_ACK状态，同时要发送随机序号seq； 第四次挥手：请求方收到FIN后，进入到TIME_CLOSE状态，再发送一个ACK给响应方，同时发送确认序号（在随机序号上+1），响应方收到这些信息确认无误，进行到CLOSED状态；完成四次挥手； 当双方同时发起关闭请求时： 前两次挥手：双方发送FIN=1码，与随机码； 后两次挥手：双方收到后，再给彼此发送ACK=1和ack number=（随机码+1）； Note: FIN码发送后，相应的方应该进入到WAIT状态或CLOSE状态； ACK响应码用来指示自己需要得到回复； 还是与握手一样，用来确认双方信息连接的无误都通过随机序码指定的运算；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"HTTP","slug":"HTTP","permalink":"https://kangshanr.github.io/tags/HTTP/"},{"name":"协议","slug":"协议","permalink":"https://kangshanr.github.io/tags/协议/"}]},{"title":"java内部类","date":"2017-04-29T05:04:38.000Z","path":"2017/04/29/java_inner_class/","text":"java内部类 java的内部类指定义在类之中的类，这个类中的范围可以是是类成员也可以在局部方法中，还可以是作用域中； 内部类只是在编译时的概念，在本质上，当经过编译后，外部类会生成outer.class文件，而其中的内部类会生成outer$inner.class类文件，也就是就算定义成内部类，其本质依然是个类； 那么内部类有什么存在的必要呢？ 内部类是外部类的内容，在内部类之外加上一层外部类，就意味着： 内部类可为public、default之外的访问修辞符所修辞，这一点能很大程度上区别开外部类； 有了以上一点，那在类中定义内部类就会在很多时候有用了，比如：静态内部类的单例模式中，将单例通过静态内部私有类的方法来获取，这样利用外部其它的类不能访问这个私有的内部类而达到控制内部类的初始化类加载，这样只有在这个相关外部类中调用时才会调用到内部类，在这样一个单例模式中就实现了单例的懒加载； 在迭代器模式中，在迭代器容器中创建了个内部类：- 容器实现类： public class Repository implements Container { String elements[] = {&quot;kfc&quot;,&quot;jfk&quot;,&quot;mcd&quot;}; /** * 返回内部类的对象，注意这儿的依赖倒置 */ @Override public Iterator getIterator() { return new DoIterator(); } /** * 内部类，实现迭代器接口 * @author Administrator * */ public class DoIterator implements Iterator{ int index; /** * 判定索引是否指向在集合之中，如果还在就返加true */ @Override public boolean hasNext() { if(index &lt; elements.length) return true; return false; } /** * 实现迭代器核心算法，如果后面还有元素就返回这个元素，最后的结果就是index会与集合的长度相等，索引指向最后的一个的后面 */ @Override public Object next() { if(this.hasNext()){ Object obj = elements[index++]; return obj; } return null; } } - 最后在外部其他的类中来构造一个此内部类： - 先引入此内部类的包：`import designpatrern.iteratorpattern.Repository.DoIterator;` - 先构造一个外部类的对象：` Repository rep = new Repository();` - 再来构造内部类对象：`DoIterator ite2 = rep.new DoIterator();` 当这个内部类的修辞符为private时，这时在其他非相关的外部类中就不能导入此类，更名别说构造对象了； 匿名内部类： 这种情况多数用于一个抽象的类或者接口想要生成一个对象，这时不得不用一个子类来实现其抽象方法或新产品才能实现，但如果这个子类只用一次的话，专门创建一个子类来装载时会造成系统资源的浪费，那么这时使用匿名内部类会更合理： 接口定义 public interface Draw {void draw(String name); } 这时我们只想实现一次特殊的draw()方法，而且只用得到一次，如果创建一个类实现这个接口（或者抽象父类），就会造成系统资源的浪费，所以就使用匿名内部类实现： main方法中测试：public static void main(String[] args) { Draw draw = new Draw(){ @Override public void draw(String name) { System.out.println(&quot;Draw.Draw....&quot;+name); } }; draw.draw(&quot;test&quot;); } 测试结果：Draw.Draw....test 其中先用接口new一个对象出来，再在这个对象中创建一个匿名的内部类并实现其draw()方法，因为是匿名的类，所以只能看到其方法在对象体{}中。 同时要实现这个匿名内部类的效果，不一定要在接口中或抽象类的抽象方法中，普通类的普通方法也一样可以实现这样的重写方法，再一次调用：//实现类的匿名内部类，这个类不一定抽象类方法也不一定是抽象方法，一样都可以实现 ProxyDraw proxy = new ProxyDraw(draw){ @Override public void draw(String name){ System.out.println(&quot;anonymity&quot;+name); } }; proxy.draw(&quot;&quot;); 测试结果：anonymity 在动态代理模式中，匿名内部类会有很好的体现，共具体实现： 接口：public interface Draw { void draw(String name); } 被代理的类：public class RealDraw implements Draw { @Override public void draw(String name) { System.out.println(&quot;RealDraw.draw&quot;+name); } } 代理（使用了匿名内部类）：public class ProxyDraw { Object target; public ProxyDraw(Object target){ this.target = target; } /* * 获取代理实例 * @see designpatrern.dynamicproxy.Draw#draw(java.lang.String) */ public Object getProxyIns() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;Porxy_start&quot;); Object returnValue = method.invoke(target, args); System.out.println(&quot;Porxy_end&quot;); return returnValue; } }); } } 测试：public static void main(String[] args) { //动态代理的实现 Draw realDraw = new RealDraw(); Draw proxyDraw = (Draw)new ProxyDraw(realDraw).getProxyIns(); proxyDraw.draw(&quot;....test.end&quot;); } 测试结果：Porxy_start RealDraw.draw....testend Porxy_end 上面代理的实现中，new一个代理实例的handler参数使用了匿名内部类，如果不使用匿名内部类，其实现过程： 将代理中匿名内部类的实现提取出来：public class InvokeHandler implements InvocationHandler { //在构造函数中就注入要调用方法的对象 Object obj; public InvokeHandler(Object obj){ this.obj = obj; } /* * 实现InvocationHandler接口（其中只有一个invoke方法） */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;invoke.start....&quot;); Object resultValue = method.invoke(obj, args); System.out.println(&quot;invoke.end....&quot;); return resultValue; } } 而代理类中获取代理的方法就应该是：public Object getProxyIns2() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvokeHandler(this.target)); } 测试：public static void main(String[] args) { //动态代理的实现 Draw realDraw = new RealDraw(); Draw proxyDraw = (Draw)new ProxyDraw(realDraw).getProxyIns2(); proxyDraw.draw(&quot;....test.end&quot;); } 测试结果：invoke.start.... RealDraw.draw....test.end invoke.end....","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"项目开发流程","date":"2017-04-28T20:33:30.000Z","path":"2017/04/29/项目开发流程（详细）/","text":"整个流程包括： 需求挖掘（核心就是用户痛点）： 作为一个商业项目的程序员，一定要搞明白项目的赢利点在哪里； 要解决用户痛点； 用户分为：直接用户、最终用户 直接用户就是项目开发中，直接对接的用户，通俗的可以理解为给钱的； 最终用户是产品开发出来后使用产品的用户； 比如给一个公司开发的无纸化办公软件，这个产品的直接用户是这个公司的管理层，他们把项目交到我们手上来开发。但最终用户就是这个公司的各类普通职员，是他们在使用这个成型的产品； 在外包项目中，在需求挖掘的过程中往往涉及到： 用户访谈 需求探索 卖家会议 领导意见 而在这整个过程中，作为开发人员不能刻意引导对方，使用引导性对话往往会带出客户的伪需求，这就会需求分析带来干扰 需求分析：在作需求分析的对象只有两个：测试人员，普通使用者；这就决定了：写需求分析说明书时，措词要易懂清晰，少用专业词汇； 整个过程是开发人员、测试人员、客户各方不断讨论的过程 一旦有新的决定性需求确定下来，比如定稿时，一定要客户签字确认，各方责任要清晰； 当定稿之后客户要求修改需求，或修改需求成本太高，一定要出需求变更说明书，同样要求客户签字； 概要设计（数据库设计E-R图可同步进行） 比如一个简单的邮箱功能，其中的数据应该包括： 发件人名师 收件人列表 主题 内容 是否有附件 抄送人列表 详细设计 数据库设计（模型图） 用例图（PowerDesigner、Visio)：描述参与者与用例之间的关系，不能用crud之类的语言，比如：开发票与销毁发票，而不是用新建发票、删除发票；注意参与者可以是人但也可以是其他角色； 时序图（PowerDesigner)：操作到哪个对象，操作后返回什么对象 流程图（Visio)： 跨职能流程图中：每一个泳道代表一个职能； 菱形：判定，出来两根线，一个是，一个否； 矩形：流程 圆角矩形：开始或结束 平行四边形：输入数据 包图（Powerdesigner) 类图（Powerdesigner) 编码 测试","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"十六进制的认识","date":"2017-04-23T07:02:43.000Z","path":"2017/04/23/hex/","text":"十六进制 在数字前直接加0x就可以使用，所用字符： 0，1，2，3，4，5，6，7，8，9，a,b,c,d,e,f 两个byte的字符共占16位，因此我们看到unicode 码时，表示字符常用4位的十六进制数字来表现： eg:0xfa14 可直接用十六进制来表现整形数据，但我们在编程中习惯于用十进制，要使用十六进制时直接使用就是； 测试代码（java)：public static void main(String[] args) { System.out.println(0xeeda); System.out.println(0x0003); System.out.println(0xa); System.out.println(0xea); } 测试结果：978346 3 10 234 中文的unicode码的范围4e00-9fa5","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"ASCII编码","date":"2017-04-23T07:02:43.000Z","path":"2017/04/23/ASCII_code/","text":"ASCII码 （American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。 关键字符ASCII值： 0:46 0~9的ASCII码值就是48~57，习惯于在代码函数中用左闭右开的区间来表示：[48,58) eg:（Java language）//用于判断字符属于哪个类型的方法 static String typeChar(char _char){ int valueChar = Integer.valueOf(_char); if(valueChar &gt;= 48 &amp;&amp; valueChar &lt; 58) return &quot;number&quot;; else if(valueChar &gt;= 65 &amp;&amp; valueChar &lt; 91) return &quot;uppercase&quot;; else if(valueChar &gt;= 97 &amp;&amp; valueChar &lt;123) return &quot;lowercase&quot;; else return &quot;symbol&quot;; } 测试：public static void main(String[] args) { System.out.println(typeChar(&apos;,&apos;)); } 测试结果：symbol 常用到的字符ASCII值： 字符 ASCII值 A 65 A-Z 65-90 a 97 a-z 97-122","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"数据校验的存在与数据类型的关系","date":"2017-04-23T07:02:43.000Z","path":"2017/04/23/data_verify/","text":"数据校验 我们在观察ASCII码等计算机语言中发现：1Byte占8位，按理应该是256个字符才对，但我们使用时，常常发现一个字节来用的只有128个字符，这是为什么？ 计算机在储存这些字符时会使用一位用来数据检验，当输出方与接收方对同一个字符的检验码一致时才说明数据没有被损坏是完整的，所以我们能用到的只有7位； 数据校验是为保证数据的完整性，使用指定的算法计算出的检验值；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"HTTP状态码","date":"2017-04-13T04:14:12.000Z","path":"2017/04/13/HTTP_status_code/","text":"HTTP状态码（HTTP status code)常见的4个HTTP的状态码： 200：请求成功 301：资源被永久地转移到其他URL 404：请求的资源不存在 500：内部服务器错误 HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求需要请求者继续操作 2** 成功，操作被成功并处理 3** 重定向,需要进一步操作以完成请求 4** 客户端错误,请求包含语法错误或完成请求 5** 服务器错误，服务器在请求过程中发生了错误 Note:常见的分类如上，在编码过程中Tomcat返回状态码时，就可以根据状态码大致判定下bug在哪里了。","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"HTTP","slug":"HTTP","permalink":"https://kangshanr.github.io/tags/HTTP/"}]},{"title":"数据库三大范式","date":"2017-03-01T03:04:38.000Z","path":"2017/03/01/database_normal_format/","text":"数据库范式 概要：数据库目前有六大范式，但一般来说只满足前三大范式（3NF）即可。第一范式最基础，依次上推，每一层是下一层的基础； 第一范式：列的原子性，每一列都是不可分割的基本数据项，但这也根据实际使用过程中来，如果在使用数据过程中并没有使用到其原子数据，那么定义最原子性的数据就没有必要了； 第二范式：列的唯一性，要保证列的唯一性，就得在保证第一范式的基础上保证每一列属性完全依赖于主键。 第三范式：各属性不依赖于其它非主键属性，在保证前两范式的前提下，第三范式是为了保证数据的无重复性，将无关的属性单独创建一个表来实现多表而数据分明；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"database","slug":"database","permalink":"https://kangshanr.github.io/tags/database/"}]},{"title":"java访问修辞符","date":"2017-01-31T05:12:34.000Z","path":"2017/01/31/java_modifier/","text":"访问修辞符 java的访问修辞符包括了四个等级：Public,protected,(default/friendly),private; 它们决定了所修辞的成员的被访问权限从高到低： public:最高权限，项目中都可以访问； protected:受保护权限，只有在同包中或者在不同包的子类可以访问； default/friendly:默认的权限，不写出来。只有在同包中可以访问； private:私有权限，只有在同类中可以被访问，也就是在哪儿被声明就只有在哪儿可以被访问； Note: 外部类只能被public和default两种修辞符，内部类可以有所有的访问修辞符； 这儿涉及到内部类的知识点： 与外部类的区别： 内部类可以被各种访问修辞符修辞，这一点区别于外部类； 当内部类的成员被声明为静态时，该内部类必须被声明为静态，这是另一点区别于外部类； 当内部类被声明为private私有时，只能在外部类中构造该内部类的对象。在迭代器模式中，让内部类实现迭代器接口，利用依赖倒置，获取到内部类（迭代器）对象用接口接收，从而实现在外部得到这个内部类。这也充分地体现了依赖于抽象而不依赖于具体，关闭了具体实现，只开放了接口； 当内部类声明为其它可以在外部访问的类型时，在外部引入这个类后，要直接构造一个内部类的实例必须先构造一个相关的外部类的对象，利用这个外部类的对象来构造才能实现。迭代器模式中例子：","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"hexo+github=your website","date":"2017-01-22T18:04:38.000Z","path":"2017/01/23/hexo+github=website/","text":"在学习使用hexo过程中的笔记，大部分来自于hexo官方网站的文档介绍；还有搭建网站过程中，参考了不少其他站主的文章：小茗的搭建网站博客使用blueLake的教程生成新浪微博秀； hexo generate 根据已提供的md文件资料生成静态网页，放在public文件夹中； hexo generate –watch 对比查看文件的改动，只有当文件改动被审查过才会执行generate命令生成静态网页； hexo generate –deploy与hexo deploy –generate 两者效果一样都在generate后执行布置命令deploy 新建md文档：hexo new [dir] filename 使用这个命令生成md文档时，当指定其生成的目录为_draft时，hexo会自动将文档的头加上： --- title: hexo+github=your website date: 2017-01-23 02:04:38 --- 而当指定目录为_post时，其效果会加上标签： --- title: hexo+github=your website date: 2017-01-23 02:04:38 tags: --- 但是全部的信息包括： --- title: hexo+github=your website date: 2017-01-23 02:04:38 categories: 默认分类 #分类，这一点用到的地方不少，*善用分类与标签* tags: [tag1,tag2,tag3]#文章标签，可空；使用多标签时，将`[]`符号带上，并且标签之间用`,`分开 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 --- Hexo默认的文件头只有title、date、tags属性，生成的html会缺少Meta信息，不利于搜索引擎收录。建议自行在文件头中添加keywords和description属性。categories属性可自行选择是否添加。标准包含全部meta信息的头应该是： --- title: ##文章标题 date: ##时间，格式为 YYYY-MM-DD HH:mm:ss categories: ##分类 tags: ##标签，多标签格式为 [tag1,tag2,...] keywords: ##文章关键词，多关键词格式为 keyword1,keywords2,... description: ##文章描述 --- 正文 生成md文档还有另外一个命令：hexo new page newpage 与上一个命令不同之处在于：生成的md文件放在了根目录而不会放在source/_post中，而会在source文件夹中生在一个newpage的folder，并在其中生一个index.md，且这个md文档的title会被设置成newpage，也就是生成了这样一个页面，而这个页面并未在网页目录中，但我们就可以好好地设置这个页面用于在其他的文档引用； 实现readmore:在任何你想要预览到此的位置加上标签&lt;!--more--&gt;，即可实现； 使用过程中摸索的小问题： 每次部署前generate一次就把public中的所有文件先覆盖了，而这样再deploy时就把github远程上资料全部覆盖，这样在github上添加readme都会被覆盖，也就导致了远程机上没有自定义的东西全是生成好的，而且每次一部署都会将先前的重新生成一次再覆盖，感觉造成了许多资源的浪费也很自定义自己想要的网页效果，问题就在于可不可以每次只生成新的资源，再只将新的资源push到master branch上，或者push到其它的branch上，再merge到一起，只要生成新的资源时不会与老资源冲突，也就能达到效果。 在landscape主题中，据观察也只变化了首页index.html与相应的日期的folder,其它的folder与file都没有改变，所以上述的方法是可行的； 但是，这样操作还有一个问题需要注意，新生成的网页的目录结构都还在，这就需要把新生成的目录结构给拷到之前已存在的目录中，并在这个添加了新网页的目录中push； 实验失败：8/25/2017 7:52:15 AM 将新的几个md文件放在source文件夹下面的_post中生成新的页面并添加在github的仓库中push上去，网站上并没部署这几个新的页面（仓库中已经有这几个新的页面的html了）； 所以，还是用最暴力的方法更新，每次重新生成整个仓库的资源，将整个仓库资源deploy到github上； 调整整个背景颜色与图片的信息： 进入到相关的主题folder中，再依次进入source--&gt;css--&gt;style.styl，打开这个文件，找到body在这个级别下就有各种配置参数可以调整，包括了background: color_value url(图片路径) 每新建一个hexo目录（也就是说当你在其它托管网站上新建一个项目时）在这个hexo目录中依然要执行上面安装所有的插件到hexo中，比如安部署器deployer：npm install hexo-deployer-git --save","tags":[{"name":"github","slug":"github","permalink":"https://kangshanr.github.io/tags/github/"}]},{"title":"正则表达式","date":"2017-01-13T04:22:23.000Z","path":"2017/01/13/regular_expression/","text":"正则表达式的使用 对字符串进行验证 各个语言中提供专门的方法与接口来执行正则表达式（比如:Java中的boolean String.matches(String regex)将其作为一个参数,返回这个字符串是否匹配得上这个正则表达式）； 正则表达式是对字符串进行逐个字符验证，从第一个字符开始，依次往后匹配，有一个不匹配就可以Over了跳出循环; 必须从头判定到尾，如果没有对尾作出判定，表达式会将字符串当作另一个更短的字符串来判定则肯定不匹配； #### 正则表达式中各个字符表达的意义： #### 元字符 描述 \\ 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\\n。“\\n”匹配换行符。序列“\\”匹配“\\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式任意次。例如，zo能匹配“z”，也能匹配“zo”以及“zoo”。等价于o{0,} + 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果[‘o’, ‘o’, ‘o’, ‘o’] .点 匹配除“\\r\\n”之外的任何单个字符。要匹配包括“\\r\\n”在内的任何字符，请使用像“[\\s\\S]”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身. [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\\b就是匹配位置的）。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持 \\D 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。 \\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 \\nml 如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（&copy;）。 \\p{P} 小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。其他六个属性：L：字母；M：标记符号（一般不会单独出现）；Z：分隔符（比如空格、换行等）；S：符号（比如数学符号、货币符号等）；N：数字（比如阿拉伯数字、罗马数字等）；C：其他字符。*注：此语法部分语言不支持，例：javascript。 \\&lt;> 匹配词（word）的开始（\\&lt;）和结束（>）。例如正则表达式\\能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。 ( ) 将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \\1 到\\9 的符号来引用。 / 将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him/her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。(里面或符号｜会被编译成markdown的制表符，所以里面的｜都用了反斜杠/) (?:pattern) 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符(/)来组合一个模式的各个部分时很有用。例如industr(?:y/ies)就是一个比industry/industries更简略的表达式。(里面或符号｜会被编译成markdown的制表符，所以里面的｜都用了反斜杠/) (?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，Windows(?=95/98/NT/2000)能匹配Windows2000中的“Windows”，但不能匹配“Windows3.1”中的Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(里面或符号｜会被编译成markdown的制表符，所以里面的｜都用了反斜杠/) 下面为了避免｜被markdown识别成制表符号换种格式： (?!pattern)： 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern)： 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”或”zood”。 Note:参考文档","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"学习C#时关于数据结构的认识","date":"2016-12-31T14:02:43.000Z","path":"2016/12/31/Csharp_datastruture/","text":"C# 数据结构高等数学相关基础知识： 计量单位（Uint）：位缩写为b,字节缩写为B，千字节为KB，兆字节MB。1B = 8b，1KB = 1024B，1MB = 1024KB 阶乘函数（Factorial Function): 0! = 0 , n! = (n-1)! *n 取上整和取下整（Floor and Ceiling）：⌊3.4⌋=3（下整） ，⌈3.4⌉=4（上整） 取模择操作符（Modulus)：% ， 5%2 返回1，这两个参数也可以为浮点类型数值，eg：5.6 %0.5 ，返回0.1 对数（Logarithm)：若ab=N，则数b叫做以a为底N的对数，记作：logaN=b,其中a叫作对数的底数，N叫真数； 递归（Recursive):算法调用自己或间接调用自己； 使用递归函数一定要留好缺口，不然就会无限调用导致内存溢出；比如，用递归函数来算阶乘，其缺口就是0！ = 1； 算法（Algorithm) 对某一选定类型的问题的求解步骤的一种描述，是指令的有限序列。其特性有： 有穷性（Finity)、确定性（Unambiguousness)、输入（Input)、输出（Output)、有效性（Realizability) 针对算法的优劣，其评价标准有：正确性（Correctness)、可读性（Readability)、健壮性（Robustness）、运行时间（Running Time)、占用空间（Storage Space) 数据结构（Data Stauct): 简记为DS,是一个二元组，DS=（D,S)，其中D为数据元素的有限集合，R是数据元素之间关系的有限集合。 相互之间存在一种或多种关系的数据元素的集合。常用的4 种数据结构类型： 集合（Set) 线性结构（Linear Structure) 树形结构（Ture Structure) 图状结构（Graphic Structure) 数据（Data) 外部世界信息的载体，能被计算机识别、存储和加工处理，是计算机程序加工的原料。 数据元素（Data Element)和数据项 数据的基本单位，有时也被称为元素、结点、顶点、记录等等。 一个数据元素可由若干个数据项组成； 数据项是不可分割、含有独立意义的最小数据单位，数据项有时也被称为字段（Field)或域（Domain)； 数据项组成数据元素，数据元素组成数据，数据组成文件。 使用数据库模型来法人代表说明这两者之间的关系： 数据对象（Data Object): 性质相同的数据元素的数据元素的集合，是数据的一个子集，例如：字母表对象｛a,b,c,d,……x,y,z} 数据类型（Data Type) 数据的聚会范围和对数据进行操作的总和。 规定了程序中对象的特性； 程序中每个变量、常量、表达式的结果都应该属于某种确定的数据类型 可分为两类： 非结构的原子类型，如，C#中的基本类型； 结构类型，其成分由多个结构类型组成，可以分解；如C#的数组类型。","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"C#","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://kangshanr.github.io/tags/数据结构/"}]},{"title":"C#语言中数据类型","date":"2016-12-25T07:02:43.000Z","path":"2016/12/25/Csharp_datatype/","text":"C#数据类型 C#中，数据共有三种类型 value types 值类型 reference types 引用类型 pointer types 指针类型 关于命名空间 namespace，msdn官网上有一句：Namespaces implicitly have public access and this is not modifiable.翻译：命名空间隐式默认为public公共访问权限，并且不能修改这个公共访问特性。也就是说命名空间访问不受限； 参考：visual studio网站","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"C#","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"}]},{"title":"C#中的抽象类","date":"2016-12-23T07:02:43.000Z","path":"2016/12/23/Csharp_abstract_class/","text":"abstract_interface abstract 修饰符用于表示所修饰的类是不完整的，并且它只能用作基类。抽象类与非抽象类在以下方面是不同的： 抽象类不能直接实例化，并且对抽象类使用 new 运算符会在编译时错误；（虽然一些变量和值在编译时的类型可以是抽象的，但是这样的变量和值必须或者为null，或者含有对非抽象类的实例的引用（此非抽象类是从抽象类派生的））； 允许（但不要求）抽象类包含抽象成员; 抽象类不能被密封(因为密封类不能被继承）; 当从抽象类派生非抽象类时，这些非抽象类必须具体实现所继承的所有抽象成员，从而重写那些抽象成员; Note: 与java相比，抽象类的特性都差不多； java中不存在密封类的说法，相对应的说法应该是final常量修辞符；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"C#","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"}]},{"title":"C#中对象生命周期","date":"2016-12-18T07:02:43.000Z","path":"2016/12/18/Csharp_object_lifecycle/","text":"C#对象生命周期 C#中，一切都可以称作为对象Object，是对象就有生命周期（准确地讲，在面向对象的高级语言中，一切皆对象，是对象就有生命周期）； 除了在“正在使用”中的正常状态外，对象还有两个状态： 构造阶段：对象构造阶段，在对象被构造出来前，此对象是不存在的。只有构造出来的对象才能被引用才能被程序所调用； 析构阶段：对象回收前的阶段，不同的语言对就不同的回收机制；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"C#","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"},{"name":"面向对象","slug":"面向对象","permalink":"https://kangshanr.github.io/tags/面向对象/"}]},{"title":"C#编程中的访问修辞符","date":"2016-12-11T07:02:43.000Z","path":"2016/12/11/Csharp_access_modifiers/","text":"C#访问修饰符C#中为了数据的安全性以及代码的拓展，定了几种访问级别，根据对应的访问修饰符，可以获取Class里面对应的字段、属性、方法等。 常见的访问修饰符有：（1）public 公有访问。不受任何限制。（2）private 私有访问。只限于本类成员访问，子类都不能访问。（3）protected 保护访问。只限于本类和子类访问。（4）internal 内部访问。只限于本项目内访问，其他不能访问。（5）protected internal 内部保护访问。只限于本项目或是子类访问，其他不能访问。 根据MSDN上面的解释，我们也可以理解对应访问修饰符的作用。 参考博客 常见成员类型的访问修饰符（1）接口(interface) 接口成员访问修饰符默认为public,且不能显示使用访问修饰符。 （2）类(class)构造函数默认为public访问修饰符。析构函数不能显示使用访问修饰符且默认为private访问修饰符。类的成员默认访问修饰符为private（java中默认为同包权限，在同包中可以被访问的，默认不写）; （3）枚举(enum)枚举类型成员默认为public访问修饰符，且不能显示使用修饰符。 （4）结构(struct) 结构成员默认为private修饰符。结构成员无法声明为protected成员，因为结构不支持继承。 （5）嵌套类型嵌套类型的默认访问修饰符为private。 和类，结构的成员默认访问类型一致。","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"C#","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"}]},{"title":"快速排序算法","date":"2016-12-03T04:54:38.000Z","path":"2016/12/03/快速排序算法的理解/","text":"今日所得 今天复习了下快速排序（使用递归），据说是效率最高的一种排序算法（相比于冒泡排序、选择排序）； 之前学习C#时领教过，当想把这个算法迁移到java中来写一个时发现久了不练都手生了； 前面多次使用递归的算法写一些方法（诸如二分法查找已经排好序数组元素的索引、递归生成满足条件（非纯数字或字母）的字符串；使用多次但没有想到过使用递归时可以无返回值； 二分排序时，必须使用无返回值的递归方法。因为二分之后返回的是数组的一部分，最后把这一部分返回给递归前方法，这时要接收这一部分的元素需要对这一部分进行遍历； 二分法排序(升序，若要降序则相反）流程： 把数组第一个元素作为中间值，从最大索引(这个还必须从后往前找，因为我们用的第一个元素作为中间值，如果从前往后找，第一个较大值会直接覆盖最大索引的值；所以，如果想实现从前往后找就得把最大索引元素值作为中间值)开始往前找，找到比这个间值小的元素就把这个值赋予给最小索引的元素； 再从最小索引元素开始往后找，找到这中间值大的元素，把这个元素值赋予给最大索引处的元素（找的过程不满足条件就把索引依次自增或自减）； 依次这样后面往前找一趟，前面往后找一趟，直到最大与最小索引相等。这时把中间值赋予给这个索引，这样就完成了一次把数组分成两个部分，前面部分值比中间值小，后面部分比中间值大； 这用上面一套流程对中间值两边的元素进行递归操作，递归缺口就是数组操作部分只有一个元素； 代码：public int getPivotIndex(int[] arr, int minIndex, int maxIndex){ int pivot = arr[minIndex]; while (minIndex &lt; maxIndex) { while (arr[maxIndex] &gt;= pivot &amp;&amp; minIndex &lt; maxIndex) { maxIndex--; } if(minIndex != maxIndex){ arr[minIndex] = arr[maxIndex]; } if(minIndex != maxIndex){ arr[minIndex] = arr[maxIndex]; } while (arr[minIndex] &lt;= pivot &amp;&amp; minIndex &lt; maxIndex) { minIndex++; } arr[maxIndex] = arr[minIndex]; } arr[minIndex] = pivot; return minIndex; } *二分法排序的流程 * @param arr * @param minIndex * @param maxIndex */ public void dichotomySort(int[] arr, int minIndex, int maxIndex){ if(minIndex &lt; maxIndex){ int index = this.getPivotIndex(arr, minIndex, maxIndex); dichotomySort(arr, minIndex, index - 1); dichotomySort(arr, index + 1, maxIndex); }else{ return; } } 二分法排序算法核心在于每一次查找把中间那一个值给定下来，并对中间值两边的数组分别再次排序,再对两边的数组分别进行同样的操作，直到不能再分割;","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://kangshanr.github.io/tags/算法/"}]},{"title":"C#中类（面向对象）的认识","date":"2016-12-01T14:02:43.000Z","path":"2016/12/01/Csharp_class/","text":"类类中有成员： - 方法 - 变量（字段） - 属性（对变量的限定） - 类中不能直接对变量赋值，只能在方法中对变量赋值。我们看到的直接赋值的情况实际上是利用构造函数直接赋值，eg：string str = &quot;str&quot;; 类的构成： 变量 构造函数 方法（构成：访问修饰符+返回类型+方法名（参数）） 重要类成员，当函数名返回类型都一样时，参数不一样，这两个函数可以共存； 方法的参数可分为： 值参数（不含任何修饰符，形参是实参的一份拷贝，方法中对形参的改变不会影响到实参的值） 引用参数 用ref关键字来申明，传递的参数实质上是实参的地址，方法中对形参的操作就是对实参的操作，在调用时一样要用到ref关键字； 其后面变量一定要初始化，因为没初始化内存中是不存在其地址的，比如，int a;这儿的变量a就是没有初始化的； 先把实参地址传入方法，再在方法中执行； 输出参数 输出参数，用关键字out来声明； 与引用参数类似，直接对实参进行操作，在声明和调用时都需要用到out关键字； out的对象不要求在传递给方法之前初始化 但在方法返回前必须对参数进行赋值； 运行原理是与引用参数相反，先申明一变量（没内存空间），再在方法里申请变量内存空间，赋值后再把值的地址out给之前申请的内存使之指向方法中这个值，所以方法返回前必须对参数赋值； 数组型参数（传入数组形参） 关键字：params 该关键字用来声明用于可变长度的形参列表，方法声明中最多只能包含一params参数； 并且该参数（数组）必须是参数列表中最后一个参数； 数组参数必须是一维数组（对应多维数组）； 不允许与ref、out修辞符组合起来用； 若实参是数组，则按引用传递；若实参是变量或表达式，则按值传递； 方法重载 给功能相似的方法提供同一名称，实现编译时的多态性，引入方法重载概念，是面向对象程序设计的重要概念。特点： 1.方法名相同（必要条件） 2.参数列表不完全相同，参数个数、参数的类型； 3.返回类型不同，参数相同，这个不是方法重载，必须重命名一个方法名； 静态成员 非静态类成员实例化后，有几个对象就有几个类中成员； 而，静态成员（两者区别如下）： 内存分配：静态变量定义在类中后，内存中只存在这一个成员； 调用方式：访问必须在前加上类名:Class.member; 生命周期：在程序运行初始就初始化分配内存了，只要不关程序就一直存在； 与之对应的非静态成员，必须初始化才存在（new），才分配内存； 非静态变量会与其实例对象同存同毁；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"C#","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"},{"name":"面向对象","slug":"面向对象","permalink":"https://kangshanr.github.io/tags/面向对象/"}]},{"title":"java编程中你不知道的一两点","date":"2016-11-23T04:04:38.000Z","path":"2016/11/23/some_tips_about_java/","text":"Java中，你不知道的一两点 关键字new是运算符: 我们都知道new是用来开辟并新的内存空间创建对象的，但大多不知道这个功能是由运算符来实现； 运算符（type）： 强制类型转换，括号中加类型，强制类型转换，它也只是个运算符 运算符instanceof： 二元布尔运算符，前跟实例名后跟类名，判定实例是否可以用此类接收； 成员访问符“.”，访问类或实例的成员； 方法调用()，除了用于强制运算顺序，括号还用于调用方法；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"关于“上火”的科学点子","date":"2016-11-23T04:04:38.000Z","path":"2016/11/23/关于“上火”的事/","text":"所谓上火：现代医学中并没有“上火”的概念。 而现实生活中，我们的“火”是从哪儿上来的呢？ 吃辣上火： 我们对吃辣上瘾的原因在于，辣椒刺激口腔内部产生类似灼烧的感觉，而这种感觉会促使大脑分泌多巴胺（多巴胺是人产生快感的来源，人类大部分上瘾行为都和它相关），从而上瘾； 因为辣椒素残留口中，持续对口腔刺激。吃辣后，刷牙漱口就行了； 吃爪子上火： 瓜子本身并不会让你上火，让你不舒服的原因在于瓜子外壳上的脏东西。不信的话，下次吃瓜子只买瓜子仁吃，看会不会上火。","tags":[]},{"title":"springMVC","date":"2016-08-20T05:29:17.000Z","path":"2016/08/20/springMVC/","text":"核心对象：中央处理器：在web.xml中配置springmvc的servlet12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中load-on-startup这个属性来指定这个中央处理器被初始化的时机： 当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些； 当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序； 核心对象： 页面控制器，处理请求并给出响应； 处理器映射器HandlerMapping：设置handler处理器与url资源的映射 使用BeanNameUrlHandlerMapping这个类时，就会将handler的name属性值作为url映射，访问这个处理器就填写其name属性值:&lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController&quot;/&gt; 如上，就可能过name属性值，设置 &lt;a href=&quot;loginController.do&gt;登录&lt;/a&gt; SimpleUrlHandlerMapping，这个类型的映射要求映射url与controller的配置id相对应，并在这个节点内将controller的id与生意人key对应起来；&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!--配置指定的url与bean的id映射,可添加多个--&gt; &lt;prop key=&quot;/login.do&quot;&gt;login&lt;/prop&gt; &lt;prop key=&quot;/login2.do&quot;&gt;login2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController&quot;/&gt; &lt;bean id=&quot;login2&quot; name=&quot;loginController2.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController2&quot;/&gt; 使用注解实现处理器与url的映射&lt;!-- 注解映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; 这个配置节点就决定了处理器与其中的方法可以被注解@RequestMapping（”url_name”）映射并指定url 处理器适配器：HandlerAdapter，用于规定处理器的编写规则 使用接口来配置适配器： 当指定为SimpleControllerHandlerAdapter时，它就规定了要想成为处理器，就要实现Controller这个接口； HttpRequestHandlerAdapter:这个适配器要求所有的Handler都必须实现HttpRequestAdapter接口； 使用注解实现配置适配器：&lt;!-- 注解适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; 这个配置节点就决定了，有@controller注解的类就是处理器 在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象； springMVC中的处理器 controller: 中央处理器DispatcherServlet在web.xml中被配置成一个servlet,并通过初始化上下文配置参数springmvc.xml的路径与设置其启动时机与该servlet初始化时机； 1234567891011121314 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 通过上一步实现来自前端请求必须都通过web.xml文件中指定的servlet处理，也就是大部分请求都是交给了springmvc，所有的springmvc的配置都在springmvc.xml文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。 springmvc.xml配置中就指定了适配器映射，使用@Controller注解就让该类成为处理器 @RequestMapping(“url_name”)则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url; 注解使用时映射的方法中，可以与前端数据相通的参数有： 简单数据类型 pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password session/request/response：用法与之前一致，可以用分发请求也可以重定向； Model/ModelAndView： 也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中； 注解@RequestParam的使用： 其中有参数： name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法； required：boolean类型，当其值为true时，请求必须带有这个参数； 使用controller处理器时，各类方法返回数据类型： ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图） String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串”response:+方法映射”； “forward:+方法映射”，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到； Restful架构 只是一种规范，终极的目标是资源URI","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"framework","slug":"framework","permalink":"https://kangshanr.github.io/tags/framework/"}]},{"title":"JDBC的理解","date":"2016-07-24T04:14:32.000Z","path":"2016/07/24/JDBC/","text":"JDBC全称：fava database connectivity,专用于java数据库连接，其中封装了基本的连接数据库的API,数据库连接的高级框架（诸如：Mybatis/Hibernate)的使用都基于JDBC的原理，也就是理解了JDBC对于我们更理解各种持久层数据连接层的框架很有帮助； 一个简单的JDBC实现/** * 获取数据库连接的方法 * @return */ public static Connection getConnection(){ Connection con = null; try{ // 获取连接mysql数据库的驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 设置连接数据库的url String url = &quot;jdbc:mysql://localhost:3306/agileone1?useUnicode=true&amp;characterEncoding=UTF-8&quot;; // 连接数据库的用户名 String userName = &quot;root&quot;; // 连接数据库的密码 String userPass=&quot;&quot;; // 从而获取到数据库连接connection con = DriverManager.getConnection(url, userName, userPass); }catch (Exception e){ e.printStackTrace(); } return con; } 上述代码块就通过java.sql包里封装好的各个类与类反射获取到了连接指定数据库的链接； 接下来就可以利用这个连接来进行crud类操作- /** * 插入数据进入数据库的方法 * @param username * @param password */ static void insertData(String username, String password){ Connection con = getConnection(); String sql = &quot;INSERT INTO Userdata (username, userPass) VALUES(&apos;&quot;+username+&quot;&apos;, &apos;&quot;+password+&quot;&apos;)&quot;; try { // 从连接创建状态 Statement state = con.createStatement(); // 执行更新语句，返回影响行数 int re = state.executeUpdate(sql); System.out.println(re); } catch (SQLException e) { e.printStackTrace(); } } /** * 模糊查询的方法 * @param name */ static void query(String name){ Connection con = getConnection(); // sql语句 String sql = &quot;SELECT * FROM userdata WHERE username = &apos;&quot; +name+&quot;&apos;&quot;; try{ Statement state = con.createStatement(); // 执行查询语句，返回批量结果集 ResultSet re = state.executeQuery(sql); // 对结果集进行迭代输出 while(re.next()){ System.out.println(&quot;id:&quot; + re.getInt(&quot;id&quot;)); System.out.println(&quot;username:&quot; + re.getString(&quot;username&quot;)); System.out.println(&quot;id:&quot; + re.getString(&quot;userPass&quot;)); } }catch(SQLException e){ e.printStackTrace(); } } 当sql语句执行完成，需要对上面建立的各个连接与状态进行关闭：/** * 关闭连接与状态的方法 */ static void close(Connection con){ if(con !=null){ try { con.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 其中针对不同的方法与连接状态，关闭的对象也不一样，除了Connection还有Statement,Prestatement,resultSet，各个对象都是调用其Close方法； 通常情况下，调用对象的Close()方法放在finally语句块中，这样就可以执行完查询语句方法后，交接将各个对象关闭； Note: 以上的代码基本实现了JDBC的整个流程，从创建连接到执行查询语句，再到关闭连接、状态、结果集 JDBC中封装的连接数据库的API包：java.sql是连接sql的基础包，使用JDBC就得引入这个jar包：mysql-connector-java-5.1.38-bin.jar","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://kangshanr.github.io/tags/数据库/"}]},{"title":"dll文件的认识","date":"2016-06-30T07:02:43.000Z","path":"2016/06/30/DLL_file/","text":"DLL动态链接库：Dymanic Link Library DLL是将程序相关的功能实现封装在一起放在指定目录（后缀名为.dll），程序运行时，再来动态链接起执行。这样就能达到多个程序共享同一个库文件，而减少程序安装大小； DLL文件与exe文件都是编译语言生成，但dll没有程序入口，所以dll不能独自执行；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"设计模式","date":"2016-06-13T04:14:38.000Z","path":"2016/06/13/DesignPattern/","text":"Design Pattern，对于编程过程中遇到各种问题的总结与归纳，是编程（通常为面向对象）过程诸多问题的优秀解决方案；菜鸟教程之设计模式 Gang of Four，四人帮提出设计模式的设计原则： 对接口编程而不是对实现编程； 优先使用对象组合而不是继承； 简介： 共23种设计模式，分为三类： 创建型Creational Patterns：提供创建对象的同时隐藏创建的逻辑，而不是用new运算符直接创建对象； - 结构型Structural Patterns:关注类和对象的组合，继承的概念被用来组合接口和定义组合对象的新功能； 行为型Behavioral Patterns:关注对象之间的通信 单例模式 对于管理类，通常只需要一个实例对象即可达到管理的目的，这种时候如果实例多个对象只会造成系统资源上的浪费，所以通常我们使用单例模式来解决这种问题； 实现单例的思路： 将构造函数私有化，并在类中实现静态单例的共享；public class UserManager{ //静态单例 private static UserManager ins; //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ ins = new UserManager(); } return ins; } //其他的执行方法 public void updateUserInfo(){} ｝ 上面例子里有个线程上的缺陷，当多线程访问这个管理类时，会造成线程不安全，为解决这个问题，就得使用双重检查锁单例：public class UserManager{ //静态单例 private static UserManager ins; private Object lock = new Object(); //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ //第一次检查 synchronized(lock){ //保证不产生多余的实例 if(ins == null){ //第二次检查 ins = new UserManager(); } } } return ins; } //其他的执行方法 public void updateUserInfo(){} ｝ 关于多线程安全的实现在单例模式中有6种不同的方式，具体参照单例模式页面； 代理模式 代理模式：与工厂模式不同在于，可能产生多个实例，同时会帮Action做事（工厂模式属于创建型模式，而代理模式属于结构型模式）； 代理(Proxy)提供了对目标对象另外的访问方式;即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. 这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 代理模式就是将要实例的对象通过代理类来实现，不通过原本的类来实例，具体实现有三种方式： 静态代理： 可以让代理类同时实现真正想的对象的类实现的接口，而在代理类中有一个真正类的属性，当想要这个真正类时，对上述属性判空，再实例化，这样通过代理类执行接口中的方法时就是执行的真正想要的类的方法了； 简单地讲，代理就是将其他的类的各种实现方法，交由代理来实现。而要达到这种效果，就可以让代理与其他的类实现同一个接口，再在代理中实现接口方法中去实现这个类的方法。这也是代理的核心，一般代理中要注入一个代理对象，调用代理方法时，就对此对象初始化并调用其相关的方法； 动态代理： 代理不用继承接口，代理由java内置的java.lang.reflect包中的Proxy类生成： 其中生成代理静态的方法：static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)； 此方法的三个参数： loader：代理目标的类加载器； interfaces：代理目标实现的接口； handler：执行处理器，指调用此代理实现接口的处理器，此处理器必须实现InvocationHandler接口，并实现其public Object invoke(Object proxy, Method method, Object[] args)方法; cglib代理（子类代理）： 此类型代理需要用到spring核心包推荐使用spring-core 3.2.5版本及以上； 动态代理与静态代理都是向上抽取依赖，要求实现接口，而cglib代理则是通过目标对象子类来实现对目标对象功能的扩展； 其实现方法： 引入的功能包能够动态地在内在中构造子类； cglib的强大在于高效生成代码，在运行期扩展java类与接口，spring赖以生存的AOP拦截的就是大量地使用了cglib的强大功能； cglib的底层：使用字节码处理框架ASM转换字节码并生成新的类（并没有弄的懂的地方，涉及JVM中内部结构，诸如：class文件的格式秘指令集） 注意：cglib的实现是依赖于代理的扩展子类，需要对代理目标进行扩展 也就是说代理类不能为final修辞； 同时，目标对象的方法不能为final/static所修辞； 工厂模式 生成一个类交由相关的工厂类实现，而不由直接的类来实现； 相关的类继承同一个接口，实现这个接口的类都可以由工厂类中同一个方法来实现实例化； 例如： //定义同一个类的抽象接口 public interface Shape{ void draw(); } //实现shape接口的类有： //Circle类 public class Circle implements Shape{ @Override public void draw(){ system.out.println(&quot;circle.draw&quot;); } } //Square类 public class Square implements Shape{ @Override public void draw(){ system.out.println(&quot;square.draw&quot;); } } //创建实例的工厂类 public class ShapeFactory{ //创建图形实例的方法 public Shape createShape(String shape){ if(shape.equalsIgnoreCase(&quot;CIRCLE”){ return new Circle(); } if(shape.equalsIgnoreCase(&quot;SQUARE”){ return new Square(); } reutnr null; } } 模式理解： 通过工厂来实现对各个类的实例化，都在工厂实现； 通过反射机制实现，增加一个同一接口的类不需要改变工厂的代码,只需要增加一个实现这个实现对应接口的类： 其工厂的代码：public class ShapeFactory{ //创建工厂的方法 public Shape createShape(Class&lt;? extends Shape&gt; clazz){ try{ return Class.forName(clazz.getName()).newInstance(); }catch(Exception e){ e.printStackTrace(); } } } 抽象工厂模式 相比较于工厂模式，抽象工厂模式在工厂模式的基础上增加生成工厂的工厂类，那么生产出来的工厂都要继承一个接口或父类，没理解到的点就在于，这个类一定要是一个抽象类吗？可以是个接口或者非抽象类吗? 该模式的优点：把同一个产品类集成到同一个工厂内，这样使用时就直接调用工厂中的方法，而生成同一个工厂里预备好的类对象，也更方便管理； 它是为了解决子工厂的扩展性问题 迭代器模式 迭代器模式的设计目的只是，用自己写迭代器来实现迭代聚合数据，而将集体或聚合的数据的遍历分离出来来达到既能访问到集合的内部数据又不暴露集合的内部结构； - 迭代器接口： public interface Iterator { public boolean hasNext(); public Object next(); } - 容器接口： public interface Container { public Iterator getIterator(); } - 容器实现类： public class Repository implements Container { String elements[] = {&quot;kfc&quot;,&quot;jfk&quot;,&quot;mcd&quot;}; /** * 返回内部类的对象，注意这儿的依赖倒置 */ @Override private Iterator getIterator() { return new DoIterator(); } /** * 内部类，实现迭代器接口 * @author Administrator */ private class DoIterator implements Iterator{ int index; /** * 判定索引是否指向在集合之中，如果还在就返加true */ @Override public boolean hasNext() { if(index &lt; elements.length) return true; return false; } /** * 实现迭代器核心算法，如果后面还有元素就返回这个元素，最后的结果就是index会与集合的长度相等，索引指向最后的一个的后面 */ @Override public Object next() { if(this.hasNext()){ Object obj = elements[index++]; return obj; } return null; } } 最后在main方法测试中写for循环实现迭代：for(Iterator iter = new Repository().getIterator();iter.hasNext();){ String ele = (String)iter.next(); System.out.println(ele); } 输出：kfc jfk mcd 适配器模式 适配器是行为型模式，将原有的行为经过组合进行扩展； 顾名思义，适配器就是将原本不适的接口或功能适配到目标对象上。 最简单的理解类型是缺省型适配器：将各个接口实现在一个适配器上，再让目标继承这个适配器（可省，直接用这个适配器new出对象来也一样可以实现），想扩展什么接口功能就重写相应的方法，就实现了适配器的扩展功能； 而比起缺省型适配器，还有类的适配器和对象适配器： 类适配器：将目标功能的接口执行并继承被适配者 被适配者：想在此类上扩展目标接口的功能（适配器的设计初衷在于，被适配者并不能直接实现目标接口）public class Adaptee { void run(){ System.out.println(&quot;Adaptee.run..........&quot;); } } 目标接口：public interface Target { void fly(); } 适配器：public class Adapter extends Adaptee implements Target { @Override//继承父类被适配者，并能方便地扩展其方法 public void run() { super.run(); System.out.println(&quot;Adapter.run.......&quot;); } //实现目标接口的方法 @Override public void fly() { System.out.println(&quot;Adapter.fly...........&quot;); } } 测试：public static void main(String[] args) { Adapter adaptee = new Adapter(); adaptee.fly(); adaptee.run(); } 测试结果：Adapter.fly........... Adaptee.run.......... Adapter.run....... note:这样的一个适配器在某种程度上来说与缺省的适配器并没有什么本质上的区别，都是将各种功能行为通过继承或实现聚合到同一个适配器上； 对象适配器模式： 装饰器模式 未完待续","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"面向对象","slug":"面向对象","permalink":"https://kangshanr.github.io/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"https://kangshanr.github.io/tags/设计模式/"}]},{"title":"转义字符的使用","date":"2016-05-30T04:02:23.000Z","path":"2016/05/30/escape_character/","text":"在C语言中： \\ 是转义标识符 \\t 横向跳到下一制表位置 \\r 回车 \\n 回车换行 \\r是return，表示回到本行首 \\n 是new line,表示到下一行，不一定是行首 三种不同的系统下，换行到下一行首所用的字符也不一样 在windows系统下，\\n\\r Unix系统下，要用\\n就行 MAC OS系统下，用\\r 而在C#中，转义字符的意义: ·一种特殊的字符常量； ·以反斜线”\\”开头，后跟一个或几个字符。 ·具有特定的含义，不同于字符原有的意义，故称“转义”字符。 ·主要用来表示那些用一般字符不便于表示的控制代码。 ·它的作用是消除紧随其后的字符的原有含义 ·用一些普通字符的组合来代替一些特殊字符，由于其组合改变了原来字符表示的含义，因此称为“转义” ·用可以看见的字符表示那不可以看见的字符, 如’\\n’表示换行 常用的转义字符及其含义： 符号 意义 \\’ 单引号 \\” 双引号 \\ 反斜杠 \\0 空 \\a 警告（产生峰鸣） 产生“滴”一声，若想产生多次可以写多个,eg:\\a\\a\\a \\b 退格 \\f 换页 \\n 换行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 示例:(C#)//用代码实现500以内整数每12个数一排，直到2、3、4、5、6、7的最小公倍数 for (int i = 1; i &lt; 501; i++) { if ((i % 2 == 0) &amp;&amp; (i % 3 == 0) &amp;&amp; (i % 4 == 0) &amp;&amp; (i % 5 == 0) &amp;&amp; (i % 6 == 0) &amp;&amp; (i % 7 == 0)) { Console.Write(i + &quot;\\r\\n&quot;); Console.WriteLine(&quot;500以内2 3 4 5 6 7的最小公倍数是：{0}&quot;, i); break; } Console.Write(i+&quot;\\t&quot;); if (i % 12 == 0) Console.WriteLine(&quot;\\a&quot;); //这儿会产生连续多次的“滴滴”声 } 在 C#里 @ 表示有反转义的作用: “c:\\temp”表示路径是c:\\temp; 而@”c:\\temp”就表示c:\\temp; 所以,@的作用就应该是忽略转义字符的作用. 参考文档","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"C#","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"},{"name":"C","slug":"C","permalink":"https://kangshanr.github.io/tags/C/"}]},{"title":"环境变量的配置","date":"2016-05-13T01:53:42.000Z","path":"2016/05/13/environment_configuration/","text":"环境变量配置 在windows下，以maven的安装环境变量为例： 可以在环境变量中新建一个指定路径（先配置M2_HOME的环境变量，新建一个系统变量：M2_HOME , 路径是绝对路径））； 再在path中添加这个路径：path值的末尾添加 ;%M2_HOME%\\bin；,这儿的；用来隔离上一个变量的路径所用，所以加不加这个;取决于上一个路径有没有在末尾添加这个符号； 这样就配置好了，前面两步也等同于直接在path中添加maven中bin目录的绝对路径（记得在前一个路径末添加‘；’）； 配置好环境变量后就意味着：在任何路径的控制台输入命令就可以唤起配置过环境变量中的命令，而不需要在命令前加上路径名或进入到这个命令所在的目录再输入命令；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"tips","slug":"tips","permalink":"https://kangshanr.github.io/tags/tips/"}]},{"title":"数据结构与算法","date":"2016-05-03T11:04:34.000Z","path":"2016/05/03/数据结构/","text":"通俗地理解，数据结构就是数据在内存中存入的结构。语言中的各类集合就是对数据结构的实现。 这其中包括了物理结构与逻辑结构； 物理结构又叫存储结构： 包括了顺序物理结构，数据元素存放在地址连续的存储单元里，数据元素之间的物理关系与逻辑关系是一致的（逻辑结构上是一对一？）（数组）； 链式物理结构，数据元素分散在任意存储单位，可以不连续，前后用指针关联； 逻辑结构：反应数据之间逻辑关系的数据结构，表示数据之间前后关系，与数据在内存中的存储位置无关； 集合结构：数据元素同属一个集合，他们之间并列，没有其他关系； 线性结构：数据元素之间一对一的相互关系； 树形结构：数据元素之间存在一对多的相互关系； 图形结构（网状结构）：数据元素存在多对多的关系； 参考博客 个人理解： 目前在编程语言学习中接触到的集合各类中的元素之间逻辑关系都是的集合结构，包括字典、列表，它们其中的元素之间只有并列关系，没有其他任何关系； 而在集合元素内部的属性关系（键值对）是一对一的线性结构（一个键对就一个值）； 数组是一个典型的顺序物理学结构，且其逻辑结构是一对一； 实例与实例的成员关系在逻辑上是一对多，一个实例对应了多个成员；方法与方法执行块，参数，都是一对多的树状逻辑关系；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"今天总结小tips","date":"2016-04-13T14:02:53.000Z","path":"2016/04/13/NaN_add/","text":"NaN NaN:Not a Number 非数值的数值，当计算中出现诸如：除数为0的除法、求负数的平方根之类的运算时，这时返回的结果就只能是一个NaN； 当这样一行代码出现时： int a = 1; 请问：a++与++a还有(a+1)这三个运算对程序意味着什么？ 这三者间有很大的区别： 当这三者作为参数传给其他方法时，第二三个都是传入2，第一个传入的是1； 影响在于a这个int类型的变量产生变化，前两者都是让a自增1，第三个没有； 所以建议，在使用某个值作为参数同进想让这个值变生变化再传入时，一定要考虑到要不要让这个变化存入到这个变量中去，如果要，可以在传入之前就把这一步运算做了，如果不要就使用其他变量接收这个值，传入其他变量； 当程序有问题时： 不能一直在一个方向上思考问题所在。很可能只是小小的单词写错的问题； 当要使用到迭代循环并返回boolean值时， 在满足其他更为重要的条件下，应该多使用或||运算，因为只要有一个条件满足时，后面的运算就不用再进入； 如果要返回一个正向为true的值时，可以声明返回结果为true，循环迭代判定时，只要有一个的结果为false，就可以跳出循环，节省计算机运算资源； // 判定是否有特殊字符 private boolean haveSymbol(String str) { boolean re = true; for(int i = 0; i &lt; str.length(); i++){ int val = (int)str.charAt(i); if(val &lt; 48 || val &gt; 122 || (val &gt; 57 &amp;&amp; val &lt; 65) || (val &gt; 90 &amp;&amp; val &lt; 97)){ re = false; break; } } return re ; } 此例子中，需求是字符串中只能有字母与数字，这就意味着，挨个判断每个字符时，只要有一个字符为特殊字符，那么返回结果就是false，无需再对后面的字符判定，直接跳出循环；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"markdownPad使用攻略","date":"2015-04-29T04:54:38.000Z","path":"2015/04/29/markdown/","text":"说明：这是一篇在使用markdown记录笔记过程中自己总结一些使用小技巧； 首先来一个： 官方的使用说明 包括了常用的快捷键使用： Welcome to GitHub Pages You can use the editor on GitHub to maintain and preview the content for your website in Markdown files. Whenever you commit to this repository, GitHub Pages will run Jekyll to rebuild the pages in your site, from the content in your Markdown files. MarkdownMarkdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for 123456789101112131415Syntax highlighted code block# Header 1## Header 2### Header 3- Bulleted- List1. Numbered2. List**Bold** and _Italic_ and `Code` text[Link](url) and ![Image](src) Shortcut: Bold (Ctrl+B) and Italic (Ctrl+I) Quotes (Ctrl+Q) Code blocks (Ctrl+K) Headings 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) Lists (Ctrl+U and Ctrl+Shift+O) Timestamp(Ctrl+T) Horizontal Rule(Ctrl+R) For more details see GitHub Flavored Markdown. Jekyll ThemesYour Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings. The name of this theme is saved in the Jekyll _config.yml configuration file. Support or ContactHaving trouble with Pages? Check out our documentation or contact support and we’ll help you sort it out. 新得到的小点子诸多功能：为知笔记中提供的一些功能，其中包括了表格的实现等没怎么用到但很实现的功能； 其他在使用过程中摸索出来的小点有： 段落：一级段落使用一个“&gt;”符号，以此类推，二级就用”&gt;&gt;”，三级就用“&gt;&gt;&gt;”，可以有n多级；得注意的是，这种格式经过hexo生成后在网站上显示为水平居中，字体放大一号，同时左边并没有段落的竖线； 插入链接：[百度](http://www.baidu.com &quot;百度一下&quot;)示范一下：百度，可以看到[]中放的是显示的字符串，()里放的是url与提示；注意，各个标识符都是小写状态，快捷键ctrl+l； 想要插入代码: 在&lt; pre &gt;标签中插入代码:这儿就是插入pre标签后的效果 在每一行代码前插入三个table符，记住是每一行代码都要在前面加上三个table符； 快捷键ctrl+k,这种方式适合短小的单行代码，因为一旦换行，就打破了代码块；","tags":[{"name":"tips","slug":"tips","permalink":"https://kangshanr.github.io/tags/tips/"}]},{"title":"html_base标签","date":"2015-03-25T07:39:42.000Z","path":"2015/03/25/html_'base'_label/","text":"简介：用于规定页面上所有的链接的默认URL和默认目标：&lt;base href=&quot;http://……“ target=&quot;_blank&quot;&gt; base标签放在标签之中; 最好把base标签排在head标签中第一个元素，这样其它的元素就可以使用base元素的信息； 一个文档中最多能使用一个base元素； 如果使用了base标签，至少要具备href属性或者target属性其中一个； 其中的元素： href：规定页面中相对链接的基准URL，其值就是一个URL; target:规定页面中所有的超链接和表单在何处打开，但该属性会被每个单独的链接中的target属性所覆盖，其值包括： _blank，打开新的页面 _ parent，在父页面打开 _self，在当前页面打开 _top，在浏览器头页面打开 framename base标签支持的属性 支持HTML的全局属性，如：class,id,style等 不支持事件属性，如:onClick之类；","tags":[{"name":"html5","slug":"html5","permalink":"https://kangshanr.github.io/tags/html5/"}]},{"title":"meta标签.md","date":"2015-03-23T06:41:48.000Z","path":"2015/03/23/meta_label/","text":"标签简介： 位于文档的头部标签之中，不包含任何内容； 所有的信息都由属性来存储，包含了文档的名称/值对； 其作用：搜索引擎优化（SEO)，定义的页面使用语言，自动刷新并指向新的页面，实现页面转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口； meta属性（就两个）： name属性： 用于描述网页与之对应的属性值为content,其中的内容便于搜索机器人查找和分类信息用； 其语法格式：&lt;meta name=&quot;参数“ content=&quot;具体的参数值&quot;&gt; name属性有以下几种参数： Keywords，用来指定关键字&lt;meta name=&quot;keywords&quot; content=&quot;meta总结、html/meta、meta属性、meta跳转”&gt; desription，网站内容描述 robots,机器人向导 author，标网页的作者 generator，代表说明网站采用的什么软件制作 COPYRIGHT,版权信息 revisit-after,代表网站征文，7days代表7天 http-equiv,相当于文件头作用，可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content,其中的内容就是各个参数的变量值；&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值”&gt; Expires，期限，设定的到期时间，一旦网页过期，呢额胆固醇服务器上重新传输。（必须使用GMT的时间格式化） Pragma（cache模式） 禁止浏览器从本地计算机的缓存中访问页面内容&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;no-cache&quot;&gt; 这样设计，说教将无法脱机浏览 Refresh(刷新），自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot;content=&quot;2;URL=http://www.haorooms.com&quot;&gt; //(注意后面的引号，分别在秒数的前面和网址的后面) Sett-Cookie(cookie设定），如果网页过期，存盘的cookie将被删除&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt; 必须使用GMT的时间格式 Window-target(显示窗口的设定），强制页面在当前窗口以独立页面显示&lt;meta http-equiv=&quot;Window-target&quot;content=&quot;_top&quot;&gt; 用来毕业后公开了我在框架里调用自己的页面 content-Type，设定显示字符集&lt;meta http-equiv=&quot;content-Type&quot;content=&quot;text/html;charset=gb2312&quot;&gt; meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文； BIG5:繁体中文； iso-2022:日文； ks_c_5601:韩文； ISO-8859-1:英文； UTF-8:世界通用的语言编码； content-Language,设定显示语言&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot;/&gt; Cache-Control，指定评语和响应遵循的缓存机制 imagetollbar,指定是否显示图片工具栏，当为false娃给显示，当为true代表显示； Content-Script-Type,W3C网页规范，指明页面中脚本中的类型；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"},{"name":"leadingEnd","slug":"leadingEnd","permalink":"https://kangshanr.github.io/tags/leadingEnd/"}]}]