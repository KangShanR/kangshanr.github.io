[{"title":"","date":"2017-08-28T20:17:22.409Z","path":"2017/08/29/项目开发流程（详细）/","text":"项目开发流程：整个流程包括： 需求挖掘（核心就是用户痛点）： 作为一个商业项目的程序员，一定要搞明白项目的赢利点在哪里； 要解决用户痛点； 用户分为：直接用户、最终用户 直接用户就是项目开发中，直接对接的用户，通俗的可以理解为给钱的； 最终用户是产品开发出来后使用产品的用户； 比如给一个公司开发的无纸化办公软件，这个产品的直接用户是这个公司的管理层，他们把项目交到我们手上来开发。但最终用户就是这个公司的各类普通职员，是他们在使用这个成型的产品； 在外包项目中，在需求挖掘的过程中往往涉及到： 用户访谈 需求探索 卖家会议 领导意见 而在这整个过程中，作为开发人员不能刻意引导对方，使用引导性对话往往会带出客户的伪需求，这就会需求分析带来干扰 需求分析：在作需求分析的对象只有两个：测试人员，普通使用者；这就决定了：写需求分析说明书时，措词要易懂清晰，少用专业词汇； 整个过程是开发人员、测试人员、客户各方不断讨论的过程 一旦有新的决定性需求确定下来，比如定稿时，一定要客户签字确认，各方责任要清晰； 当定稿之后客户要求修改需求，或修改需求成本太高，一定要出需求变更说明书，同样要求客户签字； 概要设计（数据库设计E-R图可同步进行） 比如一个简单的邮箱功能，其中的数据应该包括： 发件人名师 收件人列表 主题 内容 是否有附件 抄送人列表 详细设计 数据库设计（模型图） 用例图（PowerDesigner、Visio)：描述参与者与用例之间的关系，不能用crud之类的语言，比如：开发票与销毁发票，而不是用新建发票、删除发票；注意参与者可以是人但也可以是其他角色； 时序图（PowerDesigner)：操作到哪个对象，操作后返回什么对象 流程图（Visio)： 跨职能流程图中：每一个泳道代表一个职能； 菱形：判定，出来两根线，一个是，一个否； 矩形：流程 圆角矩形：开始或结束 平行四边形：输入数据 包图（Powerdesigner) 类图（Powerdesigner) 编码 测试 上面就是一个标准的项目开发给流程，而不同开发模型中就是使用以上的流程不同方式（周期，频次）,除了瀑布模型与螺旋模型，常用的项目开发模型还有： 迭代模型 增量模型（钱产够的情况下，先将能上线赚钱的模块开发出来上线，后续根据需求来增加不同的项目模块）","tags":[]},{"title":"无题","date":"2017-08-26T14:19:02.000Z","path":"2017/08/26/今日无题/","text":"刚才重看了一遍《当幸福来敲门》，看到Chris在实习期间，为了促进与客户的联系与第一个客户去包厢看football game，这就便结识了一众上流的客户。 我便想到，这个时候要是我是他，我做得到吗？Chris很穷，比现阶段的我还穷，但他在与他的精英客户一起看比赛的过程中，一点也不含糊，用着最专业的语言与人交流铺垫后面的工作事务。而如果是我，我肯定会在内心深处认为自己干不了这个事。这也是一般人的的认知上的缺陷。大家都会认为自己不熟悉的东西都不是自己的东西，会直接把这些东西排除在自己的思考范围之外。Chris为什么能做到？为什么我有同样的境遇时，我会把所有松懈归因到外界？同时，我为什么会松懈？因为我对自己要求低，为什么很容易让自己得过且过？因为我从来没有把自己当做一个有追求的人，并没有在内心深处认同自己是一个精英。或者说我根本不知道自己想要什么，想要成为一个什么样的人。这些最本质的思考从来没有进行过，而每次自以为是很与众不同的认知不过是用来平抚自己焦虑的安慰剂。关键点在于，没有把自己看起。从心理学角度来看，并不是一个高自尊的人。一个高自尊的人会在内心深处高看自己一眼，会把与精英互动当成理所当然，也就不会露出任何胆怯。 这也让我想到之前看到很多公号里的文章里介绍，一个强大的父亲是即使整个人都废掉了依然每天整洁清爽，并不因为穷困而开始潦倒，而是给儿女一个很爱护自己形象很会约束自己行为，随时准备与自己的贵人相遇的形象。 因此：别受到与自己水平差不多的人观念的影响，要随时与更厉害的人交流，探索他们的思维与观念，多接受别人的思考方法，学习别人的优点，思考自己的思维缺陷；保持自己的追求，当懈怠时，看看自己是不是总在寻找所谓的“小确幸”，用以填补内心的空虚。这种时候一般的表现是，做事情并没有什么效果，只是追求形式上的参与（这里不得不祭出陈昊老师一句话：参与感带来存在感，存在感带来优越感。仔细想想，是不是当下做的事只是为了满足自己的优越感）。 另外，今天在神游意淫某个与故人吹牛的场景时，想起一句诗：把酒话桑麻。原著：过故人庄——刘禹锡故人具鸡黍，邀我至田家。绿树村边合，青山郭外斜。开轩面场圃，把酒话桑麻。待到重阳日，还来就菊花。 曾经听说过欧阳老师与一个牛逼甲方在吃饭喝酒时，双方行酒令，关于“酒”的诗。双方你一句我一句，看得在场其他人目瞪口呆。忍不住，来一段： 酒逢知己千杯少，话不投机半句多。人生得意须尽欢，莫使金樽空对月。劝君更尽一杯酒，西出阳关无故人。（这一句在14年黄露家送别时酒桌上吟过，不知道在场的有没有觉得当时我很傻逼）对酒当歌，人生几何！明月几时有，把酒问青天。……实在想不起其他的了：”九九女儿红“……收工！！！","tags":[{"name":"essay","slug":"essay","permalink":"https://kangshanr.github.io/tags/essay/"}]},{"title":"神片试撸《巴霍巴利王II》","date":"2017-08-25T14:04:38.000Z","path":"2017/08/25/神片试撸《巴霍巴利王II》/","text":"今天晚上撸了一印度神片电影《巴霍巴利王II》，一部刺激荷尔蒙狂飙的电影，一部用视觉效果与背景音乐带着剧情与逻辑飞的电影，让人看了想谈恋爱想战斗想改变全世界。 绝美3D大场景， 各种虚光焦（妹子眼睛太好看了，忍不住再放一张）， 各种慢镜头， 各种高颜值， 各种强对比， 各种细节特写， 各种秀肌肉， 各种经典画面构图。 单看剧情人物性格构造说它脑残也不过分，为了个人英雄而强行让剧情与配角全都为这个英雄服务，观众能猜到下十分钟的剧情。 比起刚在国内下场不久的《摔跤吧，爸爸！》，可以预料，不管在商业上还是口碑上可能都差一截，但这片子把印度电影的长处发挥得淋漓尽致。该耍帅耍帅，该跳舞跳舞一点也不含糊，背景音乐超带感，整部电影简直串起了若干个MV，用视听效果来带着整部电影飞。总的来说，不错的片子。 另外提一句，特效渲染是国内的一家叫“蓝海创意”团队做的，国内的特效技术其实一直都是杠杠的。该片其实早在今天4月份就在印度与北美上映，也就是说上映时间早于《摔跤吧，爸爸》。国内的话，就算上映也不会有多少票房了，优酷上都可以看了，大众还会有几个愿意买单呢。","tags":[{"name":"movie","slug":"movie","permalink":"https://kangshanr.github.io/tags/movie/"}]},{"title":"得到直播：薛兆丰用经济学思维提升个人投资水平","date":"2017-08-24T00:04:38.000Z","path":"2017/08/24/薛兆丰：经济学思维与个人投资/","text":"得到直播：薛兆丰用经济学思维提升个人投资水平这里有直播的概要记录，也在最后有一些自己的思考。 中国经济会怎样？ 一个国家的经济会不会好？5个标准： 是否有一套完整的价值体系，过去30年中国改革开放的变化，一句话表述：由一个认人的社会变成了一个认钱的社会；一个认人的社会，社会资源的浪费会很大，一个认钱的社会会让社会的损耗降到最低。价格机制基本完善。 当中的制度让当中的人：一人做事一人当，别人做事别人当；每个人双手都放在自己的口袋里过日子。欧洲目前的难民危机：有一条难以接受，难民在欧洲领到救济，但不能工作。过去中国街头上有一群无所事事的年轻人，要成英雄用弹吉他、打架来定，但外资来了，工厂开过来了，这些一夜之间消失了。现在中国，每一个人，努力多一点，收获就多一点。年轻人上升的空间从来没有这么大，现在工作几年就可以独当一面，过去你想分到一套房要等到退休。 产权保护基于经济属性不基于物理属性。中国对共享经济、新兴产业的保护程度、接受程度比起欧洲好很多。日本做不通，劳动力贵。 政府是否有给新兴势力发展留有空间，新旧利益的交替是否顺利。Uber一兴起，社会的犯罪率就下降。人们对生活有了更多的期待。一碗水端平。 创新创业是不是受到保护。光看这些年国内举世无双的互联网、移动互联网产业，他们的兴起离不开整个社会体制的宽容与开放； 人机矛盾 人工智能来了，机器人带着大数据一路高歌猛进。人该怎么办？ 知识是集中不起来的，知识很重要，但生产一支铅笔的所有知识，没有人能完全弄懂的。这里面的知识是完全分散到各个人脑子里的，机器不能解决这个问题，人工智能不能把这样一个带着权重的任务处理好的。登山这个需求不是实际问题的解决方案，是人想要与人不同的人辛苦地做一件没有实际价值的事，人工智能只能派直升机把你送上去。 未来不可预测，为什么？社会的发展会受到知识的影响，人们的知识变化、想法变化，知识总在增长，知识的增量对人的影响也不可预测，哪怕人工智能已经来了，它也不可能预测的； 人的想像力是机器不能替代的。从数据到逻辑理论当中始终有一个迁跃，这里面不是一条连续的逻辑推演。计算机可以作出曲子来，但它永远不知道这首曲子好不好听。 比较优势原理，机器很多的地方，人很贵的。 人怎么办？人去学机器做不到的事。学耐用的知识：数学，学习学习的方法，保持对知识的好奇心；有了好奇心，这个世界到处都是平台给你学习，人跟机器互动。人工智能不能替代人，人工智能只会让人更有价值，蒸汽机只会让更多的工作机会产生； 投资身外物 当你有一笔可投资的钱，投在哪个地方？房产、比特币、股票、出国…… 买房目的：是用来自用还是投资。长久租金应该与产权费差不多，租售同权一出，买房的意义又少一些。你的需要是什么？中国的买房费用与租金相差3倍之多。人往哪儿挤？不是嘴上说的开门见南山的山清水秀之地，而是人聚积的大城市；聚积的好处：高楼成本很高，积聚一来，规模来了，细化分工，人的价值开始提升，周围地价就上升了。 博弈论：你想去的地方，别人也一样想去，你想得到的东西，别人也一样想得到，你能想到的好点子，别人一样也想得到；世界区分：物理的世界按过程一步一步来，每一步都按照固定规律来；经济的世界，人对世界的预期来决定世物的价格，人们事物的预测来决定价值，一切皆不可预测，一旦人们预测到了，这个东西就不再被纳入价格预测之中，价格不可预测，股市也不可预测；有没有内幕消息？会不会比别人早知道消息？没有，那么只买长线吧，看好一个国家一个公司肯定在未来上升的； 比特币，要成为货币还有很长一段距离。它有一个兴旺发展的过程，但这也是一个庞氏骗局的温床。击鼓传花的游戏中，谁来接这最后一棒？ 投资个人 对于自己的投资，更能掌控最可靠的投资方式 美国种族简历，所有人的收入统计起来，犹太人最富。地产会被外族收走，就投资首饰，首饰也被没收，就不得不选择知识、智力。 对知识的投资才是财富增长的根本原因。温度、资源都不是原因，人力资本才是改变个人改变世界的引擎； 学习各种各样的成功学，要记住别人的成功永远不可能复制过来的，永远不要忘记做自己手头能够做的事情。收入不均的问题， 不同的行业不同的人力有不同收入。用远大的目标来校正今天当下的行为。我们要追求的不是一刹那的幸福，不是当下的收入，而是一生幸福的总和，一辈子总收入。我们要看中二三十年后幸福收入总和。李嘉诚现在是赚很多钱，不是说当年他受过多少苦，他最让人佩服的是当年他在黑暗的隧道里眼前一样难以看到希望的时候，依然选择了努力，选择了学习。 后记：8/24/2017 10:02:53 PM 得到直播都是晚8点开始，这次薛老师一直讲到9点半，中途休息过两次都是讲得太久不得不喝口水休息一下，广告只在结束后小娴来拉的。 讲得很生动，听得我一直没有停下来过。听了之后开始反思这一段时间对自己的放松，这么长一段时间来自己对自己要求的降低，追求内心满足于小事，并不是让自信来源于自律，只来自于想像。 这个经济学课一开始就订阅了，刚开始的时候还听得挺认真，也有留言过，也有入选过一次精选，但后面开始学代码时，就没有抽时间来专门学习了，每天也只是在路上带着耳机听下，没有进行过深入思考。但具体反思一下，就算在开始认真听这个产品时，我也常常觉得这个还没学等待会有时间了就认真听一下，像故事中的狐狸一样，安慰自己只有在神奇岛上才能跳出最神奇的舞蹈，但别人都知道，我每天都踩在神奇岛的土地上。反观这个故事，其实狐狸也在骗自己，在某种天时地利下，自己可以跳出感动世界的舞，但这个行动一直没有实践过，也就导致了狐狸永远地看不到自己舞姿的拙劣，在各种小事中来获取满足感。这种心理机制的逻辑： 没自信面对自己失败的尴尬，导致一直把可能导致这种尴尬的情况给排开，并骗自己后面时机一到就亮绝活； 再在生活中找所谓的”小确幸“，并满足于这些众多的自嗨的”小确幸“； 直到无可挽回的地步时，就找到另外一个可以让自己隐藏自己可怜的实力点，再进入到第一步开始下一轮循环； 在这个死循环中，哪里一环可以被打破？每一环。每一环都应该提醒自己自信地面对自己，把手头的事做好就是打破魔咒的法宝。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"}]},{"title":"得到直播：打造工作方法","date":"2017-08-23T00:02:42.000Z","path":"2017/08/23/得到直播：打造工作方法/","text":"今天得到直播:打造工作方法有些启发，直播的一些记要与心得： 罗胖:打造工作方法 复制，任何行业，拿走的最多的红利的人不是最顶尖高手的人，而是专业力不错，但同时会复制传播的人，最直接简单的方式：写作，演讲； 怎么把成本覆盖掉，怎么把利复制？王石，任何一个麻烦找上我，我想法就是怎么让这个麻烦下次不再找上我； 正收益能不能复制？怎么提高自己的可复制性？ 三个字：确定性。 工作方法的高下就一点，能不能给确定性？ 能力的确定性； 靠谱与闭环，大家要知道你能力的边界，能力再小，网络中价值中都极大；老干妈，这个产品水平极高吗？不，但海外留学生都知道，想吃到中国味，老干妈一定没错；凡事有交待，件件有回应，不能成为反馈黑洞； 态度的确定性 态度不好拿，想得太多； 找到最基本简单的态度，坚持下去； 范围的确定性 每个人不管在什么层级，都是在创业； 时时刻刻要在所有人面前要表现，你在掌握全局； 思维： 上推，上推具体的操作到正式制度性抽象概念，高级餐厅的牛排旁边一定要放几朵西兰花，这样才显得高级； 下沉，你不是不写嘛，我来，你要觉得这个可以接受，那么我自己做点事，像水一样，把其他的地方勾勒出来，当对方接收到这个动作时，对方被水包裹后自然而然会被牵动； 最后有一段充满力量的话：王朔给女儿:（核心：把握自己，确定性；） 煲汤比写诗重要；自己的手艺比男人的重要；头发、胸、腰、屁股比脸重要；内心强大到混蛋比什么都重要； 在网上查了下，冯唐写这段话应该更早的，王朔应该是借用的冯唐的。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"}]},{"title":"科学思维看世间百态","date":"2017-08-23T00:02:42.000Z","path":"2017/08/23/卓老板：科学思维看世间百态/","text":"今天得到直播卓老板聊科技：用科学思维看世界运行的脉络，怎么看？直播的一些记要与心得： 科学思维三板斧： 等比缩放：WHO建议少吃糖，男性一天不超过28.5g，怎么算你的食物中有多少的糖？等比缩放。 把原来没有关系的两个事物放在自己能触及的地方； 比如：纳米和亿之间的关联怎么与你相关？ 我的身高是米，cpu的粒子是14纳米，我跟cpu就是亿倍关系。 滴答声一下是1秒，10亿意味着什么？就是32年。对于我们来说32年意味着什么大家肯定就有自己的概念了。 近似计算：通过简单地计算把一个问题定位到一个大概的范围，计算出一个大概的结果； 思维游戏问题：举国之电力，都由太阳能实现行不行？ 假如国家的财力无穷无尽，帝国时代游戏一般来设计我们太阳能？在沙漠中来铺开太阳能板 在高速公路两边的绿带铺开？下雨、阴天、维修，全国13万公里的高速公路， 近似计算鼻祖：费米，第一颗原子弹在内华达州的试爆，用纸片受远距离冲击波影响的飘距来近似计算爆炸当量（算得1万吨TNT当量，事后科学计算得2万吨），误差只有一倍（在质能方程中，估算当量误差往往很大） 对于陌生世界与陌生事物临到面前时，近似计算能力对于掌握新事物的到来很有帮助；平常生活中，这一项能力十分有用； 财务或其他对接事务时：不能有太多约束；比如，坟墓的占地在多久后会把人类居住地占完？但两代人后，人们不会对祖先的领地维护的。 建立模型：如果把人类的知识分类， 自下而上的知识，比如，考古，它的建立是一点一点地累积下来的，只能一块一块地拼图，最开始在边缘上找，再一点点往前推，在这个过程中，我们只能一点点积累证据，一点点接近真理； 自上而下的知识：流行病学，怎么传播，设定一些参数。建立一个模型，再用这个模型来推算其发展形态；如果生活中有问题能用一个模型来解释，那么就用这个模型来计算； 后记： 科学思维不能让你计算出未来事情准确发展动向，但能让你对事态的发展有一个大概地了解，不会一脸懞逼，而失去行事重心。 开始一场话之前，要对这场进行预判，在这场谈话中要达到什么目的； 如果这场话的目的在于让对方有一个很好的感受，那么在谈话过程中就尽量赞许对方，让对方流畅地表达出内心地骄傲； 如果要把自己突显出来，一定要话少，但一定要言必有物，每次场话有两三次谈话让别人印象深刻就很成功了。如果你的科学思维让你比别人看事物问题的角度更新颖开放，那么，一场谈话下来，很容易抓住这两个点让别人刮目相看。","tags":[{"name":"igot","slug":"igot","permalink":"https://kangshanr.github.io/tags/igot/"}]},{"title":"spring框架的学习","date":"2017-08-15T04:14:38.000Z","path":"2017/08/15/spring/","text":"spring配置beans的底层原理就在于通过封装好的解析xml类，将xml文件中配置好的bean实例出一个对象来，再通过配置实现bean之间的相互引用，而实现将要用到的bean（实用类）实例化并使用； Core模块 bean标签： id属性指定这个实例的唯一标识； class属性，用来指定这个实例的类定义； property子元素，指定这个对象的属性，比如：user对象中有属性name,那么这个这个user的bean对象就应该有一个子元素标签property，同时如果这个属性是另外一个本地的bean，name属性指向这个属性：&lt;property name=&quot;advice&quot; id=&quot;beanId&quot;&gt;直接使用id属性来引用到其他的bean的id就行； AOP模块 Aspect Oriented Programming,面向切面编程 切面Aspect:可以理解为模块，比如，读写数据库、权限检查、异常情况记录； Advice,增强：拦截器实现增强接口Advisor，不同的拦截器实现不同的增强接口，比如：方法前拦截器MethodBeforeInterceptor implements MethodBeforeAdvice{ //方法前拦截器 //调用对象的方法前将执行该方法。参数分别为被调用的方法、参数、对象 public void before(Method method, Object[] args, Object instance) throws Throwable{ System.out.println(&quot;即将要执行的方法：“+method.getName()); //如果是Service if(instance instanceof WaiterServiceImpl) String name = ((AopServiceImpl) instance).geName(); if(name == null)//检查是否为空 throw new NullPointerException(&quot;name属性不能为null&quot;); } method.invoke(instance,args); } } 拦截器，interceptor，也是pointcut的核心: spring拦截器的配置实现，通过增加配置：&lt;bean id=&quot;aopMethodBeforeInterceptor&quot; class=&quot;org.springframework.aop.supoort.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot;&gt; &lt;bean class=&quot;com.snail.aopdemo.advice.MethodBeforeInterceptor&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;mappedName&quot; value=&quot;withAop&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 从上面的代码可以看出： spring实现拦截器都是通过增强器Advisor，而这个增强器是一个代理，将参数（自定义的Advice）作为参数传入其中； 同时mappedName属性用来指定拦截的方法，这个方法并不是增加类中的方法，而是到时要执行到的所有的匹配方法名字段的方法； 同时：spring支持由正则表达式配置切入点：&lt;property name=&quot;patterns&quot;&gt; &lt;!-- 正则表达式配置切入点--&gt; &lt;list&gt; &lt;value&gt;.*get.*&lt;/value&gt; &lt;!--包含get字段的方法就被拦截&gt; &lt;value&gt;.*absquatulate&lt;/value&gt; &lt;!--包含absquatutulat字段的方法被拦截&gt; &lt;/list&gt; &lt;/property&gt; ORM模块 Object RelativeDatabase Mapping,对象关系型数据库映射 简介： 此模块对Hibernate/JDO/TopLink、iBatis等ORM框架提供支持； Spring提供在DAO层提供HibernateDaoSupport类与JDBCTemplate类； 在Spring里，Hibernate与SessionFactory等只是Spring一个特殊的Bean，由Spring负责实例化与销毁；所以也就不需要与Hibernate的API打交道，不需要开启关闭Hibernate的Session、Transaction，Spring自动维护这些对象； 实体类这儿用User类举例： 使用注解来让User中属性与数据库中表的列相关联； Entity类的注解： @Entity，表明这个类为实体类； @Table（name=”users”),指明此实体类与数据库users表相关联； 属性的注解： @Id，主键注解，表明这属性为数据库表中的主键 @GeneratedValue（strategy=GenerationType.IDENTITY),指明该主键生成策略为自增 @Temporal（value = TemporalType.Date),表明列属性为Date DAO层接口，不同的Entity对应不同的DAO接口： UserDao接口，就定义对User表的操作：public interface UserDao{ public void saveUser(User user); public List&lt;User&gt; findUsers(); public int getCount (); public User findUserByName(String name); } UserDao接口的实现类，UserDaoImpl： 这个实现类要继承HibernateDaoSupport类，这就意味着从父类继承了Hibernate与HibernateTimplate对象，该对象就对实体对象进行各类操作；public class UserDaoImpl extends HibernateDaoSupport implements UserDao{ //实现接口中的方法 public void saveUser(User user){ this.getHibernateTemplate().persist(user);//使用父类方法get到Template,并调用其persist方法将user存入 } } public int getCount(){ //查询记录条数 Number num = (Number)this.getSession(true).createQuery(&quot;select count (*) from User).uniqueResult(); return n.intValue(); } public List&lt;User&gt; findUsers(){ //查询所有的user return this.getHibernateTemplate().find(&quot;select * from User&quot;); } public User findUserByName(String name){ //根据用户名查询用户 List&lt;User&gt; users = this.getHibernateTemplate().find{&quot;select * from User u where u.name=?&quot;, name); //使用Template if(users.size() &gt; 0) return users.get(0);返回第一条 return null; } } 从上述代码例子中可以看出： 查询(Read)、创建(Create)都由父类HibernateDaoSupport提供的getHibernateTemplate方法获取到实例并执行实例的方法来实现，其中查询使用实例方法find(String sql, Stirng 拼接String），而save则用持久化方法persist(Object user); 当要涉及到数据库计算时，则用getSession获取到与数据库的会话对象，让会话对象执行sql统计语句； 同时，所有sql语言的操作对象都指向实体类，而没有对数据库中的表进行组织sql语句； 个人理解：spring通过封装Hibernate在框架中，让DAO接口的实现类继承HibernateDaoSupport尖，就将Hibernate对象创建出来，而直接操作这个对象的方法来获取session/Hibernate对象直接与数据库交互，而就节省了操作JDBC的代码； 配置集成Hibernate 在spring的bean.xml文件中配置集成hibernate到目前这一步只需要配置三个bean： 数据源datasource，这是一切的基础，所有的操作最终都会落到对数据库的操作上；&lt;bean id=&quot;datasource&quot; class=&quot;org.apache.commonsdbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; class=&quot;org.gjt.mm.mysql.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc\\:mysql\\://localhost\\:3306/ssh&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;propery name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; - 数据源的配置就是用依赖包中的一个封装好的类（这儿就是BasicDataSource）的对象，并将这个对象的属性值配置好，这些属性就包括了数据库的驱动、连接的url、连接数据库的用户名、密码。可以想象的是，这个处理数据库的对象封装了所有的连接数据库的方法，使用密码与用户名，交给驱动对象，这个驱动对象就按照提供的url连接到主机上的数据库，并登录到数据库； 有了数据源，就可以将关联连接库的数据源配置到sessionFactory中去：&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.annotation.AnnotationSessionFactoryBean&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;dataSource&quot;&gt; &lt;ref bean=&quot;dataSource&quot;/&gt; &lt;property/&gt; &lt;property name=&quot;annotatedClasses&quot;&gt; &lt;list&gt; &lt;value&gt;com.woniuxy.orm.class_qulified_name&lt;/value&gt; &lt;/list&gt; &lt;property/&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;pros&gt; &lt;pro key=&quot;hibernate.dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/pro&gt; &lt;pro key=&quot;hibernate.show_sql&quot;&gt;true&lt;/pro&gt; &lt;pro key=&quot;hibernate.format_sql&quot;&gt;true&lt;/pro&gt; &lt;pro key=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/pro&gt; &lt;/pros&gt; &lt;/property&gt; &lt;/bean&gt; 配置会话工厂（因为我们的实体类使用的注解映射，所以就使用注解会话工厂AnnotationSessionFatoryBean)其中包括了：数据源、实体类还有hibernate,而hibernate的配置就包括了方言、输出sql语句、格式化sql语句、创建表结构 有了会话工厂，距离操作数据库就只有让Dao配置为bean，而操作代码就getBean来获取到这个Dao的实例，让这个实例来操作数据库：&lt;bean id=&quot;userDao&quot; class=&quot;daoImpl_qualified_name&quot;&gt; &lt;property name=&quot;sessionfactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; 在Dao的bean中，将前面配置好的sessionFactory装配到其中 以上情况是实体类User是使用注解来配置的，这种情况下，使用的sessionFactory是AnnotationSessionFactoryBean,但当实体类是使用xml文件来配置时，使用的配置bean应该是LocalSessionFactoryBean。同时，sessionFactory中配置实体的方式也变成：&lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:entiteis_配置文件的路径&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; Hibernate的事务管理 分层的做法：应用层调用Service层，Service层对数据进行检查（是否重复之类），然后Service层（注入一个Dao属性）调用Dao层，Dao层调用Hibernate实现数据的操作。原则上不允许跨层访问，业务层次分明。 事务管理transaction，对应的层为Service层； spring的bean.xml配置文件的理解 所有的操作都基于对数据库的crud，所以所有的配置都围绕着操作数据库； 所以，第一个bean的是数据源：dataSource 其中的属性就包括： 连接数据库的驱动：driverClassName 数据库连接url:url 数据库连接用户名：username 数据库连接密码：password 通常情况下，我们把数据源信息都单独分离在jdbc.properties文件中，并在要用到的配置文件中将其配置为上下文&lt;context:property-placeholder&gt; location=&quot;classpath:jdbc.properties/&gt;，之后就可以在数据源dataSource中配置其中的属性：&lt;property name=&quot;driverClass&quot; value=&quot;${driver}&quot;&gt;&lt;/property&gt; 第二个配置的bean：sessionFactory 这儿就把上一次配置好的dataSource数据源装配到sessionFactory的属性中：&lt;!-- 配置本地会话工厂bean --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 指定hibernate配置文件--&gt; &lt;property name=&quot;configLocations&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt; &lt;!-- 指定hibernate映射文件--&gt; &lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:mappings/*.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; Note:这儿配置spring的sessionFactory属性就会把Hibernatek r sessionFactory属性覆盖； configLocations属性：将指定路径的配置文件都加载进去，相应的LocalSessionFactoryBean中的的此属性的setter方法的参数为可变参数:public void setConfigLocations(Resource... configLocations) { this.configLocations = configLocations; } 而在上述代码中，hibernate的配置文件也直接引入到sessionFatory中来，而在外部的hibernate配置文件： &lt;session-factory&gt; &lt;!-- 配置方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- session上下文控制权:交给session来控制 --&gt; &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;org.springframework.orm.hibernate5.SpringSessionContext&lt;/property&gt; &lt;!-- 格式化sql语句 --&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 显示sql语句 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 表的生成策略 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;/session-factory&gt; 其中配置了部分的Hibernate属性，同时也可以配置c3p0的属性在其中； 第三个配置：事务管理器transactionManager 将前面配置好的sessionFactory装配到这个bean中，作为sessionFactory属性值； 第四个配置：tx:advice，配置事务的传播特性，指定具备事务的方法名； &lt;!-- 事务配置增强 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txMng&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;batch*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;load*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;!-- 统配 --&gt; &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 最后一行统配就指定了所有的方法都配置上事务，同时isolation指此事务的隔离级别，propagation指事务的传播属性，read-only指是否为只读； 第五个配置aop:config，配置事务的切入点，以及被管理的对象&lt;aop:config&gt; &lt;aop:pointcut id=&quot;interceptorPointCuts&quot; expression=&quot;execution(* com.woniuxy.sshdemo.service.impl.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;interceptorPointCuts&quot;/&gt; &lt;/aop:config&gt; 先将切面的切点配置进来，也就是各个service的执行对象。再将这此切点配置到advisor中 其它的配置： dao的执行类，配置一个id加上sessionFactory; service的执行类,配置上dao这个属性的对象； 使用注解来实现事务的配置 这时bean.xml： 数据源不变 sessionFactory不变； 事务管理器trasactionManager依然不变； 变的是：添加一个事务注解驱动tx:annotation-driven trasaction-manager=&quot;transactionManager&quot;/&gt;，添加这个驱动配置后，对产生事务的类添加注解@Transactional，标记这个类为事务类，对其中的事务方法添加注解@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)注解（标明了这个方法的隔离水平与传播水平）。这样的注解就取代了上面例子中tx:advice与aop:config两个配置节点的功能；","tags":[{"name":"framework","slug":"framework","permalink":"https://kangshanr.github.io/tags/framework/"}]},{"title":"原创小段子之人物没原型","date":"2017-07-25T17:04:38.000Z","path":"2017/07/26/原创小段子—人物没原型/","text":"一个来自张姑娘的小故事： 暑假了，女儿欢欢喜喜大学归家。到了家门，嗲声嗲气叫：爹。。。娘。。。 爹娘笑嘻嘻看了女儿两眼后，转过头去：关于生活费，你能不能把买吃的和买穿的比例对调一下。。。","tags":[{"name":"tale","slug":"tale","permalink":"https://kangshanr.github.io/tags/tale/"}]},{"title":"Java多线程","date":"2017-07-14T04:04:38.000Z","path":"2017/07/14/java多线程/","text":"线程安全 在一个运行程序中，当另外一个线程对这个程序发起请求时，相当于重新执行其中方法，但一个类中某些属性在程序执行过程中需要保持状态的统一性，这时就需要在一个线程执行完毕后再让另一个线程执行相关的方法。这就需要实现线程安全； 实现线程安全的方法： 将方法修辞为线程安全的方法（加上修辞符synchronized)：public synchronized void doPay(int money){ if(balance &gt;= money){ balance -= money; }else{ system.out.println(&quot;你的余额不足！”） ｝ system.out.println(&quot;你的余额为：“+balance); } 使用同步块：synchronized(Object object){ //要同步的代码块 ｝ 实现同步机制是基于”监视器“这一概念，java中所有对象都拥有自己的监视器，加上同步锁，就是让这个对象进入监视中；","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"java底层之引用","date":"2017-07-13T04:04:38.000Z","path":"2017/07/13/符号引用与直接引用/","text":"直接引用与符号引用JVM运行类加载后， 在类的解析阶段，JVM会把类的二进制数据中的符号引用替换为直接引用。 符号引用：Symbolic References 以一组符号来描述 所引用的目标，而这个符号可以是任何形式的字面量，只要使用时可以无歧义定位到目标即可。 存在的原因：在编译阶段，java类并不知道所引用类的实际地址，只能使用符号来表示类的地址。而且在不同JVM实现的内存地址也不尽相同，经过符号引用这一道工序，同一个类，其符号引用必然一致。 类在解析过程中，就根据JVM实时产生的内存分配状况，将符号引用转为直接引用； 直接引用：Direct References- 直接引用是和虚拟机的布局直接相关的，同一个符号引用在不同的JVM上翻译出来的直接引用也不尽相同。某个目标有了直接引用，那说明这个目标已经被加载到内存中了 直接引用可以是： 直接指向目标的指针（如，指向类型class对象、类变量、类方法的直接引用就是指向方法区的指针）； 相对偏移量：如指向实例变量、实例方法的直接引用都是偏移量； 一个能直接定位到目标的句柄；","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"项目开发模型","date":"2017-06-22T18:14:38.000Z","path":"2017/06/23/项目开发流程/","text":"瀑布模型：(政府银行类项目） 工程开发流程： 需求分析（提出一个idea）； 可行性分析（看目前条件下是否能实现这个idea）； 总体分析：通过可行性分析后，用哪些工具包进行开发； 详细设计：当前要用哪些工具，详细的模板功能，甚至每个功能实现变量方法的名称都定下来； 垒代码：完成模板； 测试:（分系统测试，单元测试，看划分力度），带着测试去编程，bug更，性能更佳； 上线： 迭代螺旋模型：（阴阳师） 开发流程： 先出来一个粗糙模型原型，马上上线，抢占市场； 马上一次迭代，小步快跑，每一周就可以迭代一次，不停地壮大；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"Hibernate","date":"2017-05-22T18:04:38.000Z","path":"2017/05/23/Hibernate/","text":"Hibernate是一种ORM（Object Relative-Database Mapping)框架，用于与各种数据库、SQL语句打交道，是数据持久化的一咱解决方案； ORM，是在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象，一般这个对象就叫做POJO（Plain Ordinary Java Object）； OEM框架与MVC框架不同，使用范围也截然不同，类似功能的框架还有SUN的JDO、Apache的Mybatis与OpenJPA等；","tags":[{"name":"framework","slug":"framework","permalink":"https://kangshanr.github.io/tags/framework/"}]},{"title":"hexo+github=your website","date":"2017-01-22T18:04:38.000Z","path":"2017/01/23/hexo+github=website/","text":"在学习使用hexo过程中的笔记，大部分来自于hexo官方网站的文档介绍；还有搭建网站过程中，参考了不少其他站主的文章：小茗的搭建网站博客使用blueLake的教程生成新浪微博秀； hexo generate 根据已提供的md文件资料生成静态网页，放在public文件夹中； hexo generate –watch 对比查看文件的改动，只有当文件改动被审查过才会执行generate命令生成静态网页； hexo generate –deploy与hexo deploy –generate 两者效果一样都在generate后执行布置命令deploy 新建md文档：hexo new [dir] filename 使用这个命令生成md文档时，当指定其生成的目录为_draft时，hexo会自动将文档的头加上： --- title: hexo+github=your website date: 2017-01-23 02:04:38 --- 而当指定目录为_post时，其效果会加上标签： --- title: hexo+github=your website date: 2017-01-23 02:04:38 tags: --- 但是全部的信息包括： --- title: hexo+github=your website date: 2017-01-23 02:04:38 categories: 默认分类 #分类，这一点用到的地方不少，*善用分类与标签* tags: [tag1,tag2,tag3]#文章标签，可空；使用多标签时，将`[]`符号带上，并且标签之间用`,`分开 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 --- 生成md文档还有另外一个命令：hexo new page newpage 与上一个命令不同之处在于：生成的md文件放在了根目录而不会放在source/_post中，而会在source文件夹中生在一个newpage的folder，并在其中生一个index.md，且这个md文档的title会被设置成newpage，也就是生成了这样一个页面，而这个页面并未在网页目录中，但我们就可以好好地设置这个页面用于在其他的文档引用； 实现readmore:在任何你想要预览到此的位置加上标签&lt;!--more--&gt;，即可实现； 使用过程中摸索的小问题： 每次部署前generate一次就把public中的所有文件先覆盖了，而这样再deploy时就把github远程上资料全部覆盖，这样在github上添加readme都会被覆盖，也就导致了远程机上没有自定义的东西全是生成好的，而且每次一部署都会将先前的重新生成一次再覆盖，感觉造成了许多资源的浪费也很自定义自己想要的网页效果，问题就在于可不可以每次只生成新的资源，再只将新的资源push到master branch上，或者push到其它的branch上，再merge到一起，只要生成新的资源时不会与老资源冲突，也就能达到效果。 在landscape主题中，据观察也只变化了首页index.html与相应的日期的folder,其它的folder与file都没有改变，所以上述的方法是可行的； 但是，这样操作还有一个问题需要注意，新生成的网页的目录结构都还在，这就需要把新生成的目录结构给拷到之前已存在的目录中，并在这个添加了新网页的目录中push； 实验失败：8/25/2017 7:52:15 AM 将新的几个md文件放在source文件夹下面的_post中生成新的页面并添加在github的仓库中push上去，网站上并没部署这几个新的页面（仓库中已经有这几个新的页面的html了）； 所以，还是用最暴力的方法更新，每次重新生成整个仓库的资源，将整个仓库资源deploy到github上； 调整整个背景颜色与图片的信息： 进入到相关的主题folder中，再依次进入source--&gt;css--&gt;style.styl，打开这个文件，找到body在这个级别下就有各种配置参数可以调整，包括了background: color_value url(图片路径) 每新建一个hexo目录（也就是说当你在其它托管网站上新建一个项目时）在这个hexo目录中依然要执行上面安装所有的插件到hexo中，比如安部署器deployer：npm install hexo-deployer-git --save","tags":[{"name":"hexo,github","slug":"hexo-github","permalink":"https://kangshanr.github.io/tags/hexo-github/"}]},{"title":"快速排序算法","date":"2016-12-03T04:54:38.000Z","path":"2016/12/03/快速排序算法的理解/","text":"今日所得 今天复习了下快速排序（使用递归），据说是效率最高的一种排序算法（相比于冒泡排序、选择排序）； 之前学习C#时领教过，当想把这个算法迁移到java中来写一个时发现久了不练都手生了； 前面多次使用递归的算法写一些方法（诸如二分法查找已经排好序数组元素的索引、递归生成满足条件（非纯数字或字母）的字符串；使用多次但没有想到过使用递归时可以无返回值； 二分排序时，必须使用无返回值的递归方法。因为二分之后返回的是数组的一部分，最后把这一部分返回给递归前方法，这时要接收这一部分的元素需要对这一部分进行遍历； 二分法排序(升序，若要降序则相反）流程： 把数组第一个元素作为中间值，从最大索引(这个还必须从后往前找，因为我们用的第一个元素作为中间值，如果从前往后找，第一个较大值会直接覆盖最大索引的值；所以，如果想实现从前往后找就得把最大索引元素值作为中间值)开始往前找，找到比这个间值小的元素就把这个值赋予给最小索引的元素； 再从最小索引元素开始往后找，找到这中间值大的元素，把这个元素值赋予给最大索引处的元素（找的过程不满足条件就把索引依次自增或自减）； 依次这样后面往前找一趟，前面往后找一趟，直到最大与最小索引相等。这时把中间值赋予给这个索引，这样就完成了一次把数组分成两个部分，前面部分值比中间值小，后面部分比中间值大； 这用上面一套流程对中间值两边的元素进行递归操作，递归缺口就是数组操作部分只有一个元素； 代码：public int getPivotIndex(int[] arr, int minIndex, int maxIndex){ int pivot = arr[minIndex]; while (minIndex &lt; maxIndex) { while (arr[maxIndex] &gt;= pivot &amp;&amp; minIndex &lt; maxIndex) { maxIndex--; } if(minIndex != maxIndex){ arr[minIndex] = arr[maxIndex]; } if(minIndex != maxIndex){ arr[minIndex] = arr[maxIndex]; } while (arr[minIndex] &lt;= pivot &amp;&amp; minIndex &lt; maxIndex) { minIndex++; } arr[maxIndex] = arr[minIndex]; } arr[minIndex] = pivot; return minIndex; } *二分法排序的流程 * @param arr * @param minIndex * @param maxIndex */ public void dichotomySort(int[] arr, int minIndex, int maxIndex){ if(minIndex &lt; maxIndex){ int index = this.getPivotIndex(arr, minIndex, maxIndex); dichotomySort(arr, minIndex, index - 1); dichotomySort(arr, index + 1, maxIndex); }else{ return; } } 二分法排序算法核心在于每一次查找把中间那一个值给定下来，并对中间值两边的数组分别再次排序,再对两边的数组分别进行同样的操作，直到不能再分割;","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"关于“上火”的科学点子","date":"2016-11-23T04:04:38.000Z","path":"2016/11/23/关于“上火”的事/","text":"所谓上火：现代医学中并没有“上火”的概念。 而现实生活中，我们的“火”是从哪儿上来的呢？ 吃辣上火： 我们对吃辣上瘾的原因在于，辣椒刺激口腔内部产生类似灼烧的感觉，而这种感觉会促使大脑分泌多巴胺（多巴胺是人产生快感的来源，人类大部分上瘾行为都和它相关），从而上瘾； 因为辣椒素残留口中，持续对口腔刺激。吃辣后，刷牙漱口就行了； 吃爪子上火： 瓜子本身并不会让你上火，让你不舒服的原因在于瓜子外壳上的脏东西。不信的话，下次吃瓜子只买瓜子仁吃，看会不会上火。","tags":[{"name":"tips","slug":"tips","permalink":"https://kangshanr.github.io/tags/tips/"}]},{"title":"java编程中你不知道的一两点","date":"2016-11-23T04:04:38.000Z","path":"2016/11/23/关于Java你可能不知道的两点/","text":"Java中，你不知道的一两点 关键字new是运算符: 我们都知道new是用来开辟并新的内存空间创建对象的，但大多不知道这个功能是由运算符来实现； 运算符（type）： 强制类型转换，括号中加类型，强制类型转换，它也只是个运算符 运算符instanceof： 二元布尔运算符，前跟实例名后跟类名，判定实例是否可以用此类接收； 成员访问符“.”，访问类或实例的成员； 方法调用()，除了用于强制运算顺序，括号还用于调用方法；","tags":[{"name":"java","slug":"java","permalink":"https://kangshanr.github.io/tags/java/"}]},{"title":"springMVC","date":"2016-08-20T05:29:17.000Z","path":"2016/08/20/springMVC/","text":"核心对象：中央处理器：在web.xml中配置springmvc的servlet12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中load-on-startup这个属性来指定这个中央处理器被初始化的时机： 当为负数时，只有第一次使用时才会初始化，这也就带来一个问题，第一次访问时就会慢一些； 当为非负数时，中央处理器会在servlet容器启动时初始化，而这个数值就是初始化的顺序； 核心对象： 页面控制器，处理请求并给出响应； 处理器映射器HandlerMapping：设置handler处理器与url资源的映射 使用BeanNameUrlHandlerMapping这个类时，就会将handler的name属性值作为url映射，访问这个处理器就填写其name属性值:&lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController&quot;/&gt; 如上，就可能过name属性值，设置 &lt;a href=&quot;loginController.do&gt;登录&lt;/a&gt; SimpleUrlHandlerMapping，这个类型的映射要求映射url与controller的配置id相对应，并在这个节点内将controller的id与生意人key对应起来；&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!--配置指定的url与bean的id映射,可添加多个--&gt; &lt;prop key=&quot;/login.do&quot;&gt;login&lt;/prop&gt; &lt;prop key=&quot;/login2.do&quot;&gt;login2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;login&quot; name=&quot;loginController.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController&quot;/&gt; &lt;bean id=&quot;login2&quot; name=&quot;loginController2.do&quot; class=&quot;com.woniuxy.springdemo.controller.LoginController2&quot;/&gt; 使用注解实现处理器与url的映射&lt;!-- 注解映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; 这个配置节点就决定了处理器与其中的方法可以被注解@RequestMapping（”url_name”）映射并指定url 处理器适配器：HandlerAdapter，用于规定处理器的编写规则 使用接口来配置适配器： 当指定为SimpleControllerHandlerAdapter时，它就规定了要想成为处理器，就要实现Controller这个接口； HttpRequestHandlerAdapter:这个适配器要求所有的Handler都必须实现HttpRequestAdapter接口； 使用注解实现配置适配器：&lt;!-- 注解适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; 这个配置节点就决定了，有@controller注解的类就是处理器 在spring-webmvc包中web_servlet包中最后有一个配置文件DispatcherServlet.properties，这个文件就规定了springmvc的默认核心对象； springMVC中的处理器 controller: 中央处理器DispatcherServlet在web.xml中被配置成一个servlet,并通过初始化上下文配置参数springmvc.xml的路径与设置其启动时机与该servlet初始化时机； 1234567891011121314 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 通过上一步实现来自前端请求必须都通过web.xml文件中指定的servlet处理，也就是大部分请求都是交给了springmvc，所有的springmvc的配置都在springmvc.xml文件中，在这个文件中，我们常常通过注解来实现请求与处理器（处理器中的方法）的映射。 springmvc.xml配置中就指定了适配器映射，使用@Controller注解就让该类成为处理器 @RequestMapping(“url_name”)则用来指定url路径，可以用来注解类与类的方法，想要请求进入处理方法中就要通过类的url与方法的url; 注解使用时映射的方法中，可以与前端数据相通的参数有： 简单数据类型 pojo，这种情况下，pojo对象的属性名要与请求的参数名保持一致；比如，user.username User.password session/request/response：用法与之前一致，可以用分发请求也可以重定向； Model/ModelAndView： 也可以为String类型的参数，只要参数名与来自前端的请求名一致，容器会自动将其注入到方法参数中； 注解@RequestParam的使用： 其中有参数： name:用于配置参数的别名，使用这个属性就可让请求url使用别名来访问到这个方法； required：boolean类型，当其值为true时，请求必须带有这个参数； 使用controller处理器时，各类方法返回数据类型： ModelAndView，此对象中可以添加model数据（addObject（String name,Object object)方法），也可以指定view（通过setViewName(String name)方法，而这个name也就决定了去到哪个jsp视图） String 字符串：当要在使用映射方法处理之后想到转到另外一个方法中去(不进入视图）则直接返回字符串”response:+方法映射”； “forward:+方法映射”，转发到相应方法中去，与response不同在于地址栏还是原来的地址，转发并没有执行新的request与response，而是和转发前的请求共用一个request与response，所以转发前的属性在转发后一样可以读取到； Restful架构 只是一种规范，终极的目标是资源URI","tags":[{"name":"framework","slug":"framework","permalink":"https://kangshanr.github.io/tags/framework/"}]},{"title":"设计模式","date":"2016-06-13T04:14:38.000Z","path":"2016/06/13/设计模式/","text":"Design Pattern，对于编程过程中遇到各种问题的总结与归纳，是编程（通常为面向对象）过程诸多问题的优秀解决方案；菜鸟教程相关网页：http://www.runoob.com/design-pattern/design-pattern-intro.html Gang of Four，四人帮提出设计模式的设计原则： 对接口编程而不是对实现编程； 优先使用对象组合而不是继承； 简介： 共23种设计模式，分为三类： 创建型Creational Patterns： 结构型Structural Patterns: 行为型Behavioral Patterns: 单例模式 对于管理类，通常只需要一个实例对象即可达到管理的目的，这种时候如果实例多个对象只会千万资源上的浪费，所以通常我们使用单例模式来解决这种问题； 实现单例的思路： 将构造函数私有化，并在类中实现静态单例的共享；public class UserManager{ //静态单例 private static UserManager ins; //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ ins = new UserManager(); } return ins; } //其他的执行方法 public void updateUserInfo(){} ｝ 上面例子里有个线程上的缺陷，当多线程访问这个管理类时，会造成线程不安全，为解决这个问题，就得使用双重检查锁单例：public class UserManager{ //静态单例 private static UserManager ins; private Object lock = new Object(); //私有化构造函数 private UserManager(){} //获取静态单例的方法 public static UserManager getIns(){ if(ins == null){ //第一次检查 synchronized(lock){ //保证不产生多余的实例 if(ins == null){ //第二次检查 ins = new UserManager(); } } } return ins; } //其他的执行方法 public void updateUserInfo(){} ｝ 代理模式 代理模式：与工厂模式不同在于，可能产生多个实例，同时会帮Action做事； 代理模式就是将要实例的对象通过代理类来实现，不通过原本的类来实例，具体实现可以让让代理类同时实现真正想的对象的类实现的接口，而在代理类中有一个真正类的属性，当想要这个真正类时，对穿上属性判空，再实例化，这样通过代理类执行接口中的方法时就是执行的真正想要的类的方法了； 工厂模式 生成一个类交由相关的工厂类实现，而不由直接的类来实现； 相关的类继承同一个接口，实现这个接口的类都可以由工厂类中同一个方法来实现实例化； 例如： //定义同一个类的抽象接口 public interface Shape{ void draw(); } //实现shape接口的类有： //Circle类 public class Circle implements Shape{ @Override public void draw(){ system.out.println(&quot;circle.draw&quot;); } } //Square类 public class Square implements Shape{ @Override public void draw(){ system.out.println(&quot;square.draw&quot;); } } //创建实例的工厂类 public class ShapeFactory{ //创建图形实例的方法 public Shape createShape(String shape){ if(shape.equalsIgnoreCase(&quot;CIRCLE”){ return new Circle(); } if(shape.equalsIgnoreCase(&quot;SQUARE”){ return new Square(); } reutnr null; } } 模式理解： 通过工厂来实现对各个类的实例化，都在工厂实现； 通过反射机制实现，增加一个同一接口的类不需要改变工厂的代码,只需要增加一个实现这个实现对应接口的类： 其工厂的代码：public class ShapeFactory{ //创建工厂的方法 public Shape createShape(Class&lt;? extends Shape&gt; clazz){ try{ return Class.forName(clazz.getName()).newInstance(); }catch(Exception e){ e.printStackTrace(); } } } 抽象工厂模式 相比较于工厂模式，抽象工厂模式在工厂模式的基础上增加生成工厂的工厂类，那么生产出来的工厂都要继承一个接口或父类，没理解到的点就在于，这个类一定要是一个抽象类吗？可以是个接口或者非抽象类吗? 该模式的优点：把同一个产品类集成到同一个工厂内，这样使用时就直接调用工厂中的方法，而生成同一个工厂里预备好的类对象，也更方便管理； 未完待续","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"数据结构与算法","date":"2016-05-03T11:04:34.000Z","path":"2016/05/03/数据结构/","text":"通俗地理解，数据结构就是数据在内存中存入的结构。语言中的各类集合就是对数据结构的实现。 这其中包括了物理结构与逻辑结构； 物理结构又叫存储结构： 包括了顺序物理结构，数据元素存放在地址连续的存储单元里，数据元素之间的物理关系与逻辑关系是一致的（逻辑结构上是一对一？）（数组）； 链式物理结构，数据元素分散在任意存储单位，可以不连续，前后用指针关联； 逻辑结构：反应数据之间逻辑关系的数据结构，表示数据之间前后关系，与数据在内存中的存储位置无关； 集合结构：数据元素同属一个集合，他们之间并列，没有其他关系； 线性结构：数据元素之间一对一的相互关系； 树形结构：数据元素之间存在一对多的相互关系； 图形结构（网状结构）：数据元素存在多对多的关系； 参考博客 个人理解： 目前在编程语言学习中接触到的集合各类中的元素之间逻辑关系都是的集合结构，包括字典、列表，它们其中的元素之间只有并列关系，没有其他任何关系； 而在集合元素内部的属性关系（键值对）是一对一的线性结构（一个键对就一个值）； 数组是一个典型的顺序物理学结构，且其逻辑结构是一对一； 实例与实例的成员关系在逻辑上是一对多，一个实例对应了多个成员；方法与方法执行块，参数，都是一对多的树状逻辑关系；","tags":[{"name":"programming","slug":"programming","permalink":"https://kangshanr.github.io/tags/programming/"}]},{"title":"markdownPad使用攻略","date":"2015-04-29T04:54:38.000Z","path":"2015/04/29/markdown使用攻略/","text":"说明：这是一篇在使用markdown记录笔记过程中自己总结一些使用小技巧； 首先来一个： 官方的使用说明 包括了常用的快捷键使用： Welcome to GitHub Pages You can use the editor on GitHub to maintain and preview the content for your website in Markdown files. Whenever you commit to this repository, GitHub Pages will run Jekyll to rebuild the pages in your site, from the content in your Markdown files. MarkdownMarkdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for 123456789101112131415Syntax highlighted code block# Header 1## Header 2### Header 3- Bulleted- List1. Numbered2. List**Bold** and _Italic_ and `Code` text[Link](url) and ![Image](src) Shortcut: Bold (Ctrl+B) and Italic (Ctrl+I) Quotes (Ctrl+Q) Code blocks (Ctrl+K) Headings 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) Lists (Ctrl+U and Ctrl+Shift+O) Timestamp(Ctrl+T) Horizontal Rule(Ctrl+R) For more details see GitHub Flavored Markdown. Jekyll ThemesYour Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings. The name of this theme is saved in the Jekyll _config.yml configuration file. Support or ContactHaving trouble with Pages? Check out our documentation or contact support and we’ll help you sort it out. 新得到的小点子诸多功能：为知笔记中提供的一些功能，其中包括了表格的实现等没怎么用到但很实现的功能； 其他在使用过程中摸索出来的小点有： 段落：一级段落使用一个“&gt;”符号，以此类推，二级就用”&gt;&gt;”，三级就用“&gt;&gt;&gt;”，可以有n多级；得注意的是，这种格式经过hexo生成后在网站上显示为水平居中，字体放大一号，同时左边并没有段落的竖线； 插入链接：[百度](http://www.baidu.com &quot;百度一下&quot;)示范一下：百度，可以看到[]中放的是显示的字符串，()里放的是url与提示；注意，各个标识符都是小写状态，快捷键ctrl+l； 想要插入代码: 在&lt; pre &gt;标签中插入代码:这儿就是插入pre标签后的效果 在每一行代码前插入三个table符，记住是每一行代码都要在前面加上三个table符； 快捷键ctrl+k,这种方式适合短小的单行代码，因为一旦换行，就打破了代码块；","tags":[]},{"title":"html_base标签","date":"2015-03-25T07:39:42.000Z","path":"2015/03/25/html-base标签/","text":"简介：用于规定页面上所有的链接的默认URL和默认目标：&lt;base href=&quot;http://……“ target=&quot;_blank&quot;&gt; base标签放在标签之中; 最好把base标签排在head标签中第一个元素，这样其它的元素就可以使用base元素的信息； 一个文档中最多能使用一个base元素； 如果使用了base标签，至少要具备href属性或者target属性其中一个； 其中的元素： href：规定页面中相对链接的基准URL，其值就是一个URL; target:规定页面中所有的超链接和表单在何处打开，但该属性会被每个单独的链接中的target属性所覆盖，其值包括： _blank，打开新的页面 _ parent，在父页面打开 _self，在当前页面打开 _top，在浏览器头页面打开 framename base标签支持的属性 支持HTML的全局属性，如：class,id,style等 不支持事件属性，如:onClick之类；","tags":[{"name":"html","slug":"html","permalink":"https://kangshanr.github.io/tags/html/"}]},{"title":"meta标签.md","date":"2015-03-23T06:41:48.000Z","path":"2015/03/23/meta标签/","text":"标签简介： 位于文档的头部标签之中，不包含任何内容； 所有的信息都由属性来存储，包含了文档的名称/值对； 其作用：搜索引擎优化（SEO)，定义的页面使用语言，自动刷新并指向新的页面，实现页面转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口； meta属性（就两个）： name属性： 用于描述网页与之对应的属性值为content,其中的内容便于搜索机器人查找和分类信息用； 其语法格式：&lt;meta name=&quot;参数“ content=&quot;具体的参数值&quot;&gt; name属性有以下几种参数： Keywords，用来指定关键字&lt;meta name=&quot;keywords&quot; content=&quot;meta总结、html/meta、meta属性、meta跳转”&gt; desription，网站内容描述 robots,机器人向导 author，标网页的作者 generator，代表说明网站采用的什么软件制作 COPYRIGHT,版权信息 revisit-after,代表网站征文，7days代表7天 http-equiv,相当于文件头作用，可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content,其中的内容就是各个参数的变量值；&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值”&gt; Expires，期限，设定的到期时间，一旦网页过期，呢额胆固醇服务器上重新传输。（必须使用GMT的时间格式化） Pragma（cache模式） 禁止浏览器从本地计算机的缓存中访问页面内容&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;no-cache&quot;&gt; 这样设计，说教将无法脱机浏览 Refresh(刷新），自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot;content=&quot;2;URL=http://www.haorooms.com&quot;&gt; //(注意后面的引号，分别在秒数的前面和网址的后面) Sett-Cookie(cookie设定），如果网页过期，存盘的cookie将被删除&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt; 必须使用GMT的时间格式 Window-target(显示窗口的设定），强制页面在当前窗口以独立页面显示&lt;meta http-equiv=&quot;Window-target&quot;content=&quot;_top&quot;&gt; 用来毕业后公开了我在框架里调用自己的页面 content-Type，设定显示字符集&lt;meta http-equiv=&quot;content-Type&quot;content=&quot;text/html;charset=gb2312&quot;&gt; meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文； BIG5:繁体中文； iso-2022:日文； ks_c_5601:韩文； ISO-8859-1:英文； UTF-8:世界通用的语言编码； content-Language,设定显示语言&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot;/&gt; Cache-Control，指定评语和响应遵循的缓存机制 imagetollbar,指定是否显示图片工具栏，当为false娃给显示，当为true代表显示； Content-Script-Type,W3C网页规范，指明页面中脚本中的类型；","tags":[{"name":"html","slug":"html","permalink":"https://kangshanr.github.io/tags/html/"}]},{"title":"Hello World","date":"2014-01-22T18:04:38.000Z","path":"2014/01/23/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]